
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Effect-TS Documentation</title>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                line-height: 1.6;
                max-width: 900px;
                margin: 0 auto;
                padding: 20px;
                color: #1a1a1a;
            }
            pre {
                background-color: #f6f8fa;
                padding: 16px;
                border-radius: 6px;
                overflow-x: auto;
            }
            code {
                font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
                font-size: 0.9em;
            }
            h1, h2, h3, h4 {
                margin-top: 2em;
                margin-bottom: 1em;
            }
            hr {
                margin: 3em 0;
                border: none;
                border-top: 1px solid #eaeaea;
            }
            a {
                color: #0366d6;
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            img {
                max-width: 100%;
                height: auto;
            }
        </style>
    </head>
    <body>
        <hr>
<h2>title: API Reference
description: API docs covering tools, integrations, and functional programming features.
sidebar:
  order: 2</h2>
<h1>API Reference</h1>
<ul>
<li><a href="https://effect-ts.github.io/effect/docs/effect"><code>effect</code></a></li>
<li><a href="https://effect-ts.github.io/effect/docs/cli"><code>@effect/cli</code></a> (<a href="https://github.com/Effect-TS/effect/blob/main/packages/cli/README.md">Getting Started</a>)</li>
<li><a href="https://effect-ts.github.io/effect/docs/opentelemetry"><code>@effect/opentelemetry</code></a></li>
<li><a href="https://effect-ts.github.io/effect/docs/platform"><code>@effect/platform</code></a> (<a href="https://github.com/Effect-TS/effect/blob/main/packages/platform/README.md">Experimental Features</a>)</li>
<li><a href="https://effect-ts.github.io/effect/docs/printer"><code>@effect/printer</code></a> (<a href="https://github.com/Effect-TS/effect/blob/main/packages/printer/README.md">Getting Started</a>)</li>
<li><a href="https://effect-ts.github.io/effect/docs/rpc"><code>@effect/rpc</code></a> (<a href="https://github.com/Effect-TS/effect/blob/main/packages/rpc/README.md">Getting Started</a>)</li>
<li><a href="https://effect-ts.github.io/effect/docs/typeclass"><code>@effect/typeclass</code></a> (<a href="https://github.com/Effect-TS/effect/blob/main/packages/typeclass/README.md">Getting Started</a>)</li>
</ul>
<hr>
<hr>
<h2>title: Coming From ZIO
description: Key differences between Effect and ZIO.
sidebar:
  order: 3</h2>
<p>If you are coming to Effect from ZIO, there are a few differences to be aware of.</p>
<h2>Environment</h2>
<p>In Effect, we represent the environment required to run an effect workflow as a <strong>union</strong> of services:</p>
<p><strong>Example</strong> (Defining the Environment with a Union of Services)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

interface IOError {
  readonly _tag: &quot;IOError&quot;
}

interface HttpError {
  readonly _tag: &quot;HttpError&quot;
}

interface Console {
  readonly log: (msg: string) =&gt; void
}

interface Logger {
  readonly log: (msg: string) =&gt; void
}

type Response = Record&lt;string, string&gt;

// `R` is a union of `Console` and `Logger`
type Http = Effect.Effect&lt;Response, IOError | HttpError, Console | Logger&gt;
</code></pre>
<p>This may be confusing to folks coming from ZIO, where the environment is represented as an <strong>intersection</strong> of services:</p>
<pre><code class="language-scala">type Http = ZIO[Console with Logger, IOError, Response]
</code></pre>
<h2>Rationale</h2>
<p>The rationale for using a union to represent the environment required by an <code>Effect</code> workflow boils down to our desire to remove <code>Has</code> as a wrapper for services in the environment (similar to what was achieved in ZIO 2.0).</p>
<p>To be able to remove <code>Has</code> from Effect, we had to think a bit more structurally given that TypeScript is a structural type system. In TypeScript, if you have a type <code>A &amp; B</code> where there is a structural conflict between <code>A</code> and <code>B</code>, the type <code>A &amp; B</code> will reduce to <code>never</code>.</p>
<p><strong>Example</strong> (Intersection Type Conflict)</p>
<pre><code class="language-ts">interface A {
  readonly prop: string
}

interface B {
  readonly prop: number
}

const ab: A &amp; B = {
  // @ts-expect-error
  prop: &quot;&quot;
}
/*
Type &#39;string&#39; is not assignable to type &#39;never&#39;.ts(2322)
*/
</code></pre>
<p>In previous versions of Effect, intersections were used for representing an environment with multiple services. The problem with using intersections (i.e. <code>A &amp; B</code>) is that there could be multiple services in the environment that have functions and properties named in the same way. To remedy this, we wrapped services in the <code>Has</code> type (similar to ZIO 1.0), so you would have <code>Has&lt;A&gt; &amp; Has&lt;B&gt;</code> in your environment.</p>
<p>In ZIO 2.0, the <em>contravariant</em> <code>R</code> type parameter of the <code>ZIO</code> type (representing the environment) became fully phantom, thus allowing for removal of the <code>Has</code> type. This significantly improved the clarity of type signatures as well as removing another &quot;stumbling block&quot; for new users.</p>
<p>To facilitate removal of <code>Has</code> in Effect, we had to consider how types in the environment compose. By the rule of composition, contravariant parameters composed as an intersection (i.e. with <code>&amp;</code>) are equivalent to covariant parameters composed together as a union (i.e. with <code>|</code>) for purposes of assignability. Based upon this fact, we decided to diverge from ZIO and make the <code>R</code> type parameter <em>covariant</em> given <code>A | B</code> does not reduce to <code>never</code> if <code>A</code> and <code>B</code> have conflicts.</p>
<p>From our example above:</p>
<pre><code class="language-ts">interface A {
  readonly prop: string
}

interface B {
  readonly prop: number
}

// ok
const ab: A | B = {
  prop: &quot;&quot;
}
</code></pre>
<p>Representing <code>R</code> as a covariant type parameter containing the union of services required by an <code>Effect</code> workflow allowed us to remove the requirement for <code>Has</code>.</p>
<h2>Type Aliases</h2>
<p>In Effect, there are no predefined type aliases such as <code>UIO</code>, <code>URIO</code>, <code>RIO</code>, <code>Task</code>, or <code>IO</code> like in ZIO.</p>
<p>The reason for this is that type aliases are lost as soon as you compose them, which renders them somewhat useless unless you maintain <strong>multiple</strong> signatures for <strong>every</strong> function. In Effect, we have chosen not to go down this path. Instead, we utilize the <code>never</code> type to indicate unused types.</p>
<p>It&#39;s worth mentioning that the perception of type aliases being quicker to understand is often just an illusion. In Effect, the explicit notation <code>Effect&lt;A&gt;</code> clearly communicates that only type <code>A</code> is being used. On the other hand, when using a type alias like <code>RIO&lt;R, A&gt;</code>, questions arise about the type <code>E</code>. Is it <code>unknown</code>? <code>never</code>? Remembering such details becomes challenging.</p>
<hr>
<hr>
<h2>title: Effect vs fp-ts
description: Comparison of Effect and fp-ts, covering features like typed services, resource management, concurrency, and stream processing.
sidebar:
  order: 4</h2>
<h2>Key Developments</h2>
<ul>
<li><strong>Project Merger</strong>: The fp-ts project is officially merging with the Effect-TS ecosystem. Giulio Canti, the author of fp-ts, is being welcomed into the Effect organization. For more details, see the <a href="https://dev.to/effect/a-bright-future-for-effect-455m">announcement here</a>.</li>
<li><strong>Continuity and Evolution</strong>: Effect can be seen as the successor to fp-ts v2 and is effectively fp-ts v3, marking a significant evolution in the library&#39;s capabilities.</li>
</ul>
<h2>FAQ</h2>
<h3>Bundle Size Comparison Between Effect and fp-ts</h3>
<p><strong>Q: I compared the bundle sizes of two simple programs using Effect and fp-ts. Why does Effect have a larger bundle size?</strong></p>
<p>A: It&#39;s natural to observe different bundle sizes because Effect and fp-ts are distinct systems designed for different purposes.
Effect&#39;s bundle size is larger due to its included fiber runtime, which is crucial for its functionality.
While the initial bundle size may seem large, the overhead amortizes as you use Effect.</p>
<p><strong>Q: Should I be concerned about the bundle size difference when choosing between Effect and fp-ts?</strong></p>
<p>A: Not necessarily. Consider the specific requirements and benefits of each library for your project.</p>
<p>The <strong>Micro</strong> module in Effect is designed as a lightweight alternative to the standard <code>Effect</code> module, specifically for scenarios where reducing bundle size is crucial.
This module is self-contained and does not include more complex features like <code>Layer</code>, <code>Ref</code>, <code>Queue</code>, and <code>Deferred</code>.
If any major Effect modules (beyond basic data modules like <code>Option</code>, <code>Either</code>, <code>Array</code>, etc.) are used, the effect runtime will be added to your bundle, negating the benefits of Micro.
This makes Micro ideal for libraries that aim to implement Effect functionality with minimal impact on bundle size, especially for libraries that plan to expose <code>Promise</code>-based APIs.
It also supports scenarios where a client might use Micro while a server uses the full suite of Effect features, maintaining compatibility and shared logic between different parts of an application.</p>
<h2>Comparison Table</h2>
<p>The following table compares the features of the Effect and <a href="https://github.com/gcanti/fp-ts">fp-ts</a> libraries.</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>fp-ts</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td>Typed Services</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Built-in Services</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Typed errors</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Pipeable APIs</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Dual APIs</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Testability</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Resource Management</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Interruptions</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Defects</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Fiber-Based Concurrency</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Fiber Supervision</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Retry and Retry Policies</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Built-in Logging</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Built-in Scheduling</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Built-in Caching</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Built-in Batching</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Metrics</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Tracing</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Configuration</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Immutable Data Structures</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Stream Processing</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<p>Here&#39;s an explanation of each feature:</p>
<h3>Typed Services</h3>
<p>Both fp-ts and Effect libraries provide the ability to track requirements at the type level, allowing you to define and use services with specific types. In fp-ts, you can utilize the <code>ReaderTaskEither&lt;R, E, A&gt;</code> type, while in Effect, the <code>Effect&lt;A, E, R&gt;</code> type is available. It&#39;s important to note that in fp-ts, the <code>R</code> type parameter is contravariant, which means that there is no guarantee of avoiding conflicts, and the library offers only basic tools for dependency management.</p>
<p>On the other hand, in Effect, the <code>R</code> type parameter is covariant and all APIs have the ability to merge dependencies at the type level when multiple effects are involved. Effect also provides a range of specifically designed tools to simplify the management of dependencies, including <code>Tag</code>, <code>Context</code>, and <code>Layer</code>. These tools enhance the ease and flexibility of handling dependencies in your code, making it easier to compose and manage complex applications.</p>
<h3>Built-in Services</h3>
<p>The Effect library has built-in services like <code>Clock</code>, <code>Random</code> and <code>Tracer</code>, while fp-ts does not provide any default services.</p>
<h3>Typed errors</h3>
<p>Both libraries support typed errors, enabling you to define and handle errors with specific types. However, in Effect, all APIs have the ability to merge errors at the type-level when multiple effects are involved, and each effect can potentially fail with different types of errors.</p>
<p>This means that when combining multiple effects that can fail, the resulting type of the error will be a union of the individual error types. Effect provides utilities and type-level operations to handle and manage these merged error types effectively.</p>
<h3>Pipeable APIs</h3>
<p>Both fp-ts and Effect libraries provide pipeable APIs, allowing you to compose and sequence operations in a functional and readable manner using the <code>pipe</code> function. However, Effect goes a step further and offers a <code>.pipe()</code> method on each data type, making it more convenient to work with pipelines without the need to explicitly import the <code>pipe</code> function every time.</p>
<h3>Dual APIs</h3>
<p>Effect library provides dual APIs, allowing you to use the same API in different ways (e.g., &quot;data-last&quot; and &quot;data-first&quot; variants).</p>
<h3>Testability</h3>
<p>The functional style of fp-ts generally promotes good testability of the code written using it, but the library itself does not provide dedicated tools specifically designed for the testing phase. On the other hand, Effect takes testability a step further by offering additional tools that are specifically tailored to simplify the testing process.</p>
<p>Effect provides a range of utilities that improve testability. For example, it offers the <code>TestClock</code> utility, which allows you to control the passage of time during tests. This is useful for testing time-dependent code. Additionally, Effect provides the <code>TestRandom</code> utility, which enables fully deterministic testing of code that involves randomness. This ensures consistent and predictable test results. Another helpful tool is <code>ConfigProvider.fromMap</code>, which makes it easy to define mock configurations for your application during testing.</p>
<h3>Resource Management</h3>
<p>The Effect library provides built-in capabilities for resource management, while fp-ts has limited features in this area (mainly <code>bracket</code>) and they are less sophisticated.</p>
<p>In Effect, resource management refers to the ability to acquire and release resources, such as database connections, file handles, or network sockets, in a safe and controlled manner. The library offers comprehensive and refined mechanisms to handle resource acquisition and release, ensuring proper cleanup and preventing resource leaks.</p>
<h3>Interruptions</h3>
<p>The Effect library supports interruptions, which means you can interrupt and cancel ongoing computations if needed. This feature gives you more control over the execution of your code and allows you to handle situations where you want to stop a computation before it completes.</p>
<p>In Effect, interruptions are useful in scenarios where you need to handle user cancellations, timeouts, or other external events that require stopping ongoing computations. You can explicitly request an interruption and the library will safely and efficiently halt the execution of the computation.</p>
<p>On the other hand, fp-ts does not have built-in support for interruptions. Once a computation starts in fp-ts, it will continue until it completes or encounters an error, without the ability to be interrupted midway.</p>
<h3>Defects</h3>
<p>The Effect library provides mechanisms for handling defects and managing <strong>unexpected</strong> failures. In Effect, defects refer to unexpected errors or failures that can occur during the execution of a program.</p>
<p>With the Effect library, you have built-in tools and utilities to handle defects in a structured and reliable manner. It offers error handling capabilities that allow you to catch and handle exceptions, recover from failures, and gracefully handle unexpected scenarios.</p>
<p>On the other hand, fp-ts does not have built-in support specifically dedicated to managing defects. While you can handle errors using standard functional programming techniques in fp-ts, the Effect library provides a more comprehensive and streamlined approach to dealing with defects.</p>
<h3>Fiber-Based Concurrency</h3>
<p>The Effect library leverages fiber-based concurrency, which enables lightweight and efficient concurrent computations. In simpler terms, fiber-based concurrency allows multiple tasks to run concurrently, making your code more responsive and efficient.</p>
<p>With fiber-based concurrency, the Effect library can handle concurrent operations in a way that is lightweight and doesn&#39;t block the execution of other tasks. This means that you can run multiple computations simultaneously, taking advantage of the available resources and maximizing performance.</p>
<p>On the other hand, fp-ts does not have built-in support for fiber-based concurrency. While fp-ts provides a rich set of functional programming features, it doesn&#39;t have the same level of support for concurrent computations as the Effect library.</p>
<h3>Fiber Supervision</h3>
<p>Effect library provides supervision strategies for managing and monitoring fibers. fp-ts does not have built-in support for fiber supervision.</p>
<h3>Retry and Retry Policies</h3>
<p>The Effect library includes built-in support for retrying computations with customizable retry policies. This feature is not available in fp-ts out of the box, and you would need to rely on external libraries to achieve similar functionality. However, it&#39;s important to note that the external libraries may not offer the same level of sophistication and fine-tuning as the built-in retry capabilities provided by the Effect library.</p>
<p>Retry functionality allows you to automatically retry a computation or action when it fails, based on a set of predefined rules or policies. This can be particularly useful in scenarios where you are working with unreliable or unpredictable resources, such as network requests or external services.</p>
<p>The Effect library provides a comprehensive set of retry policies that you can customize to fit your specific needs. These policies define the conditions for retrying a computation, such as the number of retries, the delay between retries, and the criteria for determining if a retry should be attempted.</p>
<p>By leveraging the built-in retry functionality in the Effect library, you can handle transient errors or temporary failures in a more robust and resilient manner. This can help improve the overall reliability and stability of your applications, especially in scenarios where you need to interact with external systems or services.</p>
<p>In contrast, fp-ts does not offer built-in support for retrying computations. If you require retry functionality in fp-ts, you would need to rely on external libraries, which may not provide the same level of sophistication and flexibility as the Effect library.</p>
<p>It&#39;s worth noting that the built-in retry capabilities of the Effect library are designed to work seamlessly with its other features, such as error handling and resource management. This integration allows for a more cohesive and comprehensive approach to handling failures and retries within your computations.</p>
<h3>Built-in Logging</h3>
<p>The Effect library comes with built-in logging capabilities. This means that you can easily incorporate logging into your applications without the need for additional libraries or dependencies. In addition, the default logger provided by Effect can be replaced with a custom logger to suit your specific logging requirements.</p>
<p>Logging is an essential aspect of software development as it allows you to record and track important information during the execution of your code. It helps you monitor the behavior of your application, debug issues, and gather insights for analysis.</p>
<p>With the built-in logging capabilities of the Effect library, you can easily log messages, warnings, errors, or any other relevant information at various points in your code. This can be particularly useful for tracking the flow of execution, identifying potential issues, or capturing important events during the operation of your application.</p>
<p>On the other hand, fp-ts does not provide built-in logging capabilities. If you need logging functionality in fp-ts, you would need to rely on external libraries or implement your own logging solution from scratch. This can introduce additional complexity and dependencies into your codebase.</p>
<h3>Built-in Scheduling</h3>
<p>The Effect library provides built-in scheduling capabilities, which allows you to manage the execution of computations over time. This feature is not available in fp-ts.</p>
<p>In many applications, it&#39;s common to have tasks or computations that need to be executed at specific intervals or scheduled for future execution. For example, you might want to perform periodic data updates, trigger notifications, or run background processes at specific times. This is where built-in scheduling comes in handy.</p>
<p>On the other hand, fp-ts does not have built-in scheduling capabilities. If you need to schedule tasks or manage timed computations in fp-ts, you would have to rely on external libraries or implement your own scheduling mechanisms, which can add complexity to your codebase.</p>
<h3>Built-in Caching</h3>
<p>The Effect library provides built-in caching mechanisms, which enable you to cache the results of computations for improved performance. This feature is not available in fp-ts.</p>
<p>In many applications, computations can be time-consuming or resource-intensive, especially when dealing with complex operations or accessing remote resources. Caching is a technique used to store the results of computations so that they can be retrieved quickly without the need to recompute them every time.</p>
<p>With the built-in caching capabilities of the Effect library, you can easily cache the results of computations and reuse them when needed. This can significantly improve the performance of your application by avoiding redundant computations and reducing the load on external resources.</p>
<h3>Built-in Batching</h3>
<p>The Effect library offers built-in batching capabilities, which enable you to combine multiple computations into a single batched computation. This feature is not available in fp-ts.</p>
<p>In many scenarios, you may need to perform multiple computations that share similar inputs or dependencies. Performing these computations individually can result in inefficiencies and increased overhead. Batching is a technique that allows you to group these computations together and execute them as a single batch, improving performance and reducing unnecessary processing.</p>
<h3>Metrics</h3>
<p>The Effect library includes built-in support for collecting and reporting metrics related to computations and system behavior. It specifically supports <a href="https://opentelemetry.io/docs/specs/otel/metrics/">OpenTelemetry Metrics</a>. This feature is not available in fp-ts.</p>
<p>Metrics play a crucial role in understanding and monitoring the performance and behavior of your applications. They provide valuable insights into various aspects, such as response times, resource utilization, error rates, and more. By collecting and analyzing metrics, you can identify performance bottlenecks, optimize your code, and make informed decisions to improve your application&#39;s overall quality.</p>
<h3>Tracing</h3>
<p>The Effect library has built-in tracing capabilities, which enable you to trace and debug the execution of your code and track the path of a request through an application. Additionally, Effect offers a dedicated <a href="https://opentelemetry.io/docs/instrumentation/js/exporters/">OpenTelemetry exporter</a> for integrating with the OpenTelemetry observability framework. In contrast, fp-ts does not offer a similar tracing tool to enhance visibility into code execution.</p>
<h3>Configuration</h3>
<p>The Effect library provides built-in support for managing and accessing configuration values within your computations. This feature is not available in fp-ts.</p>
<p>Configuration values are an essential aspect of software development. They allow you to customize the behavior of your applications without modifying the code. Examples of configuration values include database connection strings, API endpoints, feature flags, and various settings that can vary between environments or deployments.</p>
<p>With the Effect library&#39;s built-in support for configuration, you can easily manage and access these values within your computations. It provides convenient utilities and abstractions to load, validate, and access configuration values, ensuring that your application has the necessary settings it requires to function correctly.</p>
<p>By leveraging the built-in configuration support in the Effect library, you can:</p>
<ul>
<li>Load configuration values from various sources such as environment variables, configuration files, or remote configuration providers.</li>
<li>Validate and ensure that the loaded configuration values adhere to the expected format and structure.</li>
<li>Access the configuration values within your computations, allowing you to use them wherever necessary.</li>
</ul>
<h3>Immutable Data Structures</h3>
<p>The Effect library provides built-in support for immutable data structures such as <code>Chunk</code>, <code>HashSet</code>, and <code>HashMap</code>. These data structures ensure that once created, their values cannot be modified, promoting safer and more predictable code. In contrast, fp-ts does not have built-in support for such data structures and only provides modules that add additional APIs to standard data types like <code>Set</code> and <code>Map</code>. While these modules can be useful, they do not offer the same level of performance optimizations and specialized operations as the built-in immutable data structures provided by the Effect library.</p>
<p>Immutable data structures offer several benefits, including:</p>
<ul>
<li><p>Immutability: Immutable data structures cannot be changed after they are created. This property eliminates the risk of accidental modifications and enables safer concurrent programming.</p>
</li>
<li><p>Predictability: With immutable data structures, you can rely on the fact that their values won&#39;t change unexpectedly. This predictability simplifies reasoning about code behavior and reduces bugs caused by mutable state.</p>
</li>
<li><p>Sharing and Reusability: Immutable data structures can be safely shared between different parts of your program. Since they cannot be modified, you don&#39;t need to create defensive copies, resulting in more efficient memory usage and improved performance.</p>
</li>
</ul>
<h3>Stream Processing</h3>
<p>The Effect ecosystem provides built-in support for stream processing, enabling you to work with streams of data. Stream processing is a powerful concept that allows you to efficiently process and transform continuous streams of data in a reactive and asynchronous manner. However, fp-ts does not have this feature built-in and relies on external libraries like RxJS to handle stream processing.</p>
<hr>
<hr>
<h2>title: Effect vs Promise
description: Comparison of Effect and Promise, covering features like type safety, concurrency, and error handling.
sidebar:
  order: 5</h2>
<p>import { Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>In this guide, we will explore the differences between <code>Promise</code> and <code>Effect</code>, two approaches to handling asynchronous operations in TypeScript. We&#39;ll discuss their type safety, creation, chaining, and concurrency, providing examples to help you understand their usage.</p>
<h2>Comparing Effects and Promises: Key Distinctions</h2>
<ul>
<li><strong>Evaluation Strategy:</strong> Promises are eagerly evaluated, whereas effects are lazily evaluated.</li>
<li><strong>Execution Mode:</strong> Promises are one-shot, executing once, while effects are multi-shot, repeatable.</li>
<li><strong>Interruption Handling and Automatic Propagation:</strong> Promises lack built-in interruption handling, posing challenges in managing interruptions, and don&#39;t automatically propagate interruptions, requiring manual abort controller management. In contrast, effects come with interruption handling capabilities and automatically compose interruption, simplifying management locally on smaller computations without the need for high-level orchestration.</li>
<li><strong>Structured Concurrency:</strong> Effects offer structured concurrency built-in, which is challenging to achieve with Promises.</li>
<li><strong>Error Reporting (Type Safety):</strong> Promises don&#39;t inherently provide detailed error reporting at the type level, whereas effects do, offering type-safe insight into error cases.</li>
<li><strong>Runtime Behavior:</strong> The Effect runtime aims to remain synchronous as long as possible, transitioning into asynchronous mode only when necessary due to computation requirements or main thread starvation.</li>
</ul>
<h2>Type safety</h2>
<p>Let&#39;s start by comparing the types of <code>Promise</code> and <code>Effect</code>. The type parameter <code>A</code> represents the resolved value of the operation:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">Promise&lt;A&gt;
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">Effect&lt;A, Error, Context&gt;
</code></pre>
</TabItem>

</Tabs>

<p>Here&#39;s what sets <code>Effect</code> apart:</p>
<ul>
<li>It allows you to track the types of errors statically through the type parameter <code>Error</code>. For more information about error management in <code>Effect</code>, see <a href="/docs/error-management/expected-errors/">Expected Errors</a>.</li>
<li>It allows you to track the types of required dependencies statically through the type parameter <code>Context</code>. For more information about context management in <code>Effect</code>, see <a href="/docs/requirements-management/services/">Managing Services</a>.</li>
</ul>
<h2>Creating</h2>
<h3>Success</h3>
<p>Let&#39;s compare creating a successful operation using <code>Promise</code> and <code>Effect</code>:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const success = Promise.resolve(2)
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const success = Effect.succeed(2)
</code></pre>
</TabItem>

</Tabs>

<h3>Failure</h3>
<p>Now, let&#39;s see how to handle failures with <code>Promise</code> and <code>Effect</code>:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const failure = Promise.reject(&quot;Uh oh!&quot;)
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const failure = Effect.fail(&quot;Uh oh!&quot;)
</code></pre>
</TabItem>

</Tabs>

<h3>Constructor</h3>
<p>Creating operations with custom logic:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const task = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    Math.random() &gt; 0.5 ? resolve(2) : reject(&quot;Uh oh!&quot;)
  }, 300)
})
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  yield* Effect.sleep(&quot;300 millis&quot;)
  return Math.random() &gt; 0.5 ? 2 : yield* Effect.fail(&quot;Uh oh!&quot;)
})
</code></pre>
</TabItem>

</Tabs>

<h2>Thenable</h2>
<p>Mapping the result of an operation:</p>
<h3>map</h3>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const mapped = Promise.resolve(&quot;Hello&quot;).then((s) =&gt; s.length)
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const mapped = Effect.succeed(&quot;Hello&quot;).pipe(
  Effect.map((s) =&gt; s.length)
  // or Effect.andThen((s) =&gt; s.length)
)
</code></pre>
</TabItem>

</Tabs>

<h3>flatMap</h3>
<p>Chaining multiple operations:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const flatMapped = Promise.resolve(&quot;Hello&quot;).then((s) =&gt;
  Promise.resolve(s.length)
)
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const flatMapped = Effect.succeed(&quot;Hello&quot;).pipe(
  Effect.flatMap((s) =&gt; Effect.succeed(s.length))
  // or Effect.andThen((s) =&gt; Effect.succeed(s.length))
)
</code></pre>
</TabItem>

</Tabs>

<h2>Comparing Effect.gen with async/await</h2>
<p>If you are familiar with <code>async</code>/<code>await</code>, you may notice that the flow of writing code is similar.</p>
<p>Let&#39;s compare the two approaches:</p>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const increment = (x: number) =&gt; x + 1

const divide = (a: number, b: number): Promise&lt;number&gt; =&gt;
  b === 0
    ? Promise.reject(new Error(&quot;Cannot divide by zero&quot;))
    : Promise.resolve(a / b)

const task1 = Promise.resolve(10)

const task2 = Promise.resolve(2)

const program = async function () {
  const a = await task1
  const b = await task2
  const n1 = await divide(a, b)
  const n2 = increment(n1)
  return `Result is: ${n2}`
}

program().then(console.log) // Output: &quot;Result is: 6&quot;
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const increment = (x: number) =&gt; x + 1

const divide = (a: number, b: number): Effect.Effect&lt;number, Error&gt; =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)

const task1 = Effect.promise(() =&gt; Promise.resolve(10))

const task2 = Effect.promise(() =&gt; Promise.resolve(2))

const program = Effect.gen(function* () {
  const a = yield* task1
  const b = yield* task2
  const n1 = yield* divide(a, b)
  const n2 = increment(n1)
  return `Result is: ${n2}`
})

Effect.runPromise(program).then(console.log)
// Output: &quot;Result is: 6&quot;
</code></pre>
</TabItem>

</Tabs>

<p>It&#39;s important to note that although the code appears similar, the two programs are not identical. The purpose of comparing them side by side is just to highlight the resemblance in how they are written.</p>
<h2>Concurrency</h2>
<h3>Promise.all()</h3>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const task1 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task1...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task1 done&quot;)
    resolve(1)
  }, 100)
})

const task2 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task2...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task2 done&quot;)
    reject(&quot;Uh oh!&quot;)
  }, 200)
})

const task3 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task3...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task3 done&quot;)
    resolve(3)
  }, 300)
})

const program = Promise.all([task1, task2, task3])

program.then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
Uh oh!
task3 done
*/
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;Executing task1...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task1 done&quot;)
  return 1
})

const task2 = Effect.gen(function* () {
  console.log(&quot;Executing task2...&quot;)
  yield* Effect.sleep(&quot;200 millis&quot;)
  console.log(&quot;task2 done&quot;)
  return yield* Effect.fail(&quot;Uh oh!&quot;)
})

const task3 = Effect.gen(function* () {
  console.log(&quot;Executing task3...&quot;)
  yield* Effect.sleep(&quot;300 millis&quot;)
  console.log(&quot;task3 done&quot;)
  return 3
})

const program = Effect.all([task1, task2, task3], {
  concurrency: &quot;unbounded&quot;
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
(FiberFailure) Error: Uh oh!
*/
</code></pre>
</TabItem>

</Tabs>

<h3>Promise.allSettled()</h3>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const task1 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task1...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task1 done&quot;)
    resolve(1)
  }, 100)
})

const task2 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task2...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task2 done&quot;)
    reject(&quot;Uh oh!&quot;)
  }, 200)
})

const task3 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task3...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task3 done&quot;)
    resolve(3)
  }, 300)
})

const program = Promise.allSettled([task1, task2, task3])

program.then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
task3 done
[
  { status: &#39;fulfilled&#39;, value: 1 },
  { status: &#39;rejected&#39;, reason: &#39;Uh oh!&#39; },
  { status: &#39;fulfilled&#39;, value: 3 }
]
*/
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;Executing task1...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task1 done&quot;)
  return 1
})

const task2 = Effect.gen(function* () {
  console.log(&quot;Executing task2...&quot;)
  yield* Effect.sleep(&quot;200 millis&quot;)
  console.log(&quot;task2 done&quot;)
  return yield* Effect.fail(&quot;Uh oh!&quot;)
})

const task3 = Effect.gen(function* () {
  console.log(&quot;Executing task3...&quot;)
  yield* Effect.sleep(&quot;300 millis&quot;)
  console.log(&quot;task3 done&quot;)
  return 3
})

const program = Effect.forEach(
  [task1, task2, task3],
  (task) =&gt; Effect.either(task), // or Effect.exit
  {
    concurrency: &quot;unbounded&quot;
  }
)

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
task3 done
[
  {
    _id: &quot;Either&quot;,
    _tag: &quot;Right&quot;,
    right: 1
  }, {
    _id: &quot;Either&quot;,
    _tag: &quot;Left&quot;,
    left: &quot;Uh oh!&quot;
  }, {
    _id: &quot;Either&quot;,
    _tag: &quot;Right&quot;,
    right: 3
  }
]
*/
</code></pre>
</TabItem>

</Tabs>

<h3>Promise.any()</h3>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const task1 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task1...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task1 done&quot;)
    reject(&quot;Something went wrong!&quot;)
  }, 100)
})

const task2 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task2...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task2 done&quot;)
    resolve(2)
  }, 200)
})

const task3 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task3...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task3 done&quot;)
    reject(&quot;Uh oh!&quot;)
  }, 300)
})

const program = Promise.any([task1, task2, task3])

program.then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
2
task3 done
*/
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;Executing task1...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task1 done&quot;)
  return yield* Effect.fail(&quot;Something went wrong!&quot;)
})

const task2 = Effect.gen(function* () {
  console.log(&quot;Executing task2...&quot;)
  yield* Effect.sleep(&quot;200 millis&quot;)
  console.log(&quot;task2 done&quot;)
  return 2
})

const task3 = Effect.gen(function* () {
  console.log(&quot;Executing task3...&quot;)
  yield* Effect.sleep(&quot;300 millis&quot;)
  console.log(&quot;task3 done&quot;)
  return yield* Effect.fail(&quot;Uh oh!&quot;)
})

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
2
*/
</code></pre>
</TabItem>

</Tabs>

<h3>Promise.race()</h3>
<Tabs syncKey="effect-vs-promise">

<TabItem label="Promise">

<pre><code class="language-ts">const task1 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task1...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task1 done&quot;)
    reject(&quot;Something went wrong!&quot;)
  }, 100)
})

const task2 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task2...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task2 done&quot;)
    reject(&quot;Uh oh!&quot;)
  }, 200)
})

const task3 = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  console.log(&quot;Executing task3...&quot;)
  setTimeout(() =&gt; {
    console.log(&quot;task3 done&quot;)
    resolve(3)
  }, 300)
})

const program = Promise.race([task1, task2, task3])

program.then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
Something went wrong!
task2 done
task3 done
*/
</code></pre>
</TabItem>

<TabItem label="Effect">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;Executing task1...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task1 done&quot;)
  return yield* Effect.fail(&quot;Something went wrong!&quot;)
})

const task2 = Effect.gen(function* () {
  console.log(&quot;Executing task2...&quot;)
  yield* Effect.sleep(&quot;200 millis&quot;)
  console.log(&quot;task2 done&quot;)
  return yield* Effect.fail(&quot;Uh oh!&quot;)
})

const task3 = Effect.gen(function* () {
  console.log(&quot;Executing task3...&quot;)
  yield* Effect.sleep(&quot;300 millis&quot;)
  console.log(&quot;task3 done&quot;)
  return 3
})

const program = Effect.raceAll([task1, task2, task3].map(Effect.either)) // or Effect.exit

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
{
  _id: &quot;Either&quot;,
  _tag: &quot;Left&quot;,
  left: &quot;Something went wrong!&quot;
}
*/
</code></pre>
</TabItem>

</Tabs>

<h2>FAQ</h2>
<p><strong>Question</strong>. What is the equivalent of starting a promise without immediately waiting for it in Effects?</p>
<pre><code class="language-ts">const task = (delay: number, name: string) =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; {
      console.log(`${name} done`)
      return resolve(name)
    }, delay)
  )

export async function program() {
  const r0 = task(2_000, &quot;long running task&quot;)
  const r1 = await task(200, &quot;task 2&quot;)
  const r2 = await task(100, &quot;task 3&quot;)
  return {
    r1,
    r2,
    r0: await r0
  }
}

program().then(console.log)
/*
Output:
task 2 done
task 3 done
long running task done
{ r1: &#39;task 2&#39;, r2: &#39;task 3&#39;, r0: &#39;long running promise&#39; }
*/
</code></pre>
<p><strong>Answer:</strong> You can achieve this by utilizing <code>Effect.fork</code> and <code>Fiber.join</code>.</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const task = (delay: number, name: string) =&gt;
  Effect.gen(function* () {
    yield* Effect.sleep(delay)
    console.log(`${name} done`)
    return name
  })

const program = Effect.gen(function* () {
  const r0 = yield* Effect.fork(task(2_000, &quot;long running task&quot;))
  const r1 = yield* task(200, &quot;task 2&quot;)
  const r2 = yield* task(100, &quot;task 3&quot;)
  return {
    r1,
    r2,
    r0: yield* Fiber.join(r0)
  }
})

Effect.runPromise(program).then(console.log)
/*
Output:
task 2 done
task 3 done
long running task done
{ r1: &#39;task 2&#39;, r2: &#39;task 3&#39;, r0: &#39;long running promise&#39; }
*/
</code></pre>
<hr>
<hr>
<h2>title: Myths About Effect
description: Debunking common misconceptions about Effect&#39;s performance, complexity, and use cases.
sidebar:
  label: Myths
  order: 1</h2>
<h2>Effect heavily relies on generators and generators are slow!</h2>
<p>Effect&#39;s internals are not built on generators, we only use generators to provide an API which closely mimics async-await. Internally async-await uses the same mechanics as generators and they are equally performant. So if you don&#39;t have a problem with async-await you won&#39;t have a problem with Effect&#39;s generators.</p>
<p>Where generators and iterables are unacceptably slow is in transforming collections of data, for that try to use plain arrays as much as possible.</p>
<h2>Effect will make your code 500x slower!</h2>
<p>Effect does perform 500x slower if you are comparing:</p>
<pre><code class="language-ts">const result = 1 + 1
</code></pre>
<p>to</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const result = Effect.runSync(
  Effect.zipWith(Effect.succeed(1), Effect.succeed(1), (a, b) =&gt; a + b)
)
</code></pre>
<p>The reason is one operation is optimized by the JIT compiler to be a direct CPU instruction and the other isn&#39;t.</p>
<p>In reality you&#39;d never use Effect in such cases, Effect is an app-level library to tame concurrency, error handling, and much more!</p>
<p>You&#39;d use Effect to coordinate your thunks of code, and you can build your thunks of code in the best perfoming manner as you see fit while still controlling execution through Effect.</p>
<h2>Effect has a huge performance overhead!</h2>
<p>Depends what you mean by performance, many times performance bottlenecks in JS are due to bad management of concurrency.</p>
<p>Thanks to structured concurrency and observability it becomes much easier to spot and optimize those issues.</p>
<p>There are apps in frontend running at 120fps that use Effect intensively, so most likely effect won&#39;t be your perf problem.</p>
<p>In regards of memory, it doesn&#39;t use much more memory than a normal program would, there are a few more allocations compared to non Effect code but usually this is no longer the case when the non Effect code does the same thing as the Effect code.</p>
<p>The advise would be start using it and monitor your code, optimise out of need not out of thought, optimizing too early is the root of all evils in software design.</p>
<h2>The bundle size is HUGE!</h2>
<p>Effect&#39;s minimum cost is about 25k of gzipped code, that chunk contains the Effect Runtime and already includes almost all the functions that you&#39;ll need in a normal app-code scenario.</p>
<p>From that point on Effect is tree-shaking friendly so you&#39;ll only include what you use.</p>
<p>Also when using Effect your own code becomes shorter and terser, so the overall cost is amortized with usage, we have apps where adopting Effect in the majority of the codebase led to reduction of the final bundle.</p>
<h2>Effect is impossible to learn, there are so many functions and modules!</h2>
<p>True, the full Effect ecosystem is quite large and some modules contain 1000s of functions, the reality is that you don&#39;t need to know them all to start being productive, you can safely start using Effect knowing just 10-20 functions and progressively discover the rest, just like you can start using TypeScript without knowing every single NPM package.</p>
<p>A short list of commonly used functions to begin are:</p>
<ul>
<li><a href="/docs/getting-started/creating-effects/#succeed">Effect.succeed</a></li>
<li><a href="/docs/getting-started/creating-effects/#fail">Effect.fail</a></li>
<li><a href="/docs/getting-started/creating-effects/#sync">Effect.sync</a></li>
<li><a href="/docs/getting-started/creating-effects/#trypromise">Effect.tryPromise</a></li>
<li><a href="/docs/getting-started/using-generators/">Effect.gen</a></li>
<li><a href="/docs/getting-started/running-effects/#runpromise">Effect.runPromise</a></li>
<li><a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a></li>
<li><a href="/docs/error-management/expected-errors/#catchall">Effect.catchAll</a></li>
<li><a href="/docs/resource-management/scope/#acquirerelease">Effect.acquireRelease</a></li>
<li><a href="/docs/resource-management/scope/#acquireuserelease">Effect.acquireUseRelease</a></li>
<li><a href="/docs/requirements-management/layers/#providing-a-layer-to-an-effect">Effect.provide</a></li>
<li><a href="/docs/requirements-management/services/#providing-a-service-implementation">Effect.provideService</a></li>
<li><a href="/docs/getting-started/building-pipelines/#andthen">Effect.andThen</a></li>
<li><a href="/docs/getting-started/building-pipelines/#map">Effect.map</a></li>
<li><a href="/docs/getting-started/building-pipelines/#tap">Effect.tap</a></li>
</ul>
<p>A short list of commonly used modules:</p>
<ul>
<li><a href="https://effect-ts.github.io/effect/effect/Effect.ts.html">Effect</a></li>
<li><a href="/docs/requirements-management/services/#creating-a-service">Context</a></li>
<li><a href="/docs/requirements-management/layers/">Layer</a></li>
<li><a href="/docs/data-types/option/">Option</a></li>
<li><a href="/docs/data-types/either/">Either</a></li>
<li><a href="https://effect-ts.github.io/effect/effect/Array.ts.html">Array</a></li>
<li><a href="/docs/code-style/pattern-matching/">Match</a></li>
</ul>
<h2>Effect is the same as RxJS and shares its problems</h2>
<p>This is a sensitive topic, let&#39;s start by saying that RxJS is a great project and that it has helped millions of developers write reliable software and we all should be thankful to the developers who contributed to such an amazing project.</p>
<p>Discussing the scope of the projects, RxJS aims to make working with Observables easy and wants to provide reactive extensions to JS, Effect instead wants to make writing production-grade TypeScript easy. While the intersection is non-empty the projects have fundamentally different objectives and strategies.</p>
<p>Sometimes people refer to RxJS in bad light, and the reason isn&#39;t RxJS in itself but rather usage of RxJS in problem domains where RxJS wasn&#39;t thought to be used.</p>
<p>Namely the idea that &quot;everything is a stream&quot; is theoretically true but it leads to fundamental limitations on developer experience, the primary issue being that streams are multi-shot (emit potentially multiple elements, or zero) and mutable delimited continuations (JS Generators) are known to be only good to represent single-shot effects (that emit a single value).</p>
<p>In short it means that writing in imperative style (think of async/await) is practically impossible with stream primitives (practically because there would be the option of replaying the generator at every element and at every step, but this tends to be inefficient and the semantics of it are counter-intuitive, it would only work under the assumption that the full body is free of side-effects), forcing the developer to use declarative approaches such as pipe to represent all of their code.</p>
<p>Effect has a Stream module (which is pull-based instead of push-based in order to be memory constant), but the basic Effect type is single-shot and it is optimised to act as a smart &amp; lazy Promise that enables imperative programming, so when using Effect you&#39;re not forced to use a declarative style for everything and you can program using a model which is similar to async-await.</p>
<p>The other big difference is that RxJS only cares about the happy-path with explicit types, it doesn&#39;t offer a way of typing errors and dependencies, Effect instead consider both errors and dependencies as explicitely typed and offers control-flow around those in a fully type-safe manner.</p>
<p>In short if you need reactive programming around Observables, use RxJS, if you need to write production-grade TypeScript that includes by default native telemetry, error handling, dependency injection, and more use Effect.</p>
<h2>Effect should be a language or Use a different language</h2>
<p>Neither solve the issue of writing production grade software in TypeScript.</p>
<p>TypeScript is an amazing language to write full stack code with deep roots in the JS ecosystem and wide compatibility of tools, it is an industrial language adopted by many large scale companies.</p>
<p>The fact that something like Effect is possible within the language and the fact that the language supports things such as generators that allows for imperative programming with custom types such as Effect makes TypeScript a unique language.</p>
<p>In fact even in functional languages such as Scala the interop with effect systems is less optimal than it is in TypeScript, to the point that effect system authors have expressed wish for their language to support as much as TypeScript supports.</p>
<hr>
<hr>
<h2>title: Batching
description: Optimize performance by batching requests and reducing redundant API calls, enhancing efficiency in data fetching and processing.
sidebar:
  order: 9</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In typical application development, when interacting with external APIs, databases, or other data sources, we often define functions that perform requests and handle their results or failures accordingly.</p>
<h3>Simple Model Setup</h3>
<p>Here&#39;s a basic model that outlines the structure of our data and possible errors:</p>
<pre><code class="language-ts">// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}
</code></pre>
<Aside type="tip" title="Use Precise Types and Detailed Errors">
  In a real world scenario we may want to use a more precise types instead
  of directly using primitives for identifiers (see [Branded
  Types](/docs/code-style/branded-types/)). Additionally, you may want to
  include more detailed information in the errors.
</Aside>

<h3>Defining API Functions</h3>
<p>Let&#39;s define functions that interact with an external API, handling common operations such as fetching todos, retrieving user details, and sending emails.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// API
// ------------------------------

// Fetches a list of todos from an external API
const getTodos = Effect.tryPromise({
  try: () =&gt;
    fetch(&quot;https://api.example.demo/todos&quot;).then(
      (res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;
    ),
  catch: () =&gt; new GetTodosError()
})

// Retrieves a user by their ID from an external API
const getUserById = (id: number) =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(`https://api.example.demo/getUserById?id=${id}`).then(
        (res) =&gt; res.json() as Promise&lt;User&gt;
      ),
    catch: () =&gt; new GetUserError()
  })

// Sends an email via an external API
const sendEmail = (address: string, text: string) =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(&quot;https://api.example.demo/sendEmail&quot;, {
        method: &quot;POST&quot;,
        headers: {
          &quot;Content-Type&quot;: &quot;application/json&quot;
        },
        body: JSON.stringify({ address, text })
      }).then((res) =&gt; res.json() as Promise&lt;void&gt;),
    catch: () =&gt; new SendEmailError()
  })

// Sends an email to a user by fetching their details first
const sendEmailToUser = (id: number, message: string) =&gt;
  getUserById(id).pipe(
    Effect.andThen((user) =&gt; sendEmail(user.email, message))
  )

// Notifies the owner of a todo by sending them an email
const notifyOwner = (todo: Todo) =&gt;
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =&gt;
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`)
    )
  )
</code></pre>
<Aside type="tip" title="Validating API Responses">
  In a real-world scenario, you might not want to trust your APIs to
  always return the expected data - for this, you can use
  [`effect/Schema`](/docs/schema/introduction/) or similar alternatives
  such as `zod`.
</Aside>

<p>While this approach is straightforward and readable, it may not be the most efficient. Repeated API calls, especially when many todos share the same owner, can significantly increase network overhead and slow down your application.</p>
<h3>Using the API Functions</h3>
<p>While these functions are clear and easy to understand, their use may not be the most efficient. For example, notifying todo owners involves repeated API calls which can be optimized.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// API
// ------------------------------

// Fetches a list of todos from an external API
const getTodos = Effect.tryPromise({
  try: () =&gt;
    fetch(&quot;https://api.example.demo/todos&quot;).then(
      (res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;
    ),
  catch: () =&gt; new GetTodosError()
})

// Retrieves a user by their ID from an external API
const getUserById = (id: number) =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(`https://api.example.demo/getUserById?id=${id}`).then(
        (res) =&gt; res.json() as Promise&lt;User&gt;
      ),
    catch: () =&gt; new GetUserError()
  })

// Sends an email via an external API
const sendEmail = (address: string, text: string) =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(&quot;https://api.example.demo/sendEmail&quot;, {
        method: &quot;POST&quot;,
        headers: {
          &quot;Content-Type&quot;: &quot;application/json&quot;
        },
        body: JSON.stringify({ address, text })
      }).then((res) =&gt; res.json() as Promise&lt;void&gt;),
    catch: () =&gt; new SendEmailError()
  })

// Sends an email to a user by fetching their details first
const sendEmailToUser = (id: number, message: string) =&gt;
  getUserById(id).pipe(
    Effect.andThen((user) =&gt; sendEmail(user.email, message))
  )

// Notifies the owner of a todo by sending them an email
const notifyOwner = (todo: Todo) =&gt;
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =&gt;
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`)
    )
  )

// Orchestrates operations on todos, notifying their owners
const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) =&gt; notifyOwner(todo), {
    concurrency: &quot;unbounded&quot;
  })
})
</code></pre>
<p>This implementation performs an API call for each todo to fetch the owner&#39;s details and send an email. If multiple todos have the same owner, this results in redundant API calls.</p>
<Aside type="tip" title="Improving Efficiency with Batch Calls">
  To optimize, consider implementing batch API calls if your backend
  supports them. This reduces the number of HTTP requests by grouping
  multiple operations into a single request, thereby enhancing performance
  and reducing load.
</Aside>

<h2>Batching</h2>
<p>Let&#39;s assume that <code>getUserById</code> and <code>sendEmail</code> can be batched. This means that we can send multiple requests in a single HTTP call, reducing the number of API requests and improving performance.</p>
<p><strong>Step-by-Step Guide to Batching</strong></p>
<ol>
<li><p><strong>Declaring Requests:</strong> We&#39;ll start by transforming our requests into structured data models. This involves detailing input parameters, expected outputs, and possible errors. Structuring requests this way not only helps in efficiently managing data but also in comparing different requests to understand if they refer to the same input parameters.</p>
</li>
<li><p><strong>Declaring Resolvers:</strong> Resolvers are designed to handle multiple requests simultaneously. By leveraging the ability to compare requests (ensuring they refer to the same input parameters), resolvers can execute several requests in one go, maximizing the utility of batching.</p>
</li>
<li><p><strong>Defining Queries:</strong> Finally, we&#39;ll define queries that utilize these batch-resolvers to perform operations. This step ties together the structured requests and their corresponding resolvers into functional components of the application.</p>
</li>
</ol>
<Aside type="caution" title="Ensuring Request Comparability">
  It's crucial for the requests to be modeled in a way that allows them to
  be comparable. This means implementing comparability (using methods like
  [Equals.equals](/docs/trait/equal/)) to identify and batch identical
  requests effectively.
</Aside>

<h3>Declaring Requests</h3>
<p>We&#39;ll design a model using the concept of a <code>Request</code> that a data source might support:</p>
<pre><code class="language-ts">Request&lt;Value, Error&gt;
</code></pre>
<p>A <code>Request</code> is a construct representing a request for a value of type <code>Value</code>, which might fail with an error of type <code>Error</code>.</p>
<p>Let&#39;s start by defining a structured model for the types of requests our data sources can handle.</p>
<pre><code class="language-ts">import { Request } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// Requests
// ------------------------------

// Define a request to get multiple Todo items which might
// fail with a GetTodosError
interface GetTodos extends Request.Request&lt;Array&lt;Todo&gt;, GetTodosError&gt; {
  readonly _tag: &quot;GetTodos&quot;
}

// Create a tagged constructor for GetTodos requests
const GetTodos = Request.tagged&lt;GetTodos&gt;(&quot;GetTodos&quot;)

// Define a request to fetch a User by ID which might
// fail with a GetUserError
interface GetUserById extends Request.Request&lt;User, GetUserError&gt; {
  readonly _tag: &quot;GetUserById&quot;
  readonly id: number
}

// Create a tagged constructor for GetUserById requests
const GetUserById = Request.tagged&lt;GetUserById&gt;(&quot;GetUserById&quot;)

// Define a request to send an email which might
// fail with a SendEmailError
interface SendEmail extends Request.Request&lt;void, SendEmailError&gt; {
  readonly _tag: &quot;SendEmail&quot;
  readonly address: string
  readonly text: string
}

// Create a tagged constructor for SendEmail requests
const SendEmail = Request.tagged&lt;SendEmail&gt;(&quot;SendEmail&quot;)
</code></pre>
<p>Each request is defined with a specific data structure that extends from a generic <code>Request</code> type, ensuring that each request carries its unique data requirements along with a specific error type.</p>
<p>By using tagged constructors like <code>Request.tagged</code>, we can easily instantiate request objects that are recognizable and manageable throughout the application.</p>
<h3>Declaring Resolvers</h3>
<p>After defining our requests, the next step is configuring how Effect resolves these requests using <code>RequestResolver</code>:</p>
<pre><code class="language-ts">RequestResolver&lt;A, R&gt;
</code></pre>
<p>A <code>RequestResolver</code> requires an environment <code>R</code> and is capable of executing requests of type <code>A</code>.</p>
<p>In this section, we&#39;ll create individual resolvers for each type of request. The granularity of your resolvers can vary, but typically, they are divided based on the batching capabilities of the corresponding API calls.</p>
<pre><code class="language-ts">import { Effect, Request, RequestResolver } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// Requests
// ------------------------------

// Define a request to get multiple Todo items which might
// fail with a GetTodosError
interface GetTodos extends Request.Request&lt;Array&lt;Todo&gt;, GetTodosError&gt; {
  readonly _tag: &quot;GetTodos&quot;
}

// Create a tagged constructor for GetTodos requests
const GetTodos = Request.tagged&lt;GetTodos&gt;(&quot;GetTodos&quot;)

// Define a request to fetch a User by ID which might
// fail with a GetUserError
interface GetUserById extends Request.Request&lt;User, GetUserError&gt; {
  readonly _tag: &quot;GetUserById&quot;
  readonly id: number
}

// Create a tagged constructor for GetUserById requests
const GetUserById = Request.tagged&lt;GetUserById&gt;(&quot;GetUserById&quot;)

// Define a request to send an email which might
// fail with a SendEmailError
interface SendEmail extends Request.Request&lt;void, SendEmailError&gt; {
  readonly _tag: &quot;SendEmail&quot;
  readonly address: string
  readonly text: string
}

// Create a tagged constructor for SendEmail requests
const SendEmail = Request.tagged&lt;SendEmail&gt;(&quot;SendEmail&quot;)

// ------------------------------
// Resolvers
// ------------------------------

// Assuming GetTodos cannot be batched, we create a standard resolver
const GetTodosResolver = RequestResolver.fromEffect(
  (_: GetTodos): Effect.Effect&lt;Todo[], GetTodosError&gt; =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/todos&quot;).then(
          (res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;
        ),
      catch: () =&gt; new GetTodosError()
    })
)

// Assuming GetUserById can be batched, we create a batched resolver
const GetUserByIdResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray&lt;GetUserById&gt;) =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/getUserByIdBatch&quot;, {
          method: &quot;POST&quot;,
          headers: {
            &quot;Content-Type&quot;: &quot;application/json&quot;
          },
          body: JSON.stringify({
            users: requests.map(({ id }) =&gt; ({ id }))
          })
        }).then((res) =&gt; res.json()) as Promise&lt;Array&lt;User&gt;&gt;,
      catch: () =&gt; new GetUserError()
    }).pipe(
      Effect.andThen((users) =&gt;
        Effect.forEach(requests, (request, index) =&gt;
          Request.completeEffect(request, Effect.succeed(users[index]!))
        )
      ),
      Effect.catchAll((error) =&gt;
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)

// Assuming SendEmail can be batched, we create a batched resolver
const SendEmailResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray&lt;SendEmail&gt;) =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/sendEmailBatch&quot;, {
          method: &quot;POST&quot;,
          headers: {
            &quot;Content-Type&quot;: &quot;application/json&quot;
          },
          body: JSON.stringify({
            emails: requests.map(({ address, text }) =&gt; ({
              address,
              text
            }))
          })
        }).then((res) =&gt; res.json() as Promise&lt;void&gt;),
      catch: () =&gt; new SendEmailError()
    }).pipe(
      Effect.andThen(
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.void)
        )
      ),
      Effect.catchAll((error) =&gt;
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)
</code></pre>
<Aside type="tip" title="Accessing Context in Resolvers">
  Resolvers can also access the context like any other effect, and there
  are many different ways to create resolvers. For further details,
  consider exploring the reference documentation for the
  [RequestResolver](https://effect-ts.github.io/effect/effect/RequestResolver.ts.html)
  module.
</Aside>

<p>In this configuration:</p>
<ul>
<li><strong>GetTodosResolver</strong> handles the fetching of multiple <code>Todo</code> items. It&#39;s set up as a standard resolver since we assume it cannot be batched.</li>
<li><strong>GetUserByIdResolver</strong> and <strong>SendEmailResolver</strong> are configured as batched resolvers. This setup is based on the assumption that these requests can be processed in batches, enhancing performance and reducing the number of API calls.</li>
</ul>
<h3>Defining Queries</h3>
<p>Now that we&#39;ve set up our resolvers, we&#39;re ready to tie all the pieces together to define our This step will enable us to perform data operations effectively within our application.</p>
<pre><code class="language-ts">import { Effect, Request, RequestResolver } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// Requests
// ------------------------------

// Define a request to get multiple Todo items which might
// fail with a GetTodosError
interface GetTodos extends Request.Request&lt;Array&lt;Todo&gt;, GetTodosError&gt; {
  readonly _tag: &quot;GetTodos&quot;
}

// Create a tagged constructor for GetTodos requests
const GetTodos = Request.tagged&lt;GetTodos&gt;(&quot;GetTodos&quot;)

// Define a request to fetch a User by ID which might
// fail with a GetUserError
interface GetUserById extends Request.Request&lt;User, GetUserError&gt; {
  readonly _tag: &quot;GetUserById&quot;
  readonly id: number
}

// Create a tagged constructor for GetUserById requests
const GetUserById = Request.tagged&lt;GetUserById&gt;(&quot;GetUserById&quot;)

// Define a request to send an email which might
// fail with a SendEmailError
interface SendEmail extends Request.Request&lt;void, SendEmailError&gt; {
  readonly _tag: &quot;SendEmail&quot;
  readonly address: string
  readonly text: string
}

// Create a tagged constructor for SendEmail requests
const SendEmail = Request.tagged&lt;SendEmail&gt;(&quot;SendEmail&quot;)

// ------------------------------
// Resolvers
// ------------------------------

// Assuming GetTodos cannot be batched, we create a standard resolver
const GetTodosResolver = RequestResolver.fromEffect(
  (_: GetTodos): Effect.Effect&lt;Todo[], GetTodosError&gt; =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/todos&quot;).then(
          (res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;
        ),
      catch: () =&gt; new GetTodosError()
    })
)

// Assuming GetUserById can be batched, we create a batched resolver
const GetUserByIdResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray&lt;GetUserById&gt;) =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/getUserByIdBatch&quot;, {
          method: &quot;POST&quot;,
          headers: {
            &quot;Content-Type&quot;: &quot;application/json&quot;
          },
          body: JSON.stringify({
            users: requests.map(({ id }) =&gt; ({ id }))
          })
        }).then((res) =&gt; res.json()) as Promise&lt;Array&lt;User&gt;&gt;,
      catch: () =&gt; new GetUserError()
    }).pipe(
      Effect.andThen((users) =&gt;
        Effect.forEach(requests, (request, index) =&gt;
          Request.completeEffect(request, Effect.succeed(users[index]!))
        )
      ),
      Effect.catchAll((error) =&gt;
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)

// Assuming SendEmail can be batched, we create a batched resolver
const SendEmailResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray&lt;SendEmail&gt;) =&gt;
    Effect.tryPromise({
      try: () =&gt;
        fetch(&quot;https://api.example.demo/sendEmailBatch&quot;, {
          method: &quot;POST&quot;,
          headers: {
            &quot;Content-Type&quot;: &quot;application/json&quot;
          },
          body: JSON.stringify({
            emails: requests.map(({ address, text }) =&gt; ({
              address,
              text
            }))
          })
        }).then((res) =&gt; res.json() as Promise&lt;void&gt;),
      catch: () =&gt; new SendEmailError()
    }).pipe(
      Effect.andThen(
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.void)
        )
      ),
      Effect.catchAll((error) =&gt;
        Effect.forEach(requests, (request) =&gt;
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)

// ------------------------------
// Queries
// ------------------------------

// Defines a query to fetch all Todo items
const getTodos: Effect.Effect&lt;
  Array&lt;Todo&gt;,
  GetTodosError
&gt; = Effect.request(GetTodos({}), GetTodosResolver)

// Defines a query to fetch a user by their ID
const getUserById = (id: number) =&gt;
  Effect.request(GetUserById({ id }), GetUserByIdResolver)

// Defines a query to send an email to a specific address
const sendEmail = (address: string, text: string) =&gt;
  Effect.request(SendEmail({ address, text }), SendEmailResolver)

// Composes getUserById and sendEmail to send an email to a specific user
const sendEmailToUser = (id: number, message: string) =&gt;
  getUserById(id).pipe(
    Effect.andThen((user) =&gt; sendEmail(user.email, message))
  )

// Uses getUserById to fetch the owner of a Todo and then sends them an email notification
const notifyOwner = (todo: Todo) =&gt;
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =&gt;
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`)
    )
  )
</code></pre>
<p>By using the <code>Effect.request</code> function, we integrate the resolvers with the request model effectively. This approach ensures that each query is optimally resolved using the appropriate resolver.</p>
<p>Although the code structure looks similar to earlier examples, employing resolvers significantly enhances efficiency by optimizing how requests are handled and reducing unnecessary API calls.</p>
<pre><code class="language-ts">const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) =&gt; notifyOwner(todo), {
    batching: true
  })
})
</code></pre>
<p>In the final setup, this program will execute only <strong>3</strong> queries to the APIs, regardless of the number of todos. This contrasts sharply with the traditional approach, which would potentially execute <strong>1 + 2n</strong> queries, where <strong>n</strong> is the number of todos. This represents a significant improvement in efficiency, especially for applications with a high volume of data interactions.</p>
<h3>Disabling Batching</h3>
<p>Batching can be locally disabled using the <code>Effect.withRequestBatching</code> utility in the following way:</p>
<pre><code class="language-ts">const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) =&gt; notifyOwner(todo), {
    concurrency: &quot;unbounded&quot;
  })
}).pipe(Effect.withRequestBatching(false))
</code></pre>
<h3>Resolvers with Context</h3>
<p>In complex applications, resolvers often need access to shared services or configurations to handle requests effectively. However, maintaining the ability to batch requests while providing the necessary context can be challenging. Here, we&#39;ll explore how to manage context in resolvers to ensure that batching capabilities are not compromised.</p>
<p>When creating request resolvers, it&#39;s crucial to manage the context carefully. Providing too much context or providing varying services to resolvers can make them incompatible for batching. To prevent such issues, the context for the resolver used in <code>Effect.request</code> is explicitly set to <code>never</code>. This forces developers to clearly define how the context is accessed and used within resolvers.</p>
<p>Consider the following example where we set up an HTTP service that the resolvers can use to execute API calls:</p>
<pre><code class="language-ts">import { Effect, Context, RequestResolver, Request } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// Requests
// ------------------------------

// Define a request to get multiple Todo items which might
// fail with a GetTodosError
interface GetTodos extends Request.Request&lt;Array&lt;Todo&gt;, GetTodosError&gt; {
  readonly _tag: &quot;GetTodos&quot;
}

// Create a tagged constructor for GetTodos requests
const GetTodos = Request.tagged&lt;GetTodos&gt;(&quot;GetTodos&quot;)

// Define a request to fetch a User by ID which might
// fail with a GetUserError
interface GetUserById extends Request.Request&lt;User, GetUserError&gt; {
  readonly _tag: &quot;GetUserById&quot;
  readonly id: number
}

// Create a tagged constructor for GetUserById requests
const GetUserById = Request.tagged&lt;GetUserById&gt;(&quot;GetUserById&quot;)

// Define a request to send an email which might
// fail with a SendEmailError
interface SendEmail extends Request.Request&lt;void, SendEmailError&gt; {
  readonly _tag: &quot;SendEmail&quot;
  readonly address: string
  readonly text: string
}

// Create a tagged constructor for SendEmail requests
const SendEmail = Request.tagged&lt;SendEmail&gt;(&quot;SendEmail&quot;)

// ------------------------------
// Resolvers With Context
// ------------------------------

class HttpService extends Context.Tag(&quot;HttpService&quot;)&lt;
  HttpService,
  { fetch: typeof fetch }
&gt;() {}

const GetTodosResolver =
  // we create a normal resolver like we did before
  RequestResolver.fromEffect((_: GetTodos) =&gt;
    Effect.andThen(HttpService, (http) =&gt;
      Effect.tryPromise({
        try: () =&gt;
          http
            .fetch(&quot;https://api.example.demo/todos&quot;)
            .then((res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;),
        catch: () =&gt; new GetTodosError()
      })
    )
  ).pipe(
    // we list the tags that the resolver can access
    RequestResolver.contextFromServices(HttpService)
  )
</code></pre>
<p>We can see now that the type of <code>GetTodosResolver</code> is no longer a <code>RequestResolver</code> but instead it is:</p>
<pre><code class="language-ts">const GetTodosResolver: Effect&lt;
  RequestResolver&lt;GetTodos, never&gt;,
  never,
  HttpService
&gt;
</code></pre>
<p>which is an effect that access the <code>HttpService</code> and returns a composed resolver that has the minimal context ready to use.</p>
<p>Once we have such effect we can directly use it in our query definition:</p>
<pre><code class="language-ts">const getTodos: Effect.Effect&lt;Todo[], GetTodosError, HttpService&gt; =
  Effect.request(GetTodos({}), GetTodosResolver)
</code></pre>
<p>We can see that the Effect correctly requires <code>HttpService</code> to be provided.</p>
<p>Alternatively you can create <code>RequestResolver</code>s as part of layers direcly accessing or closing over context from construction.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Effect, Context, RequestResolver, Request, Layer } from &quot;effect&quot;

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: &quot;User&quot;
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError {
  readonly _tag = &quot;GetUserError&quot;
}

interface Todo {
  readonly _tag: &quot;Todo&quot;
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

class GetTodosError {
  readonly _tag = &quot;GetTodosError&quot;
}

class SendEmailError {
  readonly _tag = &quot;SendEmailError&quot;
}

// ------------------------------
// Requests
// ------------------------------

// Define a request to get multiple Todo items which might
// fail with a GetTodosError
interface GetTodos extends Request.Request&lt;Array&lt;Todo&gt;, GetTodosError&gt; {
  readonly _tag: &quot;GetTodos&quot;
}

// Create a tagged constructor for GetTodos requests
const GetTodos = Request.tagged&lt;GetTodos&gt;(&quot;GetTodos&quot;)

// Define a request to fetch a User by ID which might
// fail with a GetUserError
interface GetUserById extends Request.Request&lt;User, GetUserError&gt; {
  readonly _tag: &quot;GetUserById&quot;
  readonly id: number
}

// Create a tagged constructor for GetUserById requests
const GetUserById = Request.tagged&lt;GetUserById&gt;(&quot;GetUserById&quot;)

// Define a request to send an email which might
// fail with a SendEmailError
interface SendEmail extends Request.Request&lt;void, SendEmailError&gt; {
  readonly _tag: &quot;SendEmail&quot;
  readonly address: string
  readonly text: string
}

// Create a tagged constructor for SendEmail requests
const SendEmail = Request.tagged&lt;SendEmail&gt;(&quot;SendEmail&quot;)

// ------------------------------
// Resolvers With Context
// ------------------------------

class HttpService extends Context.Tag(&quot;HttpService&quot;)&lt;
  HttpService,
  { fetch: typeof fetch }
&gt;() {}

const GetTodosResolver =
  // we create a normal resolver like we did before
  RequestResolver.fromEffect((_: GetTodos) =&gt;
    Effect.andThen(HttpService, (http) =&gt;
      Effect.tryPromise({
        try: () =&gt;
          http
            .fetch(&quot;https://api.example.demo/todos&quot;)
            .then((res) =&gt; res.json() as Promise&lt;Array&lt;Todo&gt;&gt;),
        catch: () =&gt; new GetTodosError()
      })
    )
  ).pipe(
    // we list the tags that the resolver can access
    RequestResolver.contextFromServices(HttpService)
  )

// ------------------------------
// Layers
// ------------------------------

class TodosService extends Context.Tag(&quot;TodosService&quot;)&lt;
  TodosService,
  {
    getTodos: Effect.Effect&lt;Array&lt;Todo&gt;, GetTodosError&gt;
  }
&gt;() {}

const TodosServiceLive = Layer.effect(
  TodosService,
  Effect.gen(function* () {
    const http = yield* HttpService
    const resolver = RequestResolver.fromEffect((_: GetTodos) =&gt;
      Effect.tryPromise({
        try: () =&gt;
          http
            .fetch(&quot;https://api.example.demo/todos&quot;)
            .then&lt;any, Todo[]&gt;((res) =&gt; res.json()),
        catch: () =&gt; new GetTodosError()
      })
    )
    return {
      getTodos: Effect.request(GetTodos({}), resolver)
    }
  })
)

const getTodos: Effect.Effect&lt;
  Array&lt;Todo&gt;,
  GetTodosError,
  TodosService
&gt; = Effect.andThen(TodosService, (service) =&gt; service.getTodos)
</code></pre>
<p>This way is probably the best for most of the cases given that layers are the natural primitive where to wire services together.</p>
<h2>Caching</h2>
<p>While we have significantly optimized request batching, there&#39;s another area that can enhance our application&#39;s efficiency: caching. Without caching, even with optimized batch processing, the same requests could be executed multiple times, leading to unnecessary data fetching.</p>
<p>In the Effect library, caching is handled through built-in utilities that allow requests to be stored temporarily, preventing the need to re-fetch data that hasn&#39;t changed. This feature is crucial for reducing the load on both the server and the network, especially in applications that make frequent similar requests.</p>
<p>Here&#39;s how you can implement caching for the <code>getUserById</code> query:</p>
<pre><code class="language-ts">const getUserById = (id: number) =&gt;
  Effect.request(GetUserById({ id }), GetUserByIdResolver).pipe(
    Effect.withRequestCaching(true)
  )
</code></pre>
<h2>Final Program</h2>
<p>Assuming you&#39;ve wired everything up correctly:</p>
<pre><code class="language-ts">const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) =&gt; notifyOwner(todo), {
    concurrency: &quot;unbounded&quot;
  })
}).pipe(Effect.repeat(Schedule.fixed(&quot;10 seconds&quot;)))
</code></pre>
<p>With this program, the <code>getTodos</code> operation retrieves the todos for each user. Then, the <code>Effect.forEach</code> function is used to notify the owner of each todo concurrently, without waiting for the notifications to complete.</p>
<p>The <code>repeat</code> function is applied to the entire chain of operations, and it ensures that the program repeats every 10 seconds using a fixed schedule. This means that the entire process, including fetching todos and sending notifications, will be executed repeatedly with a 10-second interval.</p>
<p>The program incorporates a caching mechanism, which prevents the same <code>GetUserById</code> operation from being executed more than once within a span of 1 minute. This default caching behavior helps optimize the program&#39;s execution and reduces unnecessary requests to fetch user data.</p>
<p>Furthermore, the program is designed to send emails in batches, allowing for efficient processing and better utilization of resources.</p>
<h2>Customizing Request Caching</h2>
<p>In real-world applications, effective caching strategies can significantly improve performance by reducing redundant data fetching. The Effect library provides flexible caching mechanisms that can be tailored for specific parts of your application or applied globally.</p>
<p>There may be scenarios where different parts of your application have unique caching requirements—some might benefit from a localized cache, while others might need a global cache setup. Let’s explore how you can configure a custom cache to meet these varied needs.</p>
<h3>Creating a Custom Cache</h3>
<p>Here&#39;s how you can create a custom cache and apply it to part of your application. This example demonstrates setting up a cache that repeats a task every 10 seconds, caching requests with specific parameters like capacity and TTL (time-to-live).</p>
<pre><code class="language-ts">const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) =&gt; notifyOwner(todo), {
    concurrency: &quot;unbounded&quot;
  })
}).pipe(
  Effect.repeat(Schedule.fixed(&quot;10 seconds&quot;)),
  Effect.provide(
    Layer.setRequestCache(
      Request.makeCache({ capacity: 256, timeToLive: &quot;60 minutes&quot; })
    )
  )
)
</code></pre>
<h3>Direct Cache Application</h3>
<p>You can also construct a cache using <code>Request.makeCache</code> and apply it directly to a specific program using <code>Effect.withRequestCache</code>. This method ensures that all requests originating from the specified program are managed through the custom cache, provided that caching is enabled.</p>
<hr>
<hr>
<h2>title: Equivalence
description: Define and customize equivalence relations for TypeScript values.
sidebar:
  order: 0</h2>
<p>The Equivalence module provides a way to define equivalence relations between values in TypeScript. An equivalence relation is a binary relation that is reflexive, symmetric, and transitive, establishing a formal notion of when two values should be considered equivalent.</p>
<h2>What is Equivalence?</h2>
<p>An <code>Equivalence&lt;A&gt;</code> represents a function that compares two values of type <code>A</code> and determines if they are equivalent. This is more flexible and customizable than simple equality checks using <code>===</code>.</p>
<p>Here&#39;s the structure of an <code>Equivalence</code>:</p>
<pre><code class="language-ts">interface Equivalence&lt;A&gt; {
  (self: A, that: A): boolean
}
</code></pre>
<h2>Using Built-in Equivalences</h2>
<p>The module provides several built-in equivalence relations for common data types:</p>
<table>
<thead>
<tr>
<th>Equivalence</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>string</code></td>
<td>Uses strict equality (<code>===</code>) for strings</td>
</tr>
<tr>
<td><code>number</code></td>
<td>Uses strict equality (<code>===</code>) for numbers</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>Uses strict equality (<code>===</code>) for booleans</td>
</tr>
<tr>
<td><code>symbol</code></td>
<td>Uses strict equality (<code>===</code>) for symbols</td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>Uses strict equality (<code>===</code>) for bigints</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>Compares <code>Date</code> objects by their timestamps</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Built-in Equivalences)</p>
<pre><code class="language-ts">import { Equivalence } from &quot;effect&quot;

console.log(Equivalence.string(&quot;apple&quot;, &quot;apple&quot;))
// Output: true

console.log(Equivalence.string(&quot;apple&quot;, &quot;orange&quot;))
// Output: false

console.log(Equivalence.Date(new Date(2023, 1, 1), new Date(2023, 1, 1)))
// Output: true

console.log(Equivalence.Date(new Date(2023, 1, 1), new Date(2023, 10, 1)))
// Output: false
</code></pre>
<h2>Deriving Equivalences</h2>
<p>For more complex data structures, you may need custom equivalences. The Equivalence module lets you derive new <code>Equivalence</code> instances from existing ones with the <code>Equivalence.mapInput</code> function.</p>
<p><strong>Example</strong> (Creating a Custom Equivalence for Objects)</p>
<pre><code class="language-ts">import { Equivalence } from &quot;effect&quot;

interface User {
  readonly id: number
  readonly name: string
}

// Create an equivalence that compares User objects based only on the id
const equivalence = Equivalence.mapInput(
  Equivalence.number, // Base equivalence for comparing numbers
  (user: User) =&gt; user.id // Function to extract the id from a User
)

// Compare two User objects: they are equivalent if their ids are the same
console.log(equivalence({ id: 1, name: &quot;Alice&quot; }, { id: 1, name: &quot;Al&quot; }))
// Output: true
</code></pre>
<p>The <code>Equivalence.mapInput</code> function takes two arguments:</p>
<ol>
<li>The existing <code>Equivalence</code> you want to use as a base (<code>Equivalence.number</code> in this case, for comparing numbers).</li>
<li>A function that extracts the value used for the equivalence check from your data structure (<code>(user: User) =&gt; user.id</code> in this case).</li>
</ol>
<hr>
<hr>
<h2>title: Order
description: Compare, sort, and manage value ordering with customizable tools for TypeScript.
sidebar:
  order: 2</h2>
<p>The Order module provides a way to compare values and determine their order.
It defines an interface <code>Order&lt;A&gt;</code> which represents a single function for comparing two values of type <code>A</code>.
The function returns <code>-1</code>, <code>0</code>, or <code>1</code>, indicating whether the first value is less than, equal to, or greater than the second value.</p>
<p>Here&#39;s the basic structure of an <code>Order</code>:</p>
<pre><code class="language-ts">interface Order&lt;A&gt; {
  (first: A, second: A): -1 | 0 | 1
}
</code></pre>
<h2>Using the Built-in Orders</h2>
<p>The Order module comes with several built-in comparators for common data types:</p>
<table>
<thead>
<tr>
<th>Order</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>string</code></td>
<td>Used for comparing strings.</td>
</tr>
<tr>
<td><code>number</code></td>
<td>Used for comparing numbers.</td>
</tr>
<tr>
<td><code>bigint</code></td>
<td>Used for comparing big integers.</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>Used for comparing <code>Date</code> objects.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Built-in Comparators)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

console.log(Order.string(&quot;apple&quot;, &quot;banana&quot;))
// Output: -1, as &quot;apple&quot; &lt; &quot;banana&quot;

console.log(Order.number(1, 1))
// Output: 0, as 1 = 1

console.log(Order.bigint(2n, 1n))
// Output: 1, as 2n &gt; 1n
</code></pre>
<h2>Sorting Arrays</h2>
<p>You can sort arrays using these comparators. The <code>Array</code> module offers a <code>sort</code> function that sorts arrays without altering the original one.</p>
<p><strong>Example</strong> (Sorting Arrays with <code>Order</code>)</p>
<pre><code class="language-ts">import { Order, Array } from &quot;effect&quot;

const strings = [&quot;b&quot;, &quot;a&quot;, &quot;d&quot;, &quot;c&quot;]

const result = Array.sort(strings, Order.string)

console.log(strings) // Original array remains unchanged
// Output: [ &#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;c&#39; ]

console.log(result) // Sorted array
// Output: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]
</code></pre>
<p>You can also use an <code>Order</code> as a comparator with JavaScript&#39;s native <code>Array.sort</code> method, but keep in mind that this will modify the original array.</p>
<p><strong>Example</strong> (Using <code>Order</code> with Native <code>Array.prototype.sort</code>)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

const strings = [&quot;b&quot;, &quot;a&quot;, &quot;d&quot;, &quot;c&quot;]

strings.sort(Order.string) // Modifies the original array

console.log(strings)
// Output: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]
</code></pre>
<h2>Deriving Orders</h2>
<p>For more complex data structures, you may need custom sorting rules. The Order module lets you derive new <code>Order</code> instances from existing ones with the <code>Order.mapInput</code> function.</p>
<p><strong>Example</strong> (Creating a Custom Order for Objects)</p>
<p>Imagine you have a list of <code>Person</code> objects, and you want to sort them by their names in ascending order.
To achieve this, you can create a custom <code>Order</code>.</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

// Define the Person interface
interface Person {
  readonly name: string
  readonly age: number
}

// Create a custom order to sort Person objects by name in ascending order
//
//      ┌─── Order&lt;Person&gt;
//      ▼
const byName = Order.mapInput(
  Order.string,
  (person: Person) =&gt; person.name
)
</code></pre>
<p>The <code>Order.mapInput</code> function takes two arguments:</p>
<ol>
<li>The existing <code>Order</code> you want to use as a base (<code>Order.string</code> in this case, for comparing strings).</li>
<li>A function that extracts the value you want to use for sorting from your data structure (<code>(person: Person) =&gt; person.name</code> in this case).</li>
</ol>
<p>Once you have defined your custom <code>Order</code>, you can apply it to sort an array of <code>Person</code> objects:</p>
<p><strong>Example</strong> (Sorting Objects Using a Custom Order)</p>
<pre><code class="language-ts">import { Order, Array } from &quot;effect&quot;

// Define the Person interface
interface Person {
  readonly name: string
  readonly age: number
}

// Create a custom order to sort Person objects by name in ascending order
const byName = Order.mapInput(
  Order.string,
  (person: Person) =&gt; person.name
)

const persons: ReadonlyArray&lt;Person&gt; = [
  { name: &quot;Charlie&quot;, age: 22 },
  { name: &quot;Alice&quot;, age: 25 },
  { name: &quot;Bob&quot;, age: 30 }
]

// Sort persons array using the custom order
const sortedPersons = Array.sort(persons, byName)

console.log(sortedPersons)
/*
Output:
[
  { name: &#39;Alice&#39;, age: 25 },
  { name: &#39;Bob&#39;, age: 30 },
  { name: &#39;Charlie&#39;, age: 22 }
]
*/
</code></pre>
<h2>Combining Orders</h2>
<p>The Order module lets you combine multiple <code>Order</code> instances to create complex sorting rules. This is useful when sorting by multiple properties.</p>
<p><strong>Example</strong> (Sorting by Multiple Criteria)</p>
<p>Imagine you have a list of people, each represented by an object with a <code>name</code> and an <code>age</code>. You want to sort this list first by name and then, for individuals with the same name, by age.</p>
<pre><code class="language-ts">import { Order, Array } from &quot;effect&quot;

// Define the Person interface
interface Person {
  readonly name: string
  readonly age: number
}

// Create an Order to sort people by their names in ascending order
const byName = Order.mapInput(
  Order.string,
  (person: Person) =&gt; person.name
)

// Create an Order to sort people by their ages in ascending order
const byAge = Order.mapInput(Order.number, (person: Person) =&gt; person.age)

// Combine orders to sort by name, then by age
const byNameAge = Order.combine(byName, byAge)

const result = Array.sort(
  [
    { name: &quot;Bob&quot;, age: 20 },
    { name: &quot;Alice&quot;, age: 18 },
    { name: &quot;Bob&quot;, age: 18 }
  ],
  byNameAge
)

console.log(result)
/*
Output:
[
  { name: &#39;Alice&#39;, age: 18 }, // Sorted by name
  { name: &#39;Bob&#39;, age: 18 },   // Sorted by age within the same name
  { name: &#39;Bob&#39;, age: 20 }
]
*/
</code></pre>
<h2>Additional Useful Functions</h2>
<p>The Order module provides additional functions for common comparison operations, making it easier to work with ordered values.</p>
<h3>Reversing Order</h3>
<p><code>Order.reverse</code> inverts the order of comparison. If you have an <code>Order</code> for ascending values, reversing it makes it descending.</p>
<p><strong>Example</strong> (Reversing an Order)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

const ascendingOrder = Order.number

const descendingOrder = Order.reverse(ascendingOrder)

console.log(ascendingOrder(1, 3))
// Output: -1 (1 &lt; 3 in ascending order)
console.log(descendingOrder(1, 3))
// Output: 1 (1 &gt; 3 in descending order)
</code></pre>
<h3>Comparing Values</h3>
<p>These functions allow you to perform simple comparisons between values:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>lessThan</code></td>
<td>Checks if one value is strictly less than another.</td>
</tr>
<tr>
<td><code>greaterThan</code></td>
<td>Checks if one value is strictly greater than another.</td>
</tr>
<tr>
<td><code>lessThanOrEqualTo</code></td>
<td>Checks if one value is less than or equal to another.</td>
</tr>
<tr>
<td><code>greaterThanOrEqualTo</code></td>
<td>Checks if one value is greater than or equal to another.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Comparison Functions)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

console.log(Order.lessThan(Order.number)(1, 2))
// Output: true (1 &lt; 2)

console.log(Order.greaterThan(Order.number)(5, 3))
// Output: true (5 &gt; 3)

console.log(Order.lessThanOrEqualTo(Order.number)(2, 2))
// Output: true (2 &lt;= 2)

console.log(Order.greaterThanOrEqualTo(Order.number)(4, 4))
// Output: true (4 &gt;= 4)
</code></pre>
<h3>Finding Minimum and Maximum</h3>
<p>The <code>Order.min</code> and <code>Order.max</code> functions return the minimum or maximum value between two values, considering the order.</p>
<p><strong>Example</strong> (Finding Minimum and Maximum Numbers)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

console.log(Order.min(Order.number)(3, 1))
// Output: 1 (1 is the minimum)

console.log(Order.max(Order.number)(5, 8))
// Output: 8 (8 is the maximum)
</code></pre>
<h3>Clamping Values</h3>
<p><code>Order.clamp</code> restricts a value within a given range. If the value is outside the range, it is adjusted to the nearest bound.</p>
<p><strong>Example</strong> (Clamping Numbers to a Range)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

// Define a function to clamp numbers between 20 and 30
const clampNumbers = Order.clamp(Order.number)({
  minimum: 20,
  maximum: 30
})

// Value 26 is within the range [20, 30], so it remains unchanged
console.log(clampNumbers(26))
// Output: 26

// Value 10 is below the minimum bound, so it is clamped to 20
console.log(clampNumbers(10))
// Output: 20

// Value 40 is above the maximum bound, so it is clamped to 30
console.log(clampNumbers(40))
// Output: 30
</code></pre>
<h3>Checking Value Range</h3>
<p><code>Order.between</code> checks if a value falls within a specified inclusive range.</p>
<p><strong>Example</strong> (Checking if Numbers Fall Within a Range)</p>
<pre><code class="language-ts">import { Order } from &quot;effect&quot;

// Create a function to check if numbers are between 20 and 30
const betweenNumbers = Order.between(Order.number)({
  minimum: 20,
  maximum: 30
})

// Value 26 falls within the range [20, 30], so it returns true
console.log(betweenNumbers(26))
// Output: true

// Value 10 is below the minimum bound, so it returns false
console.log(betweenNumbers(10))
// Output: false

// Value 40 is above the maximum bound, so it returns false
console.log(betweenNumbers(40))
// Output: false
</code></pre>
<hr>
<hr>
<h2>title: Cache
description: Optimize performance with cache for concurrent, compositional, and efficient value retrieval.
sidebar:
  order: 1</h2>
<p>In many applications, handling overlapping work is common. For example, in services that process incoming requests, it&#39;s important to avoid redundant work like handling the same request multiple times. The Cache module helps improve performance by preventing duplicate work.</p>
<p>Key Features of Cache:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Compositionality</strong></td>
<td>Allows overlapping work across different parts of the application while preserving compositional programming.</td>
</tr>
<tr>
<td><strong>Unified Sync and Async Caches</strong></td>
<td>Integrates both synchronous and asynchronous caches through a unified lookup function that computes values either way.</td>
</tr>
<tr>
<td><strong>Effect Integration</strong></td>
<td>Works natively with the Effect library, supporting concurrent lookups, failure handling, and interruption.</td>
</tr>
<tr>
<td><strong>Cache Metrics</strong></td>
<td>Tracks key metrics like entries, hits, and misses, providing insights for performance optimization.</td>
</tr>
</tbody></table>
<h2>Creating a Cache</h2>
<p>A cache is defined by a lookup function that computes the value for a given key if it&#39;s not already cached:</p>
<pre><code class="language-ts">type Lookup&lt;Key, Value, Error, Requirements&gt; = (
  key: Key
) =&gt; Effect&lt;Value, Error, Requirements&gt;
</code></pre>
<p>The lookup function takes a <code>Key</code> and returns an <code>Effect</code>, which describes how to compute the value (<code>Value</code>). This <code>Effect</code> may require an environment (<code>Requirements</code>), can fail with an <code>Error</code>, and succeed with a <code>Value</code>. Since it returns an <code>Effect</code>, it can handle both synchronous and asynchronous workflows.</p>
<p>You create a cache by providing a lookup function along with a maximum size and a time-to-live (TTL) for cached values.</p>
<pre><code class="language-ts">declare const make: &lt;Key, Value, Error, Requirements&gt;(options: {
  readonly capacity: number
  readonly timeToLive: Duration.DurationInput
  readonly lookup: Lookup&lt;Key, Value, Error, Requirements&gt;
}) =&gt; Effect&lt;Cache&lt;Key, Value, Error&gt;, never, Requirements&gt;
</code></pre>
<p>Once a cache is created, the most idiomatic way to work with it is the <code>get</code> method.
The <code>get</code> method returns the current value in the cache if it exists, or computes a new value, puts it in the cache, and returns it.</p>
<p>If multiple concurrent processes request the same value, it will only be computed once. All other processes will receive the computed value as soon as it is available. This is managed using Effect&#39;s fiber-based concurrency model without blocking the underlying thread.</p>
<p><strong>Example</strong> (Concurrent Cache Lookups)</p>
<p>In this example, we call <code>timeConsumingEffect</code> three times concurrently with the same key.
The cache runs this effect only once, so concurrent lookups will wait until the value is available:</p>
<pre><code class="language-ts">import { Effect, Cache, Duration } from &quot;effect&quot;

// Simulating an expensive lookup with a delay
const expensiveLookup = (key: string) =&gt;
  Effect.sleep(&quot;2 seconds&quot;).pipe(Effect.as(key.length))

const program = Effect.gen(function* () {
  // Create a cache with a capacity of 100 and an infinite TTL
  const cache = yield* Cache.make({
    capacity: 100,
    timeToLive: Duration.infinity,
    lookup: expensiveLookup
  })

  // Perform concurrent lookups using the same key
  const result = yield* Effect.all(
    [cache.get(&quot;key1&quot;), cache.get(&quot;key1&quot;), cache.get(&quot;key1&quot;)],
    { concurrency: &quot;unbounded&quot; }
  )
  console.log(
    &quot;Result of parallel execution of three effects&quot; +
      `with the same key: ${result}`
  )

  // Fetch and display cache stats
  const hits = yield* cache.cacheStats.pipe(
    Effect.map((stats) =&gt; stats.hits)
  )
  console.log(`Number of cache hits: ${hits}`)
  const misses = yield* cache.cacheStats.pipe(
    Effect.map((stats) =&gt; stats.misses)
  )
  console.log(`Number of cache misses: ${misses}`)
})

Effect.runPromise(program)
/*
Output:
Result of parallel execution of three effects with the same key: 4,4,4
Number of cache hits: 2
Number of cache misses: 1
*/
</code></pre>
<h2>Concurrent Access</h2>
<p>The cache is designed to be safe for concurrent access and efficient under concurrent conditions. If two concurrent processes request the same value and it is not in the cache, the value will be computed once and provided to both processes as soon as it is available. Concurrent processes will wait for the value without blocking the underlying thread.</p>
<p>If the lookup function fails or is interrupted, the error will be propagated to all concurrent processes waiting for the value. Failures are cached to prevent repeated computation of the same failed value. If interrupted, the key will be removed from the cache, so subsequent calls will attempt to compute the value again.</p>
<h2>Capacity</h2>
<p>A cache is created with a specified capacity. When the cache reaches capacity, the least recently accessed values will be removed first. The cache size may slightly exceed the specified capacity between operations.</p>
<h2>Time To Live (TTL)</h2>
<p>A cache can also have a specified time to live (TTL). Values older than the TTL will not be returned. The age is calculated from when the value was loaded into the cache.</p>
<h2>Methods</h2>
<p>In addition to <code>get</code>, the cache provides several other methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>refresh</code></td>
<td>Triggers a recomputation of the value for a key without removing the old value, allowing continued access.</td>
</tr>
<tr>
<td><code>size</code></td>
<td>Returns the current size of the cache. The size is approximate under concurrent conditions.</td>
</tr>
<tr>
<td><code>contains</code></td>
<td>Checks if a value associated with a specified key exists in the cache. Under concurrent access, the result is valid as of the check time but may change immediately after.</td>
</tr>
<tr>
<td><code>invalidate</code></td>
<td>Evicts the value associated with a specific key.</td>
</tr>
<tr>
<td><code>invalidateAll</code></td>
<td>Evicts all values from the cache.</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2>title: Caching Effects
description: Efficiently manage caching and memoization of effects with reusable tools.
sidebar:
  order: 0</h2>
<p>This section covers several functions from the library that help manage caching and memoization in your application.</p>
<h2>cachedFunction</h2>
<p>Memoizes a function with effects, caching results for the same inputs to avoid recomputation.</p>
<p><strong>Example</strong> (Memoizing a Random Number Generator)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const randomNumber = (n: number) =&gt; Random.nextIntBetween(1, n)
  console.log(&quot;non-memoized version:&quot;)
  console.log(yield* randomNumber(10)) // Generates a new random number
  console.log(yield* randomNumber(10)) // Generates a different number

  console.log(&quot;memoized version:&quot;)
  const memoized = yield* Effect.cachedFunction(randomNumber)
  console.log(yield* memoized(10)) // Generates and caches the result
  console.log(yield* memoized(10)) // Reuses the cached result
})

Effect.runFork(program)
/*
Example Output:
non-memoized version:
2
8
memoized version:
5
5
*/
</code></pre>
<h2>once</h2>
<p>Ensures an effect is executed only once, even if invoked multiple times.</p>
<p><strong>Example</strong> (Single Execution of an Effect)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const task1 = Console.log(&quot;task1&quot;)

  // Repeats task1 three times
  yield* Effect.repeatN(task1, 2)

  // Ensures task2 is executed only once
  const task2 = yield* Effect.once(Console.log(&quot;task2&quot;))

  // Attempts to repeat task2, but it will only execute once
  yield* Effect.repeatN(task2, 2)
})

Effect.runFork(program)
/*
Output:
task1
task1
task1
task2
*/
</code></pre>
<h2>cached</h2>
<p>Returns an effect that computes a result lazily and caches it. Subsequent evaluations of this effect will return the cached result without re-executing the logic.</p>
<p><strong>Example</strong> (Lazy Caching of an Expensive Task)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

let i = 1

// Simulating an expensive task with a delay
const expensiveTask = Effect.promise&lt;string&gt;(() =&gt; {
  console.log(&quot;expensive task...&quot;)
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  // Without caching, the task is executed each time
  console.log(&quot;-- non-cached version:&quot;)
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  yield* expensiveTask.pipe(Effect.andThen(Console.log))

  // With caching, the result is reused after the first run
  console.log(&quot;-- cached version:&quot;)
  const cached = yield* Effect.cached(expensiveTask)
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
/*
Output:
-- non-cached version:
expensive task...
result 1
expensive task...
result 2
-- cached version:
expensive task...
result 3
result 3
*/
</code></pre>
<h2>cachedWithTTL</h2>
<p>Returns an effect that caches its result for a specified duration, known as the <code>timeToLive</code>. When the cache expires after the duration, the effect will be recomputed upon next evaluation.</p>
<p><strong>Example</strong> (Caching with Time-to-Live)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

let i = 1

// Simulating an expensive task with a delay
const expensiveTask = Effect.promise&lt;string&gt;(() =&gt; {
  console.log(&quot;expensive task...&quot;)
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  // Caches the result for 150 milliseconds
  const cached = yield* Effect.cachedWithTTL(expensiveTask, &quot;150 millis&quot;)

  // First evaluation triggers the task
  yield* cached.pipe(Effect.andThen(Console.log))

  // Second evaluation returns the cached result
  yield* cached.pipe(Effect.andThen(Console.log))

  // Wait for 100 milliseconds, ensuring the cache expires
  yield* Effect.sleep(&quot;100 millis&quot;)

  // Recomputes the task after cache expiration
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
/*
Output:
expensive task...
result 1
result 1
expensive task...
result 2
*/
</code></pre>
<h2>cachedInvalidateWithTTL</h2>
<p>Similar to <code>Effect.cachedWithTTL</code>, this function caches an effect&#39;s result for a specified duration. It also includes an additional effect for manually invalidating the cached value before it naturally expires.</p>
<p><strong>Example</strong> (Invalidating Cache Manually)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

let i = 1

// Simulating an expensive task with a delay
const expensiveTask = Effect.promise&lt;string&gt;(() =&gt; {
  console.log(&quot;expensive task...&quot;)
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  // Caches the result for 150 milliseconds
  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
    expensiveTask,
    &quot;150 millis&quot;
  )

  // First evaluation triggers the task
  yield* cached.pipe(Effect.andThen(Console.log))

  // Second evaluation returns the cached result
  yield* cached.pipe(Effect.andThen(Console.log))

  // Invalidate the cache before it naturally expires
  yield* invalidate

  // Third evaluation triggers the task again
  // since the cache was invalidated
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
/*
Output:
expensive task...
result 1
result 1
expensive task...
result 2
*/
</code></pre>
<hr>
<hr>
<h2>title: Branded Types
description: Use branded types to enforce type safety and refine data in TypeScript.
sidebar:
  order: 3</h2>
<p>In this guide, we will explore the concept of <strong>branded types</strong> in TypeScript and learn how to create and work with them using the Brand module.
Branded types are TypeScript types with an added type tag that helps prevent accidental usage of a value in the wrong context.
They allow us to create distinct types based on an existing underlying type, enabling type safety and better code organization.</p>
<h2>The Problem with TypeScript&#39;s Structural Typing</h2>
<p>TypeScript&#39;s type system is structurally typed, meaning that two types are considered compatible if their members are compatible.
This can lead to situations where values of the same underlying type are used interchangeably, even when they represent different concepts or have different meanings.</p>
<p>Consider the following types:</p>
<pre><code class="language-ts">type UserId = number

type ProductId = number
</code></pre>
<p>Here, <code>UserId</code> and <code>ProductId</code> are structurally identical as they are both based on <code>number</code>.
TypeScript will treat these as interchangeable, potentially causing bugs if they are mixed up in your application.</p>
<p><strong>Example</strong> (Unintended Type Compatibility)</p>
<pre><code class="language-ts">type UserId = number

type ProductId = number

const getUserById = (id: UserId) =&gt; {
  // Logic to retrieve user
}

const getProductById = (id: ProductId) =&gt; {
  // Logic to retrieve product
}

const id: UserId = 1

getProductById(id) // No type error, but incorrect usage
</code></pre>
<p>In the example above, passing a <code>UserId</code> to <code>getProductById</code> does not produce a type error, even though it&#39;s logically incorrect. This happens because both types are considered interchangeable.</p>
<h2>How Branded Types Help</h2>
<p>Branded types allow you to create distinct types from the same underlying type by adding a unique type tag, enforcing proper usage at compile-time.</p>
<p>Branding is accomplished by adding a symbolic identifier that distinguishes one type from another at the type level.
This method ensures that types remain distinct without altering their runtime characteristics.</p>
<p>Let&#39;s start by introducing the <code>BrandTypeId</code> symbol:</p>
<pre><code class="language-ts">const BrandTypeId: unique symbol = Symbol.for(&quot;effect/Brand&quot;)

type ProductId = number &amp; {
  readonly [BrandTypeId]: {
    readonly ProductId: &quot;ProductId&quot; // unique identifier for ProductId
  }
}
</code></pre>
<p>This approach assigns a unique identifier as a brand to the <code>number</code> type, effectively differentiating <code>ProductId</code> from other numerical types.
The use of a symbol ensures that the branding field does not conflict with any existing properties of the <code>number</code> type.</p>
<p>Attempting to use a <code>UserId</code> in place of a <code>ProductId</code> now results in an error:</p>
<p><strong>Example</strong> (Enforcing Type Safety with Branded Types)</p>
<pre><code class="language-ts">const BrandTypeId: unique symbol = Symbol.for(&quot;effect/Brand&quot;)

type ProductId = number &amp; {
  readonly [BrandTypeId]: {
    readonly ProductId: &quot;ProductId&quot;
  }
}

const getProductById = (id: ProductId) =&gt; {
  // Logic to retrieve product
}

type UserId = number

const id: UserId = 1

// @ts-expect-error
getProductById(id)
/*
Argument of type &#39;number&#39; is not assignable to parameter of type &#39;ProductId&#39;.
  Type &#39;number&#39; is not assignable to type &#39;{ readonly [BrandTypeId]: { readonly ProductId: &quot;ProductId&quot;; }; }&#39;.ts(2345)
*/
</code></pre>
<p>The error message clearly states that a <code>number</code> cannot be used in place of a <code>ProductId</code>.</p>
<p>TypeScript won&#39;t let us pass an instance of <code>number</code> to the function accepting <code>ProductId</code> because it&#39;s missing the brand field.</p>
<p>Let&#39;s add branding to <code>UserId</code> as well:</p>
<p><strong>Example</strong> (Branding UserId and ProductId)</p>
<pre><code class="language-ts">const BrandTypeId: unique symbol = Symbol.for(&quot;effect/Brand&quot;)

type ProductId = number &amp; {
  readonly [BrandTypeId]: {
    readonly ProductId: &quot;ProductId&quot; // unique identifier for ProductId
  }
}

const getProductById = (id: ProductId) =&gt; {
  // Logic to retrieve product
}

type UserId = number &amp; {
  readonly [BrandTypeId]: {
    readonly UserId: &quot;UserId&quot; // unique identifier for UserId
  }
}

declare const id: UserId

// @ts-expect-error
getProductById(id)
/*
Argument of type &#39;UserId&#39; is not assignable to parameter of type &#39;ProductId&#39;.
  Type &#39;UserId&#39; is not assignable to type &#39;{ readonly [BrandTypeId]: { readonly ProductId: &quot;ProductId&quot;; }; }&#39;.
    Types of property &#39;[BrandTypeId]&#39; are incompatible.
      Property &#39;ProductId&#39; is missing in type &#39;{ readonly UserId: &quot;UserId&quot;; }&#39; but required in type &#39;{ readonly ProductId: &quot;ProductId&quot;; }&#39;.ts(2345)
*/
</code></pre>
<p>The error indicates that while both types use branding, the unique values associated with the branding fields (<code>&quot;ProductId&quot;</code> and <code>&quot;UserId&quot;</code>) ensure they remain distinct and non-interchangeable.</p>
<h2>Generalizing Branded Types</h2>
<p>To enhance the versatility and reusability of branded types, they can be generalized using a standardized approach:</p>
<pre><code class="language-ts">const BrandTypeId: unique symbol = Symbol.for(&quot;effect/Brand&quot;)

// Create a generic Brand interface using a unique identifier
interface Brand&lt;in out ID extends string | symbol&gt; {
  readonly [BrandTypeId]: {
    readonly [id in ID]: ID
  }
}

// Define a ProductId type branded with a unique identifier
type ProductId = number &amp; Brand&lt;&quot;ProductId&quot;&gt;

// Define a UserId type branded similarly
type UserId = number &amp; Brand&lt;&quot;UserId&quot;&gt;
</code></pre>
<p>This design allows any type to be branded using a unique identifier, either a string or symbol.</p>
<p>Here&#39;s how you can utilize the <code>Brand</code> interface, which is readily available from the Brand module, eliminating the need to craft your own implementation:</p>
<p><strong>Example</strong> (Using the Brand Interface from the Brand Module)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

// Define a ProductId type branded with a unique identifier
type ProductId = number &amp; Brand.Brand&lt;&quot;ProductId&quot;&gt;

// Define a UserId type branded similarly
type UserId = number &amp; Brand.Brand&lt;&quot;UserId&quot;&gt;
</code></pre>
<p>However, creating instances of these types directly leads to an error because the type system expects the brand structure:</p>
<p><strong>Example</strong> (Direct Assignment Error)</p>
<pre><code class="language-ts">const BrandTypeId: unique symbol = Symbol.for(&quot;effect/Brand&quot;)

interface Brand&lt;in out K extends string | symbol&gt; {
  readonly [BrandTypeId]: {
    readonly [k in K]: K
  }
}

type ProductId = number &amp; Brand&lt;&quot;ProductId&quot;&gt;

// @ts-expect-error
const id: ProductId = 1
/*
Type &#39;number&#39; is not assignable to type &#39;ProductId&#39;.
  Type &#39;number&#39; is not assignable to type &#39;Brand&lt;&quot;ProductId&quot;&gt;&#39;.ts(2322)
*/
</code></pre>
<p>You cannot directly assign a <code>number</code> to <code>ProductId</code>. The Brand module provides utilities to correctly construct values of branded types.</p>
<h2>Constructing Branded Types</h2>
<p>The Brand module provides two main functions for creating branded types: <code>nominal</code> and <code>refined</code>.</p>
<h3>nominal</h3>
<p>The <code>Brand.nominal</code> function is designed for defining branded types that do not require runtime validations.
It simply adds a type tag to the underlying type, allowing us to distinguish between values of the same type but with different meanings.
Nominal branded types are useful when we only want to create distinct types for clarity and code organization purposes.</p>
<p><strong>Example</strong> (Defining Distinct Identifiers with Nominal Branding)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

// Define UserId as a branded number
type UserId = number &amp; Brand.Brand&lt;&quot;UserId&quot;&gt;

// Constructor for UserId
const UserId = Brand.nominal&lt;UserId&gt;()

const getUserById = (id: UserId) =&gt; {
  // Logic to retrieve user
}

// Define ProductId as a branded number
type ProductId = number &amp; Brand.Brand&lt;&quot;ProductId&quot;&gt;

// Constructor for ProductId
const ProductId = Brand.nominal&lt;ProductId&gt;()

const getProductById = (id: ProductId) =&gt; {
  // Logic to retrieve product
}
</code></pre>
<p>Attempting to assign a non-<code>ProductId</code> value will result in a compile-time error:</p>
<p><strong>Example</strong> (Type Safety with Branded Identifiers)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

type UserId = number &amp; Brand.Brand&lt;&quot;UserId&quot;&gt;

const UserId = Brand.nominal&lt;UserId&gt;()

const getUserById = (id: UserId) =&gt; {
  // Logic to retrieve user
}

type ProductId = number &amp; Brand.Brand&lt;&quot;ProductId&quot;&gt;

const ProductId = Brand.nominal&lt;ProductId&gt;()

const getProductById = (id: ProductId) =&gt; {
  // Logic to retrieve product
}

// Correct usage
getProductById(ProductId(1))

// Incorrect, will result in an error
// @ts-expect-error
getProductById(1)
/*
Argument of type &#39;number&#39; is not assignable to parameter of type &#39;ProductId&#39;.
  Type &#39;number&#39; is not assignable to type &#39;Brand&lt;&quot;ProductId&quot;&gt;&#39;.ts(2345)
*/

// Also incorrect, will result in an error
// @ts-expect-error
getProductById(UserId(1))
/*
Argument of type &#39;UserId&#39; is not assignable to parameter of type &#39;ProductId&#39;.
  Type &#39;UserId&#39; is not assignable to type &#39;Brand&lt;&quot;ProductId&quot;&gt;&#39;.
    Types of property &#39;[BrandTypeId]&#39; are incompatible.
      Property &#39;ProductId&#39; is missing in type &#39;{ readonly UserId: &quot;UserId&quot;; }&#39; but required in type &#39;{ readonly ProductId: &quot;ProductId&quot;; }&#39;.ts(2345)
*/
</code></pre>
<h3>refined</h3>
<p>The <code>Brand.refined</code> function enables the creation of branded types that include data validation. It requires a refinement predicate to check the validity of input data against specific criteria.</p>
<p>When the input data does not meet the criteria, the function uses <code>Brand.error</code> to generate a <code>BrandErrors</code> data type. This provides detailed information about why the validation failed.</p>
<p><strong>Example</strong> (Creating a Branded Type with Validation)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

// Define a branded type &#39;Int&#39; to represent integer values
type Int = number &amp; Brand.Brand&lt;&quot;Int&quot;&gt;

// Define the constructor using &#39;refined&#39; to enforce integer values
const Int = Brand.refined&lt;Int&gt;(
  // Validation to ensure the value is an integer
  (n) =&gt; Number.isInteger(n),
  // Provide an error if validation fails
  (n) =&gt; Brand.error(`Expected ${n} to be an integer`)
)
</code></pre>
<p><strong>Example</strong> (Using the <code>Int</code> Constructor)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

type Int = number &amp; Brand.Brand&lt;&quot;Int&quot;&gt;

const Int = Brand.refined&lt;Int&gt;(
  // Check if the value is an integer
  (n) =&gt; Number.isInteger(n),
  // Error message if the value is not an integer
  (n) =&gt; Brand.error(`Expected ${n} to be an integer`)
)

// Create a valid Int value
const x: Int = Int(3)
console.log(x) // Output: 3

// Attempt to create an Int with an invalid value
const y: Int = Int(3.14)
// throws [ { message: &#39;Expected 3.14 to be an integer&#39; } ]
</code></pre>
<p>Attempting to assign a non-<code>Int</code> value will result in a compile-time error:</p>
<p><strong>Example</strong> (Compile-Time Error for Incorrect Assignments)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

type Int = number &amp; Brand.Brand&lt;&quot;Int&quot;&gt;

const Int = Brand.refined&lt;Int&gt;(
  (n) =&gt; Number.isInteger(n),
  (n) =&gt; Brand.error(`Expected ${n} to be an integer`)
)

// Correct usage
const good: Int = Int(3)

// Incorrect, will result in an error
// @ts-expect-error
const bad1: Int = 3

// Also incorrect, will result in an error
// @ts-expect-error
const bad2: Int = 3.14
</code></pre>
<h2>Combining Branded Types</h2>
<p>In some cases, you might need to combine multiple branded types. The Brand module provides the <code>Brand.all</code> API for this purpose:</p>
<p><strong>Example</strong> (Combining Multiple Branded Types)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

type Int = number &amp; Brand.Brand&lt;&quot;Int&quot;&gt;

const Int = Brand.refined&lt;Int&gt;(
  (n) =&gt; Number.isInteger(n),
  (n) =&gt; Brand.error(`Expected ${n} to be an integer`)
)

type Positive = number &amp; Brand.Brand&lt;&quot;Positive&quot;&gt;

const Positive = Brand.refined&lt;Positive&gt;(
  (n) =&gt; n &gt; 0,
  (n) =&gt; Brand.error(`Expected ${n} to be positive`)
)

// Combine the Int and Positive constructors
// into a new branded constructor PositiveInt
const PositiveInt = Brand.all(Int, Positive)

// Extract the branded type from the PositiveInt constructor
type PositiveInt = Brand.Brand.FromConstructor&lt;typeof PositiveInt&gt;

// Usage example

// Valid positive integer
const good: PositiveInt = PositiveInt(10)

// throws [ { message: &#39;Expected -5 to be positive&#39; } ]
const bad1: PositiveInt = PositiveInt(-5)

// throws [ { message: &#39;Expected 3.14 to be an integer&#39; } ]
const bad2: PositiveInt = PositiveInt(3.14)
</code></pre>
<hr>
<hr>
<h2>title: Simplifying Excessive Nesting
description: Simplify nested code with Do simulation and generators.
sidebar:
  label: Excessive Nesting
  order: 5</h2>
<p>import { Steps } from &quot;@astrojs/starlight/components&quot;</p>
<p>Suppose you want to create a custom function <code>elapsed</code> that prints the elapsed time taken by an effect to execute.</p>
<h2>Using plain pipe</h2>
<p>Initially, you may come up with code that uses the standard <code>pipe</code> <a href="/docs/getting-started/building-pipelines/#the-pipe-method">method</a>, but this approach can lead to excessive nesting and result in verbose and hard-to-read code:</p>
<p><strong>Example</strong> (Measuring Elapsed Time with <code>pipe</code>)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Get the current timestamp
const now = Effect.sync(() =&gt; new Date().getTime())

// Prints the elapsed time occurred to `self` to execute
const elapsed = &lt;R, E, A&gt;(
  self: Effect.Effect&lt;A, E, R&gt;
): Effect.Effect&lt;A, E, R&gt; =&gt;
  now.pipe(
    Effect.andThen((startMillis) =&gt;
      self.pipe(
        Effect.andThen((result) =&gt;
          now.pipe(
            Effect.andThen((endMillis) =&gt; {
              // Calculate the elapsed time in milliseconds
              const elapsed = endMillis - startMillis
              // Log the elapsed time
              return Console.log(`Elapsed: ${elapsed}`).pipe(
                Effect.map(() =&gt; result)
              )
            })
          )
        )
      )
    )
  )

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed(&quot;some task&quot;).pipe(Effect.delay(&quot;200 millis&quot;))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/*
Output:
Elapsed: 204
some task
*/
</code></pre>
<p>To address this issue and make the code more manageable, there is a solution: the &quot;do simulation.&quot;</p>
<h2>Using the &quot;do simulation&quot;</h2>
<p>The &quot;do simulation&quot; in Effect allows you to write code in a more declarative style, similar to the &quot;do notation&quot; in other programming languages. It provides a way to define variables and perform operations on them using functions like <code>Effect.bind</code> and <code>Effect.let</code>.</p>
<p>Here&#39;s how the do simulation works:</p>
<Steps>

<ol>
<li><p>Start the do simulation using the <code>Effect.Do</code> value:</p>
<pre><code class="language-ts">const program = Effect.Do.pipe(/* ... rest of the code */)
</code></pre>
</li>
<li><p>Within the do simulation scope, you can use the <code>Effect.bind</code> function to define variables and bind them to <code>Effect</code> values:</p>
<pre><code class="language-ts">Effect.bind(&quot;variableName&quot;, (scope) =&gt; effectValue)
</code></pre>
<ul>
<li><code>variableName</code> is the name you choose for the variable you want to define. It must be unique within the scope.</li>
<li><code>effectValue</code> is the <code>Effect</code> value that you want to bind to the variable. It can be the result of a function call or any other valid <code>Effect</code> value.</li>
</ul>
</li>
<li><p>You can accumulate multiple <code>Effect.bind</code> statements to define multiple variables within the scope:</p>
<pre><code class="language-ts">Effect.bind(&quot;variable1&quot;, () =&gt; effectValue1),
Effect.bind(&quot;variable2&quot;, ({ variable1 }) =&gt; effectValue2),
// ... additional bind statements
</code></pre>
</li>
<li><p>Inside the do simulation scope, you can also use the <code>Effect.let</code> function to define variables and bind them to simple values:</p>
<pre><code class="language-ts">Effect.let(&quot;variableName&quot;, (scope) =&gt; simpleValue)
</code></pre>
<ul>
<li><code>variableName</code> is the name you give to the variable. Like before, it must be unique within the scope.</li>
<li><code>simpleValue</code> is the value you want to assign to the variable. It can be a simple value like a <code>number</code>, <code>string</code>, or <code>boolean</code>.</li>
</ul>
</li>
<li><p>Regular Effect functions like <code>Effect.andThen</code>, <code>Effect.flatMap</code>, <code>Effect.tap</code>, and <code>Effect.map</code> can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope:</p>
<pre><code class="language-ts">Effect.andThen(({ variable1, variable2 }) =&gt; {
  // Perform operations using variable1 and variable2
  // Return an `Effect` value as the result
})
</code></pre>
</li>
</ol>
</Steps>

<p>With the do simulation, you can rewrite the <code>elapsed</code> function like this:</p>
<p><strong>Example</strong> (Using Do Simulation to Measure Elapsed Time)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Get the current timestamp
const now = Effect.sync(() =&gt; new Date().getTime())

const elapsed = &lt;R, E, A&gt;(
  self: Effect.Effect&lt;A, E, R&gt;
): Effect.Effect&lt;A, E, R&gt; =&gt;
  Effect.Do.pipe(
    Effect.bind(&quot;startMillis&quot;, () =&gt; now),
    Effect.bind(&quot;result&quot;, () =&gt; self),
    Effect.bind(&quot;endMillis&quot;, () =&gt; now),
    Effect.let(
      &quot;elapsed&quot;,
      // Calculate the elapsed time in milliseconds
      ({ startMillis, endMillis }) =&gt; endMillis - startMillis
    ),
    // Log the elapsed time
    Effect.tap(({ elapsed }) =&gt; Console.log(`Elapsed: ${elapsed}`)),
    Effect.map(({ result }) =&gt; result)
  )

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed(&quot;some task&quot;).pipe(Effect.delay(&quot;200 millis&quot;))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/*
Output:
Elapsed: 204
some task
*/
</code></pre>
<h2>Using Effect.gen</h2>
<p>The most concise and convenient solution is to use <a href="/docs/getting-started/using-generators/">Effect.gen</a>, which allows you to work with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generators</a> when dealing with effects. This approach leverages the native scope provided by the generator syntax, avoiding excessive nesting and leading to more concise code.</p>
<p><strong>Example</strong> (Using Effect.gen to Measure Elapsed Time)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Get the current timestamp
const now = Effect.sync(() =&gt; new Date().getTime())

// Prints the elapsed time occurred to `self` to execute
const elapsed = &lt;R, E, A&gt;(
  self: Effect.Effect&lt;A, E, R&gt;
): Effect.Effect&lt;A, E, R&gt; =&gt;
  Effect.gen(function* () {
    const startMillis = yield* now
    const result = yield* self
    const endMillis = yield* now
    // Calculate the elapsed time in milliseconds
    const elapsed = endMillis - startMillis
    // Log the elapsed time
    console.log(`Elapsed: ${elapsed}`)
    return result
  })

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed(&quot;some task&quot;).pipe(Effect.delay(&quot;200 millis&quot;))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/*
Output:
Elapsed: 204
some task
*/
</code></pre>
<p>Within the generator, we use <code>yield*</code> to invoke effects and bind their results to variables. This eliminates the nesting and provides a more readable and sequential code structure.</p>
<p>The generator style in Effect uses a more linear and sequential flow of execution, resembling traditional imperative programming languages. This makes the code easier to read and understand, especially for developers who are more familiar with imperative programming paradigms.</p>
<hr>
<hr>
<h2>title: Dual APIs
description: Explore data-first and data-last variants of dual APIs in the Effect ecosystem.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>When you&#39;re working with APIs in the Effect ecosystem, you may come across two different ways to use the same API.
These two ways are called the &quot;data-last&quot; and &quot;data-first&quot; variants.</p>
<p>When an API supports both variants, we call them &quot;dual&quot; APIs.</p>
<p>Here&#39;s an illustration of these two variants using <code>Effect.map</code>.</p>
<h2>Effect.map as a dual API</h2>
<p>The <code>Effect.map</code> function is defined with two TypeScript overloads. The terms &quot;data-last&quot; and &quot;data-first&quot; refer to the position of the <code>self</code> argument (also known as the &quot;data&quot;) in the signatures of the two overloads:</p>
<pre><code class="language-ts">declare const map: {
  //                               ┌─── data-last
  //                               ▼
  &lt;A, B&gt;(f: (a: A) =&gt; B): &lt;E, R&gt;(self: Effect&lt;A, E, R&gt;) =&gt; Effect&lt;B, E, R&gt;
  //             ┌─── data-first
  //             ▼
  &lt;A, E, R, B&gt;(self: Effect&lt;A, E, R&gt;, f: (a: A) =&gt; B): Effect&lt;B, E, R&gt;
}
</code></pre>
<h3>data-last</h3>
<p>In the first overload, the <code>self</code> argument comes <strong>last</strong>:</p>
<pre><code class="language-ts">declare const map: &lt;A, B&gt;(
  f: (a: A) =&gt; B
) =&gt; &lt;E, R&gt;(self: Effect&lt;A, E, R&gt;) =&gt; Effect&lt;B, E, R&gt;
</code></pre>
<p>This version is commonly used with the <code>pipe</code> function. You start by passing the <code>Effect</code> as the initial argument to <code>pipe</code> and then chain transformations like <code>Effect.map</code>:</p>
<p><strong>Example</strong> (Using data-last with <code>pipe</code>)</p>
<pre><code class="language-ts">const mappedEffect = pipe(effect, Effect.map(func))
</code></pre>
<p>This style is helpful when chaining multiple transformations, making the code easier to follow in a pipeline format:</p>
<pre><code class="language-ts">pipe(effect, Effect.map(func1), Effect.map(func2), ...)
</code></pre>
<h3>data-first</h3>
<p>In the second overload, the <code>self</code> argument comes <strong>first</strong>:</p>
<pre><code class="language-ts">declare const map: &lt;A, E, R, B&gt;(
  self: Effect&lt;A, E, R&gt;,
  f: (a: A) =&gt; B
) =&gt; Effect&lt;B, E, R&gt;
</code></pre>
<p>This form doesn&#39;t require <code>pipe</code>. Instead, you provide the <code>Effect</code> directly as the first argument:</p>
<p><strong>Example</strong> (Using data-first without <code>pipe</code>)</p>
<pre><code class="language-ts">const mappedEffect = Effect.map(effect, func)
</code></pre>
<p>This version works well when you only need to perform a single operation on the <code>Effect</code>.</p>
<Aside type="tip" title="Choosing Between Styles">
  Both overloads achieve the same result. Choose the one that best suits
  your coding style and enhances readability for your team.
</Aside>


<hr>
<hr>
<h2>title: Guidelines
description: Best practices for running Effect applications and ensuring safe, explicit coding styles.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<h2>Using runMain</h2>
<p>In Effect, <code>runMain</code> is the primary entry point for executing an Effect application on Node.js.</p>
<p><strong>Example</strong> (Running an Effect Application with Graceful Teardown)</p>
<pre><code class="language-ts">import { Effect, Console, Schedule, pipe } from &quot;effect&quot;
import { NodeRuntime } from &quot;@effect/platform-node&quot;

const program = pipe(
  Effect.addFinalizer(() =&gt; Console.log(&quot;Application is about to exit!&quot;)),
  Effect.andThen(Console.log(&quot;Application started!&quot;)),
  Effect.andThen(
    Effect.repeat(Console.log(&quot;still alive...&quot;), {
      schedule: Schedule.spaced(&quot;1 second&quot;)
    })
  ),
  Effect.scoped
)

// No graceful teardown on CTRL+C
// Effect.runPromise(program)

// Use NodeRuntime.runMain for graceful teardown on CTRL+C
NodeRuntime.runMain(program)
/*
Output:
Application started!
still alive...
still alive...
still alive...
still alive...
^C &lt;-- CTRL+C
Application is about to exit!
*/
</code></pre>
<p>The <code>runMain</code> function handles finding and interrupting all fibers. Internally, it observes the fiber and listens for <code>sigint</code> signals, ensuring a graceful shutdown of the application when interrupted (e.g., using CTRL+C).</p>
<Aside type="tip" title="Graceful Teardown">
  Ensure the teardown logic is placed in the main effect. If the fiber
  running the application or server is interrupted, `runMain` ensures that
  all resources are properly released.
</Aside>

<h3>Versions for Different Platforms</h3>
<p>Effect provides versions of <code>runMain</code> tailored for different platforms:</p>
<table>
<thead>
<tr>
<th>Platform</th>
<th>Runtime Version</th>
<th>Import Path</th>
</tr>
</thead>
<tbody><tr>
<td>Node.js</td>
<td><code>NodeRuntime.runMain</code></td>
<td><code>@effect/platform-node</code></td>
</tr>
<tr>
<td>Bun</td>
<td><code>BunRuntime.runMain</code></td>
<td><code>@effect/platform-bun</code></td>
</tr>
<tr>
<td>Browser</td>
<td><code>BrowserRuntime.runMain</code></td>
<td><code>@effect/platform-browser</code></td>
</tr>
</tbody></table>
<h2>Avoid Tacit Usage</h2>
<p>Avoid using tacit (point-free) function calls, such as <code>Effect.map(fn)</code>, or using <code>flow</code> from the <code>effect/Function</code> module.</p>
<p>In Effect, it&#39;s generally safer to write functions explicitly:</p>
<pre><code class="language-ts">Effect.map((x) =&gt; fn(x))
</code></pre>
<p>rather than in a point-free style:</p>
<pre><code class="language-ts">Effect.map(fn)
</code></pre>
<p>While tacit functions may be appealing for their brevity, they can introduce a number of problems:</p>
<ul>
<li><p>Using tacit functions, particularly when dealing with optional parameters, can be unsafe. For example, if a function has overloads, writing it in a tacit style may erase all generics, resulting in bugs. Check out this X thread for more details: <a href="https://twitter.com/MichaelArnaldi/status/1670715270845935616">link to thread</a>.</p>
</li>
<li><p>Tacit usage can also compromise TypeScript&#39;s ability to infer types, potentially causing unexpected errors. This isn&#39;t just a matter of style but a way to avoid subtle mistakes that can arise from type inference issues.</p>
</li>
<li><p>Additionally, stack traces might not be as clear when tacit usage is employed.</p>
</li>
</ul>
<p>Avoiding tacit usage is a simple precaution that makes your code more reliable.</p>
<hr>
<hr>
<h2>title: Pattern Matching
description: Simplify complex branching with pattern matching using the Match module.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Pattern matching is a method that allows developers to handle intricate conditions within a single, concise expression. It simplifies code, making it more concise and easier to understand. Additionally, it includes a process called exhaustiveness checking, which helps to ensure that no possible case has been overlooked.</p>
<p>Originating from functional programming languages, pattern matching stands as a powerful technique for code branching. It often offers a more potent and less verbose solution compared to imperative alternatives such as if/else or switch statements, particularly when dealing with complex conditions.</p>
<p>Although not yet a native feature in JavaScript, there&#39;s an ongoing <a href="https://github.com/tc39/proposal-pattern-matching">tc39 proposal</a> in its early stages to introduce pattern matching to JavaScript. However, this proposal is at stage 1 and might take several years to be implemented. Nonetheless, developers can implement pattern matching in their codebase. The <code>effect/Match</code> module provides a reliable, type-safe pattern matching implementation that is available for immediate use.</p>
<p><strong>Example</strong> (Handling Different Data Types with Pattern Matching)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Simulated dynamic input that can be a string or a number
const input: string | number = &quot;some input&quot;

//      ┌─── string
//      ▼
const result = Match.value(input).pipe(
  // Match if the value is a number
  Match.when(Match.number, (n) =&gt; `number: ${n}`),
  // Match if the value is a string
  Match.when(Match.string, (s) =&gt; `string: ${s}`),
  // Ensure all possible cases are covered
  Match.exhaustive
)

console.log(result)
// Output: &quot;string: some input&quot;
</code></pre>
<h2>How Pattern Matching Works</h2>
<p>Pattern matching follows a structured process:</p>
<ol>
<li><p><strong>Creating a matcher</strong>.
Define a <code>Matcher</code> that operates on either a specific <a href="#matching-by-type">type</a> or <a href="#matching-by-value">value</a>.</p>
</li>
<li><p><strong>Defining patterns</strong>.
Use combinators such as <code>Match.when</code>, <code>Match.not</code>, and <code>Match.tag</code> to specify matching conditions.</p>
</li>
<li><p><strong>Completing the match</strong>.
Apply a finalizer such as <code>Match.exhaustive</code>, <code>Match.orElse</code>, or <code>Match.option</code> to determine how unmatched cases should be handled.</p>
</li>
</ol>
<h2>Creating a matcher</h2>
<p>You can create a <code>Matcher</code> using either:</p>
<ul>
<li><code>Match.type&lt;T&gt;()</code>: Matches against a specific type.</li>
<li><code>Match.value(value)</code>: Matches against a specific value.</li>
</ul>
<h3>Matching by Type</h3>
<p>The <code>Match.type</code> constructor defines a <code>Matcher</code> that operates on a specific type. Once created, you can use patterns like <code>Match.when</code> to define conditions for handling different cases.</p>
<p><strong>Example</strong> (Matching Numbers and Strings)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Create a matcher for values that are either strings or numbers
//
//      ┌─── (u: string | number) =&gt; string
//      ▼
const match = Match.type&lt;string | number&gt;().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) =&gt; `number: ${n}`),
  // Match when the value is a string
  Match.when(Match.string, (s) =&gt; `string: ${s}`),
  // Ensure all possible cases are handled
  Match.exhaustive
)

console.log(match(0))
// Output: &quot;number: 0&quot;

console.log(match(&quot;hello&quot;))
// Output: &quot;string: hello&quot;
</code></pre>
<h3>Matching by Value</h3>
<p>Instead of creating a matcher for a type, you can define one directly from a specific value using <code>Match.value</code>.</p>
<p><strong>Example</strong> (Matching an Object by Property)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

const input = { name: &quot;John&quot;, age: 30 }

// Create a matcher for the specific object
const result = Match.value(input).pipe(
  // Match when the &#39;name&#39; property is &quot;John&quot;
  Match.when(
    { name: &quot;John&quot; },
    (user) =&gt; `${user.name} is ${user.age} years old`
  ),
  // Provide a fallback if no match is found
  Match.orElse(() =&gt; &quot;Oh, not John&quot;)
)

console.log(result)
// Output: &quot;John is 30 years old&quot;
</code></pre>
<h3>Enforcing a Return Type</h3>
<p>You can use <code>Match.withReturnType&lt;T&gt;()</code> to ensure that all branches return a specific type.</p>
<p><strong>Example</strong> (Validating Return Type Consistency)</p>
<p>This example enforces that every matching branch returns a <code>string</code>.</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

const match = Match.type&lt;{ a: number } | { b: string }&gt;().pipe(
  // Ensure all branches return a string
  Match.withReturnType&lt;string&gt;(),
  // ❌ Type error: &#39;number&#39; is not assignable to type &#39;string&#39;
  // @ts-expect-error
  Match.when({ a: Match.number }, (_) =&gt; _.a),
  // ✅ Correct: returns a string
  Match.when({ b: Match.string }, (_) =&gt; _.b),
  Match.exhaustive
)
</code></pre>
<Aside type="note" title="Must Be First in the Pipeline">
  The `Match.withReturnType<T>()` call must be the first instruction in the pipeline.
  If placed later, TypeScript will not properly enforce return type consistency.
</Aside>

<h2>Defining patterns</h2>
<h3>when</h3>
<p>The <code>Match.when</code> function allows you to define conditions for matching values. It supports both direct value comparisons and predicate functions.</p>
<p><strong>Example</strong> (Matching with Values and Predicates)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Create a matcher for objects with an &quot;age&quot; property
const match = Match.type&lt;{ age: number }&gt;().pipe(
  // Match when age is greater than 18
  Match.when({ age: (age) =&gt; age &gt; 18 }, (user) =&gt; `Age: ${user.age}`),
  // Match when age is exactly 18
  Match.when({ age: 18 }, () =&gt; &quot;You can vote&quot;),
  // Fallback case for all other ages
  Match.orElse((user) =&gt; `${user.age} is too young`)
)

console.log(match({ age: 20 }))
// Output: &quot;Age: 20&quot;

console.log(match({ age: 18 }))
// Output: &quot;You can vote&quot;

console.log(match({ age: 4 }))
// Output: &quot;4 is too young&quot;
</code></pre>
<h3>not</h3>
<p>The <code>Match.not</code> function allows you to exclude specific values while matching all others.</p>
<p><strong>Example</strong> (Ignoring a Specific Value)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Create a matcher for string or number values
const match = Match.type&lt;string | number&gt;().pipe(
  // Match any value except &quot;hi&quot;, returning &quot;ok&quot;
  Match.not(&quot;hi&quot;, () =&gt; &quot;ok&quot;),
  // Fallback case for when the value is &quot;hi&quot;
  Match.orElse(() =&gt; &quot;fallback&quot;)
)

console.log(match(&quot;hello&quot;))
// Output: &quot;ok&quot;

console.log(match(&quot;hi&quot;))
// Output: &quot;fallback&quot;
</code></pre>
<h3>tag</h3>
<p>The <code>Match.tag</code> function allows pattern matching based on the <code>_tag</code> field in a <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions">Discriminated Union</a>. You can specify multiple tags to match within a single pattern.</p>
<p><strong>Example</strong> (Matching a Discriminated Union by Tag)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

type Event =
  | { readonly _tag: &quot;fetch&quot; }
  | { readonly _tag: &quot;success&quot;; readonly data: string }
  | { readonly _tag: &quot;error&quot;; readonly error: Error }
  | { readonly _tag: &quot;cancel&quot; }

// Create a Matcher for Either&lt;number, string&gt;
const match = Match.type&lt;Event&gt;().pipe(
  // Match either &quot;fetch&quot; or &quot;success&quot;
  Match.tag(&quot;fetch&quot;, &quot;success&quot;, () =&gt; `Ok!`),
  // Match &quot;error&quot; and extract the error message
  Match.tag(&quot;error&quot;, (event) =&gt; `Error: ${event.error.message}`),
  // Match &quot;cancel&quot;
  Match.tag(&quot;cancel&quot;, () =&gt; &quot;Cancelled&quot;),
  Match.exhaustive
)

console.log(match({ _tag: &quot;success&quot;, data: &quot;Hello&quot; }))
// Output: &quot;Ok!&quot;

console.log(match({ _tag: &quot;error&quot;, error: new Error(&quot;Oops!&quot;) }))
// Output: &quot;Error: Oops!&quot;
</code></pre>
<Aside type="caution" title="Tag Field Naming Convention">
  The `Match.tag` function relies on the convention within the Effect
  ecosystem of naming the tag field as `"_tag"`. Ensure that your
  discriminated unions follow this naming convention for proper
  functionality.
</Aside>

<h3>Built-in Predicates</h3>
<p>The <code>Match</code> module provides built-in predicates for common types, such as <code>Match.number</code>, <code>Match.string</code>, and <code>Match.boolean</code>. These predicates simplify the process of matching against primitive types.</p>
<p><strong>Example</strong> (Using Built-in Predicates for Property Keys)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

const matchPropertyKey = Match.type&lt;PropertyKey&gt;().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) =&gt; `Key is a number: ${n}`),
  // Match when the value is a string
  Match.when(Match.string, (s) =&gt; `Key is a string: ${s}`),
  // Match when the value is a symbol
  Match.when(Match.symbol, (s) =&gt; `Key is a symbol: ${String(s)}`),
  // Ensure all possible cases are handled
  Match.exhaustive
)

console.log(matchPropertyKey(42))
// Output: &quot;Key is a number: 42&quot;

console.log(matchPropertyKey(&quot;username&quot;))
// Output: &quot;Key is a string: username&quot;

console.log(matchPropertyKey(Symbol(&quot;id&quot;)))
// Output: &quot;Key is a symbol: Symbol(id)&quot;
</code></pre>
<table>
<thead>
<tr>
<th>Predicate</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Match.string</code></td>
<td>Matches values of type <code>string</code>.</td>
</tr>
<tr>
<td><code>Match.nonEmptyString</code></td>
<td>Matches non-empty strings.</td>
</tr>
<tr>
<td><code>Match.number</code></td>
<td>Matches values of type <code>number</code>.</td>
</tr>
<tr>
<td><code>Match.boolean</code></td>
<td>Matches values of type <code>boolean</code>.</td>
</tr>
<tr>
<td><code>Match.bigint</code></td>
<td>Matches values of type <code>bigint</code>.</td>
</tr>
<tr>
<td><code>Match.symbol</code></td>
<td>Matches values of type <code>symbol</code>.</td>
</tr>
<tr>
<td><code>Match.date</code></td>
<td>Matches values that are instances of <code>Date</code>.</td>
</tr>
<tr>
<td><code>Match.record</code></td>
<td>Matches objects where keys are <code>string</code> or <code>symbol</code> and values are <code>unknown</code>.</td>
</tr>
<tr>
<td><code>Match.null</code></td>
<td>Matches the value <code>null</code>.</td>
</tr>
<tr>
<td><code>Match.undefined</code></td>
<td>Matches the value <code>undefined</code>.</td>
</tr>
<tr>
<td><code>Match.defined</code></td>
<td>Matches any defined (non-null and non-undefined) value.</td>
</tr>
<tr>
<td><code>Match.any</code></td>
<td>Matches any value without restrictions.</td>
</tr>
<tr>
<td><code>Match.is(...values)</code></td>
<td>Matches a specific set of literal values (e.g., <code>Match.is(&quot;a&quot;, 42, true)</code>).</td>
</tr>
<tr>
<td><code>Match.instanceOf(Class)</code></td>
<td>Matches instances of a given class.</td>
</tr>
</tbody></table>
<h2>Completing the match</h2>
<h3>exhaustive</h3>
<p>The <code>Match.exhaustive</code> method finalizes the pattern matching process by ensuring that all possible cases are accounted for. If any case is missing, TypeScript will produce a type error. This is particularly useful when working with unions, as it helps prevent unintended gaps in pattern matching.</p>
<p><strong>Example</strong> (Ensuring All Cases Are Covered)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Create a matcher for string or number values
const match = Match.type&lt;string | number&gt;().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) =&gt; `number: ${n}`),
  // Mark the match as exhaustive, ensuring all cases are handled
  // TypeScript will throw an error if any case is missing
  // @ts-expect-error Type &#39;string&#39; is not assignable to type &#39;never&#39;
  Match.exhaustive
)
</code></pre>
<h3>orElse</h3>
<p>The <code>Match.orElse</code> method defines a fallback value to return when no other patterns match. This ensures that the matcher always produces a valid result.</p>
<p><strong>Example</strong> (Providing a Default Value When No Patterns Match)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

// Create a matcher for string or number values
const match = Match.type&lt;string | number&gt;().pipe(
  // Match when the value is &quot;a&quot;
  Match.when(&quot;a&quot;, () =&gt; &quot;ok&quot;),
  // Fallback when no patterns match
  Match.orElse(() =&gt; &quot;fallback&quot;)
)

console.log(match(&quot;a&quot;))
// Output: &quot;ok&quot;

console.log(match(&quot;b&quot;))
// Output: &quot;fallback&quot;
</code></pre>
<h3>option</h3>
<p><code>Match.option</code> wraps the match result in an <a href="/docs/data-types/option/">Option</a>. If a match is found, it returns <code>Some(value)</code>, otherwise, it returns <code>None</code>.</p>
<p><strong>Example</strong> (Extracting a User Role with Option)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

type User = { readonly role: &quot;admin&quot; | &quot;editor&quot; | &quot;viewer&quot; }

// Create a matcher to extract user roles
const getRole = Match.type&lt;User&gt;().pipe(
  Match.when({ role: &quot;admin&quot; }, () =&gt; &quot;Has full access&quot;),
  Match.when({ role: &quot;editor&quot; }, () =&gt; &quot;Can edit content&quot;),
  Match.option // Wrap the result in an Option
)

console.log(getRole({ role: &quot;admin&quot; }))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;Has full access&#39; }

console.log(getRole({ role: &quot;viewer&quot; }))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<h3>either</h3>
<p>The <code>Match.either</code> method wraps the result in an <a href="/docs/data-types/either/">Either</a>, providing a structured way to distinguish between matched and unmatched cases. If a match is found, it returns <code>Right(value)</code>, otherwise, it returns <code>Left(no match)</code>.</p>
<p><strong>Example</strong> (Extracting a User Role with Either)</p>
<pre><code class="language-ts">import { Match } from &quot;effect&quot;

type User = { readonly role: &quot;admin&quot; | &quot;editor&quot; | &quot;viewer&quot; }

// Create a matcher to extract user roles
const getRole = Match.type&lt;User&gt;().pipe(
  Match.when({ role: &quot;admin&quot; }, () =&gt; &quot;Has full access&quot;),
  Match.when({ role: &quot;editor&quot; }, () =&gt; &quot;Can edit content&quot;),
  Match.either // Wrap the result in an Either
)

console.log(getRole({ role: &quot;admin&quot; }))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: &#39;Has full access&#39; }

console.log(getRole({ role: &quot;viewer&quot; }))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: { role: &#39;viewer&#39; } }
</code></pre>
<hr>
<hr>
<h2>title: Basic Concurrency
description: Manage and control effect execution with concurrency, interruptions, and racing.
sidebar:
  order: 0</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<h2>Concurrency Options</h2>
<p>Effect provides options to manage how effects are executed, particularly focusing on controlling how many effects run concurrently.</p>
<pre><code class="language-ts">type Options = {
  readonly concurrency?: Concurrency
}
</code></pre>
<p>The <code>concurrency</code> option is used to determine the level of concurrency, with the following values:</p>
<pre><code class="language-ts">type Concurrency = number | &quot;unbounded&quot; | &quot;inherit&quot;
</code></pre>
<p>Let&#39;s explore each configuration in detail.</p>
<Aside type="tip" title="Applicability of Concurrency Options">
  The examples here use the `Effect.all` function, but these options apply
  to many other Effect APIs.
</Aside>

<h3>Sequential Execution (Default)</h3>
<p>By default, if you don&#39;t specify any concurrency option, effects will run sequentially, one after the other. This means each effect starts only after the previous one completes.</p>
<p><strong>Example</strong> (Sequential Execution)</p>
<pre><code class="language-ts">import { Effect, Duration } from &quot;effect&quot;

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =&gt;
  Effect.promise(
    () =&gt;
      new Promise&lt;void&gt;((resolve) =&gt; {
        console.log(`start task${n}`) // Logs when the task starts
        setTimeout(() =&gt; {
          console.log(`task${n} done`) // Logs when the task finishes
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, &quot;200 millis&quot;)
const task2 = makeTask(2, &quot;100 millis&quot;)

const sequential = Effect.all([task1, task2])

Effect.runPromise(sequential)
/*
Output:
start task1
task1 done
start task2 &lt;-- task2 starts only after task1 completes
task2 done
*/
</code></pre>
<h3>Numbered Concurrency</h3>
<p>You can control how many effects run concurrently by setting a <code>number</code> for <code>concurrency</code>. For example, <code>concurrency: 2</code> allows up to two effects to run at the same time.</p>
<p><strong>Example</strong> (Limiting to 2 Concurrent Tasks)</p>
<pre><code class="language-ts">import { Effect, Duration } from &quot;effect&quot;

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =&gt;
  Effect.promise(
    () =&gt;
      new Promise&lt;void&gt;((resolve) =&gt; {
        console.log(`start task${n}`) // Logs when the task starts
        setTimeout(() =&gt; {
          console.log(`task${n} done`) // Logs when the task finishes
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, &quot;200 millis&quot;)
const task2 = makeTask(2, &quot;100 millis&quot;)
const task3 = makeTask(3, &quot;210 millis&quot;)
const task4 = makeTask(4, &quot;110 millis&quot;)
const task5 = makeTask(5, &quot;150 millis&quot;)

const numbered = Effect.all([task1, task2, task3, task4, task5], {
  concurrency: 2
})

Effect.runPromise(numbered)
/*
Output:
start task1
start task2 &lt;-- active tasks: task1, task2
task2 done
start task3 &lt;-- active tasks: task1, task3
task1 done
start task4 &lt;-- active tasks: task3, task4
task4 done
start task5 &lt;-- active tasks: task3, task5
task3 done
task5 done
*/
</code></pre>
<h3>Unbounded Concurrency</h3>
<p>When <code>concurrency: &quot;unbounded&quot;</code> is used, there&#39;s no limit to the number of effects running concurrently.</p>
<p><strong>Example</strong> (Unbounded Concurrency)</p>
<pre><code class="language-ts">import { Effect, Duration } from &quot;effect&quot;

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =&gt;
  Effect.promise(
    () =&gt;
      new Promise&lt;void&gt;((resolve) =&gt; {
        console.log(`start task${n}`) // Logs when the task starts
        setTimeout(() =&gt; {
          console.log(`task${n} done`) // Logs when the task finishes
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, &quot;200 millis&quot;)
const task2 = makeTask(2, &quot;100 millis&quot;)
const task3 = makeTask(3, &quot;210 millis&quot;)
const task4 = makeTask(4, &quot;110 millis&quot;)
const task5 = makeTask(5, &quot;150 millis&quot;)

const unbounded = Effect.all([task1, task2, task3, task4, task5], {
  concurrency: &quot;unbounded&quot;
})

Effect.runPromise(unbounded)
/*
Output:
start task1
start task2
start task3
start task4
start task5
task2 done
task4 done
task5 done
task1 done
task3 done
*/
</code></pre>
<h3>Inherit Concurrency</h3>
<p>When using <code>concurrency: &quot;inherit&quot;</code>, the concurrency level is inherited from the surrounding context. This context can be set using <code>Effect.withConcurrency(number | &quot;unbounded&quot;)</code>. If no context is provided, the default is <code>&quot;unbounded&quot;</code>.</p>
<p><strong>Example</strong> (Inheriting Concurrency from Context)</p>
<pre><code class="language-ts">import { Effect, Duration } from &quot;effect&quot;

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =&gt;
  Effect.promise(
    () =&gt;
      new Promise&lt;void&gt;((resolve) =&gt; {
        console.log(`start task${n}`) // Logs when the task starts
        setTimeout(() =&gt; {
          console.log(`task${n} done`) // Logs when the task finishes
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, &quot;200 millis&quot;)
const task2 = makeTask(2, &quot;100 millis&quot;)
const task3 = makeTask(3, &quot;210 millis&quot;)
const task4 = makeTask(4, &quot;110 millis&quot;)
const task5 = makeTask(5, &quot;150 millis&quot;)

// Running all tasks with concurrency: &quot;inherit&quot;,
// which defaults to &quot;unbounded&quot;
const inherit = Effect.all([task1, task2, task3, task4, task5], {
  concurrency: &quot;inherit&quot;
})

Effect.runPromise(inherit)
/*
Output:
start task1
start task2
start task3
start task4
start task5
task2 done
task4 done
task5 done
task1 done
task3 done
*/
</code></pre>
<p>If you use <code>Effect.withConcurrency</code>, the concurrency configuration will adjust to the specified option.</p>
<p><strong>Example</strong> (Setting Concurrency Option)</p>
<pre><code class="language-ts">import { Effect, Duration } from &quot;effect&quot;

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =&gt;
  Effect.promise(
    () =&gt;
      new Promise&lt;void&gt;((resolve) =&gt; {
        console.log(`start task${n}`) // Logs when the task starts
        setTimeout(() =&gt; {
          console.log(`task${n} done`) // Logs when the task finishes
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, &quot;200 millis&quot;)
const task2 = makeTask(2, &quot;100 millis&quot;)
const task3 = makeTask(3, &quot;210 millis&quot;)
const task4 = makeTask(4, &quot;110 millis&quot;)
const task5 = makeTask(5, &quot;150 millis&quot;)

// Running tasks with concurrency: &quot;inherit&quot;,
// which will inherit the surrounding context
const inherit = Effect.all([task1, task2, task3, task4, task5], {
  concurrency: &quot;inherit&quot;
})

// Setting a concurrency limit of 2
const withConcurrency = inherit.pipe(Effect.withConcurrency(2))

Effect.runPromise(withConcurrency)
/*
Output:
start task1
start task2 &lt;-- active tasks: task1, task2
task2 done
start task3 &lt;-- active tasks: task1, task3
task1 done
start task4 &lt;-- active tasks: task3, task4
task4 done
start task5 &lt;-- active tasks: task3, task5
task3 done
task5 done
*/
</code></pre>
<h2>Interruptions</h2>
<p>All effects in Effect are executed by <a href="/docs/concurrency/fibers/">fibers</a>. If you didn&#39;t create the fiber yourself, it was created by an operation you&#39;re using (if it&#39;s concurrent) or by the Effect <a href="/docs/runtime/">runtime</a> system.</p>
<p>A fiber is created any time an effect is run. When running effects concurrently, a fiber is created for each concurrent effect.</p>
<p>To summarize:</p>
<ul>
<li>An <code>Effect</code> is a higher-level concept that describes an effectful computation. It is lazy and immutable, meaning it represents a computation that may produce a value or fail but does not immediately execute.</li>
<li>A fiber, on the other hand, represents the running execution of an <code>Effect</code>. It can be interrupted or awaited to retrieve its result. Think of it as a way to control and interact with the ongoing computation.</li>
</ul>
<p>Fibers can be interrupted in various ways. Let&#39;s explore some of these scenarios and see examples of how to interrupt fibers in Effect.</p>
<h3>interrupt</h3>
<p>A fiber can be interrupted using the <code>Effect.interrupt</code> effect on that particular fiber.</p>
<p>This effect models the explicit interruption of the fiber in which it runs.
When executed, it causes the fiber to stop its operation immediately, capturing the interruption details such as the fiber&#39;s ID and its start time.
The resulting interruption can be observed in the <a href="/docs/data-types/exit/">Exit</a> type if the effect is run with functions like <a href="/docs/getting-started/running-effects/#runpromiseexit">runPromiseExit</a>.</p>
<p><strong>Example</strong> (Without Interruption)</p>
<p>In this case, the program runs without any interruption, logging the start and completion of the task.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  console.log(&quot;start&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;)
  console.log(&quot;done&quot;)
  return &quot;some result&quot;
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
start
done
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;some result&#39; }
*/
</code></pre>
<p><strong>Example</strong> (With Interruption)</p>
<p>Here, the fiber is interrupted after the log <code>&quot;start&quot;</code> but before the <code>&quot;done&quot;</code> log. The <code>Effect.interrupt</code> stops the fiber, and it never reaches the final log.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  console.log(&quot;start&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.interrupt
  console.log(&quot;done&quot;)
  return &quot;some result&quot;
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
start
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Interrupt&#39;,
    fiberId: {
      _id: &#39;FiberId&#39;,
      _tag: &#39;Runtime&#39;,
      id: 0,
      startTimeMillis: ...
    }
  }
}
*/
</code></pre>
<h3>onInterrupt</h3>
<p>Registers a cleanup effect to run when an effect is interrupted.</p>
<p>This function allows you to specify an effect to run when the fiber is interrupted. This effect will be executed
when the fiber is interrupted, allowing you to perform cleanup or other actions.</p>
<p><strong>Example</strong> (Running a Cleanup Action on Interruption)</p>
<p>In this example, we set up a handler that logs &quot;Cleanup completed&quot; whenever the fiber is interrupted. We then show three cases: a successful effect, a failing effect, and an interrupted effect, demonstrating how the handler is triggered depending on how the effect ends.</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((_fibers) =&gt;
  Console.log(&quot;Cleanup completed&quot;)
)

const success = Console.log(&quot;Task completed&quot;).pipe(
  Effect.as(&quot;some result&quot;),
  handler
)

Effect.runFork(success)
/*
Output:
Task completed
*/

const failure = Console.log(&quot;Task failed&quot;).pipe(
  Effect.andThen(Effect.fail(&quot;some error&quot;)),
  handler
)

Effect.runFork(failure)
/*
Output:
Task failed
*/

const interruption = Console.log(&quot;Task interrupted&quot;).pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
/*
Output:
Task interrupted
Cleanup completed
*/
</code></pre>
<h3>Interruption of Concurrent Effects</h3>
<p>When running multiple effects concurrently, such as with <code>Effect.forEach</code>, if one of the effects is interrupted, it causes all concurrent effects to be interrupted as well.</p>
<p>The resulting <a href="/docs/data-types/cause/">cause</a> includes information about which fibers were interrupted.</p>
<p><strong>Example</strong> (Interrupting Concurrent Effects)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Effect.forEach(
  [1, 2, 3],
  (n) =&gt;
    Effect.gen(function* () {
      console.log(`start #${n}`)
      yield* Effect.sleep(`${n} seconds`)
      if (n &gt; 1) {
        yield* Effect.interrupt
      }
      console.log(`done #${n}`)
    }).pipe(Effect.onInterrupt(() =&gt; Console.log(`interrupted #${n}`))),
  { concurrency: &quot;unbounded&quot; }
)

Effect.runPromiseExit(program).then((exit) =&gt;
  console.log(JSON.stringify(exit, null, 2))
)
/*
Output:
start #1
start #2
start #3
done #1
interrupted #2
interrupted #3
{
  &quot;_id&quot;: &quot;Exit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_id&quot;: &quot;Cause&quot;,
    &quot;_tag&quot;: &quot;Parallel&quot;,
    &quot;left&quot;: {
      &quot;_id&quot;: &quot;Cause&quot;,
      &quot;_tag&quot;: &quot;Interrupt&quot;,
      &quot;fiberId&quot;: {
        &quot;_id&quot;: &quot;FiberId&quot;,
        &quot;_tag&quot;: &quot;Runtime&quot;,
        &quot;id&quot;: 3,
        &quot;startTimeMillis&quot;: ...
      }
    },
    &quot;right&quot;: {
      &quot;_id&quot;: &quot;Cause&quot;,
      &quot;_tag&quot;: &quot;Sequential&quot;,
      &quot;left&quot;: {
        &quot;_id&quot;: &quot;Cause&quot;,
        &quot;_tag&quot;: &quot;Empty&quot;
      },
      &quot;right&quot;: {
        &quot;_id&quot;: &quot;Cause&quot;,
        &quot;_tag&quot;: &quot;Interrupt&quot;,
        &quot;fiberId&quot;: {
          &quot;_id&quot;: &quot;FiberId&quot;,
          &quot;_tag&quot;: &quot;Runtime&quot;,
          &quot;id&quot;: 0,
          &quot;startTimeMillis&quot;: ...
        }
      }
    }
  }
}
*/
</code></pre>
<h2>Racing</h2>
<h3>race</h3>
<p>This function takes two effects and runs them concurrently. The first effect
that successfully completes will determine the result of the race, and the
other effect will be interrupted.</p>
<p>If neither effect succeeds, the function will fail with a <a href="/docs/data-types/cause/">cause</a> containing all the errors.</p>
<p>This is useful when you want to run two effects concurrently, but only care
about the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effect.</p>
<p><strong>Example</strong> (Both Tasks Succeed)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.succeed(&quot;task1&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
/*
Output:
task1 done
task2 interrupted
*/
</code></pre>
<p><strong>Example</strong> (One Task Fails, One Succeeds)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
/*
Output:
task2 done
*/
</code></pre>
<p><strong>Example</strong> (Both Tasks Fail)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.fail(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Parallel&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;task1&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;task2&#39; }
  }
}
*/
</code></pre>
<p>If you want to handle the result of whichever task completes first, whether it succeeds or fails, you can use the <code>Effect.either</code> function. This function wraps the result in an <a href="/docs/data-types/either/">Either</a> type, allowing you to see if the result was a success (<code>Right</code>) or a failure (<code>Left</code>):</p>
<p><strong>Example</strong> (Handling Success or Failure with Either)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
/*
Output:
task2 interrupted
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;task1&#39; }
*/
</code></pre>
<h3>raceAll</h3>
<p>This function runs multiple effects concurrently and returns the result of the first one to succeed. If one effect succeeds, the others will be interrupted.</p>
<p>If none of the effects succeed, the function will fail with the last error encountered.</p>
<p>This is useful when you want to race multiple effects, but only care
about the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effects.</p>
<p><strong>Example</strong> (All Tasks Succeed)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.succeed(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const task3 = Effect.succeed(&quot;task3&quot;).pipe(
  Effect.delay(&quot;150 millis&quot;),
  Effect.tap(Console.log(&quot;task3 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task3 interrupted&quot;))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
/*
Output:
task1 done
task2 interrupted
task3 interrupted
*/
</code></pre>
<p><strong>Example</strong> (One Task Fails, Two Tasks Succeed)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const task3 = Effect.succeed(&quot;task3&quot;).pipe(
  Effect.delay(&quot;150 millis&quot;),
  Effect.tap(Console.log(&quot;task3 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task3 interrupted&quot;))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
/*
Output:
task3 done
task2 interrupted
*/
</code></pre>
<p><strong>Example</strong> (All Tasks Fail)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task1 interrupted&quot;))
)
const task2 = Effect.fail(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task2 interrupted&quot;))
)

const task3 = Effect.fail(&quot;task3&quot;).pipe(
  Effect.delay(&quot;150 millis&quot;),
  Effect.tap(Console.log(&quot;task3 done&quot;)),
  Effect.onInterrupt(() =&gt; Console.log(&quot;task3 interrupted&quot;))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;task2&#39; }
}
*/
</code></pre>
<h3>raceFirst</h3>
<p>This function takes two effects and runs them concurrently, returning the
result of the first one that completes, regardless of whether it succeeds or
fails.</p>
<p>This function is useful when you want to race two operations, and you want to
proceed with whichever one finishes first, regardless of whether it succeeds
or fails.</p>
<p><strong>Example</strong> (Both Tasks Succeed)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.succeed(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task1 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task2 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log(&quot;more work...&quot;))
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
task1 done
task2 interrupted
more work...
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;task1&#39; }
*/
</code></pre>
<p><strong>Example</strong> (One Task Fails, One Succeeds)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.fail(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task1 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task2 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log(&quot;more work...&quot;))
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
task2 interrupted
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;task1&#39; }
}
*/
</code></pre>
<h4>Disconnecting Effects</h4>
<p>The <code>Effect.raceFirst</code> function safely interrupts the &quot;loser&quot; effect once the other completes, but it will not resume until the loser is cleanly terminated.</p>
<p>If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:</p>
<pre><code class="language-ts">Effect.raceFirst(task1, task2)
</code></pre>
<p>You can use:</p>
<pre><code class="language-ts">Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
</code></pre>
<p>This allows both effects to complete independently while still terminating the losing effect in the background.</p>
<p><strong>Example</strong> (Using <code>Effect.disconnect</code> for Quicker Return)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.succeed(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task1 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task2 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log(&quot;more work...&quot;)))

Effect.runPromiseExit(program).then(console.log)
/*
Output:
task1 done
more work...
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;task1&#39; }
task2 interrupted
*/
</code></pre>
<h3>raceWith</h3>
<p>This function runs two effects concurrently and calls a specified &quot;finisher&quot; function once one of the effects completes, regardless of whether it succeeds or fails.</p>
<p>The finisher functions for each effect allow you to handle the results of each effect as soon as they complete.</p>
<p>The function takes two finisher callbacks, one for each effect, and allows you to specify how to handle the result of the race.</p>
<p>This function is useful when you need to react to the completion of either effect without waiting for both to finish. It can be used whenever you want to take action based on the first available result.</p>
<p><strong>Example</strong> (Handling Results of Concurrent Tasks)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.succeed(&quot;task1&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Console.log(&quot;task1 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task1 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)
const task2 = Effect.succeed(&quot;task2&quot;).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Console.log(&quot;task2 done&quot;)),
  Effect.onInterrupt(() =&gt;
    Console.log(&quot;task2 interrupted&quot;).pipe(Effect.delay(&quot;100 millis&quot;))
  )
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) =&gt; Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) =&gt; Console.log(`task2 exited with ${exit}`)
})

Effect.runFork(program)
/*
Output:
task1 done
task1 exited with {
  &quot;_id&quot;: &quot;Exit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: &quot;task1&quot;
}
task2 interrupted
*/
</code></pre>
<hr>
<hr>
<h2>title: Deferred
description: Master asynchronous coordination with Deferred, a one-time variable for managing effect synchronization and communication.
sidebar:
  order: 4</h2>
<p>A <code>Deferred&lt;Success, Error&gt;</code> is a specialized subtype of <code>Effect</code> that acts like a one-time variable with some unique characteristics. It can only be completed once, making it a useful tool for managing asynchronous operations and synchronization between different parts of your program.</p>
<p>A deferred is essentially a synchronization primitive that represents a value that may not be available right away. When you create a deferred, it starts out empty. Later, it can be completed with either a success value <code>Success</code> or an error value <code>Error</code>:</p>
<pre><code class="language-text">           ┌─── Represents the success type
           │        ┌─── Represents the error type
           │        │
           ▼        ▼
Deferred&lt;Success, Error&gt;
</code></pre>
<p>Once completed, it cannot be changed again.</p>
<p>When a fiber calls <code>Deferred.await</code>, it will pause until the deferred is completed. While the fiber is waiting, it doesn&#39;t block the thread, it only blocks semantically. This means other fibers can still run, ensuring efficient concurrency.</p>
<p>A deferred is conceptually similar to JavaScript&#39;s <code>Promise</code>.
The key difference is that it supports both success and error types, giving more type safety.</p>
<h2>Creating a Deferred</h2>
<p>A deferred can be created using the <code>Deferred.make</code> constructor. This returns an effect that represents the creation of the deferred. Since the creation of a deferred involves memory allocation, it must be done within an effect to ensure safe management of resources.</p>
<p><strong>Example</strong> (Creating a Deferred)</p>
<pre><code class="language-ts">import { Deferred } from &quot;effect&quot;

//      ┌─── Effect&lt;Deferred&lt;string, Error&gt;&gt;
//      ▼
const deferred = Deferred.make&lt;string, Error&gt;()
</code></pre>
<h2>Awaiting</h2>
<p>To retrieve a value from a deferred, you can use <code>Deferred.await</code>. This operation suspends the calling fiber until the deferred is completed with a value or an error.</p>
<pre><code class="language-ts">import { Effect, Deferred } from &quot;effect&quot;

//      ┌─── Effect&lt;Deferred&lt;string, Error&gt;, never, never&gt;
//      ▼
const deferred = Deferred.make&lt;string, Error&gt;()

//      ┌─── Effect&lt;string, Error, never&gt;
//      ▼
const value = deferred.pipe(Effect.andThen(Deferred.await))
</code></pre>
<h2>Completing</h2>
<p>You can complete a deferred in several ways, depending on whether you want to succeed, fail, or interrupt the waiting fibers:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Deferred.succeed</code></td>
<td>Completes the deferred successfully with a value.</td>
</tr>
<tr>
<td><code>Deferred.done</code></td>
<td>Completes the deferred with an <a href="/docs/data-types/exit/">Exit</a> value.</td>
</tr>
<tr>
<td><code>Deferred.complete</code></td>
<td>Completes the deferred with the result of an effect.</td>
</tr>
<tr>
<td><code>Deferred.completeWith</code></td>
<td>Completes the deferred with an effect. This effect will be executed by each waiting fiber, so use it carefully.</td>
</tr>
<tr>
<td><code>Deferred.fail</code></td>
<td>Fails the deferred with an error.</td>
</tr>
<tr>
<td><code>Deferred.die</code></td>
<td>Defects the deferred with a user-defined error.</td>
</tr>
<tr>
<td><code>Deferred.failCause</code></td>
<td>Fails or defects the deferred with a <a href="/docs/data-types/cause/">Cause</a>.</td>
</tr>
<tr>
<td><code>Deferred.interrupt</code></td>
<td>Interrupts the deferred, forcefully stopping or interrupting the waiting fibers.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Completing a Deferred with Success)</p>
<pre><code class="language-ts">import { Effect, Deferred } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make&lt;number, string&gt;()

  // Complete the Deferred successfully
  yield* Deferred.succeed(deferred, 1)

  // Awaiting the Deferred to get its value
  const value = yield* Deferred.await(deferred)

  console.log(value)
})

Effect.runFork(program)
// Output: 1
</code></pre>
<p>Completing a deferred produces an <code>Effect&lt;boolean&gt;</code>. This effect returns <code>true</code> if the deferred was successfully completed, and <code>false</code> if it had already been completed previously. This can be useful for tracking the state of the deferred.</p>
<p><strong>Example</strong> (Checking Completion Status)</p>
<pre><code class="language-ts">import { Effect, Deferred } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make&lt;number, string&gt;()

  // Attempt to fail the Deferred
  const firstAttempt = yield* Deferred.fail(deferred, &quot;oh no!&quot;)

  // Attempt to succeed after it has already been completed
  const secondAttempt = yield* Deferred.succeed(deferred, 1)

  console.log([firstAttempt, secondAttempt])
})

Effect.runFork(program)
// Output: [ true, false ]
</code></pre>
<h2>Checking Completion Status</h2>
<p>Sometimes, you might need to check if a deferred has been completed without suspending the fiber. This can be done using the <code>Deferred.poll</code> method. Here&#39;s how it works:</p>
<ul>
<li><code>Deferred.poll</code> returns an <code>Option&lt;Effect&lt;A, E&gt;&gt;</code>:<ul>
<li>If the <code>Deferred</code> is incomplete, it returns <code>None</code>.</li>
<li>If the <code>Deferred</code> is complete, it returns <code>Some</code>, which contains the result or error.</li>
</ul>
</li>
</ul>
<p>Additionally, you can use the <code>Deferred.isDone</code> function to check if a deferred has been completed. This method returns an <code>Effect&lt;boolean&gt;</code>, which evaluates to <code>true</code> if the <code>Deferred</code> is completed, allowing you to quickly check its state.</p>
<p><strong>Example</strong> (Polling and Checking Completion Status)</p>
<pre><code class="language-ts">import { Effect, Deferred } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make&lt;number, string&gt;()

  // Polling the Deferred to check if it&#39;s completed
  const done1 = yield* Deferred.poll(deferred)

  // Checking if the Deferred has been completed
  const done2 = yield* Deferred.isDone(deferred)

  console.log([done1, done2])
})

Effect.runFork(program)
/*
Output:
[ { _id: &#39;Option&#39;, _tag: &#39;None&#39; }, false ]
*/
</code></pre>
<h2>Common Use Cases</h2>
<p><code>Deferred</code> becomes useful when you need to wait for something specific to happen in your program.
It&#39;s ideal for scenarios where you want one part of your code to signal another part when it&#39;s ready.</p>
<p>Here are a few common use cases:</p>
<table>
<thead>
<tr>
<th><strong>Use Case</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Coordinating Fibers</strong></td>
<td>When you have multiple concurrent tasks and need to coordinate their actions, <code>Deferred</code> can help one fiber signal to another when it has completed its task.</td>
</tr>
<tr>
<td><strong>Synchronization</strong></td>
<td>Anytime you want to ensure that one piece of code doesn&#39;t proceed until another piece of code has finished its work, <code>Deferred</code> can provide the synchronization you need.</td>
</tr>
<tr>
<td><strong>Handing Over Work</strong></td>
<td>You can use <code>Deferred</code> to hand over work from one fiber to another. For example, one fiber can prepare some data, and then a second fiber can continue processing it.</td>
</tr>
<tr>
<td><strong>Suspending Execution</strong></td>
<td>When you want a fiber to pause its execution until some condition is met, a <code>Deferred</code> can be used to block it until the condition is satisfied.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Deferred to Coordinate Two Fibers)</p>
<p>In this example, a deferred is used to pass a value between two fibers.</p>
<p>By running both fibers concurrently and using the deferred as a synchronization point, we can ensure that <code>fiberB</code> only proceeds after <code>fiberA</code> has completed its task.</p>
<pre><code class="language-ts">import { Effect, Deferred, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make&lt;string, string&gt;()

  // Completes the Deferred with a value after a delay
  const taskA = Effect.gen(function* () {
    console.log(&quot;Starting task to complete the Deferred&quot;)
    yield* Effect.sleep(&quot;1 second&quot;)
    console.log(&quot;Completing the Deferred&quot;)
    return yield* Deferred.succeed(deferred, &quot;hello world&quot;)
  })

  // Waits for the Deferred and prints the value
  const taskB = Effect.gen(function* () {
    console.log(&quot;Starting task to get the value from the Deferred&quot;)
    const value = yield* Deferred.await(deferred)
    console.log(&quot;Got the value from the Deferred&quot;)
    return value
  })

  // Run both fibers concurrently
  const fiberA = yield* Effect.fork(taskA)
  const fiberB = yield* Effect.fork(taskB)

  // Wait for both fibers to complete
  const both = yield* Fiber.join(Fiber.zip(fiberA, fiberB))

  console.log(both)
})

Effect.runFork(program)
/*
Starting task to complete the Deferred
Starting task to get the value from the Deferred
Completing the Deferred
Got the value from the Deferred
[ true, &#39;hello world&#39; ]
*/
</code></pre>
<hr>
<hr>
<h2>title: Fibers
description: Understand fibers in Effect, lightweight virtual threads enabling powerful concurrency, structured lifecycles, and efficient resource management for responsive applications.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Effect is a highly concurrent framework powered by fibers. Fibers are lightweight virtual threads with resource-safe cancellation capabilities, enabling many features in Effect.</p>
<p>In this section, you will learn the basics of fibers and get familiar with some of the powerful low-level operators that utilize fibers.</p>
<h2>What Are Virtual Threads?</h2>
<p>JavaScript is inherently single-threaded, meaning it executes code in a single sequence of instructions. However, modern JavaScript environments use an event loop to manage asynchronous operations, creating the illusion of multitasking. In this context, virtual threads, or fibers, are logical threads simulated by the Effect runtime. They allow concurrent execution without relying on true multi-threading, which is not natively supported in JavaScript.</p>
<h2>How Fibers work</h2>
<p>All effects in Effect are executed by fibers. If you didn&#39;t create the fiber yourself, it was created by an operation you&#39;re using (if it&#39;s concurrent) or by the Effect runtime system.</p>
<p>A fiber is created any time an effect is run. When running effects concurrently, a fiber is created for each concurrent effect.</p>
<p>Even if you write &quot;single-threaded&quot; code with no concurrent operations, there will always be at least one fiber: the &quot;main&quot; fiber that executes your effect.</p>
<p>Effect fibers have a well-defined lifecycle based on the effect they are executing.</p>
<p>Every fiber exits with either a failure or success, depending on whether the effect it is executing fails or succeeds.</p>
<p>Effect fibers have unique identities, local state, and a status (such as done, running, or suspended).</p>
<p>To summarize:</p>
<ul>
<li>An <code>Effect</code> is a higher-level concept that describes an effectful computation. It is lazy and immutable, meaning it represents a computation that may produce a value or fail but does not immediately execute.</li>
<li>A fiber, on the other hand, represents the running execution of an <code>Effect</code>. It can be interrupted or awaited to retrieve its result. Think of it as a way to control and interact with the ongoing computation.</li>
</ul>
<h2>The Fiber Data Type</h2>
<p>The <code>Fiber</code> data type in Effect represents a &quot;handle&quot; on the execution of an effect.</p>
<p>Here is the general form of a <code>Fiber</code>:</p>
<pre><code class="language-text">        ┌─── Represents the success type
        │        ┌─── Represents the error type
        │        │
        ▼        ▼
Fiber&lt;Success, Error&gt;
</code></pre>
<p>This type indicates that a fiber:</p>
<ul>
<li>Succeeds and returns a value of type <code>Success</code></li>
<li>Fails with an error of type <code>Error</code></li>
</ul>
<p>Fibers do not have an <code>Requirements</code> type parameter because they only execute effects that have already had their requirements provided to them.</p>
<h2>Forking Effects</h2>
<p>You can create a new fiber by <strong>forking</strong> an effect. This starts the effect in a new fiber, and you receive a reference to that fiber.</p>
<p><strong>Example</strong> (Forking a Fiber)</p>
<p>In this example, the Fibonacci calculation is forked into its own fiber, allowing it to run independently of the main fiber. The reference to the <code>fib10Fiber</code> can be used later to join or interrupt the fiber.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const fib = (n: number): Effect.Effect&lt;number&gt; =&gt;
  n &lt; 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Effect&lt;RuntimeFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Effect.fork(fib(10))
</code></pre>
<h2>Joining Fibers</h2>
<p>One common operation with fibers is <strong>joining</strong> them. By using the <code>Fiber.join</code> function, you can wait for a fiber to complete and retrieve its result. The joined fiber will either succeed or fail, and the <code>Effect</code> returned by <code>join</code> reflects the outcome of the fiber.</p>
<p><strong>Example</strong> (Joining a Fiber)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const fib = (n: number): Effect.Effect&lt;number&gt; =&gt;
  n &lt; 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Effect&lt;RuntimeFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Effect.fork(fib(10))

const program = Effect.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Join the fiber and get the result
  const n = yield* Fiber.join(fiber)
  console.log(n)
})

Effect.runFork(program) // Output: 55
</code></pre>
<h2>Awaiting Fibers</h2>
<p>The <code>Fiber.await</code> function is a helpful tool when working with fibers. It allows you to wait for a fiber to complete and retrieve detailed information about how it finished. The result is encapsulated in an <a href="/docs/data-types/exit/">Exit</a> value, which gives you insight into whether the fiber succeeded, failed, or was interrupted.</p>
<p><strong>Example</strong> (Awaiting Fiber Completion)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const fib = (n: number): Effect.Effect&lt;number&gt; =&gt;
  n &lt; 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Effect&lt;RuntimeFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Effect.fork(fib(10))

const program = Effect.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Await its completion and get the Exit result
  const exit = yield* Fiber.await(fiber)
  console.log(exit)
})

Effect.runFork(program)
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: 55 }
*/
</code></pre>
<h2>Interruption Model</h2>
<p>While developing concurrent applications, there are several cases that we need to interrupt the execution of other fibers, for example:</p>
<ol>
<li><p>A parent fiber might start some child fibers to perform a task, and later the parent might decide that, it doesn&#39;t need the result of some or all of the child fibers.</p>
</li>
<li><p>Two or more fibers start race with each other. The fiber whose result is computed first wins, and all other fibers are no longer needed, and should be interrupted.</p>
</li>
<li><p>In interactive applications, a user may want to stop some already running tasks, such as clicking on the &quot;stop&quot; button to prevent downloading more files.</p>
</li>
<li><p>Computations that run longer than expected should be aborted by using timeout operations.</p>
</li>
<li><p>When we have an application that perform compute-intensive tasks based on the user inputs, if the user changes the input we should cancel the current task and perform another one.</p>
</li>
</ol>
<h3>Polling vs. Asynchronous Interruption</h3>
<p>When it comes to interrupting fibers, a naive approach is to allow one fiber to forcefully terminate another fiber. However, this approach is not ideal because it can leave shared state in an inconsistent and unreliable state if the target fiber is in the middle of modifying that state. Therefore, it does not guarantee internal consistency of the shared mutable state.</p>
<p>Instead, there are two popular and valid solutions to tackle this problem:</p>
<ol>
<li><p><strong>Semi-asynchronous Interruption (Polling for Interruption)</strong>: Imperative languages often employ polling as a semi-asynchronous signaling mechanism, such as Java. In this model, a fiber sends an interruption request to another fiber. The target fiber continuously polls the interrupt status and checks whether it has received any interruption requests from other fibers. If an interruption request is detected, the target fiber terminates itself as soon as possible.</p>
<p>With this solution, the fiber itself handles critical sections. So, if a fiber is in the middle of a critical section and receives an interruption request, it ignores the interruption and defers its handling until after the critical section.</p>
<p>However, one drawback of this approach is that if the programmer forgets to poll regularly, the target fiber can become unresponsive, leading to deadlocks. Additionally, polling a global flag is not aligned with the functional paradigm followed by Effect.</p>
</li>
<li><p><strong>Asynchronous Interruption</strong>: In asynchronous interruption, a fiber is allowed to terminate another fiber. The target fiber is not responsible for polling the interrupt status. Instead, during critical sections, the target fiber disables the interruptibility of those regions. This is a purely functional solution that doesn&#39;t require polling a global state. Effect adopts this solution for its interruption model, which is a fully asynchronous signaling mechanism.</p>
<p>This mechanism overcomes the drawback of forgetting to poll regularly. It is also fully compatible with the functional paradigm because in a purely functional computation, we can abort the computation at any point, except during critical sections where interruption is disabled.</p>
</li>
</ol>
<h3>Interrupting Fibers</h3>
<p>Fibers can be interrupted if their result is no longer needed. This action immediately stops the fiber and safely runs all finalizers to release any resources.</p>
<p>Like <code>Fiber.await</code>, the <code>Fiber.interrupt</code> function returns an <a href="/docs/data-types/exit/">Exit</a> value that provides detailed information about how the fiber ended.</p>
<p><strong>Example</strong> (Interrupting a Fiber)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Fork a fiber that runs indefinitely, printing &quot;Hi!&quot;
  const fiber = yield* Effect.fork(
    Effect.forever(Effect.log(&quot;Hi!&quot;).pipe(Effect.delay(&quot;10 millis&quot;)))
  )
  yield* Effect.sleep(&quot;30 millis&quot;)
  // Interrupt the fiber and get an Exit value detailing how it finished
  const exit = yield* Fiber.interrupt(fiber)
  console.log(exit)
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#1 message=Hi!
timestamp=... level=INFO fiber=#1 message=Hi!
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Interrupt&#39;,
    fiberId: {
      _id: &#39;FiberId&#39;,
      _tag: &#39;Runtime&#39;,
      id: 0,
      startTimeMillis: ...
    }
  }
}
*/
</code></pre>
<p>By default, the effect returned by <code>Fiber.interrupt</code> waits until the fiber has fully terminated before resuming. This ensures that no new fibers are started before the previous ones have finished, a behavior known as &quot;back-pressuring.&quot;</p>
<p>If you do not require this waiting behavior, you can fork the interruption itself, allowing the main program to proceed without waiting for the fiber to terminate:</p>
<p><strong>Example</strong> (Forking an Interruption)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    Effect.forever(Effect.log(&quot;Hi!&quot;).pipe(Effect.delay(&quot;10 millis&quot;)))
  )
  yield* Effect.sleep(&quot;30 millis&quot;)
  const _ = yield* Effect.fork(Fiber.interrupt(fiber))
  console.log(&quot;Do something else...&quot;)
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#1 message=Hi!
timestamp=... level=INFO fiber=#1 message=Hi!
Do something else...
*/
</code></pre>
<p>There is also a shorthand for background interruption called <code>Fiber.interruptFork</code>.</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    Effect.forever(Effect.log(&quot;Hi!&quot;).pipe(Effect.delay(&quot;10 millis&quot;)))
  )
  yield* Effect.sleep(&quot;30 millis&quot;)
  // const _ = yield* Effect.fork(Fiber.interrupt(fiber))
  const _ = yield* Fiber.interruptFork(fiber)
  console.log(&quot;Do something else...&quot;)
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#1 message=Hi!
timestamp=... level=INFO fiber=#1 message=Hi!
Do something else...
*/
</code></pre>
<Aside type="tip" title="Interrupting via Effect.interrupt">
  You can also interrupt fibers using the high-level API
  `Effect.interrupt`. For more details, refer to the [Effect.interrupt
  documentation](/docs/concurrency/basic-concurrency/#interruptions).
</Aside>

<h2>Composing Fibers</h2>
<p>The <code>Fiber.zip</code> and <code>Fiber.zipWith</code> functions allow you to combine two fibers into one. The resulting fiber will produce the results of both input fibers. If either fiber fails, the combined fiber will also fail.</p>
<p><strong>Example</strong> (Combining Fibers with <code>Fiber.zip</code>)</p>
<p>In this example, both fibers run concurrently, and the results are combined into a tuple.</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Fork two fibers that each produce a string
  const fiber1 = yield* Effect.fork(Effect.succeed(&quot;Hi!&quot;))
  const fiber2 = yield* Effect.fork(Effect.succeed(&quot;Bye!&quot;))

  // Combine the two fibers using Fiber.zip
  const fiber = Fiber.zip(fiber1, fiber2)

  // Join the combined fiber and get the result as a tuple
  const tuple = yield* Fiber.join(fiber)
  console.log(tuple)
})

Effect.runFork(program)
/*
Output:
[ &#39;Hi!&#39;, &#39;Bye!&#39; ]
*/
</code></pre>
<p>Another way to compose fibers is by using <code>Fiber.orElse</code>. This function allows you to provide an alternative fiber that will execute if the first one fails. If the first fiber succeeds, its result will be returned. If it fails, the second fiber will run instead, and its result will be returned regardless of its outcome.</p>
<p><strong>Example</strong> (Providing a Fallback Fiber with <code>Fiber.orElse</code>)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Fork a fiber that will fail
  const fiber1 = yield* Effect.fork(Effect.fail(&quot;Uh oh!&quot;))
  // Fork another fiber that will succeed
  const fiber2 = yield* Effect.fork(Effect.succeed(&quot;Hurray!&quot;))
  // If fiber1 fails, fiber2 will be used as a fallback
  const fiber = Fiber.orElse(fiber1, fiber2)
  const message = yield* Fiber.join(fiber)
  console.log(message)
})

Effect.runFork(program)
/*
Output:
Hurray!
*/
</code></pre>
<h2>Lifetime of Child Fibers</h2>
<p>When we fork fibers, depending on how we fork them we can have four different lifetime strategies for the child fibers:</p>
<ol>
<li><p><strong>Fork With Automatic Supervision</strong>. If we use the ordinary <code>Effect.fork</code> operation, the child fiber will be automatically supervised by the parent fiber. The lifetime child fibers are tied to the lifetime of their parent fiber. This means that these fibers will be terminated either when they end naturally, or when their parent fiber is terminated.</p>
</li>
<li><p><strong>Fork in Global Scope (Daemon)</strong>. Sometimes we want to run long-running background fibers that aren&#39;t tied to their parent fiber, and also we want to fork them in a global scope. Any fiber that is forked in global scope will become daemon fiber. This can be achieved by using the <code>Effect.forkDaemon</code> operator. As these fibers have no parent, they are not supervised, and they will be terminated when they end naturally, or when our application is terminated.</p>
</li>
<li><p><strong>Fork in Local Scope</strong>. Sometimes, we want to run a background fiber that isn&#39;t tied to its parent fiber, but we want to live that fiber in the local scope. We can fork fibers in the local scope by using <code>Effect.forkScoped</code>. Such fibers can outlive their parent fiber (so they are not supervised by their parents), and they will be terminated when their life end or their local scope is closed.</p>
</li>
<li><p><strong>Fork in Specific Scope</strong>. This is similar to the previous strategy, but we can have more fine-grained control over the lifetime of the child fiber by forking it in a specific scope. We can do this by using the <code>Effect.forkIn</code> operator.</p>
</li>
</ol>
<h3>Fork with Automatic Supervision</h3>
<p>Effect follows a <strong>structured concurrency</strong> model, where child fibers&#39; lifetimes are tied to their parent. Simply put, the lifespan of a fiber depends on the lifespan of its parent fiber.</p>
<p><strong>Example</strong> (Automatically Supervised Child Fiber)</p>
<p>In this scenario, the <code>parent</code> fiber spawns a <code>child</code> fiber that repeatedly prints a message every second.
The <code>child</code> fiber will be terminated when the <code>parent</code> fiber completes.</p>
<pre><code class="language-ts">import { Effect, Console, Schedule } from &quot;effect&quot;

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log(&quot;child: still running!&quot;),
  Schedule.fixed(&quot;1 second&quot;)
)

const parent = Effect.gen(function* () {
  console.log(&quot;parent: started!&quot;)
  // Child fiber is supervised by the parent
  yield* Effect.fork(child)
  yield* Effect.sleep(&quot;3 seconds&quot;)
  console.log(&quot;parent: finished!&quot;)
})

Effect.runFork(parent)
/*
Output:
parent: started!
child: still running!
child: still running!
child: still running!
parent: finished!
*/
</code></pre>
<p>This behavior can be extended to any level of nested fibers, ensuring a predictable and controlled fiber lifecycle.</p>
<h3>Fork in Global Scope (Daemon)</h3>
<p>You can create a long-running background fiber using <code>Effect.forkDaemon</code>. This type of fiber, known as a daemon fiber, is not tied to the lifecycle of its parent fiber. Instead, its lifetime is linked to the global scope. A daemon fiber continues running even if its parent fiber is terminated and will only stop when the global scope is closed or the fiber completes naturally.</p>
<p><strong>Example</strong> (Creating a Daemon Fiber)</p>
<p>This example shows how daemon fibers can continue running in the background even after the parent fiber has finished.</p>
<pre><code class="language-ts">import { Effect, Console, Schedule } from &quot;effect&quot;

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log(&quot;daemon: still running!&quot;),
  Schedule.fixed(&quot;1 second&quot;)
)

const parent = Effect.gen(function* () {
  console.log(&quot;parent: started!&quot;)
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep(&quot;3 seconds&quot;)
  console.log(&quot;parent: finished!&quot;)
})

Effect.runFork(parent)
/*
Output:
parent: started!
daemon: still running!
daemon: still running!
daemon: still running!
parent: finished!
daemon: still running!
daemon: still running!
daemon: still running!
daemon: still running!
daemon: still running!
...etc...
*/
</code></pre>
<p>Even if the parent fiber is interrupted, the daemon fiber will continue running independently.</p>
<p><strong>Example</strong> (Interrupting the Parent Fiber)</p>
<p>In this example, interrupting the parent fiber doesn&#39;t affect the daemon fiber, which continues to run in the background.</p>
<pre><code class="language-ts">import { Effect, Console, Schedule, Fiber } from &quot;effect&quot;

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log(&quot;daemon: still running!&quot;),
  Schedule.fixed(&quot;1 second&quot;)
)

const parent = Effect.gen(function* () {
  console.log(&quot;parent: started!&quot;)
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep(&quot;3 seconds&quot;)
  console.log(&quot;parent: finished!&quot;)
}).pipe(Effect.onInterrupt(() =&gt; Console.log(&quot;parent: interrupted!&quot;)))

// Program that interrupts the parent fiber after 2 seconds
const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(parent)
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Fiber.interrupt(fiber) // Interrupt the parent fiber
})

Effect.runFork(program)
/*
Output:
parent: started!
daemon: still running!
daemon: still running!
parent: interrupted!
daemon: still running!
daemon: still running!
daemon: still running!
daemon: still running!
daemon: still running!
...etc...
*/
</code></pre>
<h3>Fork in Local Scope</h3>
<p>Sometimes we want to create a fiber that is tied to a local <a href="/docs/resource-management/scope/">scope</a>, meaning its lifetime is not dependent on its parent fiber but is bound to the local scope in which it was forked. This can be done using the <code>Effect.forkScoped</code> operator.</p>
<p>Fibers created with <code>Effect.forkScoped</code> can outlive their parent fibers and will only be terminated when the local scope itself is closed.</p>
<p><strong>Example</strong> (Forking a Fiber in a Local Scope)</p>
<p>In this example, the <code>child</code> fiber continues to run beyond the lifetime of the <code>parent</code> fiber. The <code>child</code> fiber is tied to the local scope and will be terminated only when the scope ends.</p>
<pre><code class="language-ts">import { Effect, Console, Schedule } from &quot;effect&quot;

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log(&quot;child: still running!&quot;),
  Schedule.fixed(&quot;1 second&quot;)
)

//      ┌─── Effect&lt;void, never, Scope&gt;
//      ▼
const parent = Effect.gen(function* () {
  console.log(&quot;parent: started!&quot;)
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep(&quot;3 seconds&quot;)
  console.log(&quot;parent: finished!&quot;)
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log(&quot;Local scope started!&quot;)
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep(&quot;5 seconds&quot;)
    console.log(&quot;Leaving the local scope!&quot;)
  })
)

Effect.runFork(program)
/*
Output:
Local scope started!
parent: started!
child: still running!
child: still running!
child: still running!
parent: finished!
child: still running!
child: still running!
Leaving the local scope!
*/
</code></pre>
<h3>Fork in Specific Scope</h3>
<p>There are some cases where we need more fine-grained control, so we want to fork a fiber in a specific scope.
We can use the <code>Effect.forkIn</code> operator which takes the target scope as an argument.</p>
<p><strong>Example</strong> (Forking a Fiber in a Specific Scope)</p>
<p>In this example, the <code>child</code> fiber is forked into the <code>outerScope</code>, allowing it to outlive the inner scope but still be terminated when the <code>outerScope</code> is closed.</p>
<pre><code class="language-ts">import { Console, Effect, Schedule } from &quot;effect&quot;

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log(&quot;child: still running!&quot;),
  Schedule.fixed(&quot;1 second&quot;)
)

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() =&gt;
      Console.log(&quot;The outer scope is about to be closed!&quot;)
    )

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() =&gt;
          Console.log(&quot;The inner scope is about to be closed!&quot;)
        )
        // Fork the child fiber in the outer scope
        yield* Effect.forkIn(child, outerScope)
        yield* Effect.sleep(&quot;3 seconds&quot;)
      })
    )

    yield* Effect.sleep(&quot;5 seconds&quot;)
  })
)

Effect.runFork(program)
/*
Output:
child: still running!
child: still running!
child: still running!
The inner scope is about to be closed!
child: still running!
child: still running!
child: still running!
child: still running!
child: still running!
child: still running!
The outer scope is about to be closed!
*/
</code></pre>
<h2>When do Fibers run?</h2>
<p>Forked fibers begin execution after the current fiber completes or yields.</p>
<p><strong>Example</strong> (Late Fiber Start Captures Only One Value)</p>
<p>In the following example, the <code>changes</code> stream only captures a single value, <code>2</code>.
This happens because the fiber created by <code>Effect.fork</code> starts <strong>after</strong> the value is updated.</p>
<pre><code class="language-ts">import { Effect, SubscriptionRef, Stream, Console } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const ref = yield* SubscriptionRef.make(0)
  yield* ref.changes.pipe(
    // Log each change in SubscriptionRef
    Stream.tap((n) =&gt; Console.log(`SubscriptionRef changed to ${n}`)),
    Stream.runDrain,
    // Fork a fiber to run the stream
    Effect.fork
  )
  yield* SubscriptionRef.set(ref, 1)
  yield* SubscriptionRef.set(ref, 2)
})

Effect.runFork(program)
/*
Output:
SubscriptionRef changed to 2
*/
</code></pre>
<p>If you add a short delay with <code>Effect.sleep()</code> or call <code>Effect.yieldNow()</code>, you allow the current fiber to yield. This gives the forked fiber enough time to start and collect all values before they are updated.</p>
<Aside type="caution" title="Fiber Execution is Non-Deterministic">
  Keep in mind that the timing of fiber execution is not deterministic,
  and many factors can affect when a fiber starts. Do not rely on the idea
  that a single yield always ensures your fiber begins at a particular
  time.
</Aside>

<p><strong>Example</strong> (Delay Allows Fiber to Capture All Values)</p>
<pre><code class="language-ts">import { Effect, SubscriptionRef, Stream, Console } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const ref = yield* SubscriptionRef.make(0)
  yield* ref.changes.pipe(
    // Log each change in SubscriptionRef
    Stream.tap((n) =&gt; Console.log(`SubscriptionRef changed to ${n}`)),
    Stream.runDrain,
    // Fork a fiber to run the stream
    Effect.fork
  )

  // Allow the fiber a chance to start
  yield* Effect.sleep(&quot;100 millis&quot;)

  yield* SubscriptionRef.set(ref, 1)
  yield* SubscriptionRef.set(ref, 2)
})

Effect.runFork(program)
/*
Output:
SubscriptionRef changed to 0
SubscriptionRef changed to 1
SubscriptionRef changed to 2
*/
</code></pre>
<hr>
<hr>
<h2>title: Latch
description: A Latch synchronizes fibers by allowing them to wait until a specific event occurs, controlling access based on its open or closed state.
sidebar:
  order: 8</h2>
<p>A Latch is a synchronization tool that works like a gate, letting fibers wait until the latch is opened before they continue. The latch can be either open or closed:</p>
<ul>
<li>When closed, fibers that reach the latch wait until it opens.</li>
<li>When open, fibers pass through immediately.</li>
</ul>
<p>Once opened, a latch typically stays open, although you can close it again if needed</p>
<p>Imagine an application that processes requests only after completing an initial setup (like loading configuration data or establishing a database connection).
You can create a latch in a closed state while the setup is happening.
Any incoming requests, represented as fibers, would wait at the latch until it opens.
Once the setup is finished, you call <code>latch.open</code> so the requests can proceed.</p>
<h2>The Latch Interface</h2>
<p>A <code>Latch</code> includes several operations that let you control and observe its state:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>whenOpen</code></td>
<td>Runs a given effect only if the latch is open, otherwise, waits until it opens.</td>
</tr>
<tr>
<td><code>open</code></td>
<td>Opens the latch so that any waiting fibers can proceed.</td>
</tr>
<tr>
<td><code>close</code></td>
<td>Closes the latch, causing fibers to wait when they reach this latch in the future.</td>
</tr>
<tr>
<td><code>await</code></td>
<td>Suspends the current fiber until the latch is opened. If the latch is already open, returns immediately.</td>
</tr>
<tr>
<td><code>release</code></td>
<td>Allows waiting fibers to continue without permanently opening the latch.</td>
</tr>
</tbody></table>
<h2>Creating a Latch</h2>
<p>Use the <code>Effect.makeLatch</code> function to create a latch in an open or closed state by passing a boolean. The default is <code>false</code>, which means it starts closed.</p>
<p><strong>Example</strong> (Creating and Using a Latch)</p>
<p>In this example, the latch starts closed. A fiber logs &quot;open sesame&quot; only when the latch is open. After waiting for one second, the latch is opened, releasing the fiber:</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

// A generator function that demonstrates latch usage
const program = Effect.gen(function* () {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch()

  // Fork a fiber that logs &quot;open sesame&quot; only when the latch is open
  const fiber = yield* Console.log(&quot;open sesame&quot;).pipe(
    latch.whenOpen, // Waits for the latch to open
    Effect.fork // Fork the effect into a new fiber
  )

  // Wait for 1 second
  yield* Effect.sleep(&quot;1 second&quot;)

  // Open the latch, releasing the fiber
  yield* latch.open

  // Wait for the forked fiber to finish
  yield* fiber.await
})

Effect.runFork(program)
// Output: open sesame (after 1 second)
</code></pre>
<h2>Latch vs Semaphore</h2>
<p>A latch is good when you have a one-time event or condition that determines whether fibers can proceed. For example, you might use a latch to block all fibers until a setup step is finished, and then open the latch so everyone can continue.</p>
<p>A <a href="/docs/concurrency/semaphore/">semaphore</a> with one lock (often called a binary semaphore or a mutex) is usually for mutual exclusion: it ensures that only one fiber at a time accesses a shared resource or section of code. Once a fiber acquires the lock, no other fiber can enter the protected area until the lock is released.</p>
<p>In short:</p>
<ul>
<li>Use a <strong>latch</strong> if you&#39;re gating a set of fibers on a specific event (&quot;Wait here until this becomes true&quot;).</li>
<li>Use a <strong>semaphore (with one lock)</strong> if you need to ensure only one fiber at a time is in a critical section or using a shared resource.</li>
</ul>
<hr>
<hr>
<h2>title: PubSub
description: Effortless message broadcasting and asynchronous communication with PubSub in Effect.
sidebar:
  order: 6</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>A <code>PubSub</code> serves as an asynchronous message hub, allowing publishers to send messages that can be received by all current subscribers.</p>
<p>Unlike a <a href="/docs/concurrency/queue/">Queue</a>, where each value is delivered to only one consumer, a <code>PubSub</code> broadcasts each published message to all subscribers. This makes <code>PubSub</code> ideal for scenarios requiring message broadcasting rather than load distribution.</p>
<h2>Basic Operations</h2>
<p>A <code>PubSub&lt;A&gt;</code> stores messages of type <code>A</code> and provides two fundamental operations:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>PubSub.publish</code></td>
<td>Sends a message of type <code>A</code> to the <code>PubSub</code>, returning an effect indicating if the message was successfully published.</td>
</tr>
<tr>
<td><code>PubSub.subscribe</code></td>
<td>Creates a scoped effect that allows subscription to the <code>PubSub</code>, automatically unsubscribing when the scope ends. Subscribers receive messages through a <a href="/docs/concurrency/queue/#dequeue">Dequeue</a> which holds published messages.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Publishing a Message to Multiple Subscribers)</p>
<pre><code class="language-ts">import { Effect, PubSub, Queue } from &quot;effect&quot;

const program = Effect.scoped(
  Effect.gen(function* () {
    const pubsub = yield* PubSub.bounded&lt;string&gt;(2)

    // Two subscribers
    const dequeue1 = yield* PubSub.subscribe(pubsub)
    const dequeue2 = yield* PubSub.subscribe(pubsub)

    // Publish a message to the pubsub
    yield* PubSub.publish(pubsub, &quot;Hello from a PubSub!&quot;)

    // Each subscriber receives the message
    console.log(&quot;Subscriber 1: &quot; + (yield* Queue.take(dequeue1)))
    console.log(&quot;Subscriber 2: &quot; + (yield* Queue.take(dequeue2)))
  })
)

Effect.runFork(program)
/*
Output:
Subscriber 1: Hello from a PubSub!
Subscriber 2: Hello from a PubSub!
*/
</code></pre>
<Aside type="caution" title="Subscribe Before Publishing">
  A subscriber only receives messages published while it is actively
  subscribed. To ensure a subscriber receives a particular message,
  establish the subscription before publishing the message.
</Aside>

<h2>Creating a PubSub</h2>
<h3>Bounded PubSub</h3>
<p>A bounded <code>PubSub</code> applies back pressure to publishers when it reaches capacity, suspending additional publishing until space becomes available.</p>
<p>Back pressure ensures that all subscribers receive all messages while they are subscribed. However, it can lead to slower message delivery if a subscriber is slow.</p>
<p><strong>Example</strong> (Bounded PubSub Creation)</p>
<pre><code class="language-ts">import { PubSub } from &quot;effect&quot;

// Creates a bounded PubSub with a capacity of 2
const boundedPubSub = PubSub.bounded&lt;string&gt;(2)
</code></pre>
<h3>Dropping PubSub</h3>
<p>A dropping <code>PubSub</code> discards new values when full. The <code>PubSub.publish</code> operation returns <code>false</code> if the message is dropped.</p>
<p>In a dropping pubsub, publishers can continue to publish new values, but subscribers are not guaranteed to receive all messages.</p>
<p><strong>Example</strong> (Dropping PubSub Creation)</p>
<pre><code class="language-ts">import { PubSub } from &quot;effect&quot;

// Creates a dropping PubSub with a capacity of 2
const droppingPubSub = PubSub.dropping&lt;string&gt;(2)
</code></pre>
<h3>Sliding PubSub</h3>
<p>A sliding <code>PubSub</code> removes the oldest message to make space for new ones, ensuring that publishing never blocks.</p>
<p>A sliding pubsub prevents slow subscribers from impacting the message delivery rate. However, there&#39;s still a risk that slow subscribers may miss some messages.</p>
<p><strong>Example</strong> (Sliding PubSub Creation)</p>
<pre><code class="language-ts">import { PubSub } from &quot;effect&quot;

// Creates a sliding PubSub with a capacity of 2
const slidingPubSub = PubSub.sliding&lt;string&gt;(2)
</code></pre>
<h3>Unbounded PubSub</h3>
<p>An unbounded <code>PubSub</code> has no capacity limit, so publishing always succeeds immediately.</p>
<p>Unbounded pubsubs guarantee that all subscribers receive all messages without slowing down message delivery. However, they can grow indefinitely if messages are published faster than they are consumed.</p>
<p>Generally, it&#39;s recommended to use bounded, dropping, or sliding pubsubs unless you have specific use cases for unbounded pubsubs.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { PubSub } from &quot;effect&quot;

// Creates an unbounded PubSub with unlimited capacity
const unboundedPubSub = PubSub.unbounded&lt;string&gt;()
</code></pre>
<h2>Operators On PubSubs</h2>
<h3>publishAll</h3>
<p>The <code>PubSub.publishAll</code> function lets you publish multiple values to the pubsub at once.</p>
<p><strong>Example</strong> (Publishing Multiple Messages)</p>
<pre><code class="language-ts">import { Effect, PubSub, Queue } from &quot;effect&quot;

const program = Effect.scoped(
  Effect.gen(function* () {
    const pubsub = yield* PubSub.bounded&lt;string&gt;(2)
    const dequeue = yield* PubSub.subscribe(pubsub)
    yield* PubSub.publishAll(pubsub, [&quot;Message 1&quot;, &quot;Message 2&quot;])
    console.log(yield* Queue.takeAll(dequeue))
  })
)

Effect.runFork(program)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ &#39;Message 1&#39;, &#39;Message 2&#39; ] }
*/
</code></pre>
<h3>capacity / size</h3>
<p>You can check the capacity and current size of a pubsub using <code>PubSub.capacity</code> and <code>PubSub.size</code>, respectively.</p>
<p>Note that <code>PubSub.capacity</code> returns a <code>number</code> because the capacity is set at pubsub creation and never changes.
In contrast, <code>PubSub.size</code> returns an effect that determines the current size of the pubsub since the number of messages in the pubsub can change over time.</p>
<p><strong>Example</strong> (Retrieving PubSub Capacity and Size)</p>
<pre><code class="language-ts">import { Effect, PubSub } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const pubsub = yield* PubSub.bounded&lt;number&gt;(2)
  console.log(`capacity: ${PubSub.capacity(pubsub)}`)
  console.log(`size: ${yield* PubSub.size(pubsub)}`)
})

Effect.runFork(program)
/*
Output:
capacity: 2
size: 0
*/
</code></pre>
<h3>Shutting Down a PubSub</h3>
<p>To shut down a pubsub, use <code>PubSub.shutdown</code>. You can also verify if it has been shut down with <code>PubSub.isShutdown</code>, or wait for the shutdown to complete with <code>PubSub.awaitShutdown</code>. Shutting down a pubsub also terminates all associated queues, ensuring that the shutdown signal is effectively communicated.</p>
<h2>PubSub as an Enqueue</h2>
<p><code>PubSub</code> operators mirror those of <a href="/docs/concurrency/queue/">Queue</a> with the main difference being that <code>PubSub.publish</code> and <code>PubSub.subscribe</code> are used in place of <code>Queue.offer</code> and <code>Queue.take</code>. If you&#39;re already familiar with using a <code>Queue</code>, you’ll find <code>PubSub</code> straightforward.</p>
<p>Essentially, a <code>PubSub</code> can be seen as a <code>Enqueue</code> that only allows writes:</p>
<pre><code class="language-ts">import type { Queue } from &quot;effect&quot;

interface PubSub&lt;A&gt; extends Queue.Enqueue&lt;A&gt; {}
</code></pre>
<p>Here, the <code>Enqueue</code> type refers to a queue that only accepts enqueues (or writes). Any value enqueued here is published to the pubsub, and operations like shutdown will also affect the pubsub.</p>
<p>This design makes <code>PubSub</code> highly flexible, letting you use it anywhere you need a <code>Enqueue</code> that only accepts published values.</p>
<hr>
<hr>
<h2>title: Queue
description: Learn how to use Effect&#39;s Queue for lightweight, type-safe, and asynchronous workflows with built-in back-pressure.
sidebar:
  order: 5</h2>
<p>A <code>Queue</code> is a lightweight in-memory queue with built-in back-pressure, enabling asynchronous, purely-functional, and type-safe handling of data.</p>
<h2>Basic Operations</h2>
<p>A <code>Queue&lt;A&gt;</code> stores values of type <code>A</code> and provides two fundamental operations:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Queue.offer</code></td>
<td>Adds a value of type <code>A</code> to the queue.</td>
</tr>
<tr>
<td><code>Queue.take</code></td>
<td>Removes and returns the oldest value from the queue.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Adding and Retrieving an Item)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Creates a bounded queue with capacity 100
  const queue = yield* Queue.bounded&lt;number&gt;(100)
  // Adds 1 to the queue
  yield* Queue.offer(queue, 1)
  // Retrieves and removes the oldest value
  const value = yield* Queue.take(queue)
  return value
})

Effect.runPromise(program).then(console.log)
// Output: 1
</code></pre>
<h2>Creating a Queue</h2>
<p>Queues can be <strong>bounded</strong> (with a specified capacity) or <strong>unbounded</strong> (without a limit). Different types of queues handle new values differently when they reach capacity.</p>
<h3>Bounded Queue</h3>
<p>A bounded queue applies back-pressure when full, meaning any <code>Queue.offer</code> operation will suspend until there is space.</p>
<p><strong>Example</strong> (Creating a Bounded Queue)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

// Creating a bounded queue with a capacity of 100
const boundedQueue = Queue.bounded&lt;number&gt;(100)
</code></pre>
<h3>Dropping Queue</h3>
<p>A dropping queue discards new values if the queue is full.</p>
<p><strong>Example</strong> (Creating a Dropping Queue)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

// Creating a dropping queue with a capacity of 100
const droppingQueue = Queue.dropping&lt;number&gt;(100)
</code></pre>
<h3>Sliding Queue</h3>
<p>A sliding queue removes old values to make space for new ones when it reaches capacity.</p>
<p><strong>Example</strong> (Creating a Sliding Queue)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

// Creating a sliding queue with a capacity of 100
const slidingQueue = Queue.sliding&lt;number&gt;(100)
</code></pre>
<h3>Unbounded Queue</h3>
<p>An unbounded queue has no capacity limit, allowing unrestricted additions.</p>
<p><strong>Example</strong> (Creating an Unbounded Queue)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

// Creates an unbounded queue without a capacity limit
const unboundedQueue = Queue.unbounded&lt;number&gt;()
</code></pre>
<h2>Adding Items to a Queue</h2>
<h3>offer</h3>
<p>Use <code>Queue.offer</code> to add values to the queue.</p>
<p><strong>Example</strong> (Adding a Single Item)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(100)
  // Adds 1 to the queue
  yield* Queue.offer(queue, 1)
})
</code></pre>
<p>When using a back-pressured queue, <code>Queue.offer</code> suspends if the queue is full. To avoid blocking the main fiber, you can fork the <code>Queue.offer</code> operation.</p>
<p><strong>Example</strong> (Handling a Full Queue with <code>Effect.fork</code>)</p>
<pre><code class="language-ts">import { Effect, Queue, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(1)
  // Fill the queue with one item
  yield* Queue.offer(queue, 1)
  // Attempting to add a second item will suspend as the queue is full
  const fiber = yield* Effect.fork(Queue.offer(queue, 2))
  // Empties the queue to make space
  yield* Queue.take(queue)
  // Joins the fiber, completing the suspended offer
  yield* Fiber.join(fiber)
  // Returns the size of the queue after additions
  return yield* Queue.size(queue)
})

Effect.runPromise(program).then(console.log)
// Output: 1
</code></pre>
<h3>offerAll</h3>
<p>You can also add multiple items at once using <code>Queue.offerAll</code>.</p>
<p><strong>Example</strong> (Adding Multiple Items)</p>
<pre><code class="language-ts">import { Effect, Queue, Array } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(100)
  const items = Array.range(1, 10)
  // Adds all items to the queue at once
  yield* Queue.offerAll(queue, items)
  // Returns the size of the queue after additions
  return yield* Queue.size(queue)
})

Effect.runPromise(program).then(console.log)
// Output: 10
</code></pre>
<h2>Consuming Items from a Queue</h2>
<h3>take</h3>
<p>The <code>Queue.take</code> operation removes and returns the oldest item from the queue. If the queue is empty, <code>Queue.take</code> will suspend and only resume when an item is added. To prevent blocking, you can fork the <code>Queue.take</code> operation into a new fiber.</p>
<p><strong>Example</strong> (Waiting for an Item in a Fiber)</p>
<pre><code class="language-ts">import { Effect, Queue, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;string&gt;(100)
  // This take operation will suspend because the queue is empty
  const fiber = yield* Effect.fork(Queue.take(queue))
  // Adds an item to the queue
  yield* Queue.offer(queue, &quot;something&quot;)
  // Joins the fiber to get the result of the take operation
  const value = yield* Fiber.join(fiber)
  return value
})

Effect.runPromise(program).then(console.log)
// Output: something
</code></pre>
<h3>poll</h3>
<p>To retrieve the queue&#39;s first item without suspending, use <code>Queue.poll</code>. If the queue is empty, <code>Queue.poll</code> returns <code>None</code>; if it has an item, it wraps it in <code>Some</code>.</p>
<p><strong>Example</strong> (Polling an Item)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(100)
  // Adds items to the queue
  yield* Queue.offer(queue, 10)
  yield* Queue.offer(queue, 20)
  // Retrieves the first item if available
  const head = yield* Queue.poll(queue)
  return head
})

Effect.runPromise(program).then(console.log)
/*
Output:
{
  _id: &quot;Option&quot;,
  _tag: &quot;Some&quot;,
  value: 10
}
*/
</code></pre>
<h3>takeUpTo</h3>
<p>To retrieve multiple items, use <code>Queue.takeUpTo</code>, which returns up to the specified number of items.
If there aren&#39;t enough items, it returns all available items without waiting for more.</p>
<p>This function is particularly useful for batch processing when an exact number of items is not required. It ensures the program continues working with whatever data is currently available.</p>
<p>If you need to wait for an exact number of items before proceeding, consider using <a href="#taken">takeN</a>.</p>
<p><strong>Example</strong> (Taking Up to N Items)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(100)

  // Adds items to the queue
  yield* Queue.offer(queue, 1)
  yield* Queue.offer(queue, 2)
  yield* Queue.offer(queue, 3)

  // Retrieves up to 2 items
  const chunk = yield* Queue.takeUpTo(queue, 2)
  console.log(chunk)

  return &quot;some result&quot;
})

Effect.runPromise(program).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
some result
*/
</code></pre>
<h3>takeN</h3>
<p>Takes a specified number of elements from a queue. If the queue does not contain enough elements, the operation suspends until the required number of elements become available.</p>
<p>This function is useful for scenarios where processing requires an exact number of items at a time, ensuring that the operation does not proceed until the batch is complete.</p>
<p><strong>Example</strong> (Taking a Fixed Number of Items)</p>
<pre><code class="language-ts">import { Effect, Queue, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Create a queue that can hold up to 100 elements
  const queue = yield* Queue.bounded&lt;number&gt;(100)

  // Fork a fiber that attempts to take 3 items from the queue
  const fiber = yield* Effect.fork(
    Effect.gen(function* () {
      console.log(&quot;Attempting to take 3 items from the queue...&quot;)
      const chunk = yield* Queue.takeN(queue, 3)
      console.log(`Successfully took 3 items: ${chunk}`)
    })
  )

  // Offer only 2 items initially
  yield* Queue.offer(queue, 1)
  yield* Queue.offer(queue, 2)
  console.log(
    &quot;Offered 2 items. The fiber is now waiting for the 3rd item...&quot;
  )

  // Simulate some delay
  yield* Effect.sleep(&quot;2 seconds&quot;)

  // Offer the 3rd item, which will unblock the takeN call
  yield* Queue.offer(queue, 3)
  console.log(&quot;Offered the 3rd item, which should unblock the fiber.&quot;)

  // Wait for the fiber to finish
  yield* Fiber.join(fiber)
  return &quot;some result&quot;
})

Effect.runPromise(program).then(console.log)
/*
Output:
Offered 2 items. The fiber is now waiting for the 3rd item...
Attempting to take 3 items from the queue...
Offered the 3rd item, which should unblock the fiber.
Successfully took 3 items: {
  &quot;_id&quot;: &quot;Chunk&quot;,
  &quot;values&quot;: [
    1,
    2,
    3
  ]
}
some result
*/
</code></pre>
<h3>takeAll</h3>
<p>To retrieve all items from the queue at once, use <code>Queue.takeAll</code>. This operation completes immediately, returning an empty collection if the queue is empty.</p>
<p><strong>Example</strong> (Taking All Items)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(100)
  // Adds items to the queue
  yield* Queue.offer(queue, 10)
  yield* Queue.offer(queue, 20)
  yield* Queue.offer(queue, 30)
  // Retrieves all items from the queue
  const chunk = yield* Queue.takeAll(queue)
  return chunk
})

Effect.runPromise(program).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 10, 20, 30 ]
}
*/
</code></pre>
<h2>Shutting Down a Queue</h2>
<h3>shutdown</h3>
<p>The <code>Queue.shutdown</code> operation allows you to interrupt all fibers that are currently suspended on <code>offer*</code> or <code>take*</code> operations. This action also empties the queue and makes any future <code>offer*</code> and <code>take*</code> calls terminate immediately.</p>
<p><strong>Example</strong> (Interrupting Fibers on Queue Shutdown)</p>
<pre><code class="language-ts">import { Effect, Queue, Fiber } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(3)
  // Forks a fiber that waits to take an item from the queue
  const fiber = yield* Effect.fork(Queue.take(queue))
  // Shuts down the queue, interrupting the fiber
  yield* Queue.shutdown(queue)
  // Joins the interrupted fiber
  yield* Fiber.join(fiber)
})
</code></pre>
<h3>awaitShutdown</h3>
<p>The <code>Queue.awaitShutdown</code> operation can be used to run an effect when the queue shuts down. It waits until the queue is closed and resumes immediately if the queue is already shut down.</p>
<p><strong>Example</strong> (Waiting for Queue Shutdown)</p>
<pre><code class="language-ts">import { Effect, Queue, Fiber, Console } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded&lt;number&gt;(3)
  // Forks a fiber to await queue shutdown and log a message
  const fiber = yield* Effect.fork(
    Queue.awaitShutdown(queue).pipe(
      Effect.andThen(Console.log(&quot;shutting down&quot;))
    )
  )
  // Shuts down the queue, triggering the await in the fiber
  yield* Queue.shutdown(queue)
  yield* Fiber.join(fiber)
})

Effect.runPromise(program)
// Output: shutting down
</code></pre>
<h2>Offer-only / Take-only Queues</h2>
<p>Sometimes, you might want certain parts of your code to only add values to a queue (<code>Enqueue</code>) or only retrieve values from a queue (<code>Dequeue</code>). Effect provides interfaces to enforce these specific capabilities.</p>
<h3>Enqueue</h3>
<p>All methods for adding values to a queue are defined by the <code>Enqueue</code> interface. This restricts the queue to only offer operations.</p>
<p><strong>Example</strong> (Restricting Queue to Offer-only Operations)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

const send = (offerOnlyQueue: Queue.Enqueue&lt;number&gt;, value: number) =&gt; {
  // This queue is restricted to offer operations only

  // Error: cannot use take on an offer-only queue
  // @ts-expect-error
  Queue.take(offerOnlyQueue)

  // Valid offer operation
  return Queue.offer(offerOnlyQueue, value)
}
</code></pre>
<h3>Dequeue</h3>
<p>Similarly, all methods for retrieving values from a queue are defined by the <code>Dequeue</code> interface, which restricts the queue to only take operations.</p>
<p><strong>Example</strong> (Restricting Queue to Take-only Operations)</p>
<pre><code class="language-ts">import { Queue } from &quot;effect&quot;

const receive = (takeOnlyQueue: Queue.Dequeue&lt;number&gt;) =&gt; {
  // This queue is restricted to take operations only

  // Error: cannot use offer on a take-only queue
  // @ts-expect-error
  Queue.offer(takeOnlyQueue, 1)

  // Valid take operation
  return Queue.take(takeOnlyQueue)
}
</code></pre>
<p>The <code>Queue</code> type combines both <code>Enqueue</code> and <code>Dequeue</code>, so you can easily pass it to different parts of your code, enforcing only <code>Enqueue</code> or <code>Dequeue</code> behaviors as needed.</p>
<p><strong>Example</strong> (Using Offer-only and Take-only Queues Together)</p>
<pre><code class="language-ts">import { Effect, Queue } from &quot;effect&quot;

const send = (offerOnlyQueue: Queue.Enqueue&lt;number&gt;, value: number) =&gt; {
  return Queue.offer(offerOnlyQueue, value)
}

const receive = (takeOnlyQueue: Queue.Dequeue&lt;number&gt;) =&gt; {
  return Queue.take(takeOnlyQueue)
}

const program = Effect.gen(function* () {
  const queue = yield* Queue.unbounded&lt;number&gt;()

  // Add values to the queue
  yield* send(queue, 1)
  yield* send(queue, 2)

  // Retrieve values from the queue
  console.log(yield* receive(queue))
  console.log(yield* receive(queue))
})

Effect.runFork(program)
/*
Output:
1
2
*/
</code></pre>
<hr>
<hr>
<h2>title: Semaphore
description: Learn to use semaphores in Effect for precise control of concurrency, managing resource access, and coordinating asynchronous tasks effectively.
sidebar:
  order: 7</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>A semaphore is a synchronization mechanism used to manage access to a shared resource. In Effect, semaphores help control resource access or coordinate tasks within asynchronous, concurrent operations.</p>
<p>A semaphore acts as a generalized mutex, allowing a set number of <strong>permits</strong> to be held and released concurrently. Permits act like tickets, giving tasks or fibers controlled access to a shared resource. When no permits are available, tasks trying to acquire one will wait until a permit is released.</p>
<h2>Creating a Semaphore</h2>
<p>The <code>Effect.makeSemaphore</code> function initializes a semaphore with a specified number of permits.
Each permit allows one task to access a resource or perform an operation concurrently, and multiple permits enable a configurable level of concurrency.</p>
<p><strong>Example</strong> (Creating a Semaphore with 3 Permits)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Create a semaphore with 3 permits
const mutex = Effect.makeSemaphore(3)
</code></pre>
<h2>withPermits</h2>
<p>The <code>withPermits</code> method lets you specify the number of permits required to run an effect. Once the specified permits are available, it runs the effect, automatically releasing the permits when the task completes.</p>
<p><strong>Example</strong> (Forcing Sequential Task Execution with a One-Permit Semaphore)</p>
<p>In this example, three tasks are started concurrently, but they run sequentially because the one-permit semaphore only allows one task to proceed at a time.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  yield* Effect.log(&quot;start&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.log(&quot;end&quot;)
})

const program = Effect.gen(function* () {
  const mutex = yield* Effect.makeSemaphore(1)

  // Wrap the task to require one permit, forcing sequential execution
  const semTask = mutex
    .withPermits(1)(task)
    .pipe(Effect.withLogSpan(&quot;elapsed&quot;))

  // Run 3 tasks concurrently, but they execute sequentially
  // due to the one-permit semaphore
  yield* Effect.all([semTask, semTask, semTask], {
    concurrency: &quot;unbounded&quot;
  })
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#1 message=start elapsed=3ms
timestamp=... level=INFO fiber=#1 message=end elapsed=2010ms
timestamp=... level=INFO fiber=#2 message=start elapsed=2012ms
timestamp=... level=INFO fiber=#2 message=end elapsed=4017ms
timestamp=... level=INFO fiber=#3 message=start elapsed=4018ms
timestamp=... level=INFO fiber=#3 message=end elapsed=6026ms
*/
</code></pre>
<p><strong>Example</strong> (Using Multiple Permits to Control Concurrent Task Execution)</p>
<p>In this example, we create a semaphore with five permits and use <code>withPermits(n)</code> to allocate a different number of permits for each task:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const mutex = yield* Effect.makeSemaphore(5)

  const tasks = [1, 2, 3, 4, 5].map((n) =&gt;
    mutex
      .withPermits(n)(
        Effect.delay(Effect.log(`process: ${n}`), &quot;2 seconds&quot;)
      )
      .pipe(Effect.withLogSpan(&quot;elapsed&quot;))
  )

  yield* Effect.all(tasks, { concurrency: &quot;unbounded&quot; })
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#1 message=&quot;process: 1&quot; elapsed=2011ms
timestamp=... level=INFO fiber=#2 message=&quot;process: 2&quot; elapsed=2017ms
timestamp=... level=INFO fiber=#3 message=&quot;process: 3&quot; elapsed=4020ms
timestamp=... level=INFO fiber=#4 message=&quot;process: 4&quot; elapsed=6025ms
timestamp=... level=INFO fiber=#5 message=&quot;process: 5&quot; elapsed=8034ms
*/
</code></pre>
<Aside type="note" title="Permit Release Guarantee">
  The `withPermits` method guarantees that permits are released after each
  task, even if the task fails or is interrupted.
</Aside>


<hr>
<hr>
<h2>title: Configuration
description: Efficiently manage application configurations with built-in types, flexible providers, and advanced features like defaults, validation, and redaction.
sidebar:
  order: 5</h2>
<p>import { Aside, Badge } from &quot;@astrojs/starlight/components&quot;</p>
<p>Configuration is an essential aspect of any cloud-native application. Effect simplifies the process of managing configuration by offering a convenient interface for configuration providers.</p>
<p>The configuration front-end in Effect enables ecosystem libraries and applications to specify their configuration requirements in a declarative manner. It offloads the complex tasks to a <code>ConfigProvider</code>, which can be supplied by third-party libraries.</p>
<p>Effect comes bundled with a straightforward default <code>ConfigProvider</code> that retrieves configuration data from environment variables. This default provider can be used during development or as a starting point before transitioning to more advanced configuration providers.</p>
<p>To make our application configurable, we need to understand three essential elements:</p>
<ul>
<li><p><strong>Config Description</strong>: We describe the configuration data using an instance of <code>Config&lt;A&gt;</code>. If the configuration data is simple, such as a <code>string</code>, <code>number</code>, or <code>boolean</code>, we can use the built-in functions provided by the <code>Config</code> module. For more complex data types like <a href="#custom-configurations">HostPort</a>, we can combine primitive configs to create a custom configuration description.</p>
</li>
<li><p><strong>Config Frontend</strong>: We utilize the instance of <code>Config&lt;A&gt;</code> to load the configuration data described by the instance (a <code>Config</code> is, in itself, an effect). This process leverages the current <code>ConfigProvider</code> to retrieve the configuration.</p>
</li>
<li><p><strong>Config Backend</strong>: The <code>ConfigProvider</code> serves as the underlying engine that manages the configuration loading process. Effect comes with a default config provider as part of its default services. This default provider reads the configuration data from environment variables. If we want to use a custom config provider, we can utilize the <code>Layer.setConfigProvider</code> layer to configure the Effect runtime accordingly.</p>
</li>
</ul>
<h2>Basic Configuration Types</h2>
<p>Effect provides several built-in types for configuration values, which you can use right out of the box:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>string</code></td>
<td>Constructs a config for a string value.</td>
</tr>
<tr>
<td><code>number</code></td>
<td>Constructs a config for a float value.</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>Constructs a config for a boolean value.</td>
</tr>
<tr>
<td><code>integer</code></td>
<td>Constructs a config for an integer value.</td>
</tr>
<tr>
<td><code>date</code></td>
<td>Constructs a config for a date value.</td>
</tr>
<tr>
<td><code>literal</code></td>
<td>Constructs a config for a literal (*) value.</td>
</tr>
<tr>
<td><code>logLevel</code></td>
<td>Constructs a config for a <a href="/docs/observability/logging/#log-levels">LogLevel</a> value.</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>Constructs a config for a duration value.</td>
</tr>
<tr>
<td><code>redacted</code></td>
<td>Constructs a config for a secret value.</td>
</tr>
<tr>
<td><code>url</code></td>
<td>Constructs a config for an URL value.</td>
</tr>
</tbody></table>
<p>(*) <code>string | number | boolean | null | bigint</code></p>
<p><strong>Example</strong> (Using Primitives)</p>
<p>Here&#39;s an example of loading a basic configuration using environment variables for <code>HOST</code> and <code>PORT</code>:</p>
<pre><code class="language-ts">import { Effect, Config } from &quot;effect&quot;

// Define a program that loads HOST and PORT configuration
const program = Effect.gen(function* () {
  // Load the HOST from environment variables
  const host = yield* Config.string(&quot;HOST&quot;)
  // Load the PORT as a number
  const port = yield* Config.number(&quot;PORT&quot;)

  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(program)
</code></pre>
<p>If you run this without setting the required environment variables:</p>
<pre><code class="language-sh">npx tsx primitives.ts
</code></pre>
<p>you&#39;ll see an error indicating the missing configuration:</p>
<pre><code class="language-ansi">[Error: (Missing data at HOST: &quot;Expected HOST to exist in the process context&quot;)] {
  name: &#39;(FiberFailure) Error&#39;,
  [Symbol(effect/Runtime/FiberFailure)]: Symbol(effect/Runtime/FiberFailure),
  [Symbol(effect/Runtime/FiberFailure/Cause)]: {
    _tag: &#39;Fail&#39;,
    error: {
      _op: &#39;MissingData&#39;,
      path: [ &#39;HOST&#39; ],
      message: &#39;Expected HOST to exist in the process context&#39;
    }
  }
}
</code></pre>
<p>To run the program successfully, set the environment variables as shown below:</p>
<pre><code class="language-sh">HOST=localhost PORT=8080 npx tsx primitives.ts
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">Application started: localhost:8080
</code></pre>
<h2>Default Values</h2>
<p>Sometimes, you may encounter situations where an environment variable is missing, leading to an incomplete configuration. To address this, Effect provides the <code>Config.withDefault</code> function, which allows you to specify a default value. This fallback ensures that your application continues to function even if a required environment variable is not set.</p>
<p><strong>Example</strong> (Using Default Values)</p>
<pre><code class="language-ts">import { Effect, Config } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const host = yield* Config.string(&quot;HOST&quot;)
  // Use default 8080 if PORT is not set
  const port = yield* Config.number(&quot;PORT&quot;).pipe(Config.withDefault(8080))
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(program)
</code></pre>
<p>Running this program with only the <code>HOST</code> environment variable set:</p>
<pre><code class="language-sh">HOST=localhost npx tsx defaults.ts
</code></pre>
<p>produces the following output:</p>
<pre><code class="language-ansi">Application started: localhost:8080
</code></pre>
<p>In this case, even though the <code>PORT</code> environment variable is not set, the program continues to run, using the default value of <code>8080</code> for the port. This ensures that the application remains functional without requiring every configuration to be explicitly provided.</p>
<h2>Constructors for Configurations</h2>
<p>Effect provides several built-in constructors that allow you to define and manipulate configurations. These constructors take a <code>Config</code> as input and produce another <code>Config</code>, enabling more complex configuration structures.</p>
<p>Here are some of the key constructors:</p>
<table>
<thead>
<tr>
<th>Constructor</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>array</code></td>
<td>Constructs a configuration for an array of values.</td>
</tr>
<tr>
<td><code>chunk</code></td>
<td>Constructs a configuration for a sequence of values.</td>
</tr>
<tr>
<td><code>option</code></td>
<td>Returns an optional configuration. If the data is missing, the result will be <code>None</code>; otherwise, it will be <code>Some</code>.</td>
</tr>
<tr>
<td><code>repeat</code></td>
<td>Describes a sequence of values, each following the structure of the given config.</td>
</tr>
<tr>
<td><code>hashSet</code></td>
<td>Constructs a configuration for a set of values.</td>
</tr>
<tr>
<td><code>hashMap</code></td>
<td>Constructs a configuration for a key-value map.</td>
</tr>
</tbody></table>
<p>Additionally, there are three special constructors for specific use cases:</p>
<table>
<thead>
<tr>
<th>Constructor</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>succeed</code></td>
<td>Constructs a config that contains a predefined value.</td>
</tr>
<tr>
<td><code>fail</code></td>
<td>Constructs a config that fails with the specified error message.</td>
</tr>
<tr>
<td><code>all</code></td>
<td>Combines multiple configurations into a tuple, struct, or argument list.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>array</code> Constructor)</p>
<p>The following example demonstrates how to load an environment variable as an array of strings using the <code>Config.array</code> constructor.</p>
<pre><code class="language-ts">import { Effect, Config } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Load array from env var MY_ARRAY
  const config = yield* Config.array(Config.string(), &quot;MY_ARRAY&quot;)
  console.log(config)
})

Effect.runPromise(program)
</code></pre>
<p>If we run this program with the following environment variable:</p>
<pre><code class="language-sh">MY_ARRAY=a,b,c npx tsx array.ts
</code></pre>
<p>The output will be:</p>
<pre><code class="language-ansi">[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</code></pre>
<p>This shows how the <code>array</code> constructor converts a comma-separated string from an environment variable into an array of values, making configuration handling more flexible.</p>
<h2>Operators</h2>
<p>Effect provides several built-in operators to work with configurations, allowing you to manipulate and transform them according to your needs.</p>
<h3>Transforming Operators</h3>
<p>These operators enable you to modify configurations or validate their values:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>validate</code></td>
<td>Ensures that a configuration meets certain criteria, returning a validation error if it does not.</td>
</tr>
<tr>
<td><code>map</code></td>
<td>Transforms the values of a configuration using a provided function.</td>
</tr>
<tr>
<td><code>mapAttempt</code></td>
<td>Similar to <code>map</code>, but catches any errors thrown by the function and converts them into validation errors.</td>
</tr>
<tr>
<td><code>mapOrFail</code></td>
<td>Like <code>map</code>, but the function can fail. If it does, the result is a validation error.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>validate</code> Operator)</p>
<pre><code class="language-ts">import { Effect, Config } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Load the NAME environment variable and validate its length
  const config = yield* Config.string(&quot;NAME&quot;).pipe(
    Config.validate({
      message: &quot;Expected a string at least 4 characters long&quot;,
      validation: (s) =&gt; s.length &gt;= 4
    })
  )
  console.log(config)
})

Effect.runPromise(program)
</code></pre>
<p>If we run this program with an invalid <code>NAME</code> value:</p>
<pre><code class="language-sh">NAME=foo npx tsx validate.ts
</code></pre>
<p>The output will be:</p>
<pre><code class="language-ansi">[Error: (Invalid data at NAME: &quot;Expected a string at least 4 characters long&quot;)] {
  name: &#39;(FiberFailure) Error&#39;,
  [Symbol(effect/Runtime/FiberFailure)]: Symbol(effect/Runtime/FiberFailure),
  [Symbol(effect/Runtime/FiberFailure/Cause)]: {
    _tag: &#39;Fail&#39;,
    error: {
      _op: &#39;InvalidData&#39;,
      path: [ &#39;NAME&#39; ],
      message: &#39;Expected a string at least 4 characters long&#39;
    }
  }
}
</code></pre>
<h3>Fallback Operators</h3>
<p>Fallback operators are useful when you want to provide alternative configurations in case of errors or missing data. These operators ensure that your program can still run even if some configuration values are unavailable.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>orElse</code></td>
<td>Attempts to use the primary config first. If it fails or is missing, it falls back to another config.</td>
</tr>
<tr>
<td><code>orElseIf</code></td>
<td>Similar to <code>orElse</code>, but it switches to the fallback config only if the error matches a condition.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>orElse</code> for Fallback)</p>
<p>In this example, the program requires two configuration values: <code>A</code> and <code>B</code>. We set up two configuration providers, each containing only one of the required values. Using the <code>orElse</code> operator, we combine these providers so the program can retrieve both <code>A</code> and <code>B</code>.</p>
<pre><code class="language-ts">import { Config, ConfigProvider, Effect, Layer } from &quot;effect&quot;

// A program that requires two configurations: A and B
const program = Effect.gen(function* () {
  const A = yield* Config.string(&quot;A&quot;) // Retrieve config A
  const B = yield* Config.string(&quot;B&quot;) // Retrieve config B
  console.log(`A: ${A}, B: ${B}`)
})

// First provider has A but is missing B
const provider1 = ConfigProvider.fromMap(new Map([[&quot;A&quot;, &quot;A&quot;]]))

// Second provider has B but is missing A
const provider2 = ConfigProvider.fromMap(new Map([[&quot;B&quot;, &quot;B&quot;]]))

// Use `orElse` to fall back from provider1 to provider2
const layer = Layer.setConfigProvider(
  provider1.pipe(ConfigProvider.orElse(() =&gt; provider2))
)

Effect.runPromise(Effect.provide(program, layer))
</code></pre>
<p>If we run this program:</p>
<pre><code class="language-sh">npx tsx orElse.ts
</code></pre>
<p>The output will be:</p>
<pre><code class="language-ansi">A: A, B: B
</code></pre>
<Aside type="tip">
  In this example, we use `ConfigProvider.fromMap` to create a
  configuration provider from a simple JavaScript `Map`. This is
  particularly useful for testing, as described in the [Testing
  Configurable Services](#testing-configurable-services) section.
</Aside>

<h2>Custom Configurations</h2>
<p>Effect allows you to define configurations for custom types by combining primitive configs using <code>Config</code> <a href="#operators">operators</a> (such as <code>zip</code>, <code>orElse</code>, <code>map</code>) and <a href="#constructors-for-configurations">constructors</a> (like <code>array</code>, <code>hashSet</code>).</p>
<p>For example, let&#39;s create a <code>HostPort</code> class, which has two fields: <code>host</code> and <code>port</code>.</p>
<pre><code class="language-ts">class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}
</code></pre>
<p>To define a configuration for this custom type, we can combine primitive configs for <code>string</code> and <code>number</code>:</p>
<pre><code class="language-ts">import { Config } from &quot;effect&quot;

class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

// Combine the configuration for &#39;HOST&#39; and &#39;PORT&#39;
const both = Config.all([Config.string(&quot;HOST&quot;), Config.number(&quot;PORT&quot;)])

// Map the configuration values into a HostPort instance
const config = Config.map(
  both,
  ([host, port]) =&gt; new HostPort(host, port)
)
</code></pre>
<p>In this example, <code>Config.all(configs)</code> combines two primitive configurations, <code>Config&lt;string&gt;</code> and <code>Config&lt;number&gt;</code>, into a <code>Config&lt;[string, number]&gt;</code>. The <code>Config.map</code> operator is then used to transform these values into an instance of the <code>HostPort</code> class.</p>
<p><strong>Example</strong> (Using Custom Configuration)</p>
<pre><code class="language-ts">import { Effect, Config } from &quot;effect&quot;

class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

// Combine the configuration for &#39;HOST&#39; and &#39;PORT&#39;
const both = Config.all([Config.string(&quot;HOST&quot;), Config.number(&quot;PORT&quot;)])

// Map the configuration values into a HostPort instance
const config = Config.map(
  both,
  ([host, port]) =&gt; new HostPort(host, port)
)

// Main program that reads configuration and starts the application
const program = Effect.gen(function* () {
  const hostPort = yield* config
  console.log(`Application started: ${hostPort.url}`)
})

Effect.runPromise(program)
</code></pre>
<p>When you run this program, it will try to retrieve the values for <code>HOST</code> and <code>PORT</code> from your environment variables:</p>
<pre><code class="language-sh">HOST=localhost PORT=8080 npx tsx App.ts
</code></pre>
<p>If successful, it will print:</p>
<pre><code class="language-ansi">Application started: localhost:8080
</code></pre>
<h2>Top-level and Nested Configurations</h2>
<p>We&#39;ve seen how to define configurations at the top level, whether for primitive or custom types. In some cases, though, you might want to structure your configurations in a more nested way, organizing them under common namespaces for clarity and manageability.</p>
<p>For instance, consider the following <code>ServiceConfig</code> type:</p>
<pre><code class="language-ts">class ServiceConfig {
  constructor(
    readonly host: string,
    readonly port: number,
    readonly timeout: number
  ) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}
</code></pre>
<p>If you were to use this configuration in your application, it would expect the <code>HOST</code>, <code>PORT</code>, and <code>TIMEOUT</code> environment variables at the top level. But in many cases, you may want to organize configurations under a shared namespace—for example, grouping <code>HOST</code> and <code>PORT</code> under a <code>SERVER</code> namespace, while keeping <code>TIMEOUT</code> at the root.</p>
<p>To do this, you can use the <code>Config.nested</code> operator, which allows you to nest configuration values under a specific namespace. Let&#39;s update the previous example to reflect this:</p>
<pre><code class="language-ts">import { Config } from &quot;effect&quot;

class ServiceConfig {
  constructor(
    readonly host: string,
    readonly port: number,
    readonly timeout: number
  ) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

const serverConfig = Config.all([
  Config.string(&quot;HOST&quot;),
  Config.number(&quot;PORT&quot;)
])

const serviceConfig = Config.map(
  Config.all([
    // Read &#39;HOST&#39; and &#39;PORT&#39; from &#39;SERVER&#39; namespace
    Config.nested(serverConfig, &quot;SERVER&quot;),
    // Read &#39;TIMEOUT&#39; from the root namespace
    Config.number(&quot;TIMEOUT&quot;)
  ]),
  ([[host, port], timeout]) =&gt; new ServiceConfig(host, port, timeout)
)
</code></pre>
<p>Now, if you run your application with this configuration setup, it will look for the following environment variables:</p>
<ul>
<li><code>SERVER_HOST</code> for the host value</li>
<li><code>SERVER_PORT</code> for the port value</li>
<li><code>TIMEOUT</code> for the timeout value</li>
</ul>
<p>This structured approach keeps your configuration more organized, especially when dealing with multiple services or complex applications.</p>
<h2>Testing Configurable Services</h2>
<p>When testing services, there are times when you need to provide specific configurations for your tests. To simulate this, it&#39;s useful to mock the configuration backend that reads these values.</p>
<p>You can achieve this using the <code>ConfigProvider.fromMap</code> constructor. This method allows you to create a configuration provider from a <code>Map&lt;string, string&gt;</code>, where the map represents the configuration data. You can then use this mock provider in place of the default one by calling <code>Layer.setConfigProvider</code>. This function returns a <code>Layer</code> that can override the default configuration for your tests.</p>
<p><strong>Example</strong> (Mocking a Config Provider for Testing)</p>
<pre><code class="language-ts">import { Config, ConfigProvider, Layer, Effect } from &quot;effect&quot;

class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

const config = Config.map(
  Config.all([Config.string(&quot;HOST&quot;), Config.number(&quot;PORT&quot;)]),
  ([host, port]) =&gt; new HostPort(host, port)
)

const program = Effect.gen(function* () {
  const hostPort = yield* config
  console.log(`Application started: ${hostPort.url}`)
})

// Create a mock config provider using a map with test data
const mockConfigProvider = ConfigProvider.fromMap(
  new Map([
    [&quot;HOST&quot;, &quot;localhost&quot;],
    [&quot;PORT&quot;, &quot;8080&quot;]
  ])
)

// Override the default config provider with the mock provider
const layer = Layer.setConfigProvider(mockConfigProvider)

// Run the program using the mock config provider
Effect.runPromise(Effect.provide(program, layer))
// Output: Application started: localhost:8080
</code></pre>
<p>This approach helps you create isolated tests that don&#39;t rely on external environment variables, ensuring your tests run consistently with mock configurations.</p>
<Aside type="caution" title="Namespace Separator">
  When specifying nested configurations in the map, you must use `.` to
  separate levels of the namespace (e.g., `SERVER.PORT`) instead of `_`.
  For example, `SERVER_PORT` will not be recognized as a nested key.
</Aside>

<p><strong>Example</strong> (Providing Nested Configuration Values)</p>
<pre><code class="language-ts">import { Config, ConfigProvider, Layer, Effect } from &quot;effect&quot;

const config = Config.nested(Config.number(&quot;PORT&quot;), &quot;SERVER&quot;)

const mockConfigProvider = ConfigProvider.fromMap(
  // Use &#39;.&#39; as a separator for nested keys
  new Map([[&quot;SERVER.PORT&quot;, &quot;8080&quot;]])
)

Effect.runPromise(
  Effect.provide(config, Layer.setConfigProvider(mockConfigProvider))
).then(console.log)
// Output: 8080
</code></pre>
<h2>Redacted</h2>
<p>The <code>Config.redacted</code> function is used to handle sensitive information safely. It parses the configuration value and wraps it in a <code>Redacted&lt;string&gt;</code>, a specialized <a href="/docs/data-types/redacted/">data type</a> designed to protect secrets.</p>
<p>When you log a <code>Redacted</code> value using <code>console.log</code>, the actual content remains hidden, providing an extra layer of security. To access the real value, you must explicitly use <code>Redacted.value</code>.</p>
<p><strong>Example</strong> (Handling Redacted Values)</p>
<pre><code class="language-ts">import { Effect, Config, Redacted } from &quot;effect&quot;

const program = Effect.gen(function* () {
  //      ┌─── Redacted&lt;string&gt;
  //      ▼
  const redacted = yield* Config.redacted(&quot;API_KEY&quot;)

  // Log the redacted value, which won&#39;t reveal the actual secret
  console.log(`Console output: ${redacted}`)

  // Access the real value using Redacted.value and log it
  console.log(`Actual value: ${Redacted.value(redacted)}`)
})

Effect.runPromise(program)
</code></pre>
<p>When this program is executed:</p>
<pre><code class="language-sh">API_KEY=my-api-key tsx redacted.ts
</code></pre>
<p>The output will look like this:</p>
<pre><code class="language-ansi">Console output: &lt;redacted&gt;
Actual value: my-api-key
</code></pre>
<p>As shown, when logging the <code>Redacted</code> value using <code>console.log</code>, the output is <code>&lt;redacted&gt;</code>, ensuring that sensitive data remains concealed. However, by using <code>Redacted.value</code>, the true value (<code>&quot;my-api-key&quot;</code>) can be accessed and displayed, providing controlled access to the secret.</p>
<h3>Wrapping a Config with Redacted</h3>
<p>By default, when you pass a string to <code>Config.redacted</code>, it returns a <code>Redacted&lt;string&gt;</code>. You can also pass a <code>Config</code> (such as <code>Config.number</code>) to ensure that only validated values are accepted. This adds an extra layer of security by ensuring that sensitive data is properly validated before being redacted.</p>
<p><strong>Example</strong> (Redacting and Validating a Number)</p>
<pre><code class="language-ts">import { Effect, Config, Redacted } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Wrap the validated number configuration with redaction
  //
  //      ┌─── Redacted&lt;number&gt;
  //      ▼
  const redacted = yield* Config.redacted(Config.number(&quot;SECRET&quot;))

  console.log(`Console output: ${redacted}`)
  console.log(`Actual value: ${Redacted.value(redacted)}`)
})

Effect.runPromise(program)
</code></pre>
<h2>Secret <Badge text="Deprecated" variant="caution" /></h2>
<p><em>Deprecated since version 3.3.0: Please use <a href="#redacted">Config.redacted</a> for handling sensitive information going forward.</em></p>
<p>The <code>Config.secret</code> function was previously used to secure sensitive information in a similar way to <code>Config.redacted</code>. It wraps configuration values in a <code>Secret</code> type, which also conceals details when logged but allows access via <code>Secret.value</code>.</p>
<p><strong>Example</strong> (Using Deprecated <code>Config.secret</code>)</p>
<pre><code class="language-ts">import { Effect, Config, Secret } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const secret = yield* Config.secret(&quot;API_KEY&quot;)

  // Log the secret value, which won&#39;t reveal the actual secret
  console.log(`Console output: ${secret}`)

  // Access the real value using Secret.value and log it
  console.log(`Actual value: ${Secret.value(secret)}`)
})

Effect.runPromise(program)
</code></pre>
<p>When this program is executed:</p>
<pre><code class="language-sh">API_KEY=my-api-key tsx secret.ts
</code></pre>
<p>The output will look like this:</p>
<pre><code class="language-ansi">Console output: Secret(&lt;redacted&gt;)
Actual value: my-api-key
</code></pre>
<hr>
<hr>
<h2>title: BigDecimal
description: The BigDecimal data type represents arbitrary-precision decimal numbers.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In JavaScript, numbers are typically stored as 64-bit floating-point values. While floating-point numbers are fast and versatile, they can introduce small rounding errors. These are often hard to notice in everyday usage but can become problematic in areas like finance or statistics, where small inaccuracies may lead to larger discrepancies over time.</p>
<p>By using the BigDecimal module, you can avoid these issues and perform calculations with a higher degree of precision.</p>
<p>The <code>BigDecimal</code> data type can represent real numbers with a large number of decimal places, preventing the common errors of floating-point math (for example, 0.1 + 0.2 ≠ 0.3).</p>
<h2>How BigDecimal Works</h2>
<p>A <code>BigDecimal</code> represents a number using two components:</p>
<ol>
<li><code>value</code>: A <code>BigInt</code> that stores the digits of the number.</li>
<li><code>scale</code>: A 64-bit integer that determines the position of the decimal point.</li>
</ol>
<p>The number represented by a <code>BigDecimal</code> is calculated as: value x 10<sup>-scale</sup>.</p>
<ul>
<li>If <code>scale</code> is zero or positive, it specifies the number of digits to the right of the decimal point.</li>
<li>If <code>scale</code> is negative, the <code>value</code> is multiplied by 10 raised to the power of the negated scale.</li>
</ul>
<p>For example:</p>
<ul>
<li>A <code>BigDecimal</code> with <code>value = 12345n</code> and <code>scale = 2</code> represents <code>123.45</code>.</li>
<li>A <code>BigDecimal</code> with <code>value = 12345n</code> and <code>scale = -2</code> represents <code>1234500</code>.</li>
</ul>
<p>The maximum precision is large but not infinite, limited to 2<sup>63</sup> decimal places.</p>
<h2>Creating a BigDecimal</h2>
<h3>make</h3>
<p>The <code>make</code> function creates a <code>BigDecimal</code> by specifying a <code>BigInt</code> value and a scale. The <code>scale</code> determines the number of digits to the right of the decimal point.</p>
<p><strong>Example</strong> (Creating a BigDecimal with a Specified Scale)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

// Create a BigDecimal from a BigInt (1n) with a scale of 2
const decimal = BigDecimal.make(1n, 2)

console.log(decimal)
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;1&#39;, scale: 2 }

// Convert the BigDecimal to a string
console.log(String(decimal))
// Output: BigDecimal(0.01)

// Format the BigDecimal as a standard decimal string
console.log(BigDecimal.format(decimal))
// Output: 0.01

// Convert the BigDecimal to exponential notation
console.log(BigDecimal.toExponential(decimal))
// Output: 1e-2
</code></pre>
<h3>fromBigInt</h3>
<p>The <code>fromBigInt</code> function creates a <code>BigDecimal</code> from a <code>bigint</code>. The <code>scale</code> defaults to <code>0</code>, meaning the number has no fractional part.</p>
<p><strong>Example</strong> (Creating a BigDecimal from a BigInt)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const decimal = BigDecimal.fromBigInt(10n)

console.log(decimal)
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;10&#39;, scale: 0 }
</code></pre>
<h3>fromString</h3>
<p>Parses a numerical string into a <code>BigDecimal</code>. Returns an <code>Option&lt;BigDecimal&gt;</code>:</p>
<ul>
<li><code>Some(BigDecimal)</code> if the string is valid.</li>
<li><code>None</code> if the string is invalid.</li>
</ul>
<p><strong>Example</strong> (Parsing a String into a BigDecimal)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const decimal = BigDecimal.fromString(&quot;0.02&quot;)

console.log(decimal)
/*
Output:
{
  _id: &#39;Option&#39;,
  _tag: &#39;Some&#39;,
  value: { _id: &#39;BigDecimal&#39;, value: &#39;2&#39;, scale: 2 }
}
*/
</code></pre>
<h3>unsafeFromString</h3>
<p>The <code>unsafeFromString</code> function is a variant of <code>fromString</code> that throws an error if the input string is invalid. Use this only when you are confident that the input will always be valid.</p>
<p><strong>Example</strong> (Unsafe Parsing of a String)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const decimal = BigDecimal.unsafeFromString(&quot;0.02&quot;)

console.log(decimal)
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;2&#39;, scale: 2 }
</code></pre>
<h3>unsafeFromNumber</h3>
<p>Creates a <code>BigDecimal</code> from a JavaScript <code>number</code>. Throws a <code>RangeError</code> for non-finite numbers (<code>NaN</code>, <code>+Infinity</code>, or <code>-Infinity</code>).</p>
<p><strong>Example</strong> (Unsafe Parsing of a Number)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

console.log(BigDecimal.unsafeFromNumber(123.456))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;123456&#39;, scale: 3 }
</code></pre>
<Aside type="caution" title="Avoid Direct Conversion">
  Avoid converting floating-point numbers directly to `BigDecimal`, as
  their representation may already introduce precision issues.
</Aside>

<h2>Basic Arithmetic Operations</h2>
<p>The BigDecimal module supports a variety of arithmetic operations that provide precision and avoid the rounding errors common in standard JavaScript arithmetic. Below is a list of supported operations:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>sum</code></td>
<td>Adds two <code>BigDecimal</code> values.</td>
</tr>
<tr>
<td><code>subtract</code></td>
<td>Subtracts one <code>BigDecimal</code> value from another.</td>
</tr>
<tr>
<td><code>multiply</code></td>
<td>Multiplies two <code>BigDecimal</code> values.</td>
</tr>
<tr>
<td><code>divide</code></td>
<td>Divides one <code>BigDecimal</code> value by another, returning an <code>Option&lt;BigDecimal&gt;</code>.</td>
</tr>
<tr>
<td><code>unsafeDivide</code></td>
<td>Divides one <code>BigDecimal</code> value by another, throwing an error if the divisor is zero.</td>
</tr>
<tr>
<td><code>negate</code></td>
<td>Negates a <code>BigDecimal</code> value (i.e., changes its sign).</td>
</tr>
<tr>
<td><code>remainder</code></td>
<td>Returns the remainder of dividing one <code>BigDecimal</code> value by another, returning an <code>Option&lt;BigDecimal&gt;</code>.</td>
</tr>
<tr>
<td><code>unsafeRemainder</code></td>
<td>Returns the remainder of dividing one <code>BigDecimal</code> value by another, throwing an error if the divisor is zero.</td>
</tr>
<tr>
<td><code>sign</code></td>
<td>Returns the sign of a <code>BigDecimal</code> value (<code>-1</code>, <code>0</code>, or <code>1</code>).</td>
</tr>
<tr>
<td><code>abs</code></td>
<td>Returns the absolute value of a <code>BigDecimal</code>.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Performing Basic Arithmetic with BigDecimal)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const dec1 = BigDecimal.unsafeFromString(&quot;1.05&quot;)
const dec2 = BigDecimal.unsafeFromString(&quot;2.10&quot;)

// Addition
console.log(String(BigDecimal.sum(dec1, dec2)))
// Output: BigDecimal(3.15)

// Multiplication
console.log(String(BigDecimal.multiply(dec1, dec2)))
// Output: BigDecimal(2.205)

// Subtraction
console.log(String(BigDecimal.subtract(dec2, dec1)))
// Output: BigDecimal(1.05)

// Division (safe, returns Option&lt;BigDecimal&gt;)
console.log(BigDecimal.divide(dec2, dec1))
/*
Output:
{
  _id: &#39;Option&#39;,
  _tag: &#39;Some&#39;,
  value: { _id: &#39;BigDecimal&#39;, value: &#39;2&#39;, scale: 0 }
}
*/

// Division (unsafe, throws if divisor is zero)
console.log(String(BigDecimal.unsafeDivide(dec2, dec1)))
// Output: BigDecimal(2)

// Negation
console.log(String(BigDecimal.negate(dec1)))
// Output: BigDecimal(-1.05)

// Modulus (unsafe, throws if divisor is zero)
console.log(
  String(
    BigDecimal.unsafeRemainder(dec2, BigDecimal.unsafeFromString(&quot;0.6&quot;))
  )
)
// Output: BigDecimal(0.3)
</code></pre>
<p>Using <code>BigDecimal</code> for arithmetic operations helps to avoid the inaccuracies commonly encountered with floating-point numbers in JavaScript. For example:</p>
<p><strong>Example</strong> (Avoiding Floating-Point Errors)</p>
<pre><code class="language-ts">const dec1 = 1.05
const dec2 = 2.1

console.log(String(dec1 + dec2))
// Output: 3.1500000000000004
</code></pre>
<h2>Comparison Operations</h2>
<p>The <code>BigDecimal</code> module provides several functions for comparing decimal values. These allow you to determine the relative order of two values, find the minimum or maximum, and check specific properties like positivity or integer status.</p>
<h3>Comparison Functions</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>lessThan</code></td>
<td>Checks if the first <code>BigDecimal</code> is smaller than the second.</td>
</tr>
<tr>
<td><code>lessThanOrEqualTo</code></td>
<td>Checks if the first <code>BigDecimal</code> is smaller than or equal to the second.</td>
</tr>
<tr>
<td><code>greaterThan</code></td>
<td>Checks if the first <code>BigDecimal</code> is larger than the second.</td>
</tr>
<tr>
<td><code>greaterThanOrEqualTo</code></td>
<td>Checks if the first <code>BigDecimal</code> is larger than or equal to the second.</td>
</tr>
<tr>
<td><code>min</code></td>
<td>Returns the smaller of two <code>BigDecimal</code> values.</td>
</tr>
<tr>
<td><code>max</code></td>
<td>Returns the larger of two <code>BigDecimal</code> values.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Comparing Two BigDecimal Values)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const dec1 = BigDecimal.unsafeFromString(&quot;1.05&quot;)
const dec2 = BigDecimal.unsafeFromString(&quot;2.10&quot;)

console.log(BigDecimal.lessThan(dec1, dec2))
// Output: true

console.log(BigDecimal.lessThanOrEqualTo(dec1, dec2))
// Output: true

console.log(BigDecimal.greaterThan(dec1, dec2))
// Output: false

console.log(BigDecimal.greaterThanOrEqualTo(dec1, dec2))
// Output: false

console.log(BigDecimal.min(dec1, dec2))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;105&#39;, scale: 2 }

console.log(BigDecimal.max(dec1, dec2))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;210&#39;, scale: 2 }
</code></pre>
<h3>Predicates for Comparison</h3>
<p>The module also includes predicates to check specific properties of a <code>BigDecimal</code>:</p>
<table>
<thead>
<tr>
<th>Predicate</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>isZero</code></td>
<td>Checks if the value is exactly zero.</td>
</tr>
<tr>
<td><code>isPositive</code></td>
<td>Checks if the value is positive.</td>
</tr>
<tr>
<td><code>isNegative</code></td>
<td>Checks if the value is negative.</td>
</tr>
<tr>
<td><code>between</code></td>
<td>Checks if the value lies within a specified range (inclusive).</td>
</tr>
<tr>
<td><code>isInteger</code></td>
<td>Checks if the value is an integer (i.e., no fractional part).</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Checking the Sign and Properties of BigDecimal Values)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const dec1 = BigDecimal.unsafeFromString(&quot;1.05&quot;)
const dec2 = BigDecimal.unsafeFromString(&quot;-2.10&quot;)

console.log(BigDecimal.isZero(BigDecimal.unsafeFromString(&quot;0&quot;)))
// Output: true

console.log(BigDecimal.isPositive(dec1))
// Output: true

console.log(BigDecimal.isNegative(dec2))
// Output: true

console.log(
  BigDecimal.between({
    minimum: BigDecimal.unsafeFromString(&quot;1&quot;),
    maximum: BigDecimal.unsafeFromString(&quot;2&quot;)
  })(dec1)
)
// Output: true

console.log(
  BigDecimal.isInteger(dec2),
  BigDecimal.isInteger(BigDecimal.fromBigInt(3n))
)
// Output: false true
</code></pre>
<h2>Normalization and Equality</h2>
<p>In some cases, two <code>BigDecimal</code> values can have different internal representations but still represent the same number.</p>
<p>For example, <code>1.05</code> could be internally represented with different scales, such as:</p>
<ul>
<li><code>105n</code> with a scale of <code>2</code></li>
<li><code>1050n</code> with a scale of <code>3</code></li>
</ul>
<p>To ensure consistency, you can normalize a <code>BigDecimal</code> to adjust the scale and remove trailing zeros.</p>
<h3>Normalization</h3>
<p>The <code>BigDecimal.normalize</code> function adjusts the scale of a <code>BigDecimal</code> and eliminates any unnecessary trailing zeros in its internal representation.</p>
<p><strong>Example</strong> (Normalizing a BigDecimal)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const dec = BigDecimal.make(1050n, 3)

console.log(BigDecimal.normalize(dec))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;105&#39;, scale: 2 }
</code></pre>
<h3>Equality</h3>
<p>To check if two <code>BigDecimal</code> values are numerically equal, regardless of their internal representation, use the <code>BigDecimal.equals</code> function.</p>
<p><strong>Example</strong> (Checking Equality)</p>
<pre><code class="language-ts">import { BigDecimal } from &quot;effect&quot;

const dec1 = BigDecimal.make(105n, 2)
const dec2 = BigDecimal.make(1050n, 3)

console.log(BigDecimal.equals(dec1, dec2))
// Output: true
</code></pre>
<hr>
<hr>
<h2>title: Cause
description: Comprehensive error analysis with Cause in Effect - track failures, defects, and interruptions with precise details.
sidebar:
  order: 2</h2>
<p>The <a href="/docs/getting-started/the-effect-type/"><code>Effect&lt;A, E, R&gt;</code></a> type is polymorphic in error type <code>E</code>, allowing flexibility in handling any desired error type. However, there is often additional information about failures that the error type <code>E</code> alone does not capture.</p>
<p>To address this, Effect uses the <code>Cause&lt;E&gt;</code> data type to store various details such as:</p>
<ul>
<li>Unexpected errors or defects</li>
<li>Stack and execution traces</li>
<li>Reasons for fiber interruptions</li>
</ul>
<p>Effect strictly preserves all failure-related information, storing a full picture of the error context in the <code>Cause</code> type. This comprehensive approach enables precise analysis and handling of failures, ensuring no data is lost.</p>
<p>Though <code>Cause</code> values aren&#39;t typically manipulated directly, they underlie errors within Effect workflows, providing access to both concurrent and sequential error details. This allows for thorough error analysis when needed.</p>
<h2>Creating Causes</h2>
<p>You can intentionally create an effect with a specific cause using <code>Effect.failCause</code>.</p>
<p><strong>Example</strong> (Defining Effects with Different Causes)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

// Define an effect that dies with an unexpected error
//
//      ┌─── Effect&lt;never, never, never&gt;
//      ▼
const die = Effect.failCause(Cause.die(&quot;Boom!&quot;))

// Define an effect that fails with an expected error
//
//      ┌─── Effect&lt;never, string, never&gt;
//      ▼
const fail = Effect.failCause(Cause.fail(&quot;Oh no!&quot;))
</code></pre>
<p>Some causes do not influence the error type of the effect, leading to <code>never</code> in the error channel:</p>
<pre><code class="language-text">                ┌─── no error information
                ▼
Effect&lt;never, never, never&gt;
</code></pre>
<p>For instance, <code>Cause.die</code> does not specify an error type for the effect, while <code>Cause.fail</code> does, setting the error channel type accordingly.</p>
<h2>Cause Variations</h2>
<p>There are several causes for various errors, in this section, we will describe each of these causes.</p>
<h3>Empty</h3>
<p>The <code>Empty</code> cause signifies the absence of any errors.</p>
<h3>Fail</h3>
<p>The <code>Fail&lt;E&gt;</code> cause represents a failure due to an expected error of type <code>E</code>.</p>
<h3>Die</h3>
<p>The <code>Die</code> cause indicates a failure resulting from a defect, which is an unexpected or unintended error.</p>
<h3>Interrupt</h3>
<p>The <code>Interrupt</code> cause represents a failure due to <code>Fiber</code> interruption and contains the <code>FiberId</code> of the interrupted <code>Fiber</code>.</p>
<h3>Sequential</h3>
<p>The <code>Sequential</code> cause combines two causes that occurred one after the other.</p>
<p>For example, in an <code>Effect.ensuring</code> operation (analogous to <code>try-finally</code>), if both the <code>try</code> and <code>finally</code> sections fail, the two errors are represented in sequence by a <code>Sequential</code> cause.</p>
<p><strong>Example</strong> (Capturing Sequential Failures with a <code>Sequential</code> Cause)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

const program = Effect.failCause(Cause.fail(&quot;Oh no!&quot;)).pipe(
  Effect.ensuring(Effect.failCause(Cause.die(&quot;Boom!&quot;)))
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Sequential&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh no!&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: &#39;Boom!&#39; }
  }
}
*/
</code></pre>
<h3>Parallel</h3>
<p>The <code>Parallel</code> cause combines two causes that occurred concurrently.</p>
<p>In Effect programs, two operations may run in parallel, potentially leading to multiple failures. When both computations fail simultaneously, a <code>Parallel</code> cause represents the concurrent errors within the effect workflow.</p>
<p><strong>Example</strong> (Capturing Concurrent Failures with a <code>Parallel</code> Cause)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

const program = Effect.all(
  [
    Effect.failCause(Cause.fail(&quot;Oh no!&quot;)),
    Effect.failCause(Cause.die(&quot;Boom!&quot;))
  ],
  { concurrency: 2 }
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Parallel&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh no!&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: &#39;Boom!&#39; }
  }
}
*/
</code></pre>
<h2>Retrieving the Cause of an Effect</h2>
<p>To retrieve the cause of a failed effect, use <code>Effect.cause</code>. This allows you to inspect or handle the exact reason behind the failure.</p>
<p><strong>Example</strong> (Retrieving and Inspecting a Failure Cause)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const cause = yield* Effect.cause(Effect.fail(&quot;Oh no!&quot;))
  console.log(cause)
})

Effect.runPromise(program)
/*
Output:
{ _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh no!&#39; }
*/
</code></pre>
<h2>Guards</h2>
<p>To determine the specific type of a <code>Cause</code>, use the guards provided in the Cause module:</p>
<ul>
<li><code>Cause.isEmpty</code>: Checks if the cause is empty, indicating no error.</li>
<li><code>Cause.isFailType</code>: Identifies causes that represent an expected failure.</li>
<li><code>Cause.isDie</code>: Identifies causes that represent an unexpected defect.</li>
<li><code>Cause.isInterruptType</code>: Identifies causes related to fiber interruptions.</li>
<li><code>Cause.isSequentialType</code>: Checks if the cause consists of sequential errors.</li>
<li><code>Cause.isParallelType</code>: Checks if the cause contains parallel errors.</li>
</ul>
<p><strong>Example</strong> (Using Guards to Identify Cause Types)</p>
<pre><code class="language-ts">import { Cause } from &quot;effect&quot;

const cause = Cause.fail(new Error(&quot;my message&quot;))

if (Cause.isFailType(cause)) {
  console.log(cause.error.message) // Output: my message
}
</code></pre>
<p>These guards allow you to accurately identify the type of a <code>Cause</code>, making it easier to handle various error cases in your code. Whether dealing with expected failures, unexpected defects, interruptions, or composite errors, these guards provide a clear method for assessing and managing error scenarios.</p>
<h2>Pattern Matching</h2>
<p>The <code>Cause.match</code> function provides a straightforward way to handle each case of a <code>Cause</code>. By defining callbacks for each possible cause type, you can respond to specific error scenarios with custom behavior.</p>
<p><strong>Example</strong> (Pattern Matching on Different Causes)</p>
<pre><code class="language-ts">import { Cause } from &quot;effect&quot;

const cause = Cause.parallel(
  Cause.fail(new Error(&quot;my fail message&quot;)),
  Cause.die(&quot;my die message&quot;)
)

console.log(
  Cause.match(cause, {
    onEmpty: &quot;(empty)&quot;,
    onFail: (error) =&gt; `(error: ${error.message})`,
    onDie: (defect) =&gt; `(defect: ${defect})`,
    onInterrupt: (fiberId) =&gt; `(fiberId: ${fiberId})`,
    onSequential: (left, right) =&gt;
      `(onSequential (left: ${left}) (right: ${right}))`,
    onParallel: (left, right) =&gt;
      `(onParallel (left: ${left}) (right: ${right})`
  })
)
/*
Output:
(onParallel (left: (error: my fail message)) (right: (defect: my die message))
*/
</code></pre>
<h2>Pretty Printing</h2>
<p>Clear and readable error messages are key for effective debugging. The <code>Cause.pretty</code> function helps by formatting error messages in a structured way, making it easier to understand failure details.</p>
<p><strong>Example</strong> (Using <code>Cause.pretty</code> for Readable Error Messages)</p>
<pre><code class="language-ts">import { Cause, FiberId } from &quot;effect&quot;

console.log(Cause.pretty(Cause.empty))
/*
Output:
All fibers interrupted without errors.
*/

console.log(Cause.pretty(Cause.fail(new Error(&quot;my fail message&quot;))))
/*
Output:
Error: my fail message
    ...stack trace...
*/

console.log(Cause.pretty(Cause.die(&quot;my die message&quot;)))
/*
Output:
Error: my die message
*/

console.log(Cause.pretty(Cause.interrupt(FiberId.make(1, 0))))
/*
Output:
All fibers interrupted without errors.
*/

console.log(
  Cause.pretty(Cause.sequential(Cause.fail(&quot;fail1&quot;), Cause.fail(&quot;fail2&quot;)))
)
/*
Output:
Error: fail1
Error: fail2
*/
</code></pre>
<h2>Retrieval of Failures and Defects</h2>
<p>To specifically collect failures or defects from a <code>Cause</code>, you can use <code>Cause.failures</code> and <code>Cause.defects</code>. These functions allow you to inspect only the errors or unexpected defects that occurred.</p>
<p><strong>Example</strong> (Extracting Failures and Defects from a Cause)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const cause = yield* Effect.cause(
    Effect.all([
      Effect.fail(&quot;error 1&quot;),
      Effect.die(&quot;defect&quot;),
      Effect.fail(&quot;error 2&quot;)
    ])
  )
  console.log(Cause.failures(cause))
  console.log(Cause.defects(cause))
})

Effect.runPromise(program)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ &#39;error 1&#39; ] }
{ _id: &#39;Chunk&#39;, values: [] }
*/
</code></pre>
<hr>
<hr>
<h2>title: Chunk
description: Learn about Chunk, a high-performance immutable data structure in Effect, offering efficient operations like concatenation, slicing, and conversions.
sidebar:
  order: 3</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>A <code>Chunk&lt;A&gt;</code> represents an ordered, immutable collection of values of type <code>A</code>. While similar to an array, <code>Chunk</code> provides a functional interface, optimizing certain operations that can be costly with regular arrays, like repeated concatenation.</p>
<Aside type="caution" title="Use Chunk Only for Repeated Concatenation">
  `Chunk` is optimized to manage the performance cost of repeated array
  concatenation. For cases that do not involve repeated concatenation,
  using `Chunk` may introduce unnecessary overhead, resulting in slower
  performance.
</Aside>

<h2>Why Use Chunk?</h2>
<ul>
<li><p><strong>Immutability</strong>: Unlike standard JavaScript arrays, which are mutable, <code>Chunk</code> provides a truly immutable collection, preventing data from being modified after creation. This is especially useful in concurrent programming contexts where immutability can enhance data consistency.</p>
</li>
<li><p><strong>High Performance</strong>: <code>Chunk</code> supports specialized operations for efficient array manipulation, such as appending single elements or concatenating chunks, making these operations faster than their regular JavaScript array equivalents.</p>
</li>
</ul>
<h2>Creating a Chunk</h2>
<h3>empty</h3>
<p>Create an empty <code>Chunk</code> with <code>Chunk.empty</code>.</p>
<p><strong>Example</strong> (Creating an Empty Chunk)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

//      ┌─── Chunk&lt;number&gt;
//      ▼
const chunk = Chunk.empty&lt;number&gt;()
</code></pre>
<h3>make</h3>
<p>To create a <code>Chunk</code> with specific values, use <code>Chunk.make(...values)</code>. Note that the resulting chunk is typed as non-empty.</p>
<p><strong>Example</strong> (Creating a Non-Empty Chunk)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

//      ┌─── NonEmptyChunk&lt;number&gt;
//      ▼
const chunk = Chunk.make(1, 2, 3)
</code></pre>
<h3>fromIterable</h3>
<p>You can create a <code>Chunk</code> by providing a collection, either from an iterable or directly from an array.</p>
<p><strong>Example</strong> (Creating a Chunk from an Iterable)</p>
<pre><code class="language-ts">import { Chunk, List } from &quot;effect&quot;

const fromArray = Chunk.fromIterable([1, 2, 3])

const fromList = Chunk.fromIterable(List.make(1, 2, 3))
</code></pre>
<Aside type="caution" title="Performance Consideration">
  `Chunk.fromIterable` creates a new copy of the iterable's elements. For
  large data sets or repeated use, this cloning process can impact
  performance.
</Aside>

<h3>unsafeFromArray</h3>
<p><code>Chunk.unsafeFromArray</code> creates a <code>Chunk</code> directly from an array without cloning. This approach can improve performance by avoiding the overhead of copying data but requires caution, as it bypasses the usual immutability guarantees.</p>
<p><strong>Example</strong> (Directly Creating a Chunk from an Array)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

const chunk = Chunk.unsafeFromArray([1, 2, 3])
</code></pre>
<Aside type="caution" title="Risk of Mutable Data">
  Using `Chunk.unsafeFromArray` can lead to unexpected behavior if the
  original array is modified after the chunk is created. For safer,
  immutable behavior, use `Chunk.fromIterable` instead.
</Aside>

<h2>Concatenating</h2>
<p>To combine two <code>Chunk</code> instances into one, use <code>Chunk.appendAll</code>.</p>
<p><strong>Example</strong> (Combining Two Chunks into One)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

// Concatenate two chunks with different types of elements
//
//      ┌─── NonEmptyChunk&lt;string | number&gt;
//      ▼
const chunk = Chunk.appendAll(Chunk.make(1, 2), Chunk.make(&quot;a&quot;, &quot;b&quot;))

console.log(chunk)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, &#39;a&#39;, &#39;b&#39; ] }
*/
</code></pre>
<h2>Dropping</h2>
<p>To remove elements from the beginning of a <code>Chunk</code>, use <code>Chunk.drop</code>, specifying the number of elements to discard.</p>
<p><strong>Example</strong> (Dropping Elements from the Start)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

// Drops the first 2 elements from the Chunk
const chunk = Chunk.drop(Chunk.make(1, 2, 3, 4), 2)
</code></pre>
<h2>Comparing</h2>
<p>To check if two <code>Chunk</code> instances are equal, use <a href="/docs/trait/equal/"><code>Equal.equals</code></a>. This function compares the contents of each <code>Chunk</code> for structural equality.</p>
<p><strong>Example</strong> (Comparing Two Chunks)</p>
<pre><code class="language-ts">import { Chunk, Equal } from &quot;effect&quot;

const chunk1 = Chunk.make(1, 2)
const chunk2 = Chunk.make(1, 2, 3)

console.log(Equal.equals(chunk1, chunk1))
// Output: true

console.log(Equal.equals(chunk1, chunk2))
// Output: false

console.log(Equal.equals(chunk1, Chunk.make(1, 2)))
// Output: true
</code></pre>
<h2>Converting</h2>
<p>Convert a <code>Chunk</code> to a <code>ReadonlyArray</code> using <code>Chunk.toReadonlyArray</code>. The resulting type varies based on the <code>Chunk</code>&#39;s contents, distinguishing between empty, non-empty, and generic chunks.</p>
<p><strong>Example</strong> (Converting a Chunk to a ReadonlyArray)</p>
<pre><code class="language-ts">import { Chunk } from &quot;effect&quot;

//      ┌─── readonly [number, ...number[]]
//      ▼
const nonEmptyArray = Chunk.toReadonlyArray(Chunk.make(1, 2, 3))

//      ┌─── readonly never[]
//      ▼
const emptyArray = Chunk.toReadonlyArray(Chunk.empty())

declare const chunk: Chunk.Chunk&lt;number&gt;

//      ┌─── readonly number[]
//      ▼
const array = Chunk.toReadonlyArray(chunk)
</code></pre>
<hr>
<hr>
<h2>title: Data
description: Define immutable data structures, ensure equality, and manage errors seamlessly with Effect&#39;s Data module.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The Data module simplifies creating and handling data structures in TypeScript. It provides tools for <strong>defining data types</strong>, ensuring <strong>equality</strong> between objects, and <strong>hashing</strong> data for efficient comparisons.</p>
<h2>Value Equality</h2>
<p>The Data module provides constructors for creating data types with built-in support for equality and hashing, eliminating the need for custom implementations.</p>
<p>This means that two values created using these constructors are considered equal if they have the same structure and values.</p>
<h3>struct</h3>
<p>In plain JavaScript, objects are considered equal only if they refer to the exact same instance.</p>
<p><strong>Example</strong> (Comparing Two Objects in Plain JavaScript)</p>
<pre><code class="language-ts">const alice = { name: &quot;Alice&quot;, age: 30 }

// This comparison is false because they are different instances
// @ts-expect-error
console.log(alice === { name: &quot;Alice&quot;, age: 30 }) // Output: false
</code></pre>
<p>However, the <code>Data.struct</code> constructor allows you to compare values based on their structure and content.</p>
<p><strong>Example</strong> (Creating and Checking Equality of Structs)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

//      ┌─── { readonly name: string; readonly age: number; }
//      ▼
const alice = Data.struct({ name: &quot;Alice&quot;, age: 30 })

// Check if Alice is equal to a new object
// with the same structure and values
console.log(Equal.equals(alice, Data.struct({ name: &quot;Alice&quot;, age: 30 })))
// Output: true

// Check if Alice is equal to a plain JavaScript object
// with the same content
console.log(Equal.equals(alice, { name: &quot;Alice&quot;, age: 30 }))
// Output: false
</code></pre>
<p>The comparison performed by <code>Equal.equals</code> is <strong>shallow</strong>, meaning nested objects are not compared recursively unless they are also created using <code>Data.struct</code>.</p>
<p><strong>Example</strong> (Shallow Comparison with Nested Objects)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

const nested = Data.struct({ name: &quot;Alice&quot;, nested_field: { value: 42 } })

// This will be false because the nested objects are compared by reference
console.log(
  Equal.equals(
    nested,
    Data.struct({ name: &quot;Alice&quot;, nested_field: { value: 42 } })
  )
)
// Output: false
</code></pre>
<p>To ensure nested objects are compared by structure, use <code>Data.struct</code> for them as well.</p>
<p><strong>Example</strong> (Correctly Comparing Nested Objects)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

const nested = Data.struct({
  name: &quot;Alice&quot;,
  nested_field: Data.struct({ value: 42 })
})

// Now, the comparison returns true
console.log(
  Equal.equals(
    nested,
    Data.struct({
      name: &quot;Alice&quot;,
      nested_field: Data.struct({ value: 42 })
    })
  )
)
// Output: true
</code></pre>
<h3>tuple</h3>
<p>To represent your data using tuples, you can use the <code>Data.tuple</code> constructor. This ensures that your tuples can be compared structurally.</p>
<p><strong>Example</strong> (Creating and Checking Equality of Tuples)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

//      ┌─── readonly [string, number]
//      ▼
const alice = Data.tuple(&quot;Alice&quot;, 30)

// Check if Alice is equal to a new tuple
// with the same structure and values
console.log(Equal.equals(alice, Data.tuple(&quot;Alice&quot;, 30)))
// Output: true

// Check if Alice is equal to a plain JavaScript tuple
// with the same content
console.log(Equal.equals(alice, [&quot;Alice&quot;, 30]))
// Output: false
</code></pre>
<Aside type="caution" title="Shallow Comparison">
  `Equal.equals` only checks the top-level structure. Use `Data`
  constructors for nested objects if you need deep comparisons.
</Aside>

<h3>array</h3>
<p>You can use <code>Data.array</code> to create an array-like data structure that supports structural equality.</p>
<p><strong>Example</strong> (Creating and Checking Equality of Arrays)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

//      ┌─── readonly number[]
//      ▼
const numbers = Data.array([1, 2, 3, 4, 5])

// Check if the array is equal to a new array
// with the same values
console.log(Equal.equals(numbers, Data.array([1, 2, 3, 4, 5])))
// Output: true

// Check if the array is equal to a plain JavaScript array
// with the same content
console.log(Equal.equals(numbers, [1, 2, 3, 4, 5]))
// Output: false
</code></pre>
<Aside type="caution" title="Shallow Comparison">
  `Equal.equals` only checks the top-level structure. Use `Data`
  constructors for nested objects if you need deep comparisons.
</Aside>

<h2>Constructors</h2>
<p>The module introduces a concept known as &quot;Case classes&quot;, which automate various essential operations when defining data types.
These operations include generating <strong>constructors</strong>, handling <strong>equality</strong> checks, and managing <strong>hashing</strong>.</p>
<p>Case classes can be defined in two primary ways:</p>
<ul>
<li>as plain objects using <code>case</code> or <code>tagged</code></li>
<li>as TypeScript classes using <code>Class</code> or <code>TaggedClass</code></li>
</ul>
<h3>case</h3>
<p>The <code>Data.case</code> helper generates constructors and built-in support for equality checks and hashing for your data type.</p>
<p><strong>Example</strong> (Defining a Case Class and Checking Equality)</p>
<p>In this example, <code>Data.case</code> is used to create a constructor for <code>Person</code>. The resulting instances have built-in support for equality checks, allowing you to compare them directly using <code>Equal.equals</code>.</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

interface Person {
  readonly name: string
}

// Create a constructor for `Person`
//
//      ┌─── (args: { readonly name: string; }) =&gt; Person
//      ▼
const make = Data.case&lt;Person&gt;()

const alice = make({ name: &quot;Alice&quot; })

console.log(Equal.equals(alice, make({ name: &quot;Alice&quot; })))
// Output: true

console.log(Equal.equals(alice, make({ name: &quot;John&quot; })))
// Output: false
</code></pre>
<p><strong>Example</strong> (Defining and Comparing Nested Case Classes)</p>
<p>This example demonstrates using <code>Data.case</code> to create nested data structures, such as a <code>Person</code> type containing an <code>Address</code>. Both <code>Person</code> and <code>Address</code> constructors support equality checks.</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

interface Address {
  readonly street: string
  readonly city: string
}

// Create a constructor for `Address`
const Address = Data.case&lt;Address&gt;()

interface Person {
  readonly name: string
  readonly address: Address
}

// Create a constructor for `Person`
const Person = Data.case&lt;Person&gt;()

const alice = Person({
  name: &quot;Alice&quot;,
  address: Address({ street: &quot;123 Main St&quot;, city: &quot;Wonderland&quot; })
})

const anotherAlice = Person({
  name: &quot;Alice&quot;,
  address: Address({ street: &quot;123 Main St&quot;, city: &quot;Wonderland&quot; })
})

console.log(Equal.equals(alice, anotherAlice))
// Output: true
</code></pre>
<p>Alternatively, you can use <code>Data.struct</code> to create nested data structures without defining a separate <code>Address</code> constructor.</p>
<p><strong>Example</strong> (Using <code>Data.struct</code> for Nested Objects)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

interface Person {
  readonly name: string
  readonly address: {
    readonly street: string
    readonly city: string
  }
}

// Create a constructor for `Person`
const Person = Data.case&lt;Person&gt;()

const alice = Person({
  name: &quot;Alice&quot;,
  address: Data.struct({ street: &quot;123 Main St&quot;, city: &quot;Wonderland&quot; })
})

const anotherAlice = Person({
  name: &quot;Alice&quot;,
  address: Data.struct({ street: &quot;123 Main St&quot;, city: &quot;Wonderland&quot; })
})

console.log(Equal.equals(alice, anotherAlice))
// Output: true
</code></pre>
<p><strong>Example</strong> (Defining and Comparing Recursive Case Classes)</p>
<p>This example demonstrates a recursive structure using <code>Data.case</code> to define a binary tree where each node can contain other nodes.</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

interface BinaryTree&lt;T&gt; {
  readonly value: T
  readonly left: BinaryTree&lt;T&gt; | null
  readonly right: BinaryTree&lt;T&gt; | null
}

// Create a constructor for `BinaryTree`
const BinaryTree = Data.case&lt;BinaryTree&lt;number&gt;&gt;()

const tree1 = BinaryTree({
  value: 0,
  left: BinaryTree({ value: 1, left: null, right: null }),
  right: null
})

const tree2 = BinaryTree({
  value: 0,
  left: BinaryTree({ value: 1, left: null, right: null }),
  right: null
})

console.log(Equal.equals(tree1, tree2))
// Output: true
</code></pre>
<h3>tagged</h3>
<p>When you&#39;re working with a data type that includes a tag field, like in disjoint union types, defining the tag manually for each instance can get repetitive. Using the <code>case</code> approach requires you to specify the tag field every time, which can be cumbersome.</p>
<p><strong>Example</strong> (Defining a Tagged Case Class Manually)</p>
<p>Here, we create a <code>Person</code> type with a <code>_tag</code> field using <code>Data.case</code>. Notice that the <code>_tag</code> needs to be specified for every new instance.</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

interface Person {
  readonly _tag: &quot;Person&quot; // the tag
  readonly name: string
}

const Person = Data.case&lt;Person&gt;()

// Repeating `_tag: &#39;Person&#39;` for each instance
const alice = Person({ _tag: &quot;Person&quot;, name: &quot;Alice&quot; })
const bob = Person({ _tag: &quot;Person&quot;, name: &quot;Bob&quot; })
</code></pre>
<p>To streamline this process, the <code>Data.tagged</code> helper automatically adds the tag. It follows the convention in the Effect ecosystem of naming the tag field as <code>&quot;_tag&quot;</code>.</p>
<p><strong>Example</strong> (Using Data.tagged to Simplify Tagging)</p>
<p>The <code>Data.tagged</code> helper allows you to define the tag just once, making instance creation simpler.</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

interface Person {
  readonly _tag: &quot;Person&quot; // the tag
  readonly name: string
}

const Person = Data.tagged&lt;Person&gt;(&quot;Person&quot;)

// The `_tag` field is automatically added
const alice = Person({ name: &quot;Alice&quot; })
const bob = Person({ name: &quot;Bob&quot; })

console.log(alice)
// Output: { name: &#39;Alice&#39;, _tag: &#39;Person&#39; }
</code></pre>
<h3>Class</h3>
<p>If you prefer working with classes instead of plain objects, you can use <code>Data.Class</code> as an alternative to <code>Data.case</code>. This approach may feel more natural in scenarios where you want a class-oriented structure, complete with methods and custom logic.</p>
<p><strong>Example</strong> (Using Data.Class for a Class-Oriented Structure)</p>
<p>Here&#39;s how to define a <code>Person</code> class using <code>Data.Class</code>:</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

// Define a Person class extending Data.Class
class Person extends Data.Class&lt;{ name: string }&gt; {}

// Create an instance of Person
const alice = new Person({ name: &quot;Alice&quot; })

// Check for equality between two instances
console.log(Equal.equals(alice, new Person({ name: &quot;Alice&quot; })))
// Output: true
</code></pre>
<p>One of the benefits of using classes is that you can easily add custom methods and getters. This allows you to extend the functionality of your data types.</p>
<p><strong>Example</strong> (Adding Custom Getters to a Class)</p>
<p>In this example, we add a <code>upperName</code> getter to the <code>Person</code> class to return the name in uppercase:</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

// Extend Person class with a custom getter
class Person extends Data.Class&lt;{ name: string }&gt; {
  get upperName() {
    return this.name.toUpperCase()
  }
}

// Create an instance and use the custom getter
const alice = new Person({ name: &quot;Alice&quot; })

console.log(alice.upperName)
// Output: ALICE
</code></pre>
<h3>TaggedClass</h3>
<p>If you prefer a class-based approach but also want the benefits of tagging for disjoint unions, <code>Data.TaggedClass</code> can be a helpful option. It works similarly to <code>tagged</code> but is tailored for class definitions.</p>
<p><strong>Example</strong> (Defining a Tagged Class with Built-In Tagging)</p>
<p>Here&#39;s how to define a <code>Person</code> class using <code>Data.TaggedClass</code>. Notice that the tag <code>&quot;Person&quot;</code> is automatically added:</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

// Define a tagged class Person with the _tag &quot;Person&quot;
class Person extends Data.TaggedClass(&quot;Person&quot;)&lt;{ name: string }&gt; {}

// Create an instance of Person
const alice = new Person({ name: &quot;Alice&quot; })

console.log(alice)
// Output: Person { name: &#39;Alice&#39;, _tag: &#39;Person&#39; }

// Check equality between two instances
console.log(Equal.equals(alice, new Person({ name: &quot;Alice&quot; })))
// Output: true
</code></pre>
<p>One benefit of using tagged classes is the ability to easily add custom methods and getters, extending the class&#39;s functionality as needed.</p>
<p><strong>Example</strong> (Adding Custom Getters to a Tagged Class)</p>
<p>In this example, we add a <code>upperName</code> getter to the <code>Person</code> class, which returns the name in uppercase:</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

// Extend the Person class with a custom getter
class Person extends Data.TaggedClass(&quot;Person&quot;)&lt;{ name: string }&gt; {
  get upperName() {
    return this.name.toUpperCase()
  }
}

// Create an instance and use the custom getter
const alice = new Person({ name: &quot;Alice&quot; })

console.log(alice.upperName)
// Output: ALICE
</code></pre>
<h2>Union of Tagged Structs</h2>
<p>To create a disjoint union of tagged structs, you can use <code>Data.TaggedEnum</code> and <code>Data.taggedEnum</code>. These utilities make it straightforward to define and work with unions of plain objects.</p>
<h3>Definition</h3>
<p>The type passed to <code>Data.TaggedEnum</code> must be an object where the keys represent the tags,
and the values define the structure of the corresponding data types.</p>
<p><strong>Example</strong> (Defining a Tagged Union and Checking Equality)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

// Define a union type using TaggedEnum
type RemoteData = Data.TaggedEnum&lt;{
  Loading: {}
  Success: { readonly data: string }
  Failure: { readonly reason: string }
}&gt;

// Create constructors for each case in the union
const { Loading, Success, Failure } = Data.taggedEnum&lt;RemoteData&gt;()

// Instantiate different states
const state1 = Loading()
const state2 = Success({ data: &quot;test&quot; })
const state3 = Success({ data: &quot;test&quot; })
const state4 = Failure({ reason: &quot;not found&quot; })

// Check equality between states
console.log(Equal.equals(state2, state3)) // Output: true
console.log(Equal.equals(state2, state4)) // Output: false

// Display the states
console.log(state1) // Output: { _tag: &#39;Loading&#39; }
console.log(state2) // Output: { data: &#39;test&#39;, _tag: &#39;Success&#39; }
console.log(state4) // Output: { reason: &#39;not found&#39;, _tag: &#39;Failure&#39; }
</code></pre>
<Aside type="note" title="Tag Field Naming Convention">
  The tag field `"_tag"` is used to identify the type of each state,
  following Effect's naming convention.
</Aside>

<h3>$is and $match</h3>
<p>The <code>Data.taggedEnum</code> provides <code>$is</code> and <code>$match</code> functions for convenient type guarding and pattern matching.</p>
<p><strong>Example</strong> (Using Type Guards and Pattern Matching)</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

type RemoteData = Data.TaggedEnum&lt;{
  Loading: {}
  Success: { readonly data: string }
  Failure: { readonly reason: string }
}&gt;

const { $is, $match, Loading, Success } = Data.taggedEnum&lt;RemoteData&gt;()

// Use `$is` to create a type guard for &quot;Loading&quot;
const isLoading = $is(&quot;Loading&quot;)

console.log(isLoading(Loading()))
// Output: true
console.log(isLoading(Success({ data: &quot;test&quot; })))
// Output: false

// Use `$match` for pattern matching
const matcher = $match({
  Loading: () =&gt; &quot;this is a Loading&quot;,
  Success: ({ data }) =&gt; `this is a Success: ${data}`,
  Failure: ({ reason }) =&gt; `this is a Failre: ${reason}`
})

console.log(matcher(Success({ data: &quot;test&quot; })))
// Output: &quot;this is a Success: test&quot;
</code></pre>
<h3>Adding Generics</h3>
<p>You can create more flexible and reusable tagged unions by using <code>TaggedEnum.WithGenerics</code>. This approach allows you to define tagged unions that can handle different types dynamically.</p>
<p><strong>Example</strong> (Using Generics with TaggedEnum)</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

// Define a generic TaggedEnum for RemoteData
type RemoteData&lt;Success, Failure&gt; = Data.TaggedEnum&lt;{
  Loading: {}
  Success: { data: Success }
  Failure: { reason: Failure }
}&gt;

// Extend TaggedEnum.WithGenerics to add generics
interface RemoteDataDefinition extends Data.TaggedEnum.WithGenerics&lt;2&gt; {
  readonly taggedEnum: RemoteData&lt;this[&quot;A&quot;], this[&quot;B&quot;]&gt;
}

// Create constructors for the generic RemoteData
const { Loading, Failure, Success } =
  Data.taggedEnum&lt;RemoteDataDefinition&gt;()

// Instantiate each case with specific types
const loading = Loading()
const failure = Failure({ reason: &quot;not found&quot; })
const success = Success({ data: 1 })
</code></pre>
<h2>Errors</h2>
<p>In Effect, handling errors is simplified using specialized constructors:</p>
<ul>
<li><code>Error</code></li>
<li><code>TaggedError</code></li>
</ul>
<p>These constructors make defining custom error types straightforward, while also providing useful integrations like equality checks and structured error handling.</p>
<h3>Error</h3>
<p><code>Data.Error</code> lets you create an <code>Error</code> type with extra fields beyond the typical <code>message</code> property.</p>
<p><strong>Example</strong> (Creating a Custom Error with Additional Fields)</p>
<pre><code class="language-ts">import { Data } from &quot;effect&quot;

// Define a custom error with additional fields
class NotFound extends Data.Error&lt;{ message: string; file: string }&gt; {}

// Create an instance of the custom error
const err = new NotFound({
  message: &quot;Cannot find this file&quot;,
  file: &quot;foo.txt&quot;
})

console.log(err instanceof Error)
// Output: true

console.log(err.file)
// Output: foo.txt
console.log(err)
/*
Output:
NotFound [Error]: Cannot find this file
  file: &#39;foo.txt&#39;
  ... stack trace ...
*/
</code></pre>
<p>You can yield an instance of <code>NotFound</code> directly in an <a href="/docs/getting-started/using-generators/">Effect.gen</a>, without needing to use <code>Effect.fail</code>.</p>
<p><strong>Example</strong> (Yielding a Custom Error in <code>Effect.gen</code>)</p>
<pre><code class="language-ts">import { Data, Effect } from &quot;effect&quot;

class NotFound extends Data.Error&lt;{ message: string; file: string }&gt; {}

const program = Effect.gen(function* () {
  yield* new NotFound({
    message: &quot;Cannot find this file&quot;,
    file: &quot;foo.txt&quot;
  })
})

Effect.runPromise(program)
/*
throws:
Error: Cannot find this file
    at ... {
  name: &#39;(FiberFailure) Error&#39;,
  [Symbol(effect/Runtime/FiberFailure/Cause)]: {
    _tag: &#39;Fail&#39;,
    error: NotFound [Error]: Cannot find this file
        at ...stack trace...
      file: &#39;foo.txt&#39;
    }
  }
}
*/
</code></pre>
<h3>TaggedError</h3>
<p>Effect provides a <code>TaggedError</code> API to add a <code>_tag</code> field automatically to your custom errors. This simplifies error handling with APIs like <a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a> or <a href="/docs/error-management/expected-errors/#catchtags">Effect.catchTags</a>.</p>
<pre><code class="language-ts">import { Data, Effect, Console } from &quot;effect&quot;

// Define a custom tagged error
class NotFound extends Data.TaggedError(&quot;NotFound&quot;)&lt;{
  message: string
  file: string
}&gt; {}

const program = Effect.gen(function* () {
  yield* new NotFound({
    message: &quot;Cannot find this file&quot;,
    file: &quot;foo.txt&quot;
  })
}).pipe(
  // Catch and handle the tagged error
  Effect.catchTag(&quot;NotFound&quot;, (err) =&gt;
    Console.error(`${err.message} (${err.file})`)
  )
)

Effect.runPromise(program)
// Output: Cannot find this file (foo.txt)
</code></pre>
<h3>Native Cause Support</h3>
<p>Errors created using <code>Data.Error</code> or <code>Data.TaggedError</code> can include a <code>cause</code> property, integrating with the native <code>cause</code> feature of JavaScript&#39;s <code>Error</code> for more detailed error tracing.</p>
<p><strong>Example</strong> (Using the <code>cause</code> Property)</p>
<pre><code class="language-ts">import { Data, Effect } from &quot;effect&quot;

// Define an error with a cause property
class MyError extends Data.Error&lt;{ cause: Error }&gt; {}

const program = Effect.gen(function* () {
  yield* new MyError({
    cause: new Error(&quot;Something went wrong&quot;)
  })
})

Effect.runPromise(program)
/*
throws:
Error: An error has occurred
    at ... {
  name: &#39;(FiberFailure) Error&#39;,
  [Symbol(effect/Runtime/FiberFailure/Cause)]: {
    _tag: &#39;Fail&#39;,
    error: MyError
        at ...
      [cause]: Error: Something went wrong
          at ...
*/
</code></pre>
<hr>
<hr>
<h2>title: DateTime
description: Work with precise points in time using Effect&#39;s DateTime, supporting creation, comparison, and arithmetic operations for efficient time handling.
sidebar:
  order: 5</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Working with dates and times in JavaScript can be challenging. The built-in <code>Date</code> object mutates its internal state, and time zone handling can be confusing. These design choices can lead to errors when working on applications that rely on date-time accuracy, such as scheduling systems, timestamping services, or logging utilities.</p>
<p>The DateTime module aims to address these limitations by offering:</p>
<ul>
<li><strong>Immutable Data</strong>: Each <code>DateTime</code> is an immutable structure, reducing mistakes related to in-place mutations.</li>
<li><strong>Time Zone Support</strong>: <code>DateTime</code> provides robust support for time zones, including automatic daylight saving time adjustments.</li>
<li><strong>Arithmetic Operations</strong>: You can perform arithmetic operations on <code>DateTime</code> instances, such as adding or subtracting durations.</li>
</ul>
<h2>The DateTime Type</h2>
<p>A <code>DateTime</code> represents a moment in time. It can be stored as either a simple UTC value or as a value with an associated time zone. Storing time this way helps you manage both precise timestamps and the context for how that time should be displayed or interpreted.</p>
<p>There are two main variants of <code>DateTime</code>:</p>
<ol>
<li><p><strong>Utc</strong>: An immutable structure that uses <code>epochMillis</code> (milliseconds since the Unix epoch) to represent a point in time in Coordinated Universal Time (UTC).</p>
</li>
<li><p><strong>Zoned</strong>: Includes <code>epochMillis</code> along with a <code>TimeZone</code>, allowing you to attach an offset or a named region (like &quot;America/New_York&quot;) to the timestamp.</p>
</li>
</ol>
<h3>Why Have Two Variants?</h3>
<ul>
<li><strong>Utc</strong> is straightforward if you only need a universal reference without relying on local time zones.</li>
<li><strong>Zoned</strong> is helpful when you need to keep track of time zone information for tasks such as converting to local times or adjusting for daylight saving time.</li>
</ul>
<h3>TimeZone Variants</h3>
<p>A <code>TimeZone</code> can be either:</p>
<ul>
<li><strong>Offset</strong>: Represents a fixed offset from UTC (for example, UTC+2 or UTC-5).</li>
<li><strong>Named</strong>: Uses a named region (e.g., &quot;Europe/London&quot; or &quot;America/New_York&quot;) that automatically accounts for region-specific rules like daylight saving time changes.</li>
</ul>
<h3>TypeScript Definition</h3>
<p>Below is the TypeScript definition for the <code>DateTime</code> type:</p>
<pre><code class="language-ts">type DateTime = Utc | Zoned

interface Utc {
  readonly _tag: &quot;Utc&quot;
  readonly epochMillis: number
}

interface Zoned {
  readonly _tag: &quot;Zoned&quot;
  readonly epochMillis: number
  readonly zone: TimeZone
}

type TimeZone = TimeZone.Offset | TimeZone.Named

declare namespace TimeZone {
  interface Offset {
    readonly _tag: &quot;Offset&quot;
    readonly offset: number
  }

  interface Named {
    readonly _tag: &quot;Named&quot;
    readonly id: string
  }
}
</code></pre>
<h2>The DateTime.Parts Type</h2>
<p>The <code>DateTime.Parts</code> type defines the main components of a date, such as the year, month, day, hours, minutes, and seconds.</p>
<pre><code class="language-ts">namespace DateTime {
  interface Parts {
    readonly millis: number
    readonly seconds: number
    readonly minutes: number
    readonly hours: number
    readonly day: number
    readonly month: number
    readonly year: number
  }

  interface PartsWithWeekday extends Parts {
    readonly weekDay: number
  }
}
</code></pre>
<h2>The DateTime.Input Type</h2>
<p>The <code>DateTime.Input</code> type is a flexible input type that can be used to create a <code>DateTime</code> instance. It can be one of the following:</p>
<ul>
<li>A <code>DateTime</code> instance</li>
<li>A JavaScript <code>Date</code> object</li>
<li>A numeric value representing milliseconds since the Unix epoch</li>
<li>An object with partial date <a href="#the-datetimeparts-type">parts</a> (e.g., <code>{ year: 2024, month: 1, day: 1 }</code>)</li>
<li>A string that can be parsed by JavaScript&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse">Date.parse</a></li>
</ul>
<pre><code class="language-ts">namespace DateTime {
  type Input = DateTime | Partial&lt;Parts&gt; | Date | number | string
}
</code></pre>
<h2>Utc Constructors</h2>
<p><code>Utc</code> is an immutable structure that uses <code>epochMillis</code> (milliseconds since the Unix epoch) to represent a point in time in Coordinated Universal Time (UTC).</p>
<h3>unsafeFromDate</h3>
<p>Creates a <code>Utc</code> from a JavaScript <code>Date</code>.
Throws an <code>IllegalArgumentException</code> if the provided <code>Date</code> is invalid.</p>
<p>When a <code>Date</code> object is passed, it is converted to a <code>Utc</code> instance. The time is interpreted as the local time of the system executing the code and then adjusted to UTC. This ensures a consistent, timezone-independent representation of the date and time.</p>
<p><strong>Example</strong> (Converting Local Time to UTC in Italy)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// Create a Utc instance from a local JavaScript Date
//
//     ┌─── Utc
//     ▼
const utc = DateTime.unsafeFromDate(new Date(&quot;2025-01-01 04:00:00&quot;))

console.log(utc)
// Output: DateTime.Utc(2025-01-01T03:00:00.000Z)

console.log(utc.epochMillis)
// Output: 1735700400000
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li>The local time <strong>2025-01-01 04:00:00</strong> (in Italy, CET) is converted to <strong>UTC</strong> by subtracting the timezone offset (UTC+1 in January).</li>
<li>As a result, the UTC time becomes <strong>2025-01-01 03:00:00.000Z</strong>.</li>
<li><code>epochMillis</code> provides the same time as milliseconds since the Unix Epoch, ensuring a precise numeric representation of the UTC timestamp.</li>
</ul>
<h3>unsafeMake</h3>
<p>Creates a <code>Utc</code> from a <a href="#the-datetimeinput-type">DateTime.Input</a>.</p>
<p><strong>Example</strong> (Creating a DateTime with unsafeMake)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// From a JavaScript Date
const utc1 = DateTime.unsafeMake(new Date(&quot;2025-01-01 04:00:00&quot;))
console.log(utc1)
// Output: DateTime.Utc(2025-01-01T03:00:00.000Z)

// From partial date parts
const utc2 = DateTime.unsafeMake({ year: 2025 })
console.log(utc2)
// Output: DateTime.Utc(2025-01-01T00:00:00.000Z)

// From a string
const utc3 = DateTime.unsafeMake(&quot;2025-01-01&quot;)
console.log(utc3)
// Output: DateTime.Utc(2025-01-01T00:00:00.000Z)
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li>The local time <strong>2025-01-01 04:00:00</strong> (in Italy, CET) is converted to <strong>UTC</strong> by subtracting the timezone offset (UTC+1 in January).</li>
<li>As a result, the UTC time becomes <strong>2025-01-01 03:00:00.000Z</strong>.</li>
</ul>
<h3>make</h3>
<p>Similar to <a href="#unsafemake">unsafeMake</a>, but returns an <a href="/docs/data-types/option/">Option</a> instead of throwing an error if the input is invalid.
If the input is invalid, it returns <code>None</code>. If valid, it returns <code>Some</code> containing the <code>Utc</code>.</p>
<p><strong>Example</strong> (Creating a DateTime Safely)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// From a JavaScript Date
const maybeUtc1 = DateTime.make(new Date(&quot;2025-01-01 04:00:00&quot;))
console.log(maybeUtc1)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;2025-01-01T03:00:00.000Z&#39; }
*/

// From partial date parts
const maybeUtc2 = DateTime.make({ year: 2025 })
console.log(maybeUtc2)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;2025-01-01T00:00:00.000Z&#39; }
*/

// From a string
const maybeUtc3 = DateTime.make(&quot;2025-01-01&quot;)
console.log(maybeUtc3)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;2025-01-01T00:00:00.000Z&#39; }
*/
</code></pre>
<p><strong>Explanation</strong>:</p>
<ul>
<li>The local time <strong>2025-01-01 04:00:00</strong> (in Italy, CET) is converted to <strong>UTC</strong> by subtracting the timezone offset (UTC+1 in January).</li>
<li>As a result, the UTC time becomes <strong>2025-01-01 03:00:00.000Z</strong>.</li>
</ul>
<h2>Zoned Constructors</h2>
<p>A <code>Zoned</code> includes <code>epochMillis</code> along with a <code>TimeZone</code>, allowing you to attach an offset or a named region (like &quot;America/New_York&quot;) to the timestamp.</p>
<h3>unsafeMakeZoned</h3>
<p>Creates a <code>Zoned</code> by combining a <a href="#the-datetimeinput-type">DateTime.Input</a> with an optional <code>TimeZone</code>.
This allows you to represent a specific point in time with an associated time zone.</p>
<p>The time zone can be provided in several ways:</p>
<ul>
<li>As a <code>TimeZone</code> object</li>
<li>A string identifier (e.g., <code>&quot;Europe/London&quot;</code>)</li>
<li>A numeric offset in milliseconds</li>
</ul>
<p>If the input or time zone is invalid, an <code>IllegalArgumentException</code> is thrown.</p>
<p><strong>Example</strong> (Creating a Zoned DateTime Without Specifying a Time Zone)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// Create a Zoned DateTime based on the system&#39;s local time zone
const zoned = DateTime.unsafeMakeZoned(new Date(&quot;2025-01-01 04:00:00&quot;))

console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T04:00:00.000+01:00)

console.log(zoned.zone)
// Output: TimeZone.Offset(+01:00)
</code></pre>
<p>Here, the system&#39;s time zone (CET, which is UTC+1 in January) is used to create the <code>Zoned</code> instance.</p>
<p><strong>Example</strong> (Specifying a Named Time Zone)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// Create a Zoned DateTime with a specified named time zone
const zoned = DateTime.unsafeMakeZoned(new Date(&quot;2025-01-01 04:00:00&quot;), {
  timeZone: &quot;Europe/Rome&quot;
})

console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T04:00:00.000+01:00[Europe/Rome])

console.log(zoned.zone)
// Output: TimeZone.Named(Europe/Rome)
</code></pre>
<p>In this case, the <code>&quot;Europe/Rome&quot;</code> time zone is explicitly provided, resulting in the <code>Zoned</code> instance being tied to this named time zone.</p>
<p>By default, the input date is treated as a UTC value and then adjusted for the specified time zone. To interpret the input date as being in the specified time zone, you can use the <code>adjustForTimeZone</code> option.</p>
<p><strong>Example</strong> (Adjusting for Time Zone Interpretation)</p>
<p>The following example assumes the code is executed on a system in Italy (CET timezone):</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// Interpret the input date as being in the specified time zone
const zoned = DateTime.unsafeMakeZoned(new Date(&quot;2025-01-01 04:00:00&quot;), {
  timeZone: &quot;Europe/Rome&quot;,
  adjustForTimeZone: true
})

console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T03:00:00.000+01:00[Europe/Rome])

console.log(zoned.zone)
// Output: TimeZone.Named(Europe/Rome)
</code></pre>
<p><strong>Explanation</strong></p>
<ul>
<li><strong>Without <code>adjustForTimeZone</code></strong>: The input date is interpreted as UTC and then adjusted to the specified time zone. For instance, <code>2025-01-01 04:00:00</code> in UTC becomes <code>2025-01-01T04:00:00.000+01:00</code> in CET (UTC+1).</li>
<li><strong>With <code>adjustForTimeZone: true</code></strong>: The input date is interpreted as being in the specified time zone. For example, <code>2025-01-01 04:00:00</code> in &quot;Europe/Rome&quot; (CET) is adjusted to its corresponding UTC time, resulting in <code>2025-01-01T03:00:00.000+01:00</code>.</li>
</ul>
<h3>makeZoned</h3>
<p>The <code>makeZoned</code> function works similarly to <a href="#unsafemakezoned">unsafeMakeZoned</a> but provides a safer approach. Instead of throwing an error when the input is invalid, it returns an <code>Option&lt;Zoned&gt;</code>.
If the input is invalid, it returns <code>None</code>. If valid, it returns <code>Some</code> containing the <code>Zoned</code>.</p>
<p><strong>Example</strong> (Safely Creating a Zoned DateTime)</p>
<pre><code class="language-ts">import { DateTime, Option } from &quot;effect&quot;

//      ┌─── Option&lt;Zoned&gt;
//      ▼
const zoned = DateTime.makeZoned(new Date(&quot;2025-01-01 04:00:00&quot;), {
  timeZone: &quot;Europe/Rome&quot;
})

if (Option.isSome(zoned)) {
  console.log(&quot;The DateTime is valid&quot;)
}
</code></pre>
<h3>makeZonedFromString</h3>
<p>Creates a <code>Zoned</code> by parsing a string in the format <code>YYYY-MM-DDTHH:mm:ss.sss+HH:MM[IANA timezone identifier]</code>.</p>
<p>If the input string is valid, the function returns a <code>Some</code> containing the <code>Zoned</code>. If the input is invalid, it returns <code>None</code>.</p>
<p><strong>Example</strong> (Parsing a Zoned DateTime from a String)</p>
<pre><code class="language-ts">import { DateTime, Option } from &quot;effect&quot;

//      ┌─── Option&lt;Zoned&gt;
//      ▼
const zoned = DateTime.makeZonedFromString(
  &quot;2025-01-01T03:00:00.000+01:00[Europe/Rome]&quot;
)

if (Option.isSome(zoned)) {
  console.log(&quot;The DateTime is valid&quot;)
}
</code></pre>
<h2>Current Time</h2>
<h3>now</h3>
<p>Provides the current UTC time as a <code>Effect&lt;Utc&gt;</code>, using the <a href="/docs/requirements-management/default-services/">Clock</a> service.</p>
<p><strong>Example</strong> (Retrieving the Current UTC Time)</p>
<pre><code class="language-ts">import { DateTime, Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  //      ┌─── Utc
  //      ▼
  const currentTime = yield* DateTime.now
})
</code></pre>
<Aside type="tip" title="Why Use the Clock Service?">
  Using the `Clock` service ensures that time is consistent across your
  application, which is particularly useful in testing environments where
  you may need to control or mock the current time.
</Aside>

<h3>unsafeNow</h3>
<p>Retrieves the current UTC time immediately using <code>Date.now()</code>, without the <a href="/docs/requirements-management/default-services/">Clock</a> service.</p>
<p><strong>Example</strong> (Getting the Current UTC Time Immediately)</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

//      ┌─── Utc
//      ▼
const currentTime = DateTime.unsafeNow()
</code></pre>
<h2>Guards</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>isDateTime</code></td>
<td>Checks if a value is a <code>DateTime</code>.</td>
</tr>
<tr>
<td><code>isTimeZone</code></td>
<td>Checks if a value is a <code>TimeZone</code>.</td>
</tr>
<tr>
<td><code>isTimeZoneOffset</code></td>
<td>Checks if a value is a <code>TimeZone.Offset</code>.</td>
</tr>
<tr>
<td><code>isTimeZoneNamed</code></td>
<td>Checks if a value is a <code>TimeZone.Named</code>.</td>
</tr>
<tr>
<td><code>isUtc</code></td>
<td>Checks if a <code>DateTime</code> is the <code>Utc</code> variant.</td>
</tr>
<tr>
<td><code>isZoned</code></td>
<td>Checks if a <code>DateTime</code> is the <code>Zoned</code> variant.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Validating a DateTime)</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

function printDateTimeInfo(x: unknown) {
  if (DateTime.isDateTime(x)) {
    console.log(&quot;This is a valid DateTime&quot;)
  } else {
    console.log(&quot;Not a DateTime&quot;)
  }
}
</code></pre>
<h2>Time Zone Management</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>setZone</code></td>
<td>Creates a <code>Zoned</code> from <code>DateTime</code> by applying the given <code>TimeZone</code>.</td>
</tr>
<tr>
<td><code>setZoneOffset</code></td>
<td>Creates a <code>Zoned</code> from <code>DateTime</code> using a fixed offset (in ms).</td>
</tr>
<tr>
<td><code>setZoneNamed</code></td>
<td>Creates a <code>Zoned</code> from <code>DateTime</code> from an IANA time zone identifier or returns <code>None</code> if invalid.</td>
</tr>
<tr>
<td><code>unsafeSetZoneNamed</code></td>
<td>Creates a <code>Zoned</code> from <code>DateTime</code> from an IANA time zone identifier or throws if invalid.</td>
</tr>
<tr>
<td><code>zoneUnsafeMakeNamed</code></td>
<td>Creates a <code>TimeZone.Named</code> from a IANA time zone identifier or throws if the identifier is invalid.</td>
</tr>
<tr>
<td><code>zoneMakeNamed</code></td>
<td>Creates a <code>TimeZone.Named</code> from a IANA time zone identifier or returns <code>None</code> if invalid.</td>
</tr>
<tr>
<td><code>zoneMakeNamedEffect</code></td>
<td>Creates a <code>Effect&lt;TimeZone.Named, IllegalArgumentException&gt;</code> from a IANA time zone identifier failing with <code>IllegalArgumentException</code> if invalid</td>
</tr>
<tr>
<td><code>zoneMakeOffset</code></td>
<td>Creates a <code>TimeZone.Offset</code> from a numeric offset in milliseconds.</td>
</tr>
<tr>
<td><code>zoneMakeLocal</code></td>
<td>Creates a <code>TimeZone.Named</code> from the system&#39;s local time zone.</td>
</tr>
<tr>
<td><code>zoneFromString</code></td>
<td>Attempts to parse a time zone from a string, returning <code>None</code> if invalid.</td>
</tr>
<tr>
<td><code>zoneToString</code></td>
<td>Returns a string representation of a <code>TimeZone</code>.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Applying a Time Zone to a DateTime)</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

// Create a UTC DateTime
//
//     ┌─── Utc
//     ▼
const utc = DateTime.unsafeMake(&quot;2024-01-01&quot;)

// Create a named time zone for New York
//
//      ┌─── TimeZone.Named
//      ▼
const zoneNY = DateTime.zoneUnsafeMakeNamed(&quot;America/New_York&quot;)

// Apply it to the DateTime
//
//      ┌─── Zoned
//      ▼
const zoned = DateTime.setZone(utc, zoneNY)

console.log(zoned)
// Output: DateTime.Zoned(2023-12-31T19:00:00.000-05:00[America/New_York])
</code></pre>
<h3>zoneFromString</h3>
<p>Parses a string to create a <code>DateTime.TimeZone</code>.</p>
<p>This function attempts to interpret the input string as either:</p>
<ul>
<li>A numeric time zone offset (e.g., &quot;GMT&quot;, &quot;+01:00&quot;)</li>
<li>An IANA time zone identifier (e.g., &quot;Europe/London&quot;)</li>
</ul>
<p>If the string matches an offset format, it is converted into a <code>TimeZone.Offset</code>.
Otherwise, it attempts to create a <code>TimeZone.Named</code> using the input.</p>
<p>If the input string is invalid, <code>Option.none()</code> is returned.</p>
<p><strong>Example</strong> (Parsing a Time Zone from a String)</p>
<pre><code class="language-ts">import { DateTime, Option } from &quot;effect&quot;

// Attempt to parse a numeric offset
const offsetZone = DateTime.zoneFromString(&quot;+01:00&quot;)
console.log(Option.isSome(offsetZone))
// Output: true

// Attempt to parse an IANA time zone
const namedZone = DateTime.zoneFromString(&quot;Europe/London&quot;)
console.log(Option.isSome(namedZone))
// Output: true

// Invalid input
const invalidZone = DateTime.zoneFromString(&quot;Invalid/Zone&quot;)
console.log(Option.isSome(invalidZone))
// Output: false
</code></pre>
<h2>Comparisons</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>distance</code></td>
<td>Returns the difference (in ms) between two <code>DateTime</code>s.</td>
</tr>
<tr>
<td><code>distanceDurationEither</code></td>
<td>Returns a <code>Left</code> or <code>Right</code> <code>Duration</code> depending on order.</td>
</tr>
<tr>
<td><code>distanceDuration</code></td>
<td>Returns a <code>Duration</code> indicating how far apart two times are.</td>
</tr>
<tr>
<td><code>min</code></td>
<td>Returns the earlier of two <code>DateTime</code> values.</td>
</tr>
<tr>
<td><code>max</code></td>
<td>Returns the later of two <code>DateTime</code> values.</td>
</tr>
<tr>
<td><code>greaterThan</code>, <code>greaterThanOrEqualTo</code>, etc.</td>
<td>Checks ordering between two <code>DateTime</code> values.</td>
</tr>
<tr>
<td><code>between</code></td>
<td>Checks if a <code>DateTime</code> lies within the given bounds.</td>
</tr>
<tr>
<td><code>isFuture</code>, <code>isPast</code>, <code>unsafeIsFuture</code>, etc.</td>
<td>Checks if a <code>DateTime</code> is in the future or past.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Finding the Distance Between Two DateTimes)</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

const utc1 = DateTime.unsafeMake(&quot;2025-01-01T00:00:00Z&quot;)
const utc2 = DateTime.add(utc1, { days: 1 })

console.log(DateTime.distance(utc1, utc2))
// Output: 86400000 (one day)

console.log(DateTime.distanceDurationEither(utc1, utc2))
/*
Output:
{
  _id: &#39;Either&#39;,
  _tag: &#39;Right&#39;,
  right: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 86400000 }
}
*/

console.log(DateTime.distanceDuration(utc1, utc2))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 86400000 }
</code></pre>
<h2>Conversions</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>toDateUtc</code></td>
<td>Returns a JavaScript <code>Date</code> in UTC.</td>
</tr>
<tr>
<td><code>toDate</code></td>
<td>Applies the time zone (if present) and converts to a JavaScript <code>Date</code>.</td>
</tr>
<tr>
<td><code>zonedOffset</code></td>
<td>For a <code>Zoned</code> DateTime, returns the time zone offset in ms.</td>
</tr>
<tr>
<td><code>zonedOffsetIso</code></td>
<td>For a <code>Zoned</code> DateTime, returns an ISO offset string like &quot;+01:00&quot;.</td>
</tr>
<tr>
<td><code>toEpochMillis</code></td>
<td>Returns the Unix epoch time in milliseconds.</td>
</tr>
<tr>
<td><code>removeTime</code></td>
<td>Returns a <code>Utc</code> with the time cleared (only date remains).</td>
</tr>
</tbody></table>
<h2>Parts</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>toParts</code></td>
<td>Returns time zone adjusted date parts (including weekday).</td>
</tr>
<tr>
<td><code>toPartsUtc</code></td>
<td>Returns UTC date parts (including weekday).</td>
</tr>
<tr>
<td><code>getPart</code> / <code>getPartUtc</code></td>
<td>Retrieves a specific part (e.g., <code>&quot;year&quot;</code> or <code>&quot;month&quot;</code>) from the date.</td>
</tr>
<tr>
<td><code>setParts</code> / <code>setPartsUtc</code></td>
<td>Updates certain parts of a date, preserving or ignoring the time zone.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Extracting Parts from a DateTime)</p>
<pre><code class="language-ts">import { DateTime } from &quot;effect&quot;

const zoned = DateTime.setZone(
  DateTime.unsafeMake(&quot;2024-01-01&quot;),
  DateTime.zoneUnsafeMakeNamed(&quot;Europe/Rome&quot;)
)

console.log(DateTime.getPart(zoned, &quot;month&quot;))
// Output: 1
</code></pre>
<h2>Math</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>addDuration</code></td>
<td>Adds the given <code>Duration</code> to a <code>DateTime</code>.</td>
</tr>
<tr>
<td><code>subtractDuration</code></td>
<td>Subtracts the given <code>Duration</code> from a <code>DateTime</code>.</td>
</tr>
<tr>
<td><code>add</code></td>
<td>Adds numeric parts (e.g., <code>{ hours: 2 }</code>) to a <code>DateTime</code>.</td>
</tr>
<tr>
<td><code>subtract</code></td>
<td>Subtracts numeric parts.</td>
</tr>
<tr>
<td><code>startOf</code></td>
<td>Moves a <code>DateTime</code> to the start of the given unit (e.g., the beginning of a day or month).</td>
</tr>
<tr>
<td><code>endOf</code></td>
<td>Moves a <code>DateTime</code> to the end of the given unit.</td>
</tr>
<tr>
<td><code>nearest</code></td>
<td>Rounds a <code>DateTime</code> to the nearest specified unit.</td>
</tr>
</tbody></table>
<h2>Formatting</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>format</code></td>
<td>Formats a <code>DateTime</code> as a string using the <code>DateTimeFormat</code> API.</td>
</tr>
<tr>
<td><code>formatLocal</code></td>
<td>Uses the system&#39;s local time zone and locale for formatting.</td>
</tr>
<tr>
<td><code>formatUtc</code></td>
<td>Forces UTC formatting.</td>
</tr>
<tr>
<td><code>formatIntl</code></td>
<td>Uses a provided <code>Intl.DateTimeFormat</code>.</td>
</tr>
<tr>
<td><code>formatIso</code></td>
<td>Returns an ISO 8601 string in UTC.</td>
</tr>
<tr>
<td><code>formatIsoDate</code></td>
<td>Returns an ISO date string, adjusted for the time zone.</td>
</tr>
<tr>
<td><code>formatIsoDateUtc</code></td>
<td>Returns an ISO date string in UTC.</td>
</tr>
<tr>
<td><code>formatIsoOffset</code></td>
<td>Formats a <code>Zoned</code> as a string with an offset like &quot;+01:00&quot;.</td>
</tr>
<tr>
<td><code>formatIsoZoned</code></td>
<td>Formats a <code>Zoned</code> in the form <code>YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Zone]</code>.</td>
</tr>
</tbody></table>
<h2>Layers for Current Time Zone</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>CurrentTimeZone</code></td>
<td>A service tag for the current time zone.</td>
</tr>
<tr>
<td><code>setZoneCurrent</code></td>
<td>Sets a <code>DateTime</code> to use the current time zone.</td>
</tr>
<tr>
<td><code>withCurrentZone</code></td>
<td>Provides an effect with a specified time zone.</td>
</tr>
<tr>
<td><code>withCurrentZoneLocal</code></td>
<td>Uses the system&#39;s local time zone for the effect.</td>
</tr>
<tr>
<td><code>withCurrentZoneOffset</code></td>
<td>Uses a fixed offset (in ms) for the effect.</td>
</tr>
<tr>
<td><code>withCurrentZoneNamed</code></td>
<td>Uses a named time zone identifier (e.g., &quot;Europe/London&quot;).</td>
</tr>
<tr>
<td><code>nowInCurrentZone</code></td>
<td>Retrieves the current time as a <code>Zoned</code> in the configured time zone.</td>
</tr>
<tr>
<td><code>layerCurrentZone</code></td>
<td>Creates a Layer providing the <code>CurrentTimeZone</code> service.</td>
</tr>
<tr>
<td><code>layerCurrentZoneOffset</code></td>
<td>Creates a Layer from a fixed offset.</td>
</tr>
<tr>
<td><code>layerCurrentZoneNamed</code></td>
<td>Creates a Layer from a named time zone, failing if invalid.</td>
</tr>
<tr>
<td><code>layerCurrentZoneLocal</code></td>
<td>Creates a Layer from the system&#39;s local time zone.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using the Current Time Zone in an Effect)</p>
<pre><code class="language-ts">import { DateTime, Effect } from &quot;effect&quot;

// Retrieve the current time in the &quot;Europe/London&quot; time zone
const program = Effect.gen(function* () {
  const zonedNow = yield* DateTime.nowInCurrentZone
  console.log(zonedNow)
}).pipe(DateTime.withCurrentZoneNamed(&quot;Europe/London&quot;))

Effect.runFork(program)
/*
Example Output:
DateTime.Zoned(2025-01-06T18:36:38.573+00:00[Europe/London])
*/
</code></pre>
<hr>
<hr>
<h2>title: Duration
description: Work with precise time spans using Effect&#39;s Duration, supporting creation, comparison, and arithmetic operations for efficient time handling.
sidebar:
  order: 6</h2>
<p>The <code>Duration</code> data type data type is used to represent specific non-negative spans of time. It is commonly used to represent time intervals or durations in various operations, such as timeouts, delays, or scheduling. The <code>Duration</code> type provides a convenient way to work with time units and perform calculations on durations.</p>
<h2>Creating Durations</h2>
<p>The Duration module includes several constructors to create durations in different units.</p>
<p><strong>Example</strong> (Creating Durations in Various Units)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

// Create a duration of 100 milliseconds
const duration1 = Duration.millis(100)

// Create a duration of 2 seconds
const duration2 = Duration.seconds(2)

// Create a duration of 5 minutes
const duration3 = Duration.minutes(5)
</code></pre>
<p>You can create durations using units such as nanoseconds, microsecond, milliseconds, seconds, minutes, hours, days, and weeks.</p>
<p>For an infinite duration, use <code>Duration.infinity</code>.</p>
<p><strong>Example</strong> (Creating an Infinite Duration)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

console.log(String(Duration.infinity))
/*
Output:
Duration(Infinity)
*/
</code></pre>
<p>Another option for creating durations is using the <code>Duration.decode</code> helper:</p>
<ul>
<li><code>number</code> values are treated as milliseconds.</li>
<li><code>bigint</code> values are treated as nanoseconds.</li>
<li>Strings must follow the format <code>&quot;${number} ${unit}&quot;</code>.</li>
</ul>
<p><strong>Example</strong> (Decoding Values into Durations)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

Duration.decode(10n) // same as Duration.nanos(10)
Duration.decode(100) // same as Duration.millis(100)
Duration.decode(Infinity) // same as Duration.infinity

Duration.decode(&quot;10 nanos&quot;) // same as Duration.nanos(10)
Duration.decode(&quot;20 micros&quot;) // same as Duration.micros(20)
Duration.decode(&quot;100 millis&quot;) // same as Duration.millis(100)
Duration.decode(&quot;2 seconds&quot;) // same as Duration.seconds(2)
Duration.decode(&quot;5 minutes&quot;) // same as Duration.minutes(5)
Duration.decode(&quot;7 hours&quot;) // same as Duration.hours(7)
Duration.decode(&quot;3 weeks&quot;) // same as Duration.weeks(3)
</code></pre>
<h2>Getting the Duration Value</h2>
<p>You can retrieve the value of a duration in milliseconds using <code>Duration.toMillis</code>.</p>
<p><strong>Example</strong> (Getting Duration in Milliseconds)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

console.log(Duration.toMillis(Duration.seconds(30)))
// Output: 30000
</code></pre>
<p>To get the value of a duration in nanoseconds, use <code>Duration.toNanos</code>. Note that <code>toNanos</code> returns an <code>Option&lt;bigint&gt;</code> because the duration might be infinite.</p>
<p><strong>Example</strong> (Getting Duration in Nanoseconds)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

console.log(Duration.toNanos(Duration.millis(100)))
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 100000000n }
*/
</code></pre>
<p>To get a <code>bigint</code> value without <code>Option</code>, use <code>Duration.unsafeToNanos</code>. However, it will throw an error for infinite durations.</p>
<p><strong>Example</strong> (Retrieving Nanoseconds Unsafely)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

console.log(Duration.unsafeToNanos(Duration.millis(100)))
// Output: 100000000n

console.log(Duration.unsafeToNanos(Duration.infinity))
/*
throws:
Error: Cannot convert infinite duration to nanos
  ...stack trace...
*/
</code></pre>
<h2>Comparing Durations</h2>
<p>Use the following functions to compare two durations:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>lessThan</code></td>
<td>Returns <code>true</code> if the first duration is less than the second.</td>
</tr>
<tr>
<td><code>lessThanOrEqualTo</code></td>
<td>Returns <code>true</code> if the first duration is less than or equal to the second.</td>
</tr>
<tr>
<td><code>greaterThan</code></td>
<td>Returns <code>true</code> if the first duration is greater than the second.</td>
</tr>
<tr>
<td><code>greaterThanOrEqualTo</code></td>
<td>Returns <code>true</code> if the first duration is greater than or equal to the second.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Comparing Two Durations)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

const duration1 = Duration.seconds(30)
const duration2 = Duration.minutes(1)

console.log(Duration.lessThan(duration1, duration2))
// Output: true

console.log(Duration.lessThanOrEqualTo(duration1, duration2))
// Output: true

console.log(Duration.greaterThan(duration1, duration2))
// Output: false

console.log(Duration.greaterThanOrEqualTo(duration1, duration2))
// Output: false
</code></pre>
<h2>Performing Arithmetic Operations</h2>
<p>You can perform arithmetic operations on durations, like addition and multiplication.</p>
<p><strong>Example</strong> (Adding and Multiplying Durations)</p>
<pre><code class="language-ts">import { Duration } from &quot;effect&quot;

const duration1 = Duration.seconds(30)
const duration2 = Duration.minutes(1)

// Add two durations
console.log(String(Duration.sum(duration1, duration2)))
/*
Output:
Duration(1m 30s)
*/

// Multiply a duration by a factor
console.log(String(Duration.times(duration1, 2)))
/*
Output:
Duration(1m)
*/
</code></pre>
<hr>
<hr>
<h2>title: Either
description: Represent exclusive values as Left or Right with the Either data type, enabling precise control flow in computations.
sidebar:
  order: 7</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>Either</code> data type represents two exclusive values: an <code>Either&lt;R, L&gt;</code> can be a <code>Right</code> value or a <code>Left</code> value, where <code>R</code> is the type of the <code>Right</code> value, and <code>L</code> is the type of the <code>Left</code> value.</p>
<h2>Understanding Either and Exit</h2>
<p>Either is primarily used as a <strong>simple discriminated union</strong> and is not recommended as the main result type for operations requiring detailed error information.</p>
<p><a href="/docs/data-types/exit/">Exit</a> is the preferred <strong>result type</strong> within Effect for capturing comprehensive details about failures.
It encapsulates the outcomes of effectful computations, distinguishing between success and various failure modes, such as errors, defects and interruptions.</p>
<h2>Creating Eithers</h2>
<p>You can create an <code>Either</code> using the <code>Either.right</code> and <code>Either.left</code> constructors.</p>
<p>Use <code>Either.right</code> to create a <code>Right</code> value of type <code>R</code>.</p>
<p><strong>Example</strong> (Creating a Right Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const rightValue = Either.right(42)

console.log(rightValue)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 42 }
*/
</code></pre>
<p>Use <code>Either.left</code> to create a <code>Left</code> value of type <code>L</code>.</p>
<p><strong>Example</strong> (Creating a Left Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const leftValue = Either.left(&quot;not a number&quot;)

console.log(leftValue)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;not a number&#39; }
*/
</code></pre>
<h2>Guards</h2>
<p>Use <code>Either.isLeft</code> and <code>Either.isRight</code> to check whether an <code>Either</code> is a <code>Left</code> or <code>Right</code> value.</p>
<p><strong>Example</strong> (Using Guards to Check the Type of Either)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const foo = Either.right(42)

if (Either.isLeft(foo)) {
  console.log(`The left value is: ${foo.left}`)
} else {
  console.log(`The Right value is: ${foo.right}`)
}
// Output: &quot;The Right value is: 42&quot;
</code></pre>
<h2>Pattern Matching</h2>
<p>Use <code>Either.match</code> to handle both cases of an <code>Either</code> by specifying separate callbacks for <code>Left</code> and <code>Right</code>.</p>
<p><strong>Example</strong> (Pattern Matching with Either)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const foo = Either.right(42)

const message = Either.match(foo, {
  onLeft: (left) =&gt; `The left value is: ${left}`,
  onRight: (right) =&gt; `The Right value is: ${right}`
})

console.log(message)
// Output: &quot;The Right value is: 42&quot;
</code></pre>
<h2>Mapping</h2>
<h3>Mapping over the Right Value</h3>
<p>Use <code>Either.map</code> to transform the <code>Right</code> value of an <code>Either</code>. The function you provide will only apply to the <code>Right</code> value, leaving any <code>Left</code> value unchanged.</p>
<p><strong>Example</strong> (Transforming the Right Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

// Transform the Right value by adding 1
const rightResult = Either.map(Either.right(1), (n) =&gt; n + 1)
console.log(rightResult)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 2 }
*/

// The transformation is ignored for Left values
const leftResult = Either.map(Either.left(&quot;not a number&quot;), (n) =&gt; n + 1)
console.log(leftResult)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;not a number&#39; }
*/
</code></pre>
<h3>Mapping over the Left Value</h3>
<p>Use <code>Either.mapLeft</code> to transform the <code>Left</code> value of an <code>Either</code>. The provided function only applies to the <code>Left</code> value, leaving any <code>Right</code> value unchanged.</p>
<p><strong>Example</strong> (Transforming the Left Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

// The transformation is ignored for Right values
const rightResult = Either.mapLeft(Either.right(1), (s) =&gt; s + &quot;!&quot;)
console.log(rightResult)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 1 }
*/

// Transform the Left value by appending &quot;!&quot;
const leftResult = Either.mapLeft(
  Either.left(&quot;not a number&quot;),
  (s) =&gt; s + &quot;!&quot;
)
console.log(leftResult)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;not a number!&#39; }
*/
</code></pre>
<h3>Mapping over Both Values</h3>
<p>Use <code>Either.mapBoth</code> to transform both the <code>Left</code> and <code>Right</code> values of an <code>Either</code>. This function takes two separate transformation functions: one for the <code>Left</code> value and another for the <code>Right</code> value.</p>
<p><strong>Example</strong> (Transforming Both Left and Right Values)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const transformedRight = Either.mapBoth(Either.right(1), {
  onLeft: (s) =&gt; s + &quot;!&quot;,
  onRight: (n) =&gt; n + 1
})
console.log(transformedRight)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 2 }
*/

const transformedLeft = Either.mapBoth(Either.left(&quot;not a number&quot;), {
  onLeft: (s) =&gt; s + &quot;!&quot;,
  onRight: (n) =&gt; n + 1
})
console.log(transformedLeft)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;not a number!&#39; }
*/
</code></pre>
<h2>Interop with Effect</h2>
<p>The <code>Either</code> type works as a subtype of the <code>Effect</code> type, allowing you to use it with functions from the <code>Effect</code> module. While these functions are built to handle <code>Effect</code> values, they can also manage <code>Either</code> values correctly.</p>
<h3>How Either Maps to Effect</h3>
<table>
<thead>
<tr>
<th>Either Variant</th>
<th>Mapped to Effect</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Left&lt;L&gt;</code></td>
<td><code>Effect&lt;never, L&gt;</code></td>
<td>Represents a failure</td>
</tr>
<tr>
<td><code>Right&lt;R&gt;</code></td>
<td><code>Effect&lt;R&gt;</code></td>
<td>Represents a success</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Combining <code>Either</code> with <code>Effect</code>)</p>
<pre><code class="language-ts">import { Effect, Either } from &quot;effect&quot;

// Function to get the head of an array, returning Either
const head = &lt;A&gt;(array: ReadonlyArray&lt;A&gt;): Either.Either&lt;A, string&gt; =&gt;
  array.length &gt; 0 ? Either.right(array[0]) : Either.left(&quot;empty array&quot;)

// Simulated fetch function that returns Effect
const fetchData = (): Effect.Effect&lt;string, string&gt; =&gt; {
  const success = Math.random() &gt; 0.5
  return success
    ? Effect.succeed(&quot;some data&quot;)
    : Effect.fail(&quot;Failed to fetch data&quot;)
}

// Mixing Either and Effect
const program = Effect.all([head([1, 2, 3]), fetchData()])

Effect.runPromise(program).then(console.log)
/*
Example Output:
[ 1, &#39;some data&#39; ]
*/
</code></pre>
<h2>Combining Two or More Eithers</h2>
<h3>zipWith</h3>
<p>The <code>Either.zipWith</code> function lets you combine two <code>Either</code> values using a provided function. It creates a new <code>Either</code> that holds the combined value of both original <code>Either</code> values.</p>
<p><strong>Example</strong> (Combining Two Eithers into an Object)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; = Either.right(&quot;John&quot;)
const maybeAge: Either.Either&lt;number, string&gt; = Either.right(25)

// Combine the name and age into a person object
const person = Either.zipWith(maybeName, maybeAge, (name, age) =&gt; ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: { name: &#39;JOHN&#39;, age: 25 } }
*/
</code></pre>
<p>If either of the <code>Either</code> values is <code>Left</code>, the result will be <code>Left</code>, holding the first encountered <code>Left</code> value:</p>
<p><strong>Example</strong> (Combining Eithers with a Left Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; = Either.right(&quot;John&quot;)
const maybeAge: Either.Either&lt;number, string&gt; = Either.left(&quot;Oh no!&quot;)

// Since maybeAge is a Left, the result will also be Left
const person = Either.zipWith(maybeName, maybeAge, (name, age) =&gt; ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;Oh no!&#39; }
*/
</code></pre>
<h3>all</h3>
<p>To combine multiple <code>Either</code> values without transforming their contents, you can use <code>Either.all</code>. This function returns an <code>Either</code> with a structure matching the input:</p>
<ul>
<li>If you pass a tuple, the result will be a tuple of the same length.</li>
<li>If you pass a struct, the result will be a struct with the same keys.</li>
<li>If you pass an <code>Iterable</code>, the result will be an array.</li>
</ul>
<p><strong>Example</strong> (Combining Multiple Eithers into a Tuple and Struct)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; = Either.right(&quot;John&quot;)
const maybeAge: Either.Either&lt;number, string&gt; = Either.right(25)

//      ┌─── Either&lt;[string, number], string&gt;
//      ▼
const tuple = Either.all([maybeName, maybeAge])
console.log(tuple)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: [ &#39;John&#39;, 25 ] }
*/

//      ┌─── Either&lt;{ name: string; age: number; }, string&gt;
//      ▼
const struct = Either.all({ name: maybeName, age: maybeAge })
console.log(struct)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: { name: &#39;John&#39;, age: 25 } }
*/
</code></pre>
<p>If one or more <code>Either</code> values are <code>Left</code>, the first <code>Left</code> encountered is returned:</p>
<p><strong>Example</strong> (Handling Multiple Left Values)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; =
  Either.left(&quot;name not found&quot;)
const maybeAge: Either.Either&lt;number, string&gt; =
  Either.left(&quot;age not found&quot;)

// The first Left value will be returned
console.log(Either.all([maybeName, maybeAge]))
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;name not found&#39; }
*/
</code></pre>
<h2>gen</h2>
<p>Similar to <a href="/docs/getting-started/using-generators/">Effect.gen</a>, <code>Either.gen</code> provides a more readable, generator-based syntax for working with <code>Either</code> values, making code that involves <code>Either</code> easier to write and understand. This approach is similar to using <code>async/await</code> but tailored for <code>Either</code>.</p>
<p><strong>Example</strong> (Using <code>Either.gen</code> to Create a Combined Value)</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; = Either.right(&quot;John&quot;)
const maybeAge: Either.Either&lt;number, string&gt; = Either.right(25)

const program = Either.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(program)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: { name: &#39;JOHN&#39;, age: 25 } }
*/
</code></pre>
<p>When any of the <code>Either</code> values in the sequence is <code>Left</code>, the generator immediately returns the <code>Left</code> value, skipping further operations:</p>
<p><strong>Example</strong> (Handling a <code>Left</code> Value with <code>Either.gen</code>)</p>
<p>In this example, <code>Either.gen</code> halts execution as soon as it encounters the <code>Left</code> value, effectively propagating the error without performing further operations.</p>
<pre><code class="language-ts">import { Either } from &quot;effect&quot;

const maybeName: Either.Either&lt;string, string&gt; = Either.left(&quot;Oh no!&quot;)
const maybeAge: Either.Either&lt;number, string&gt; = Either.right(25)

const program = Either.gen(function* () {
  console.log(&quot;Retrieving name...&quot;)
  const name = (yield* maybeName).toUpperCase()
  console.log(&quot;Retrieving age...&quot;)
  const age = yield* maybeAge
  return { name, age }
})

console.log(program)
/*
Output:
Retrieving name...
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;Oh no!&#39; }
*/
</code></pre>
<p>The use of <code>console.log</code> in these example is for demonstration purposes only. When using <code>Either.gen</code>, avoid including side effects in your generator functions, as <code>Either</code> should remain a pure data structure.</p>
<hr>
<hr>
<h2>title: Exit
description: Represent the result of an Effect workflow with Exit, capturing success values or failure causes.
sidebar:
  order: 8</h2>
<p>An <code>Exit&lt;A, E&gt;</code> describes the result of running an <code>Effect</code> workflow.</p>
<p>There are two possible states for an <code>Exit&lt;A, E&gt;</code>:</p>
<ul>
<li><code>Exit.Success</code>: Contains a success value of type <code>A</code>.</li>
<li><code>Exit.Failure</code>: Contains a failure <a href="/docs/data-types/cause/">Cause</a> of type <code>E</code>.</li>
</ul>
<h2>Creating Exits</h2>
<p>The Exit module provides two primary functions for constructing exit values: <code>Exit.succeed</code> and <code>Exit.fail</code>. These functions represent the outcomes of an effectful computation in terms of success or failure.</p>
<h3>succeed</h3>
<p><code>Exit.succeed</code> creates an <code>Exit</code> value that represents a successful outcome. You use this function when you want to indicate that a computation completed successfully and to provide the resulting value.</p>
<p><strong>Example</strong> (Creating a Successful Exit)</p>
<pre><code class="language-ts">import { Exit } from &quot;effect&quot;

// Create an Exit representing a successful outcome with the value 42
const successExit = Exit.succeed(42)

console.log(successExit)
// Output: { _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: 42 }
</code></pre>
<h3>fail</h3>
<p><code>Exit.fail</code> creates an <code>Exit</code> value that represents a failure. The failure is described using a <a href="/docs/data-types/cause/">Cause</a> object, which can encapsulate expected errors, defects, interruptions, or even composite errors.</p>
<p><strong>Example</strong> (Creating a Failed Exit)</p>
<pre><code class="language-ts">import { Exit, Cause } from &quot;effect&quot;

// Create an Exit representing a failure with an error message
const failureExit = Exit.fail(Cause.fail(&quot;Something went wrong&quot;))

console.log(failureExit)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Something went wrong&#39; }
}
*/
</code></pre>
<h2>Pattern Matching</h2>
<p>You can handle different outcomes of an <code>Exit</code> using the <code>Exit.match</code> function.
This function lets you provide two separate callbacks to handle both success and failure cases of an <code>Effect</code> execution.</p>
<p><strong>Example</strong> (Matching Success and Failure States)</p>
<pre><code class="language-ts">import { Effect, Exit, Cause } from &quot;effect&quot;

const simulatedSuccess = Effect.runSyncExit(Effect.succeed(1))

console.log(
  Exit.match(simulatedSuccess, {
    onFailure: (cause) =&gt;
      `Exited with failure state: ${Cause.pretty(cause)}`,
    onSuccess: (value) =&gt; `Exited with success value: ${value}`
  })
)
// Output: &quot;Exited with success value: 1&quot;

const simulatedFailure = Effect.runSyncExit(Effect.fail(&quot;error&quot;))

console.log(
  Exit.match(simulatedFailure, {
    onFailure: (cause) =&gt;
      `Exited with failure state: ${Cause.pretty(cause)}`,
    onSuccess: (value) =&gt; `Exited with success value: ${value}`
  })
)
// Output: &quot;Exited with failure state: Error: error&quot;
</code></pre>
<h2>Exit vs Either</h2>
<p>Conceptually, <code>Exit&lt;A, E&gt;</code> can be thought of as <code>Either&lt;A, Cause&lt;E&gt;&gt;</code>. However, the <a href="/docs/data-types/cause/">Cause</a> type represents more than just expected errors of type <code>E</code>. It includes:</p>
<ul>
<li>Interruption causes</li>
<li>Defects (unexpected errors)</li>
<li>The combination of multiple causes</li>
</ul>
<p>This allows <code>Cause</code> to capture richer and more complex error states compared to a simple <code>Either</code>.</p>
<h2>Exit vs Effect</h2>
<p><code>Exit</code> is actually a subtype of <code>Effect</code>. This means that <code>Exit</code> values can also be considered as <code>Effect</code> values.</p>
<ul>
<li>An <code>Exit</code>, in essence, is a &quot;constant computation&quot;.</li>
<li><code>Effect.succeed</code> is essentially the same as <code>Exit.succeed</code>.</li>
<li><code>Effect.fail</code> is the same as <code>Exit.fail</code>.</li>
</ul>
<hr>
<hr>
<h2>title: Option
description: Represent optional values with Option, supporting presence (Some) or absence (None) and seamless operations like mapping, combining, and pattern matching.
sidebar:
  order: 9</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>Option</code> data type represents optional values. An <code>Option&lt;A&gt;</code> can either be <code>Some&lt;A&gt;</code>, containing a value of type <code>A</code>, or <code>None</code>, representing the absence of a value.</p>
<p>You can use <code>Option</code> in scenarios like:</p>
<ul>
<li>Using it for initial values</li>
<li>Returning values from functions that are not defined for all possible inputs (referred to as &quot;partial functions&quot;)</li>
<li>Managing optional fields in data structures</li>
<li>Handling optional function arguments</li>
</ul>
<h2>Creating Options</h2>
<h3>some</h3>
<p>Use the <code>Option.some</code> constructor to create an <code>Option</code> that holds a value of type <code>A</code>.</p>
<p><strong>Example</strong> (Creating an Option with a Value)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// An Option holding the number 1
const value = Option.some(1)

console.log(value)
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }
</code></pre>
<h3>none</h3>
<p>Use the <code>Option.none</code> constructor to create an <code>Option</code> representing the absence of a value.</p>
<p><strong>Example</strong> (Creating an Option with No Value)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// An Option holding no value
const noValue = Option.none()

console.log(noValue)
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<h3>liftPredicate</h3>
<p>You can create an <code>Option</code> based on a predicate, for example, to check if a value is positive.</p>
<p><strong>Example</strong> (Using Explicit Option Creation)</p>
<p>Here&#39;s how you can achieve this using <code>Option.none</code> and <code>Option.some</code>:</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const isPositive = (n: number) =&gt; n &gt; 0

const parsePositive = (n: number): Option.Option&lt;number&gt; =&gt;
  isPositive(n) ? Option.some(n) : Option.none()
</code></pre>
<p><strong>Example</strong> (Using <code>Option.liftPredicate</code> for Conciseness)</p>
<p>Alternatively, you can simplify the above logic with <code>Option.liftPredicate</code>:</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const isPositive = (n: number) =&gt; n &gt; 0

//      ┌─── (b: number) =&gt; Option&lt;number&gt;
//      ▼
const parsePositive = Option.liftPredicate(isPositive)
</code></pre>
<h2>Modeling Optional Properties</h2>
<p>Consider a <code>User</code> model where the <code>&quot;email&quot;</code> property is optional and can hold a <code>string</code> value. We use the <code>Option&lt;string&gt;</code> type to represent this optional property:</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option&lt;string&gt;
}
</code></pre>
<Aside type="note" title="Property Key Always Present">
  Optionality only applies to the value of the property. The key `"email"`
  will always be present in the object, regardless of whether it has a
  value or not.
</Aside>

<p>Here are examples of how to create <code>User</code> instances with and without an email:</p>
<p><strong>Example</strong> (Creating Users with and without Email)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option&lt;string&gt;
}

const withEmail: User = {
  id: 1,
  username: &quot;john_doe&quot;,
  email: Option.some(&quot;john.doe@example.com&quot;)
}

const withoutEmail: User = {
  id: 2,
  username: &quot;jane_doe&quot;,
  email: Option.none()
}
</code></pre>
<h2>Guards</h2>
<p>You can check whether an <code>Option</code> is a <code>Some</code> or a <code>None</code> using the <code>Option.isSome</code> and <code>Option.isNone</code> guards.</p>
<p><strong>Example</strong> (Using Guards to Check Option Values)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const foo = Option.some(1)

console.log(Option.isSome(foo))
// Output: true

if (Option.isNone(foo)) {
  console.log(&quot;Option is empty&quot;)
} else {
  console.log(`Option has a value: ${foo.value}`)
}
// Output: &quot;Option has a value: 1&quot;
</code></pre>
<h2>Pattern Matching</h2>
<p>Use <code>Option.match</code> to handle both cases of an <code>Option</code> by specifying separate callbacks for <code>None</code> and <code>Some</code>.</p>
<p><strong>Example</strong> (Pattern Matching with Option)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const foo = Option.some(1)

const message = Option.match(foo, {
  onNone: () =&gt; &quot;Option is empty&quot;,
  onSome: (value) =&gt; `Option has a value: ${value}`
})

console.log(message)
// Output: &quot;Option has a value: 1&quot;
</code></pre>
<h2>Working with Option</h2>
<h3>map</h3>
<p>The <code>Option.map</code> function lets you transform the value inside an <code>Option</code> without manually unwrapping and re-wrapping it. If the <code>Option</code> holds a value (<code>Some</code>), the transformation function is applied. If the <code>Option</code> is <code>None</code>, the function is ignored, and the <code>Option</code> remains unchanged.</p>
<p><strong>Example</strong> (Mapping a Value in Some)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// Transform the value inside Some
console.log(Option.map(Option.some(1), (n) =&gt; n + 1))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 }
</code></pre>
<p>When dealing with <code>None</code>, the mapping function is not executed, and the <code>Option</code> remains <code>None</code>:</p>
<p><strong>Example</strong> (Mapping over None)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// Mapping over None results in None
console.log(Option.map(Option.none(), (n) =&gt; n + 1))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<h3>flatMap</h3>
<p>The <code>Option.flatMap</code> function is similar to <code>Option.map</code>, but it is designed to handle cases where the transformation might return another <code>Option</code>. This allows us to chain computations that depend on whether or not a value is present in an <code>Option</code>.</p>
<p>Consider a <code>User</code> model that includes a nested optional <code>Address</code>, which itself contains an optional <code>street</code> property:</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option&lt;string&gt;
  readonly address: Option.Option&lt;Address&gt;
}

interface Address {
  readonly city: string
  readonly street: Option.Option&lt;string&gt;
}
</code></pre>
<p>In this model, the <code>address</code> field is an <code>Option&lt;Address&gt;</code>, and the <code>street</code> field within <code>Address</code> is an <code>Option&lt;string&gt;</code>.</p>
<p>We can use <code>Option.flatMap</code> to extract the <code>street</code> property from <code>address</code>:</p>
<p><strong>Example</strong> (Extracting a Nested Optional Property)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

interface Address {
  readonly city: string
  readonly street: Option.Option&lt;string&gt;
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option&lt;string&gt;
  readonly address: Option.Option&lt;Address&gt;
}

const user: User = {
  id: 1,
  username: &quot;john_doe&quot;,
  email: Option.some(&quot;john.doe@example.com&quot;),
  address: Option.some({
    city: &quot;New York&quot;,
    street: Option.some(&quot;123 Main St&quot;)
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(
  Option.flatMap((address) =&gt; address.street)
)

console.log(street)
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;123 Main St&#39; }
</code></pre>
<p>If <code>user.address</code> is <code>Some</code>, <code>Option.flatMap</code> applies the function <code>(address) =&gt; address.street</code> to retrieve the <code>street</code> value.</p>
<p>If <code>user.address</code> is <code>None</code>, the function is not executed, and <code>street</code> remains <code>None</code>.</p>
<p>This approach lets us handle nested optional values concisely, avoiding manual checks and making the code cleaner and easier to read.</p>
<h3>filter</h3>
<p>The <code>Option.filter</code> function allows you to filter an <code>Option</code> based on a given predicate. If the predicate is not met or if the <code>Option</code> is <code>None</code>, the result will be <code>None</code>.</p>
<p><strong>Example</strong> (Filtering an Option Value)</p>
<p>Here&#39;s how you can simplify some code using <code>Option.filter</code> for a more idiomatic approach:</p>
<p>Original Code</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// Function to remove empty strings from an Option
const removeEmptyString = (input: Option.Option&lt;string&gt;) =&gt; {
  if (Option.isSome(input) &amp;&amp; input.value === &quot;&quot;) {
    return Option.none() // Return None if the value is an empty string
  }
  return input // Otherwise, return the original Option
}

console.log(removeEmptyString(Option.none()))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(removeEmptyString(Option.some(&quot;&quot;)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(removeEmptyString(Option.some(&quot;a&quot;)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;a&#39; }
</code></pre>
<p>Refactored Idiomatic Code</p>
<p>Using <code>Option.filter</code>, we can write the same logic more concisely:</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const removeEmptyString = (input: Option.Option&lt;string&gt;) =&gt;
  Option.filter(input, (value) =&gt; value !== &quot;&quot;)

console.log(removeEmptyString(Option.none()))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(removeEmptyString(Option.some(&quot;&quot;)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(removeEmptyString(Option.some(&quot;a&quot;)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;a&#39; }
</code></pre>
<h2>Getting the Value from an Option</h2>
<p>To retrieve the value stored inside an <code>Option</code>, you can use several helper functions provided by the <code>Option</code> module. Here&#39;s an overview of the available methods:</p>
<h3>getOrThrow</h3>
<p>This function extracts the value from a <code>Some</code>. If the <code>Option</code> is <code>None</code>, it throws an error.</p>
<p><strong>Example</strong> (Retrieving Value or Throwing an Error)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

console.log(Option.getOrThrow(Option.some(10)))
// Output: 10

console.log(Option.getOrThrow(Option.none()))
// throws: Error: getOrThrow called on a None
</code></pre>
<h3>getOrNull / getOrUndefined</h3>
<p>These functions convert a <code>None</code> to either <code>null</code> or <code>undefined</code>, which is useful when working with non-<code>Option</code>-based code.</p>
<p><strong>Example</strong> (Converting <code>None</code> to <code>null</code> or <code>undefined</code>)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

console.log(Option.getOrNull(Option.some(5)))
// Output: 5

console.log(Option.getOrNull(Option.none()))
// Output: null

console.log(Option.getOrUndefined(Option.some(5)))
// Output: 5

console.log(Option.getOrUndefined(Option.none()))
// Output: undefined
</code></pre>
<h3>getOrElse</h3>
<p>This function allows you to specify a default value to return when the <code>Option</code> is <code>None</code>.</p>
<p><strong>Example</strong> (Providing a Default Value When <code>None</code>)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

console.log(Option.getOrElse(Option.some(5), () =&gt; 0))
// Output: 5

console.log(Option.getOrElse(Option.none(), () =&gt; 0))
// Output: 0
</code></pre>
<h2>Fallback</h2>
<h3>orElse</h3>
<p>When a computation returns <code>None</code>, you might want to try an alternative computation that yields an <code>Option</code>. The <code>Option.orElse</code> function is helpful in such cases. It lets you chain multiple computations, moving on to the next if the current one results in <code>None</code>. This approach is often used in retry logic, attempting computations until one succeeds or all possibilities are exhausted.</p>
<p><strong>Example</strong> (Attempting Alternative Computations)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

// Simulating a computation that may or may not produce a result
const computation = (): Option.Option&lt;number&gt; =&gt;
  Math.random() &lt; 0.5 ? Option.some(10) : Option.none()

// Simulates an alternative computation
const alternativeComputation = (): Option.Option&lt;number&gt; =&gt;
  Math.random() &lt; 0.5 ? Option.some(20) : Option.none()

// Attempt the first computation, then try an alternative if needed
const program = computation().pipe(
  Option.orElse(() =&gt; alternativeComputation())
)

const result = Option.match(program, {
  onNone: () =&gt; &quot;Both computations resulted in None&quot;,
  // At least one computation succeeded
  onSome: (value) =&gt; `Computed value: ${value}`
})

console.log(result)
// Output: Computed value: 10
</code></pre>
<h3>firstSomeOf</h3>
<p>You can also use <code>Option.firstSomeOf</code> to get the first <code>Some</code> value from an iterable of <code>Option</code> values:</p>
<p><strong>Example</strong> (Retrieving the First <code>Some</code> Value)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const first = Option.firstSomeOf([
  Option.none(),
  Option.some(2),
  Option.none(),
  Option.some(3)
])

console.log(first)
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 }
</code></pre>
<h2>Interop with Nullable Types</h2>
<p>When dealing with the <code>Option</code> data type, you may encounter code that uses <code>undefined</code> or <code>null</code> to represent optional values. The <code>Option</code> module provides several APIs to make interaction with these nullable types straightforward.</p>
<h3>fromNullable</h3>
<p><code>Option.fromNullable</code> converts a nullable value (<code>null</code> or <code>undefined</code>) into an <code>Option</code>. If the value is <code>null</code> or <code>undefined</code>, it returns <code>Option.none()</code>. Otherwise, it wraps the value in <code>Option.some()</code>.</p>
<p><strong>Example</strong> (Creating Option from Nullable Values)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

console.log(Option.fromNullable(null))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(Option.fromNullable(undefined))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(Option.fromNullable(1))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }
</code></pre>
<p>If you need to convert an <code>Option</code> back to a nullable value, there are two helper methods:</p>
<ul>
<li><code>Option.getOrNull</code>: Converts <code>None</code> to <code>null</code>.</li>
<li><code>Option.getOrUndefined</code>: Converts <code>None</code> to <code>undefined</code>.</li>
</ul>
<h2>Interop with Effect</h2>
<p>The <code>Option</code> type works as a subtype of the <code>Effect</code> type, allowing you to use it with functions from the <code>Effect</code> module. While these functions are built to handle <code>Effect</code> values, they can also manage <code>Option</code> values correctly.</p>
<h3>How Option Maps to Effect</h3>
<table>
<thead>
<tr>
<th>Option Variant</th>
<th>Mapped to Effect</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>None</code></td>
<td><code>Effect&lt;never, NoSuchElementException&gt;</code></td>
<td>Represents the absence of a value</td>
</tr>
<tr>
<td><code>Some&lt;A&gt;</code></td>
<td><code>Effect&lt;A&gt;</code></td>
<td>Represents the presence of a value</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Combining <code>Option</code> with <code>Effect</code>)</p>
<pre><code class="language-ts">import { Effect, Option } from &quot;effect&quot;

// Function to get the head of an array, returning Option
const head = &lt;A&gt;(array: ReadonlyArray&lt;A&gt;): Option.Option&lt;A&gt; =&gt;
  array.length &gt; 0 ? Option.some(array[0]) : Option.none()

// Simulated fetch function that returns Effect
const fetchData = (): Effect.Effect&lt;string, string&gt; =&gt; {
  const success = Math.random() &gt; 0.5
  return success
    ? Effect.succeed(&quot;some data&quot;)
    : Effect.fail(&quot;Failed to fetch data&quot;)
}

// Mixing Either and Effect
const program = Effect.all([head([1, 2, 3]), fetchData()])

Effect.runPromise(program).then(console.log)
/*
Example Output:
[ 1, &#39;some data&#39; ]
*/
</code></pre>
<h2>Combining Two or More Options</h2>
<h3>zipWith</h3>
<p>The <code>Option.zipWith</code> function lets you combine two <code>Option</code> values using a provided function. It creates a new <code>Option</code> that holds the combined value of both original <code>Option</code> values.</p>
<p><strong>Example</strong> (Combining Two Options into an Object)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.some(&quot;John&quot;)
const maybeAge: Option.Option&lt;number&gt; = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) =&gt; ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: { name: &#39;JOHN&#39;, age: 25 } }
*/
</code></pre>
<p>If either of the <code>Option</code> values is <code>None</code>, the result will be <code>None</code>:</p>
<p><strong>Example</strong> (Handling None Values)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.some(&quot;John&quot;)
const maybeAge: Option.Option&lt;number&gt; = Option.none()

// Since maybeAge is a None, the result will also be None
const person = Option.zipWith(maybeName, maybeAge, (name, age) =&gt; ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<h3>all</h3>
<p>To combine multiple <code>Option</code> values without transforming their contents, you can use <code>Option.all</code>. This function returns an <code>Option</code> with a structure matching the input:</p>
<ul>
<li>If you pass a tuple, the result will be a tuple of the same length.</li>
<li>If you pass a struct, the result will be a struct with the same keys.</li>
<li>If you pass an <code>Iterable</code>, the result will be an array.</li>
</ul>
<p><strong>Example</strong> (Combining Multiple Options into a Tuple and Struct)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.some(&quot;John&quot;)
const maybeAge: Option.Option&lt;number&gt; = Option.some(25)

//      ┌─── Option&lt;[string, number]&gt;
//      ▼
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: [ &#39;John&#39;, 25 ] }
*/

//      ┌─── Option&lt;{ name: string; age: number; }&gt;
//      ▼
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: { name: &#39;John&#39;, age: 25 } }
*/
</code></pre>
<p>If any of the <code>Option</code> values are <code>None</code>, the result will be <code>None</code>:</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.some(&quot;John&quot;)
const maybeAge: Option.Option&lt;number&gt; = Option.none()

console.log(Option.all([maybeName, maybeAge]))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<h2>gen</h2>
<p>Similar to <a href="/docs/getting-started/using-generators/">Effect.gen</a>, <code>Option.gen</code> provides a more readable, generator-based syntax for working with <code>Option</code> values, making code that involves <code>Option</code> easier to write and understand. This approach is similar to using <code>async/await</code> but tailored for <code>Option</code>.</p>
<p><strong>Example</strong> (Using <code>Option.gen</code> to Create a Combined Value)</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.some(&quot;John&quot;)
const maybeAge: Option.Option&lt;number&gt; = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: { name: &#39;JOHN&#39;, age: 25 } }
*/
</code></pre>
<p>When any of the <code>Option</code> values in the sequence is <code>None</code>, the generator immediately returns the <code>None</code> value, skipping further operations:</p>
<p><strong>Example</strong> (Handling a <code>None</code> Value with <code>Option.gen</code>)</p>
<p>In this example, <code>Option.gen</code> halts execution as soon as it encounters the <code>None</code> value, effectively propagating the missing value without performing further operations.</p>
<pre><code class="language-ts">import { Option } from &quot;effect&quot;

const maybeName: Option.Option&lt;string&gt; = Option.none()
const maybeAge: Option.Option&lt;number&gt; = Option.some(25)

const program = Option.gen(function* () {
  console.log(&quot;Retrieving name...&quot;)
  const name = (yield* maybeName).toUpperCase()
  console.log(&quot;Retrieving age...&quot;)
  const age = yield* maybeAge
  return { name, age }
})

console.log(program)
/*
Output:
Retrieving name...
{ _id: &#39;Option&#39;, _tag: &#39;None&#39; }
*/
</code></pre>
<p>The use of <code>console.log</code> in these example is for demonstration purposes only. When using <code>Option.gen</code>, avoid including side effects in your generator functions, as <code>Option</code> should remain a pure data structure.</p>
<h2>Equivalence</h2>
<p>You can compare <code>Option</code> values using the <code>Option.getEquivalence</code> function. This function allows you to specify how to compare the contents of <code>Option</code> types by providing an <a href="/docs/behaviour/equivalence/">Equivalence</a> for the type of value they may contain.</p>
<p><strong>Example</strong> (Comparing Optional Numbers for Equivalence)</p>
<p>Suppose you have optional numbers and want to check if they are equivalent. Here&#39;s how you can use <code>Option.getEquivalence</code>:</p>
<pre><code class="language-ts">import { Option, Equivalence } from &quot;effect&quot;

const myEquivalence = Option.getEquivalence(Equivalence.number)

console.log(myEquivalence(Option.some(1), Option.some(1)))
// Output: true, both options contain the number 1

console.log(myEquivalence(Option.some(1), Option.some(2)))
// Output: false, the numbers are different

console.log(myEquivalence(Option.some(1), Option.none()))
// Output: false, one is a number and the other is empty
</code></pre>
<h2>Sorting</h2>
<p>You can sort a collection of <code>Option</code> values using the <code>Option.getOrder</code> function. This function helps specify a custom sorting rule for the type of value contained within the <code>Option</code>.</p>
<p><strong>Example</strong> (Sorting Optional Numbers)</p>
<p>Suppose you have a list of optional numbers and want to sort them in ascending order, with empty values (<code>Option.none()</code>) treated as the lowest:</p>
<pre><code class="language-ts">import { Option, Array, Order } from &quot;effect&quot;

const items = [Option.some(1), Option.none(), Option.some(2)]

// Create an order for sorting Option values containing numbers
const myOrder = Option.getOrder(Order.number)

console.log(Array.sort(myOrder)(items))
/*
Output:
[
  { _id: &#39;Option&#39;, _tag: &#39;None&#39; },           // None appears first because it&#39;s considered the lowest
  { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }, // Sorted in ascending order
  { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 }
]
*/
</code></pre>
<p><strong>Example</strong> (Sorting Optional Dates in Reverse Order)</p>
<p>Consider a more complex case where you have a list of objects containing optional dates, and you want to sort them in descending order, with <code>Option.none()</code> values at the end:</p>
<pre><code class="language-ts">import { Option, Array, Order } from &quot;effect&quot;

const items = [
  { data: Option.some(new Date(10)) },
  { data: Option.some(new Date(20)) },
  { data: Option.none() }
]

// Define the order to sort dates within Option values in reverse
const sorted = Array.sortWith(
  items,
  (item) =&gt; item.data,
  Order.reverse(Option.getOrder(Order.Date))
)

console.log(sorted)
/*
Output:
[
  { data: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;1970-01-01T00:00:00.020Z&#39; } },
  { data: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;1970-01-01T00:00:00.010Z&#39; } },
  { data: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } } // None placed last
]
*/
</code></pre>
<hr>
<hr>
<h2>title: Redacted
description: Securely handle sensitive data with the Redacted module, preventing accidental exposure in logs while supporting safe value access and comparison.
sidebar:
  order: 10</h2>
<p>The Redacted module provides functionality for handling sensitive information securely within your application.
By using the <code>Redacted</code> data type, you can ensure that sensitive values are not accidentally exposed in logs or error messages.</p>
<h2>make</h2>
<p>The <code>Redacted.make</code> function creates a <code>Redacted&lt;A&gt;</code> instance from a given value <code>A</code>, ensuring the content is securely hidden.</p>
<p><strong>Example</strong> (Hiding Sensitive Information from Logs)</p>
<p>Using <code>Redacted.make</code> helps prevent sensitive information, such as API keys, from being accidentally exposed in logs or error messages.</p>
<pre><code class="language-ts">import { Redacted, Effect } from &quot;effect&quot;

// Create a redacted API key
const API_KEY = Redacted.make(&quot;1234567890&quot;)

console.log(API_KEY)
// Output: {}

console.log(String(API_KEY))
// Output: &lt;redacted&gt;

Effect.runSync(Effect.log(API_KEY))
// Output: timestamp=... level=INFO fiber=#0 message=&quot;\&quot;&lt;redacted&gt;\&quot;&quot;
</code></pre>
<h2>value</h2>
<p>The <code>Redacted.value</code> function retrieves the original value from a <code>Redacted</code> instance. Use this function carefully, as it exposes the sensitive data, potentially making it visible in logs or accessible in unintended ways.</p>
<p><strong>Example</strong> (Accessing the Underlying Sensitive Value)</p>
<pre><code class="language-ts">import { Redacted } from &quot;effect&quot;

const API_KEY = Redacted.make(&quot;1234567890&quot;)

// Expose the redacted value
console.log(Redacted.value(API_KEY))
// Output: &quot;1234567890&quot;
</code></pre>
<h2>unsafeWipe</h2>
<p>The <code>Redacted.unsafeWipe</code> function erases the underlying value of a <code>Redacted</code> instance, making it inaccessible. This helps ensure that sensitive data does not remain in memory longer than needed.</p>
<p><strong>Example</strong> (Wiping Sensitive Data from Memory)</p>
<pre><code class="language-ts">import { Redacted } from &quot;effect&quot;

const API_KEY = Redacted.make(&quot;1234567890&quot;)

console.log(Redacted.value(API_KEY))
// Output: &quot;1234567890&quot;

Redacted.unsafeWipe(API_KEY)

console.log(Redacted.value(API_KEY))
/*
throws:
Error: Unable to get redacted value
*/
</code></pre>
<h2>getEquivalence</h2>
<p>The <code>Redacted.getEquivalence</code> function generates an <a href="/docs/behaviour/equivalence/">Equivalence</a> for <code>Redacted&lt;A&gt;</code> values using an Equivalence for the underlying values of type <code>A</code>. This allows you to compare <code>Redacted</code> values securely without revealing their content.</p>
<p><strong>Example</strong> (Comparing Redacted Values)</p>
<pre><code class="language-ts">import { Redacted, Equivalence } from &quot;effect&quot;

const API_KEY1 = Redacted.make(&quot;1234567890&quot;)
const API_KEY2 = Redacted.make(&quot;1-34567890&quot;)
const API_KEY3 = Redacted.make(&quot;1234567890&quot;)

const equivalence = Redacted.getEquivalence(Equivalence.string)

console.log(equivalence(API_KEY1, API_KEY2))
// Output: false

console.log(equivalence(API_KEY1, API_KEY3))
// Output: true
</code></pre>
<hr>
<hr>
<h2>title: Error Accumulation
description: Learn to manage errors effectively in Effect workflows with tools for sequential execution, error accumulation, and result partitioning.
sidebar:
  order: 8</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Sequential combinators such as <a href="/docs/getting-started/control-flow/#zip">Effect.zip</a>, <a href="/docs/getting-started/control-flow/#all">Effect.all</a> and <a href="/docs/getting-started/control-flow/#foreach">Effect.forEach</a> have a &quot;fail fast&quot; policy when it comes to error management. This means that they stop and return immediately when they encounter the first error.</p>
<p>Here&#39;s an example using <code>Effect.zip</code>, which stops at the first failure and only shows the first error:</p>
<p><strong>Example</strong> (Fail Fast with <code>Effect.zip</code>)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Console.log(&quot;task1&quot;).pipe(Effect.as(1))
const task2 = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))
const task3 = Console.log(&quot;task2&quot;).pipe(Effect.as(3))
const task4 = Effect.fail(&quot;Oh no!&quot;).pipe(Effect.as(4))

const program = task1.pipe(
  Effect.zip(task2),
  Effect.zip(task3),
  Effect.zip(task4)
)

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
task1
(FiberFailure) Error: Oh uh!
*/
</code></pre>
<p>The <code>Effect.forEach</code> function behaves similarly. It applies an effectful operation to each element in a collection, but will stop when it hits the first error:</p>
<p><strong>Example</strong> (Fail Fast with <code>Effect.forEach</code>)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Effect.forEach([1, 2, 3, 4, 5], (n) =&gt; {
  if (n &lt; 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
item 1
item 2
item 3
(FiberFailure) Error: 4 is not less that 4
*/
</code></pre>
<p>However, there are cases where you may want to collect all errors rather than fail fast. In these situations, you can use functions that accumulate both successes and errors.</p>
<h2>validate</h2>
<p>The <code>Effect.validate</code> function is similar to <code>Effect.zip</code>, but it continues combining effects even after encountering errors, accumulating both successes and failures.</p>
<p><strong>Example</strong> (Validating and Collecting Errors)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Console.log(&quot;task1&quot;).pipe(Effect.as(1))
const task2 = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))
const task3 = Console.log(&quot;task2&quot;).pipe(Effect.as(3))
const task4 = Effect.fail(&quot;Oh no!&quot;).pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
task1
task2
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Sequential&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh uh!&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh no!&#39; }
  }
}
*/
</code></pre>
<h2>validateAll</h2>
<p>The <code>Effect.validateAll</code> function is similar to the <code>Effect.forEach</code> function. It transforms all elements of a collection using the provided effectful operation, but it collects all errors in the error channel, as well as the success values in the success channel.</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;number[], string[], never&gt;
//      ▼
const program = Effect.validateAll([1, 2, 3, 4, 5], (n) =&gt; {
  if (n &lt; 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
item 1
item 2
item 3
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: [ &#39;4 is not less that 4&#39;, &#39;5 is not less that 4&#39; ]
  }
}
*/
</code></pre>
<Aside type="caution" title="Loss of Successes">
  Note that this function is lossy, which means that if there are any
  errors, all successes will be lost. If you need to preserve both
  successes and failures, consider using [Effect.partition](#partition).
</Aside>

<h2>validateFirst</h2>
<p>The <code>Effect.validateFirst</code> function is similar to <code>Effect.validateAll</code> but it returns the first successful result, or all errors if none succeed.</p>
<p><strong>Example</strong> (Returning the First Success)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string[], never&gt;
//      ▼
const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) =&gt; {
  if (n &lt; 4) {
    return Effect.fail(`${n} is not less that 4`)
  } else {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  }
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
item 4
4
*/
</code></pre>
<p>Notice that <code>Effect.validateFirst</code> returns a single <code>number</code> as the success type, rather than an array of results like <code>Effect.validateAll</code>.</p>
<h2>partition</h2>
<p>The <code>Effect.partition</code> function processes an iterable and applies an effectful function to each element. It returns a tuple, where the first part contains all the failures, and the second part contains all the successes.</p>
<p><strong>Example</strong> (Partitioning Successes and Failures)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;[string[], number[]], never, never&gt;
//      ▼
const program = Effect.partition([0, 1, 2, 3, 4], (n) =&gt; {
  if (n % 2 === 0) {
    return Effect.succeed(n)
  } else {
    return Effect.fail(`${n} is not even`)
  }
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
[ [ &#39;1 is not even&#39;, &#39;3 is not even&#39; ], [ 0, 2, 4 ] ]
*/
</code></pre>
<p>This operator is an unexceptional effect, meaning the error channel type is <code>never</code>. Failures are collected without stopping the effect, so the entire operation completes and returns both errors and successes.</p>
<hr>
<hr>
<h2>title: Error Channel Operations
description: Explore operations on the error channel in Effect, including error mapping, filtering, inspecting, merging, and flipping channels.
sidebar:
  order: 9</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In Effect you can perform various operations on the error channel of effects. These operations allow you to transform, inspect, and handle errors in different ways. Let&#39;s explore some of these operations.</p>
<h2>Map Operations</h2>
<h3>mapError</h3>
<p>The <code>Effect.mapError</code> function is used when you need to transform or modify an error produced by an effect, without affecting the success value. This can be helpful when you want to add extra information to the error or change its type.</p>
<p><strong>Example</strong> (Mapping an Error)</p>
<p>Here, the error type changes from <code>string</code> to <code>Error</code>.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const simulatedTask = Effect.fail(&quot;Oh no!&quot;).pipe(Effect.as(1))

//      ┌─── Effect&lt;number, Error, never&gt;
//      ▼
const mapped = Effect.mapError(
  simulatedTask,
  (message) =&gt; new Error(message)
)
</code></pre>
<Aside type="note">
  It's important to note that using the `Effect.mapError` function does
  not change the overall success or failure of the effect. It only
  transforms the values in the error channel while preserving the effect's
  original success or failure status.
</Aside>

<h3>mapBoth</h3>
<p>The <code>Effect.mapBoth</code> function allows you to apply transformations to both channels: the error channel and the success channel of an effect. It takes two map functions as arguments: one for the error channel and the other for the success channel.</p>
<p><strong>Example</strong> (Mapping Both Success and Error)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const simulatedTask = Effect.fail(&quot;Oh no!&quot;).pipe(Effect.as(1))

//      ┌─── Effect&lt;boolean, Error, never&gt;
//      ▼
const modified = Effect.mapBoth(simulatedTask, {
  onFailure: (message) =&gt; new Error(message),
  onSuccess: (n) =&gt; n &gt; 0
})
</code></pre>
<Aside type="note">
  It's important to note that using the `Effect.mapBoth` function does not
  change the overall success or failure of the effect. It only transforms
  the values in the error and success channels while preserving the
  effect's original success or failure status.
</Aside>

<h2>Filtering the Success Channel</h2>
<p>The Effect library provides several operators to filter values on the success channel based on a given predicate.</p>
<p>These operators offer different strategies for handling cases where the predicate fails:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>filterOrFail</code></td>
<td>This operator filters the values on the success channel based on a predicate. If the predicate fails for any value, the original effect fails with an error.</td>
</tr>
<tr>
<td><code>filterOrDie</code> / <code>filterOrDieMessage</code></td>
<td>These operators also filter the values on the success channel based on a predicate. If the predicate fails for any value, the original effect terminates abruptly. The <code>filterOrDieMessage</code> variant allows you to provide a custom error message.</td>
</tr>
<tr>
<td><code>filterOrElse</code></td>
<td>This operator filters the values on the success channel based on a predicate. If the predicate fails for any value, an alternative effect is executed instead.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Filtering Success Values)</p>
<pre><code class="language-ts">import { Effect, Random, Cause } from &quot;effect&quot;

// Fail with a custom error if predicate is false
const task1 = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) =&gt; n &gt;= 0,
  () =&gt; &quot;random number is negative&quot;
)

// Die with a custom exception if predicate is false
const task2 = Effect.filterOrDie(
  Random.nextRange(-1, 1),
  (n) =&gt; n &gt;= 0,
  () =&gt; new Cause.IllegalArgumentException(&quot;random number is negative&quot;)
)

// Die with a custom error message if predicate is false
const task3 = Effect.filterOrDieMessage(
  Random.nextRange(-1, 1),
  (n) =&gt; n &gt;= 0,
  &quot;random number is negative&quot;
)

// Run an alternative effect if predicate is false
const task4 = Effect.filterOrElse(
  Random.nextRange(-1, 1),
  (n) =&gt; n &gt;= 0,
  () =&gt; task3
)
</code></pre>
<p>It&#39;s important to note that depending on the specific filtering operator used, the effect can either fail, terminate abruptly, or execute an alternative effect when the predicate fails. Choose the appropriate operator based on your desired error handling strategy and program logic.</p>
<p>The filtering APIs can also be combined with <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">user-defined type guards</a> to improve type safety and code clarity. This ensures that only valid types pass through.</p>
<p><strong>Example</strong> (Using a Type Guard)</p>
<pre><code class="language-ts">import { Effect, pipe } from &quot;effect&quot;

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () =&gt; Promise&lt;User | null&gt;

const program = pipe(
  Effect.promise(() =&gt; auth()),
  // Use filterOrFail with a custom type guard to ensure user is not null
  Effect.filterOrFail(
    (user): user is User =&gt; user !== null, // Type guard
    () =&gt; new Error(&quot;Unauthorized&quot;)
  ),
  // &#39;user&#39; now has the type `User` (not `User | null`)
  Effect.andThen((user) =&gt; user.name)
)
</code></pre>
<p>In the example above, a guard is used within the <code>filterOrFail</code> API to ensure that the <code>user</code> is of type <code>User</code> rather than <code>User | null</code>.</p>
<p>If you prefer, you can utilize a pre-made guard like <a href="https://effect-ts.github.io/effect/effect/Predicate.ts.html#isnotnull">Predicate.isNotNull</a> for simplicity and consistency.</p>
<h2>Inspecting Errors</h2>
<p>Similar to <a href="/docs/getting-started/building-pipelines/#tap">tapping</a> for success values, Effect provides several operators for inspecting error values.
These operators allow developers to observe failures or underlying issues without modifying the outcome.</p>
<h3>tapError</h3>
<p>Executes an effectful operation to inspect the failure of an effect without altering it.</p>
<p><strong>Example</strong> (Inspecting Errors)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Simulate a task that fails with an error
const task: Effect.Effect&lt;number, string&gt; = Effect.fail(&quot;NetworkError&quot;)

// Use tapError to log the error message when the task fails
const tapping = Effect.tapError(task, (error) =&gt;
  Console.log(`expected error: ${error}`)
)

Effect.runFork(tapping)
/*
Output:
expected error: NetworkError
*/
</code></pre>
<h3>tapErrorTag</h3>
<p>This function allows you to inspect errors that match a specific tag, helping you handle different error types more precisely.</p>
<p><strong>Example</strong> (Inspecting Tagged Errors)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

class NetworkError {
  readonly _tag = &quot;NetworkError&quot;
  constructor(readonly statusCode: number) {}
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
  constructor(readonly field: string) {}
}

// Create a task that fails with a NetworkError
const task: Effect.Effect&lt;number, NetworkError | ValidationError&gt; =
  Effect.fail(new NetworkError(504))

// Use tapErrorTag to inspect only NetworkError types and log the status code
const tapping = Effect.tapErrorTag(task, &quot;NetworkError&quot;, (error) =&gt;
  Console.log(`expected error: ${error.statusCode}`)
)

Effect.runFork(tapping)
/*
Output:
expected error: 504
*/
</code></pre>
<h3>tapErrorCause</h3>
<p>This function inspects the complete cause of an error, including failures and defects.</p>
<p><strong>Example</strong> (Inspecting Error Causes)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Create a task that fails with a NetworkError
const task1: Effect.Effect&lt;number, string&gt; = Effect.fail(&quot;NetworkError&quot;)

const tapping1 = Effect.tapErrorCause(task1, (cause) =&gt;
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping1)
/*
Output:
error cause: Error: NetworkError
*/

// Simulate a severe failure in the system
const task2: Effect.Effect&lt;number, string&gt; = Effect.dieMessage(
  &quot;Something went wrong&quot;
)

const tapping2 = Effect.tapErrorCause(task2, (cause) =&gt;
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping2)
/*
Output:
error cause: RuntimeException: Something went wrong
  ... stack trace ...
*/
</code></pre>
<h3>tapDefect</h3>
<p>Specifically inspects non-recoverable failures or defects in an effect (i.e., one or more <a href="/docs/data-types/cause/#die">Die</a> causes).</p>
<p><strong>Example</strong> (Inspecting Defects)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Simulate a task that fails with a recoverable error
const task1: Effect.Effect&lt;number, string&gt; = Effect.fail(&quot;NetworkError&quot;)

// tapDefect won&#39;t log anything because NetworkError is not a defect
const tapping1 = Effect.tapDefect(task1, (cause) =&gt;
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping1)
/*
No Output
*/

// Simulate a severe failure in the system
const task2: Effect.Effect&lt;number, string&gt; = Effect.dieMessage(
  &quot;Something went wrong&quot;
)

// Log the defect using tapDefect
const tapping2 = Effect.tapDefect(task2, (cause) =&gt;
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping2)
/*
Output:
defect: RuntimeException: Something went wrong
  ... stack trace ...
*/
</code></pre>
<h3>tapBoth</h3>
<p>Inspects both success and failure outcomes of an effect, performing different actions based on the result.</p>
<p><strong>Example</strong> (Inspecting Both Success and Failure)</p>
<pre><code class="language-ts">import { Effect, Random, Console } from &quot;effect&quot;

// Simulate a task that might fail
const task = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) =&gt; n &gt;= 0,
  () =&gt; &quot;random number is negative&quot;
)

// Use tapBoth to log both success and failure outcomes
const tapping = Effect.tapBoth(task, {
  onFailure: (error) =&gt; Console.log(`failure: ${error}`),
  onSuccess: (randomNumber) =&gt;
    Console.log(`random number: ${randomNumber}`)
})

Effect.runFork(tapping)
/*
Example Output:
failure: random number is negative
*/
</code></pre>
<h2>Exposing Errors in The Success Channel</h2>
<p>The <code>Effect.either</code> function transforms an <code>Effect&lt;A, E, R&gt;</code> into an effect that encapsulates both potential failure and success within an <a href="/docs/data-types/either/">Either</a> data type:</p>
<pre><code class="language-ts">Effect&lt;A, E, R&gt; -&gt; Effect&lt;Either&lt;A, E&gt;, never, R&gt;
</code></pre>
<p>This means if you have an effect with the following type:</p>
<pre><code class="language-ts">Effect&lt;string, HttpError, never&gt;
</code></pre>
<p>and you call <code>Effect.either</code> on it, the type becomes:</p>
<pre><code class="language-ts">Effect&lt;Either&lt;string, HttpError&gt;, never, never&gt;
</code></pre>
<p>The resulting effect cannot fail because the potential failure is now represented within the <code>Either</code>&#39;s <code>Left</code> type.
The error type of the returned <code>Effect</code> is specified as <code>never</code>, confirming that the effect is structured to not fail.</p>
<p>This function becomes especially useful when recovering from effects that may fail when using <a href="/docs/getting-started/using-generators/#understanding-effectgen">Effect.gen</a>:</p>
<p><strong>Example</strong> (Using <code>Effect.either</code> to Handle Errors)</p>
<pre><code class="language-ts">import { Effect, Either, Console } from &quot;effect&quot;

// Simulate a task that fails
//
//      ┌─── Either&lt;number, string, never&gt;
//      ▼
const program = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

//      ┌─── Either&lt;number, never, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  //      ┌─── Either&lt;number, string&gt;
  //      ▼
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    yield* Console.log(`failure: ${error}`)
    return 0
  } else {
    const value = failureOrSuccess.right
    yield* Console.log(`success: ${value}`)
    return value
  }
})

Effect.runPromise(recovered).then(console.log)
/*
Output:
failure: Oh uh!
0
*/
</code></pre>
<h2>Exposing the Cause in The Success Channel</h2>
<p>You can use the <code>Effect.cause</code> function to expose the cause of an effect, which is a more detailed representation of failures, including error messages and defects.</p>
<p><strong>Example</strong> (Logging the Cause of Failure)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const program = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

//      ┌─── Effect&lt;void, never, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  const cause = yield* Effect.cause(program)
  yield* Console.log(cause)
})
</code></pre>
<h2>Merging the Error Channel into the Success Channel</h2>
<p>The <code>Effect.merge</code> function allows you to combine the error channel with the success channel. This results in an effect that never fails; instead, both successes and errors are handled as values in the success channel.</p>
<p><strong>Example</strong> (Combining Error and Success Channels)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const program = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

//      ┌─── Effect&lt;number | string, never, never&gt;
//      ▼
const recovered = Effect.merge(program)
</code></pre>
<h2>Flipping Error and Success Channels</h2>
<p>The <code>Effect.flip</code> function allows you to switch the error and success channels of an effect. This means that what was previously a success becomes the error, and vice versa.</p>
<p><strong>Example</strong> (Swapping Error and Success Channels)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const program = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

//      ┌─── Effect&lt;string, number, never&gt;
//      ▼
const flipped = Effect.flip(program)
</code></pre>
<hr>
<hr>
<h2>title: Expected Errors
description: Learn how Effect manages expected errors with precise error tracking, short-circuiting, and powerful recovery techniques.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Expected errors are tracked at the type level by the <a href="/docs/getting-started/the-effect-type/">Effect data type</a> in the &quot;Error channel&quot;:</p>
<pre><code class="language-text">         ┌─── Represents the success type
         │        ┌─── Represents the error type
         │        │      ┌─── Represents required dependencies
         ▼        ▼      ▼
Effect&lt;Success, Error, Requirements&gt;
</code></pre>
<p>This means that the <code>Effect</code> type captures not only what the program returns on success but also what type of error it might produce.</p>
<p><strong>Example</strong> (Creating an Effect That Can Fail)</p>
<p>In this example, we define a program that might randomly fail with an <code>HttpError</code>.</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

//      ┌─── Effect&lt;string, HttpError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  // Generate a random number between 0 and 1
  const n = yield* Random.next

  // Simulate an HTTP error
  if (n &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }

  return &quot;some result&quot;
})
</code></pre>
<p>The type of <code>program</code> tells us that it can either return a <code>string</code> or fail with an <code>HttpError</code>:</p>
<pre><code class="language-ts">const program: Effect&lt;string, HttpError, never&gt;
</code></pre>
<p>In this case, we use a class to represent the <code>HttpError</code> type, which allows us to define both the error type and a constructor. However, you can use whatever
you like to model your error types.</p>
<p>It&#39;s also worth noting that we added a readonly <code>_tag</code> field to the class:</p>
<pre><code class="language-ts">class HttpError {
  // This field serves as a discriminant for the error
  readonly _tag = &quot;HttpError&quot;
}
</code></pre>
<p>This discriminant field will be useful when we discuss APIs like <a href="#catchtag">Effect.catchTag</a>, which help in handling specific error types.</p>
<Aside type="tip" title="Discriminant Fields">
  Adding a discriminant field, such as `_tag`, can be beneficial for
  distinguishing between different types of errors during error handling.
  It also prevents TypeScript from unifying types, ensuring that each
  error is treated uniquely based on its discriminant value.

<p>For more information on constructing tagged errors, see <a href="/docs/error-management/yieldable-errors/#datataggederror">Data.TaggedError</a>.</p>
</Aside>

<h2>Error Tracking</h2>
<p>In Effect, if a program can fail with multiple types of errors, they are automatically tracked as a union of those error types.
This allows you to know exactly what errors can occur during execution, making error handling more precise and predictable.</p>
<p>The example below illustrates how errors are automatically tracked for you.</p>
<p><strong>Example</strong> (Automatically Tracking Errors)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  // Generate two random numbers between 0 and 1
  const n1 = yield* Random.next
  const n2 = yield* Random.next

  // Simulate an HTTP error
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  // Simulate a validation error
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }

  return &quot;some result&quot;
})
</code></pre>
<p>Effect automatically keeps track of the possible errors that can occur during the execution of the program as a union:</p>
<pre><code class="language-ts">const program: Effect&lt;string, HttpError | ValidationError, never&gt;
</code></pre>
<p>indicating that it can potentially fail with either a <code>HttpError</code> or a <code>ValidationError</code>.</p>
<h2>Short-Circuiting</h2>
<p>When working with APIs like <a href="/docs/getting-started/using-generators/#understanding-effectgen">Effect.gen</a>, <a href="/docs/getting-started/building-pipelines/#map">Effect.map</a>, <a href="/docs/getting-started/building-pipelines/#flatmap">Effect.flatMap</a>, and <a href="/docs/getting-started/building-pipelines/#andthen">Effect.andThen</a>, it&#39;s important to understand how they handle errors.
These APIs are designed to <strong>short-circuit the execution</strong> upon encountering the <strong>first error</strong>.</p>
<p>What does this mean for you as a developer? Well, let&#39;s say you have a chain of operations or a collection of effects to be executed in sequence. If any error occurs during the execution of one of these effects, the remaining computations will be skipped, and the error will be propagated to the final result.</p>
<p>In simpler terms, the short-circuiting behavior ensures that if something goes wrong at any step of your program, it won&#39;t waste time executing unnecessary computations. Instead, it will immediately stop and return the error to let you know that something went wrong.</p>
<p><strong>Example</strong> (Short-Circuiting Behavior)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Define three effects representing different tasks.
const task1 = Console.log(&quot;Executing task1...&quot;)
const task2 = Effect.fail(&quot;Something went wrong!&quot;)
const task3 = Console.log(&quot;Executing task3...&quot;)

// Compose the three tasks to run them in sequence.
// If one of the tasks fails, the subsequent tasks won&#39;t be executed.
const program = Effect.gen(function* () {
  yield* task1
  // After task1, task2 is executed, but it fails with an error
  yield* task2
  // This computation won&#39;t be executed because the previous one fails
  yield* task3
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Executing task1...
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Something went wrong!&#39; }
}
*/
</code></pre>
<p>This code snippet demonstrates the short-circuiting behavior when an error occurs.
Each operation depends on the successful execution of the previous one.
If any error occurs, the execution is short-circuited, and the error is propagated.
In this specific example, <code>task3</code> is never executed because an error occurs in <code>task2</code>.</p>
<h2>Catching All Errors</h2>
<h3>either</h3>
<p>The <code>Effect.either</code> function transforms an <code>Effect&lt;A, E, R&gt;</code> into an effect that encapsulates both potential failure and success within an <a href="/docs/data-types/either/">Either</a> data type:</p>
<pre><code class="language-ts">Effect&lt;A, E, R&gt; -&gt; Effect&lt;Either&lt;A, E&gt;, never, R&gt;
</code></pre>
<p>This means if you have an effect with the following type:</p>
<pre><code class="language-ts">Effect&lt;string, HttpError, never&gt;
</code></pre>
<p>and you call <code>Effect.either</code> on it, the type becomes:</p>
<pre><code class="language-ts">Effect&lt;Either&lt;string, HttpError&gt;, never, never&gt;
</code></pre>
<p>The resulting effect cannot fail because the potential failure is now represented within the <code>Either</code>&#39;s <code>Left</code> type.
The error type of the returned <code>Effect</code> is specified as <code>never</code>, confirming that the effect is structured to not fail.</p>
<p>By yielding an <code>Either</code>, we gain the ability to &quot;pattern match&quot; on this type to handle both failure and success cases within the generator function.</p>
<p><strong>Example</strong> (Using <code>Effect.either</code> to Handle Errors)</p>
<pre><code class="language-ts">import { Effect, Either, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  //      ┌─── Either&lt;string, HttpError | ValidationError&gt;
  //      ▼
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    // Failure case: you can extract the error from the `left` property
    const error = failureOrSuccess.left
    return `Recovering from ${error._tag}`
  } else {
    // Success case: you can extract the value from the `right` property
    return failureOrSuccess.right
  }
})
</code></pre>
<p>As you can see since all errors are handled, the error type of the resulting effect <code>recovered</code> is <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, never, never&gt;
</code></pre>
<p>We can make the code less verbose by using the <code>Either.match</code> function, which directly accepts the two callback functions for handling errors and successful values:</p>
<p><strong>Example</strong> (Simplifying with <code>Either.match</code>)</p>
<pre><code class="language-ts">import { Effect, Either, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  //      ┌─── Either&lt;string, HttpError | ValidationError&gt;
  //      ▼
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) =&gt; `Recovering from ${error._tag}`,
    onRight: (value) =&gt; value // Do nothing in case of success
  })
})
</code></pre>
<h3>option</h3>
<p>Transforms an effect to encapsulate both failure and success using the <a href="/docs/data-types/option/">Option</a> data type.</p>
<p>The <code>Effect.option</code> function wraps the success or failure of an effect within the
<code>Option</code> type, making both cases explicit. If the original effect succeeds,
its value is wrapped in <code>Option.some</code>. If it fails, the failure is mapped to
<code>Option.none</code>.</p>
<p>The resulting effect cannot fail directly, as the error type is set to <code>never</code>. However, fatal errors like defects are not encapsulated.</p>
<p><strong>Example</strong> (Using <code>Effect.option</code> to Handle Errors)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Success&#39;,
  value: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }
}
*/

const maybe2 = Effect.option(Effect.fail(&quot;Uh oh!&quot;))

Effect.runPromiseExit(maybe2).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Success&#39;,
  value: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
}
*/

const maybe3 = Effect.option(Effect.die(&quot;Boom!&quot;))

Effect.runPromiseExit(maybe3).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: &#39;Boom!&#39; }
}
*/
</code></pre>
<h3>catchAll</h3>
<p>Handles all errors in an effect by providing a fallback effect.</p>
<p>The <code>Effect.catchAll</code> function catches any errors that may occur during the
execution of an effect and allows you to handle them by specifying a fallback
effect. This ensures that the program continues without failing by recovering
from errors using the provided fallback logic.</p>
<Aside type="note" title="Recoverable Errors Only">
  `Effect.catchAll` only handles recoverable errors. It will not recover
  from unrecoverable defects. See [Effect.catchAllCause](#catchallcause)
  for handling all types of failures.
</Aside>

<p><strong>Example</strong> (Providing Recovery Logic for Recoverable Errors)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = program.pipe(
  Effect.catchAll((error) =&gt;
    Effect.succeed(`Recovering from ${error._tag}`)
  )
)
</code></pre>
<p>We can observe that the type in the error channel of our program has changed to <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, never, never&gt;
</code></pre>
<p>indicating that all errors have been handled.</p>
<h3>catchAllCause</h3>
<p>Handles both recoverable and unrecoverable errors by providing a recovery effect.</p>
<p>The <code>Effect.catchAllCause</code> function allows you to handle all errors, including
unrecoverable defects, by providing a recovery effect. The recovery logic is
based on the <code>Cause</code> of the error, which provides detailed information about
the failure.</p>
<p><strong>Example</strong> (Recovering from All Errors)</p>
<pre><code class="language-ts">import { Cause, Effect } from &quot;effect&quot;

// Define an effect that may fail with a recoverable or unrecoverable error
const program = Effect.fail(&quot;Something went wrong!&quot;)

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =&gt;
    Cause.isFailType(cause)
      ? Effect.succeed(&quot;Recovered from a regular error&quot;)
      : Effect.succeed(&quot;Recovered from a defect&quot;)
  )
)

Effect.runPromise(recovered).then(console.log)
// Output: &quot;Recovered from a regular error&quot;
</code></pre>
<Aside type="tip" title="When to Recover from Defects">
  Defects are unexpected errors that typically shouldn't be recovered
  from, as they often indicate serious issues. However, in some cases,
  such as dynamically loaded plugins, controlled recovery might be needed.
</Aside>

<h2>Catching Some Errors</h2>
<h3>either</h3>
<p>The <a href="#either"><code>Effect.either</code></a> function, which was previously shown as a way to catch all errors, can also be used to catch specific errors.</p>
<p>By yielding an <code>Either</code>, we gain the ability to &quot;pattern match&quot; on this type to handle both failure and success cases within the generator function.</p>
<p><strong>Example</strong> (Handling Specific Errors with <code>Effect.either</code>)</p>
<pre><code class="language-ts">import { Effect, Random, Either } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, ValidationError, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    // Only handle HttpError errors
    if (error._tag === &quot;HttpError&quot;) {
      return &quot;Recovering from HttpError&quot;
    } else {
      // Rethrow ValidationError
      return yield* Effect.fail(error)
    }
  } else {
    return failureOrSuccess.right
  }
})
</code></pre>
<p>We can observe that the type in the error channel of our program has changed to only show <code>ValidationError</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, ValidationError, never&gt;
</code></pre>
<p>indicating that <code>HttpError</code> has been handled.</p>
<p>If we also want to handle <code>ValidationError</code>, we can easily add another case to our code:</p>
<pre><code class="language-ts">import { Effect, Random, Either } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    // Handle both HttpError and ValidationError
    if (error._tag === &quot;HttpError&quot;) {
      return &quot;Recovering from HttpError&quot;
    } else {
      return &quot;Recovering from ValidationError&quot;
    }
  } else {
    return failureOrSuccess.right
  }
})
</code></pre>
<p>We can observe that the type in the error channel has changed to <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, never, never&gt;
</code></pre>
<p>indicating that all errors have been handled.</p>
<h3>catchSome</h3>
<p>Catches and recovers from specific types of errors, allowing you to attempt recovery only for certain errors.</p>
<p><code>Effect.catchSome</code> lets you selectively catch and handle errors of certain
types by providing a recovery effect for specific errors. If the error
matches a condition, recovery is attempted; if not, it doesn&#39;t affect the
program. This function doesn&#39;t alter the error type, meaning the error type
remains the same as in the original effect.</p>
<p><strong>Example</strong> (Handling Specific Errors with <code>Effect.catchSome</code>)</p>
<pre><code class="language-ts">import { Effect, Random, Option } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const recovered = program.pipe(
  Effect.catchSome((error) =&gt; {
    // Only handle HttpError errors
    if (error._tag === &quot;HttpError&quot;) {
      return Option.some(Effect.succeed(&quot;Recovering from HttpError&quot;))
    } else {
      return Option.none()
    }
  })
)
</code></pre>
<p>In the code above, <code>Effect.catchSome</code> takes a function that examines the error and decides whether to attempt recovery or not. If the error matches a specific condition, recovery can be attempted by returning <code>Option.some(effect)</code>. If no recovery is possible, you can simply return <code>Option.none()</code>.</p>
<p>It&#39;s important to note that while <code>Effect.catchSome</code> lets you catch specific errors, it doesn&#39;t alter the error type itself.
Therefore, the resulting effect will still have the same error type as the original effect:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, HttpError | ValidationError, never&gt;
</code></pre>
<h3>catchIf</h3>
<p>Recovers from specific errors based on a predicate.</p>
<p><code>Effect.catchIf</code> works similarly to <a href="#catchsome"><code>Effect.catchSome</code></a>, but it allows you to
recover from errors by providing a predicate function. If the predicate
matches the error, the recovery effect is applied. This function doesn&#39;t
alter the error type, so the resulting effect still carries the original
error type unless a user-defined type guard is used to narrow the type.</p>
<p><strong>Example</strong> (Catching Specific Errors with a Predicate)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, ValidationError, never&gt;
//      ▼
const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) =&gt; error._tag === &quot;HttpError&quot;,
    () =&gt; Effect.succeed(&quot;Recovering from HttpError&quot;)
  )
)
</code></pre>
<p>It&#39;s important to note that for TypeScript versions &lt; 5.5, while <code>Effect.catchIf</code> lets you catch specific errors, it <strong>doesn&#39;t alter the error type</strong> itself.
Therefore, the resulting effect will still have the same error type as the original effect:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, HttpError | ValidationError, never&gt;
</code></pre>
<p>In TypeScript versions &gt;= 5.5, improved type narrowing causes the resulting error type to be inferred as <code>ValidationError</code>.</p>
<h4>Workaround For TypeScript versions &lt; 5.5</h4>
<p>If you provide a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">user-defined type guard</a> instead of a predicate, the resulting error type will be pruned, returning an <code>Effect&lt;string, ValidationError, never&gt;</code>:</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, ValidationError, never&gt;
//      ▼
const recovered = program.pipe(
  Effect.catchIf(
    // User-defined type guard
    (error): error is HttpError =&gt; error._tag === &quot;HttpError&quot;,
    () =&gt; Effect.succeed(&quot;Recovering from HttpError&quot;)
  )
)
</code></pre>
<h3>catchTag</h3>
<p>Catches and handles specific errors by their <code>_tag</code> field, which is used as a discriminator.</p>
<p><code>Effect.catchTag</code> is useful when your errors are tagged with a <code>_tag</code> field
that identifies the error type. You can use this function to handle specific
error types by matching the <code>_tag</code> value. This allows for precise error
handling, ensuring that only specific errors are caught and handled.</p>
<p>The error type must have a <code>_tag</code> field to use <code>Effect.catchTag</code>. This field
is used to identify and match errors.</p>
<p><strong>Example</strong> (Handling Errors by Tag)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, ValidationError, never&gt;
//      ▼
const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag(&quot;HttpError&quot;, (_HttpError) =&gt;
    Effect.succeed(&quot;Recovering from HttpError&quot;)
  )
)
</code></pre>
<p>In the example above, the <code>Effect.catchTag</code> function allows us to handle <code>HttpError</code> specifically.
If a <code>HttpError</code> occurs during the execution of the program, the provided error handler function will be invoked,
and the program will proceed with the recovery logic specified within the handler.</p>
<p>We can observe that the type in the error channel of our program has changed to only show <code>ValidationError</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, ValidationError, never&gt;
</code></pre>
<p>indicating that <code>HttpError</code> has been handled.</p>
<p>If we also wanted to handle <code>ValidationError</code>, we can simply add another <code>catchTag</code>:</p>
<p><strong>Example</strong> (Handling Multiple Error Types with <code>catchTag</code>)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = program.pipe(
  // Handle both HttpError and ValidationError
  Effect.catchTag(&quot;HttpError&quot;, (_HttpError) =&gt;
    Effect.succeed(&quot;Recovering from HttpError&quot;)
  ),
  Effect.catchTag(&quot;ValidationError&quot;, (_ValidationError) =&gt;
    Effect.succeed(&quot;Recovering from ValidationError&quot;)
  )
)
</code></pre>
<p>We can observe that the type in the error channel of our program has changed to <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Effect&lt;string, never, never&gt;
</code></pre>
<p>indicating that all errors have been handled.</p>
<Aside type="caution" title="Error Type Requirement">
  The error type must have a readonly `_tag` field to use `catchTag`. This
  field is used to identify and match errors.
</Aside>

<h3>catchTags</h3>
<p>Handles multiple errors in a single block of code using their <code>_tag</code> field.</p>
<p><code>Effect.catchTags</code> is a convenient way to handle multiple error types at
once. Instead of using <a href="#catchtag"><code>Effect.catchTag</code></a> multiple times, you can pass an
object where each key is an error type&#39;s <code>_tag</code>, and the value is the handler
for that specific error. This allows you to catch and recover from multiple
error types in a single call.</p>
<p><strong>Example</strong> (Handling Multiple Tagged Error Types at Once)</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Effect&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 &lt; 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 &lt; 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return &quot;some result&quot;
})

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) =&gt;
      Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) =&gt;
      Effect.succeed(`Recovering from ValidationError`)
  })
)
</code></pre>
<p>This function takes an object where each property represents a specific error <code>_tag</code> (<code>&quot;HttpError&quot;</code> and <code>&quot;ValidationError&quot;</code> in this case),
and the corresponding value is the error handler function to be executed when that particular error occurs.</p>
<Aside type="caution" title="Error Type Requirement">
  The error type must have a readonly `_tag` field to use `catchTag`. This
  field is used to identify and match errors.
</Aside>


<hr>
<hr>
<h2>title: Fallback
description: Learn techniques to handle failures and implement fallback mechanisms in Effect programs.
sidebar:
  order: 3</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>This page explains various techniques for handling failures and creating fallback mechanisms in the Effect library.</p>
<h2>orElse</h2>
<p><code>Effect.orElse</code> allows you to attempt to run an effect, and if it fails, you
can provide a fallback effect to run instead.</p>
<p>This is useful for handling failures gracefully by defining an alternative effect to execute if the first
one encounters an error.</p>
<p><strong>Example</strong> (Handling Fallback with <code>Effect.orElse</code>)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const success = Effect.succeed(&quot;success&quot;)
const failure = Effect.fail(&quot;failure&quot;)
const fallback = Effect.succeed(&quot;fallback&quot;)

// Try the success effect first, fallback is not used
const program1 = Effect.orElse(success, () =&gt; fallback)
console.log(Effect.runSync(program1))
// Output: &quot;success&quot;

// Try the failure effect first, fallback is used
const program2 = Effect.orElse(failure, () =&gt; fallback)
console.log(Effect.runSync(program2))
// Output: &quot;fallback&quot;
</code></pre>
<h2>orElseFail</h2>
<p><code>Effect.orElseFail</code> allows you to replace the failure from one effect with a
custom failure value. If the effect fails, you can provide a new failure to
be returned instead of the original one.</p>
<p>This function only applies to failed effects. If the effect
succeeds, it will remain unaffected.</p>
<p><strong>Example</strong> (Replacing Failure with <code>Effect.orElseFail</code>)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const validate = (age: number): Effect.Effect&lt;number, string&gt; =&gt; {
  if (age &lt; 0) {
    return Effect.fail(&quot;NegativeAgeError&quot;)
  } else if (age &lt; 18) {
    return Effect.fail(&quot;IllegalAgeError&quot;)
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () =&gt; &quot;invalid age&quot;)

console.log(Effect.runSyncExit(program))
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;invalid age&#39; }
}
*/
</code></pre>
<h2>orElseSucceed</h2>
<p><code>Effect.orElseSucceed</code> allows you to replace the failure of an effect with a
success value. If the effect fails, it will instead succeed with the provided
value, ensuring the effect always completes successfully.</p>
<p>This is useful when you want to guarantee a successful result regardless of whether the original
effect failed.</p>
<p>The function ensures that any failure is effectively &quot;swallowed&quot; and replaced
by a successful value, which can be helpful for providing default values in
case of failure.</p>
<p>This function only applies to failed effects. If the effect
already succeeds, it will remain unchanged.</p>
<p><strong>Example</strong> (Replacing Failure with Success using <code>Effect.orElseSucceed</code>)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const validate = (age: number): Effect.Effect&lt;number, string&gt; =&gt; {
  if (age &lt; 0) {
    return Effect.fail(&quot;NegativeAgeError&quot;)
  } else if (age &lt; 18) {
    return Effect.fail(&quot;IllegalAgeError&quot;)
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () =&gt; 18)

console.log(Effect.runSyncExit(program))
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: 18 }
*/
</code></pre>
<h2>firstSuccessOf</h2>
<p><code>Effect.firstSuccessOf</code> allows you to try multiple effects in sequence, and
as soon as one of them succeeds, it returns that result. If all effects fail,
it returns the error of the last effect in the list.</p>
<p>This is useful when you
have several potential alternatives and want to use the first one that works.</p>
<p>This function is sequential, meaning that the <code>Effect</code> values in the iterable
will be executed in sequence, and the first one that succeeds will determine
the outcome of the resulting <code>Effect</code> value.</p>
<Aside type="caution" title="Empty Collection Error">
  If the collection provided to the `Effect.firstSuccessOf` function is
  empty, it will throw an `IllegalArgumentException` error.
</Aside>

<p><strong>Example</strong> (Finding Configuration with Fallbacks)</p>
<p>In this example, we try to retrieve a configuration from different nodes. If the primary node fails, we fall back to other nodes until we find a successful configuration.</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

interface Config {
  host: string
  port: number
  apiKey: string
}

// Create a configuration object with sample values
const makeConfig = (name: string): Config =&gt; ({
  host: `${name}.example.com`,
  port: 8080,
  apiKey: &quot;12345-abcde&quot;
})

// Simulate retrieving configuration from a remote node
const remoteConfig = (name: string): Effect.Effect&lt;Config, Error&gt; =&gt;
  Effect.gen(function* () {
    // Simulate node3 being the only one with available config
    if (name === &quot;node3&quot;) {
      yield* Console.log(`Config for ${name} found`)
      return makeConfig(name)
    } else {
      yield* Console.log(`Unavailable config for ${name}`)
      return yield* Effect.fail(new Error(`Config not found for ${name}`))
    }
  })

// Define the master configuration and potential fallback nodes
const masterConfig = remoteConfig(&quot;master&quot;)
const nodeConfigs = [&quot;node1&quot;, &quot;node2&quot;, &quot;node3&quot;, &quot;node4&quot;].map(remoteConfig)

// Attempt to find a working configuration,
// starting with the master and then falling back to other nodes
const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])

// Run the effect to retrieve the configuration
const result = Effect.runSync(config)

console.log(result)
/*
Output:
Unavailable config for master
Unavailable config for node1
Unavailable config for node2
Config for node3 found
{ host: &#39;node3.example.com&#39;, port: 8080, apiKey: &#39;12345-abcde&#39; }
*/
</code></pre>
<hr>
<hr>
<h2>title: Matching
description: Learn to handle success and failure cases in Effect programs with tools for pattern matching, value ignoring, side effects, and precise failure analysis.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In the Effect module, similar to other modules like <a href="/docs/data-types/option/#pattern-matching">Option</a> and <a href="/docs/data-types/exit/#pattern-matching">Exit</a>, we have a <code>Effect.match</code> function that allows us to handle different cases simultaneously.
Additionally, Effect provides various functions to manage both success and failure scenarios in effectful programs.</p>
<h2>match</h2>
<p><code>Effect.match</code> lets you define custom handlers for both success and failure
scenarios. You provide separate functions to handle each case, allowing you
to process the result if the effect succeeds, or handle the error if the
effect fails.</p>
<p>This is useful for structuring your code to respond differently to success or failure without triggering side effects.</p>
<p><strong>Example</strong> (Handling Both Success and Failure Cases)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const success: Effect.Effect&lt;number, Error&gt; = Effect.succeed(42)

const program1 = Effect.match(success, {
  onFailure: (error) =&gt; `failure: ${error.message}`,
  onSuccess: (value) =&gt; `success: ${value}`
})

// Run and log the result of the successful effect
Effect.runPromise(program1).then(console.log)
// Output: &quot;success: 42&quot;

const failure: Effect.Effect&lt;number, Error&gt; = Effect.fail(
  new Error(&quot;Uh oh!&quot;)
)

const program2 = Effect.match(failure, {
  onFailure: (error) =&gt; `failure: ${error.message}`,
  onSuccess: (value) =&gt; `success: ${value}`
})

// Run and log the result of the failed effect
Effect.runPromise(program2).then(console.log)
// Output: &quot;failure: Uh oh!&quot;
</code></pre>
<h2>ignore</h2>
<p><code>Effect.ignore</code> allows you to run an effect without caring about its result,
whether it succeeds or fails.</p>
<p>This is useful when you only care about the side effects of the effect and do not need to handle or process its outcome.</p>
<p><strong>Example</strong> (Using <code>Effect.ignore</code> to Discard Values)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, string, never&gt;
//      ▼
const task = Effect.fail(&quot;Uh oh!&quot;).pipe(Effect.as(5))

//      ┌─── Effect&lt;void, never, never&gt;
//      ▼
const program = Effect.ignore(task)
</code></pre>
<h2>matchEffect</h2>
<p>The <code>Effect.matchEffect</code> function is similar to <a href="#match">Effect.match</a>, but it
enables you to perform side effects in the handlers for both success and
failure outcomes.</p>
<p>This is useful when you need to execute additional actions,
like logging or notifying users, based on whether an effect succeeds or
fails.</p>
<p><strong>Example</strong> (Handling Success and Failure with Side Effects)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const success: Effect.Effect&lt;number, Error&gt; = Effect.succeed(42)
const failure: Effect.Effect&lt;number, Error&gt; = Effect.fail(
  new Error(&quot;Uh oh!&quot;)
)

const program1 = Effect.matchEffect(success, {
  onFailure: (error) =&gt;
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =&gt;
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program1))
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;success: 42&quot;
success: 42
*/

const program2 = Effect.matchEffect(failure, {
  onFailure: (error) =&gt;
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =&gt;
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program2))
/*
Output:
timestamp=... level=INFO fiber=#1 message=&quot;failure: Uh oh!&quot;
failure: Uh oh!
*/
</code></pre>
<h2>matchCause</h2>
<p>The <code>Effect.matchCause</code> function allows you to handle failures with access to
the full <a href="/docs/data-types/cause/">cause</a> of the failure within a fiber.</p>
<p>This is useful for differentiating between different types of errors, such as regular failures,
defects, or interruptions. You can provide specific handling logic for each
failure type based on the cause.</p>
<p><strong>Example</strong> (Handling Different Failure Causes)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task: Effect.Effect&lt;number, Error&gt; = Effect.die(&quot;Uh oh!&quot;)

const program = Effect.matchCause(task, {
  onFailure: (cause) =&gt; {
    switch (cause._tag) {
      case &quot;Fail&quot;:
        // Handle standard failure
        return `Fail: ${cause.error.message}`
      case &quot;Die&quot;:
        // Handle defects (unexpected errors)
        return `Die: ${cause.defect}`
      case &quot;Interrupt&quot;:
        // Handle interruption
        return `${cause.fiberId} interrupted!`
    }
    // Fallback for other causes
    return &quot;failed due to other causes&quot;
  },
  onSuccess: (value) =&gt;
    // task completes successfully
    `succeeded with ${value} value`
})

Effect.runPromise(program).then(console.log)
// Output: &quot;Die: Uh oh!&quot;
</code></pre>
<h2>matchCauseEffect</h2>
<p>The <code>Effect.matchCauseEffect</code> function works similarly to <a href="#matchcause">Effect.matchCause</a>,
but it also allows you to perform additional side effects based on the
failure cause.</p>
<p>This function provides access to the complete <a href="/docs/data-types/cause/">cause</a> of the
failure, making it possible to differentiate between various failure types,
and allows you to respond accordingly while performing side effects (like
logging or other operations).</p>
<p><strong>Example</strong> (Handling Different Failure Causes with Side Effects)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task: Effect.Effect&lt;number, Error&gt; = Effect.die(&quot;Uh oh!&quot;)

const program = Effect.matchCauseEffect(task, {
  onFailure: (cause) =&gt; {
    switch (cause._tag) {
      case &quot;Fail&quot;:
        // Handle standard failure with a logged message
        return Console.log(`Fail: ${cause.error.message}`)
      case &quot;Die&quot;:
        // Handle defects (unexpected errors) by logging the defect
        return Console.log(`Die: ${cause.defect}`)
      case &quot;Interrupt&quot;:
        // Handle interruption and log the fiberId that was interrupted
        return Console.log(`${cause.fiberId} interrupted!`)
    }
    // Fallback for other causes
    return Console.log(&quot;failed due to other causes&quot;)
  },
  onSuccess: (value) =&gt;
    // Log success if the task completes successfully
    Console.log(`succeeded with ${value} value`)
})

Effect.runPromise(program)
// Output: &quot;Die: Uh oh!&quot;
</code></pre>
<hr>
<hr>
<h2>title: Parallel and Sequential Errors
description: Handle concurrent and sequential errors in Effect programs, capturing multiple failures and ensuring robust error management in concurrent and sequential workflows.
sidebar:
  order: 10</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>When working with Effect, if an error occurs, the default behavior is to fail with the first error encountered.</p>
<p><strong>Example</strong> (Failing on the First Error)</p>
<p>Here, the program fails with the first error it encounters, <code>&quot;Oh uh!&quot;</code>.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const fail = Effect.fail(&quot;Oh uh!&quot;)
const die = Effect.dieMessage(&quot;Boom!&quot;)

// Run both effects sequentially
const program = Effect.all([fail, die])

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh uh!&#39; }
}
*/
</code></pre>
<h2>Parallel Errors</h2>
<p>In some cases, you might encounter multiple errors, especially during concurrent computations. When tasks are run concurrently, multiple errors can happen at the same time.</p>
<p><strong>Example</strong> (Handling Multiple Errors in Concurrent Computations)</p>
<p>In this example, both the <code>fail</code> and <code>die</code> effects are executed concurrently. Since both fail, the program will report multiple errors in the output.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const fail = Effect.fail(&quot;Oh uh!&quot;)
const die = Effect.dieMessage(&quot;Boom!&quot;)

// Run both effects concurrently
const program = Effect.all([fail, die], {
  concurrency: &quot;unbounded&quot;
}).pipe(Effect.asVoid)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Parallel&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh uh!&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: [Object] }
  }
}
*/
</code></pre>
<h3>parallelErrors</h3>
<p>Effect provides a function called <code>Effect.parallelErrors</code> that captures all failure errors from concurrent operations in the error channel.</p>
<p><strong>Example</strong> (Capturing Multiple Concurrent Failures)</p>
<p>In this example, <code>Effect.parallelErrors</code> combines the errors from <code>fail1</code> and <code>fail2</code> into a single error.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const fail1 = Effect.fail(&quot;Oh uh!&quot;)
const fail2 = Effect.fail(&quot;Oh no!&quot;)
const die = Effect.dieMessage(&quot;Boom!&quot;)

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: &quot;unbounded&quot;
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: [ &#39;Oh uh!&#39;, &#39;Oh no!&#39; ] }
}
*/
</code></pre>
<Aside type="note" title="Applicability">
  Note that `Effect.parallelErrors` is only for failures, not defects or
  interruptions.
</Aside>

<h2>Sequential Errors</h2>
<p>When working with resource-safety operators like <code>Effect.ensuring</code>, you may encounter multiple sequential errors.
This happens because regardless of whether the original effect has any errors or not, the finalizer is uninterruptible and will always run.</p>
<p><strong>Example</strong> (Handling Multiple Sequential Errors)</p>
<p>In this example, both <code>fail</code> and the finalizer <code>die</code> result in sequential errors, and both are captured.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Simulate an effect that fails
const fail = Effect.fail(&quot;Oh uh!&quot;)

// Simulate a finalizer that causes a defect
const die = Effect.dieMessage(&quot;Boom!&quot;)

// The finalizer &#39;die&#39; will always run, even if &#39;fail&#39; fails
const program = fail.pipe(Effect.ensuring(die))

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Sequential&#39;,
    left: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh uh!&#39; },
    right: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: [Object] }
  }
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Retrying
description: Enhance resilience with Effect&#39;s retrying strategies, enabling robust handling of transient failures with customizable retry policies and fallback mechanisms.
sidebar:
  order: 5</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In software development, it&#39;s common to encounter situations where an operation may fail temporarily due to various factors such as network issues, resource unavailability, or external dependencies. In such cases, it&#39;s often desirable to retry the operation automatically, allowing it to succeed eventually.</p>
<p>Retrying is a powerful mechanism to handle transient failures and ensure the successful execution of critical operations. In Effect retrying is made simple and flexible with built-in functions and scheduling strategies.</p>
<p>In this guide, we will explore the concept of retrying in Effect and learn how to use the <code>retry</code> and <code>retryOrElse</code> functions to handle failure scenarios. We&#39;ll see how to define retry policies using schedules, which dictate when and how many times the operation should be retried.</p>
<p>Whether you&#39;re working on network requests, database interactions, or any other potentially error-prone operations, mastering the retrying capabilities of effect can significantly enhance the resilience and reliability of your applications.</p>
<h2>retry</h2>
<p>The <code>Effect.retry</code> function takes an effect and a <a href="/docs/scheduling/introduction/">Schedule</a> policy, and will automatically retry the effect if it fails, following the rules of the policy.</p>
<p>If the effect ultimately succeeds, the result will be returned.</p>
<p>If the maximum retries are exhausted and the effect still fails, the failure is propagated.</p>
<p>This can be useful when dealing with intermittent failures, such as network issues or temporary resource unavailability. By defining a retry policy, you can control the number of retries, the delay between them, and when to stop retrying.</p>
<p><strong>Example</strong> (Retrying with a Fixed Delay)</p>
<pre><code class="language-ts">import { Effect, Schedule } from &quot;effect&quot;

let count = 0

// Simulates an effect with possible failures
const task = Effect.async&lt;string, Error&gt;((resume) =&gt; {
  if (count &lt;= 2) {
    count++
    console.log(&quot;failure&quot;)
    resume(Effect.fail(new Error()))
  } else {
    console.log(&quot;success&quot;)
    resume(Effect.succeed(&quot;yay!&quot;))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.fixed(&quot;100 millis&quot;)

const repeated = Effect.retry(task, policy)

Effect.runPromise(repeated).then(console.log)
/*
Output:
failure
failure
failure
success
yay!
*/
</code></pre>
<h3>Retrying n Times Immediately</h3>
<p>You can also retry a failing effect a set number of times with a simpler policy that retries immediately:</p>
<p><strong>Example</strong> (Retrying a Task up to 5 times)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

let count = 0

// Simulates an effect with possible failures
const task = Effect.async&lt;string, Error&gt;((resume) =&gt; {
  if (count &lt;= 2) {
    count++
    console.log(&quot;failure&quot;)
    resume(Effect.fail(new Error()))
  } else {
    console.log(&quot;success&quot;)
    resume(Effect.succeed(&quot;yay!&quot;))
  }
})

// Retry the task up to 5 times
Effect.runPromise(Effect.retry(task, { times: 5 }))
/*
Output:
failure
failure
failure
success
*/
</code></pre>
<h3>Retrying Based on a Condition</h3>
<p>You can customize how retries are managed by specifying conditions. Use the <code>until</code> or <code>while</code> options to control when retries stop.</p>
<p><strong>Example</strong> (Retrying Until a Specific Condition is Met)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

let count = 0

// Define an effect that simulates varying error on each invocation
const action = Effect.failSync(() =&gt; {
  console.log(`Action called ${++count} time(s)`)
  return `Error ${count}`
})

// Retry the action until a specific condition is met
const program = Effect.retry(action, {
  until: (err) =&gt; err === &quot;Error 3&quot;
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Action called 1 time(s)
Action called 2 time(s)
Action called 3 time(s)
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Error 3&#39; }
}
*/
</code></pre>
<Aside type="tip" title="Alternative">
  You can also use
  [Effect.repeat](/docs/scheduling/repetition/#repeating-based-on-a-condition)
  if your retry condition is based on successful outcomes rather than
  errors.
</Aside>

<h2>retryOrElse</h2>
<p>The <code>Effect.retryOrElse</code> function attempts to retry a failing effect multiple times according to a defined <a href="/docs/scheduling/introduction/">Schedule</a> policy.</p>
<p>If the retries are exhausted and the effect still fails, it runs a fallback effect instead.</p>
<p>This function is useful when you want to handle failures gracefully by specifying an alternative action after repeated failures.</p>
<p><strong>Example</strong> (Retrying with Fallback)</p>
<pre><code class="language-ts">import { Effect, Schedule, Console } from &quot;effect&quot;

let count = 0

// Simulates an effect with possible failures
const task = Effect.async&lt;string, Error&gt;((resume) =&gt; {
  if (count &lt;= 2) {
    count++
    console.log(&quot;failure&quot;)
    resume(Effect.fail(new Error()))
  } else {
    console.log(&quot;success&quot;)
    resume(Effect.succeed(&quot;yay!&quot;))
  }
})

// Retry the task with a delay between retries and a maximum of 2 retries
const policy = Schedule.addDelay(Schedule.recurs(2), () =&gt; &quot;100 millis&quot;)

// If all retries fail, run the fallback effect
const repeated = Effect.retryOrElse(
  task,
  policy,
  // fallback
  () =&gt; Console.log(&quot;orElse&quot;).pipe(Effect.as(&quot;default value&quot;))
)

Effect.runPromise(repeated).then(console.log)
/*
Output:
failure
failure
failure
orElse
default value
*/
</code></pre>
<hr>
<hr>
<h2>title: Sandboxing
description: Master error handling in Effect with sandboxing, enabling detailed inspection and recovery from failures, defects, and interruptions.
sidebar:
  order: 7</h2>
<p>Errors are an inevitable part of programming, and they can arise from various sources like failures, defects, fiber interruptions, or combinations of these. This guide explains how to use the <code>Effect.sandbox</code> function to isolate and understand the causes of errors in your Effect-based code.</p>
<h2>sandbox / unsandbox</h2>
<p>The <code>Effect.sandbox</code> function allows you to encapsulate all the potential causes of an error in an effect. It exposes the full cause of an effect, whether it&#39;s due to a failure, defect, fiber interruption, or a combination of these factors.</p>
<p>In simple terms, it takes an effect <code>Effect&lt;A, E, R&gt;</code> and transforms it into an effect <code>Effect&lt;A, Cause&lt;E&gt;, R&gt;</code> where the error channel now contains a detailed cause of the error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Effect&lt;A, E, R&gt; -&gt; Effect&lt;A, Cause&lt;E&gt;, R&gt;
</code></pre>
<p>By using the <code>Effect.sandbox</code> function, you gain access to the underlying causes of exceptional effects. These causes are represented as a type of <code>Cause&lt;E&gt;</code> and are available in the error channel of the <code>Effect</code> data type.</p>
<p>Once you have exposed the causes, you can utilize standard error-handling operators like <a href="/docs/error-management/expected-errors/#catchall">Effect.catchAll</a> and <a href="/docs/error-management/expected-errors/#catchtags">Effect.catchTags</a> to handle errors more effectively. These operators allow you to respond to specific error conditions.</p>
<p>If needed, we can undo the sandboxing operation with <code>Effect.unsandbox</code>.</p>
<p><strong>Example</strong> (Handling Different Error Causes)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;string, Error, never&gt;
//      ▼
const task = Effect.fail(new Error(&quot;Oh uh!&quot;)).pipe(
  Effect.as(&quot;primary result&quot;)
)

//      ┌─── Effect&lt;string, Cause&lt;Error&gt;, never&gt;
//      ▼
const sandboxed = Effect.sandbox(task)

const program = Effect.catchTags(sandboxed, {
  Die: (cause) =&gt;
    Console.log(`Caught a defect: ${cause.defect}`).pipe(
      Effect.as(&quot;fallback result on defect&quot;)
    ),
  Interrupt: (cause) =&gt;
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
      Effect.as(&quot;fallback result on fiber interruption&quot;)
    ),
  Fail: (cause) =&gt;
    Console.log(`Caught a defect: ${cause.error}`).pipe(
      Effect.as(&quot;fallback result on failure&quot;)
    )
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

Effect.runPromise(main).then(console.log)
/*
Output:
Caught a defect: Oh uh!
fallback result on failure
*/
</code></pre>
<hr>
<hr>
<h2>title: Timing Out
description: Set time limits on operations with Effect, ensuring tasks complete within specified durations and customizing behavior for timeouts.
sidebar:
  order: 6</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In programming, it&#39;s common to deal with tasks that may take some time to complete. Often, we want to enforce a limit on how long we&#39;re willing to wait for these tasks. The <code>Effect.timeout</code> function helps by placing a time constraint on an operation, ensuring it doesn&#39;t run indefinitely.</p>
<h2>Basic Usage</h2>
<h3>timeout</h3>
<p>The <code>Effect.timeout</code> function employs a <a href="/docs/data-types/duration/">Duration</a> parameter to establish a time limit on an operation. If the operation exceeds this limit, a <code>TimeoutException</code> is triggered, indicating a timeout has occurred.</p>
<p><strong>Example</strong> (Setting a Timeout)</p>
<p>Here, the task completes within the timeout duration, so the result is returned successfully.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

// Sets a 3-second timeout for the task
const timedEffect = task.pipe(Effect.timeout(&quot;3 seconds&quot;))

// Output will show that the task completes successfully
// as it falls within the timeout duration
Effect.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
Processing complete.
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;Result&#39; }
*/
</code></pre>
<p>If the operation exceeds the specified duration, a <code>TimeoutException</code> is raised:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout(&quot;1 second&quot;))

Effect.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: { _tag: &#39;TimeoutException&#39; }
  }
}
*/
</code></pre>
<h3>timeoutOption</h3>
<p>If you want to handle timeouts more gracefully, consider using <code>Effect.timeoutOption</code>. This function treats timeouts as regular results, wrapping the outcome in an <a href="/docs/data-types/option/">Option</a>.</p>
<p><strong>Example</strong> (Handling Timeout as an Option)</p>
<p>In this example, the first task completes successfully, while the second times out. The result of the timed-out task is represented as <code>None</code> in the <code>Option</code> type.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption(&quot;3 seconds&quot;)),
  task.pipe(Effect.timeoutOption(&quot;1 second&quot;))
])

Effect.runPromise(timedOutEffect).then(console.log)
/*
Output:
Start processing...
Processing complete.
Start processing...
[
  { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;Result&#39; },
  { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
]
*/
</code></pre>
<h2>Handling Timeouts</h2>
<p>When an operation does not finish within the specified duration, the behavior of the <code>Effect.timeout</code> depends on whether the operation is &quot;uninterruptible&quot;.</p>
<Aside type="note" title="Uninterruptible Effects">
  An uninterruptible effect is one that, once started, cannot be stopped
  mid-execution by the timeout mechanism directly. This could be because
  the operations within the effect need to run to completion to avoid
  leaving the system in an inconsistent state.
</Aside>

<ol>
<li><p><strong>Interruptible Operation</strong>: If the operation can be interrupted, it is terminated immediately once the timeout threshold is reached, resulting in a <code>TimeoutException</code>.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const timedEffect = task.pipe(Effect.timeout(&quot;1 second&quot;))

Effect.runPromiseExit(timedEffect).then(console.log)
/*
 Output:
 Start processing...
 {
   _id: &#39;Exit&#39;,
   _tag: &#39;Failure&#39;,
   cause: {
     _id: &#39;Cause&#39;,
     _tag: &#39;Fail&#39;,
     failure: { _tag: &#39;TimeoutException&#39; }
   }
 }
 */
</code></pre>
</li>
<li><p><strong>Uninterruptible Operation</strong>: If the operation is uninterruptible, it continues until completion before the <code>TimeoutException</code> is assessed.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const timedEffect = task.pipe(
  Effect.uninterruptible,
  Effect.timeout(&quot;1 second&quot;)
)

// Outputs a TimeoutException after the task completes,
// because the task is uninterruptible
Effect.runPromiseExit(timedEffect).then(console.log)
/*
 Output:
 Start processing...
 Processing complete.
 {
   _id: &#39;Exit&#39;,
   _tag: &#39;Failure&#39;,
   cause: {
     _id: &#39;Cause&#39;,
     _tag: &#39;Fail&#39;,
     failure: { _tag: &#39;TimeoutException&#39; }
   }
 }
 */
</code></pre>
</li>
</ol>
<h2>Disconnection on Timeout</h2>
<p>The <code>Effect.disconnect</code> function provides a way to handle timeouts in uninterruptible effects more flexibly. It allows an uninterruptible effect to complete in the background, while the main control flow proceeds as if a timeout had occurred.</p>
<p>Here&#39;s the distinction:</p>
<p><strong>Without</strong> <code>Effect.disconnect</code>:</p>
<ul>
<li>An uninterruptible effect will ignore the timeout and continue executing until it completes, after which the timeout error is assessed.</li>
<li>This can lead to delays in recognizing a timeout condition because the system must wait for the effect to complete.</li>
</ul>
<p><strong>With</strong> <code>Effect.disconnect</code>:</p>
<ul>
<li>The uninterruptible effect is allowed to continue in the background, independent of the main control flow.</li>
<li>The main control flow recognizes the timeout immediately and proceeds with the timeout error or alternative logic, without having to wait for the effect to complete.</li>
<li>This method is particularly useful when the operations of the effect do not need to block the continuation of the program, despite being marked as uninterruptible.</li>
</ul>
<p><strong>Example</strong> (Running Uninterruptible Tasks with Timeout and Background Completion)</p>
<p>Consider a scenario where a long-running data processing task is initiated, and you want to ensure the system remains responsive, even if the data processing takes too long:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const longRunningTask = Effect.gen(function* () {
  console.log(&quot;Start heavy processing...&quot;)
  yield* Effect.sleep(&quot;5 seconds&quot;) // Simulate a long process
  console.log(&quot;Heavy processing done.&quot;)
  return &quot;Data processed&quot;
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout(&quot;1 second&quot;)
)

Effect.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start heavy processing...
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: { _tag: &#39;TimeoutException&#39; }
  }
}
Heavy processing done.
*/
</code></pre>
<p>In this example, the system detects the timeout after one second, but the long-running task continues and completes in the background, without blocking the program&#39;s flow.</p>
<h2>Customizing Timeout Behavior</h2>
<p>In addition to the basic <code>Effect.timeout</code> function, there are variations available that allow you to customize the behavior when a timeout occurs.</p>
<h3>timeoutFail</h3>
<p>The <code>Effect.timeoutFail</code> function allows you to produce a specific error when a timeout happens.</p>
<p><strong>Example</strong> (Custom Timeout Error)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

class MyTimeoutError {
  readonly _tag = &quot;MyTimeoutError&quot;
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: &quot;1 second&quot;,
    onTimeout: () =&gt; new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Start processing...
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: MyTimeoutError { _tag: &#39;MyTimeoutError&#39; }
  }
}
*/
</code></pre>
<h3>timeoutFailCause</h3>
<p><code>Effect.timeoutFailCause</code> lets you define a specific defect to throw when a timeout occurs. This is helpful for treating timeouts as exceptional cases in your code.</p>
<p><strong>Example</strong> (Custom Defect on Timeout)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: &quot;1 second&quot;,
    onTimeout: () =&gt; Cause.die(&quot;Timed out!&quot;) // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Start processing...
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: &#39;Timed out!&#39; }
}
*/
</code></pre>
<h3>timeoutTo</h3>
<p><code>Effect.timeoutTo</code> provides more flexibility compared to <code>Effect.timeout</code>, allowing you to define different outcomes for both successful and timed-out operations. This can be useful when you want to customize the result based on whether the operation completes in time or not.</p>
<p><strong>Example</strong> (Handling Success and Timeout with <a href="/docs/data-types/either/">Either</a>)</p>
<pre><code class="language-ts">import { Effect, Either } from &quot;effect&quot;

const task = Effect.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: &quot;1 second&quot;,
    onSuccess: (result): Either.Either&lt;string, string&gt; =&gt;
      Either.right(result),
    onTimeout: (): Either.Either&lt;string, string&gt; =&gt;
      Either.left(&quot;Timed out!&quot;)
  })
)

Effect.runPromise(program).then(console.log)
/*
Output:
Start processing...
{
  _id: &quot;Either&quot;,
  _tag: &quot;Left&quot;,
  left: &quot;Timed out!&quot;
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Two Types of Errors
description: Learn how Effect differentiates between expected and unexpected errors to enhance error tracking and recovery.
sidebar:
  order: 0</h2>
<p>Just like any other program, Effect programs may fail for expected or unexpected reasons.
The difference between a non-Effect program and an Effect program is in the detail provided to you when your program fails.
Effect attempts to preserve as much information as possible about what caused your program to fail to produce a detailed,
comprehensive, and human readable failure message.</p>
<p>In an Effect program, there are two possible ways for a program to fail:</p>
<ul>
<li><p><strong>Expected Errors</strong>: These are errors that developers anticipate and expect as part of normal program execution.</p>
</li>
<li><p><strong>Unexpected Errors</strong>: These are errors that occur unexpectedly and are not part of the intended program flow.</p>
</li>
</ul>
<h2>Expected Errors</h2>
<p>These errors, also referred to as <em>failures</em>, <em>typed errors</em>
or <em>recoverable errors</em>, are errors that developers anticipate as part of the normal program execution.
They serve a similar purpose to checked exceptions and play a role in defining the program&#39;s domain and control flow.</p>
<p>Expected errors <strong>are tracked</strong> at the type level by the <code>Effect</code> data type in the &quot;Error&quot; channel:</p>
<pre><code class="language-ts">const program: Effect&lt;string, HttpError, never&gt;
</code></pre>
<p>it is evident from the type that the program can fail with an error of type <code>HttpError</code>.</p>
<h2>Unexpected Errors</h2>
<p>Unexpected errors, also referred to as <em>defects</em>, <em>untyped errors</em>, or <em>unrecoverable errors</em>, are errors that developers
do not anticipate occurring during normal program execution.
Unlike expected errors, which are considered part of a program&#39;s domain and control flow,
unexpected errors resemble unchecked exceptions and lie outside the expected behavior of the program.</p>
<p>Since these errors are not expected, Effect <strong>does not track</strong> them at the type level.
However, the Effect runtime does keep track of these errors and provides several methods to aid in recovering from unexpected errors.</p>
<hr>
<hr>
<h2>title: Unexpected Errors
description: Understand how Effect handles unexpected errors with tools to manage defects, terminate execution, and selectively recover from critical failures.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>There are situations where you may encounter unexpected errors, and you need to decide how to handle them. Effect provides functions to help you deal with such scenarios, allowing you to take appropriate actions when errors occur during the execution of your effects.</p>
<h2>Creating Unrecoverable Errors</h2>
<p>In the same way it is possible to leverage combinators such as <a href="/docs/getting-started/creating-effects/#fail">Effect.fail</a> to create values of type <code>Effect&lt;never, E, never&gt;</code> the Effect library provides tools to create defects.</p>
<p>Creating defects is a common necessity when dealing with errors from which it is not possible to recover from a business logic perspective, such as attempting to establish a connection that is refused after multiple retries.</p>
<p>In those cases terminating the execution of the effect and moving into reporting, through an output such as stdout or some external monitoring service, might be the best solution.</p>
<p>The following functions and combinators allow for termination of the effect and are often used to convert values of type <code>Effect&lt;A, E, R&gt;</code> into values of type <code>Effect&lt;A, never, R&gt;</code> allowing the programmer an escape hatch from having to handle and recover from errors for which there is no sensible way to recover.</p>
<h3>die</h3>
<p>Creates an effect that terminates a fiber with a specified error.</p>
<p>Use <code>Effect.die</code> when encountering unexpected conditions in your code that should
not be handled as regular errors but instead represent unrecoverable defects.</p>
<p>The <code>Effect.die</code> function is used to signal a defect, which represents a critical
and unexpected error in the code. When invoked, it produces an effect that
does not handle the error and instead terminates the fiber.</p>
<p>The error channel of the resulting effect is of type <code>never</code>, indicating that
it cannot recover from this failure.</p>
<p><strong>Example</strong> (Terminating on Division by Zero with a Specified Error)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (a: number, b: number) =&gt;
  b === 0
    ? Effect.die(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
/*
Output:
(FiberFailure) Error: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h3>dieMessage</h3>
<p>Creates an effect that terminates a fiber with a <code>RuntimeException</code> containing the specified message.</p>
<p>Use <code>Effect.dieMessage</code> when you want to terminate a fiber due to an unrecoverable
defect and include a clear explanation in the message.</p>
<p>The <code>Effect.dieMessage</code> function is used to signal a defect, representing a critical
and unexpected error in the code. When invoked, it produces an effect that
terminates the fiber with a <code>RuntimeException</code> carrying the given message.</p>
<p>The resulting effect has an error channel of type <code>never</code>, indicating it does
not handle or recover from the error.</p>
<p><strong>Example</strong> (Terminating on Division by Zero with a Specified Message)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (a: number, b: number) =&gt;
  b === 0
    ? Effect.dieMessage(&quot;Cannot divide by zero&quot;)
    : Effect.succeed(a / b)

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
/*
Output:
(FiberFailure) RuntimeException: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h2>Converting Failures to Defects</h2>
<h3>orDie</h3>
<p>Converts an effect&#39;s failure into a fiber termination, removing the error from the effect&#39;s type.</p>
<p>Use <code>Effect.orDie</code> when failures should be treated as unrecoverable defects and no error handling is required.</p>
<p>The <code>Effect.orDie</code> function is used when you encounter errors that you do not want to handle or recover from.
It removes the error type from the effect and ensures that any failure will terminate the fiber.
This is useful for propagating failures as defects, signaling that they should not be handled within the effect.</p>
<p><strong>Example</strong> (Propagating an Error as a Defect)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (a: number, b: number) =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const program = Effect.orDie(divide(1, 0))

Effect.runPromise(program).catch(console.error)
/*
Output:
(FiberFailure) Error: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h3>orDieWith</h3>
<p>Converts an effect&#39;s failure into a fiber termination with a custom error.</p>
<p>Use <code>Effect.orDieWith</code> when failures should terminate the fiber as defects, and you want to customize
the error for clarity or debugging purposes.</p>
<p>The <code>Effect.orDieWith</code> function behaves like <a href="#ordie">Effect.orDie</a>, but it allows you to provide a mapping
function to transform the error before terminating the fiber. This is useful for cases where
you want to include a more detailed or user-friendly error when the failure is propagated
as a defect.</p>
<p><strong>Example</strong> (Customizing Defect)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (a: number, b: number) =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const program = Effect.orDieWith(
  divide(1, 0),
  (error) =&gt; new Error(`defect: ${error.message}`)
)

Effect.runPromise(program).catch(console.error)
/*
Output:
(FiberFailure) Error: defect: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h2>Catching All Defects</h2>
<p>There is no sensible way to recover from defects. The functions we&#39;re
about to discuss should be used only at the boundary between Effect and
an external system, to transmit information on a defect for diagnostic
or explanatory purposes.</p>
<h3>exit</h3>
<p>The <code>Effect.exit</code> function transforms an <code>Effect&lt;A, E, R&gt;</code> into an effect that encapsulates both potential failure and success within an <a href="/docs/data-types/exit/">Exit</a> data type:</p>
<pre><code class="language-ts">Effect&lt;A, E, R&gt; -&gt; Effect&lt;Exit&lt;A, E&gt;, never, R&gt;
</code></pre>
<p>This means if you have an effect with the following type:</p>
<pre><code class="language-ts">Effect&lt;string, HttpError, never&gt;
</code></pre>
<p>and you call <code>Effect.exit</code> on it, the type becomes:</p>
<pre><code class="language-ts">Effect&lt;Exit&lt;string, HttpError&gt;, never, never&gt;
</code></pre>
<p>The resulting effect cannot fail because the potential failure is now represented within the <code>Exit</code>&#39;s <code>Failure</code> type.
The error type of the returned effect is specified as <code>never</code>, confirming that the effect is structured to not fail.</p>
<p>By yielding an <code>Exit</code>, we gain the ability to &quot;pattern match&quot; on this type to handle both failure and success cases within the generator function.</p>
<p><strong>Example</strong> (Catching Defects with <code>Effect.exit</code>)</p>
<pre><code class="language-ts">import { Effect, Cause, Console, Exit } from &quot;effect&quot;

// Simulating a runtime error
const task = Effect.dieMessage(&quot;Boom!&quot;)

const program = Effect.gen(function* () {
  const exit = yield* Effect.exit(task)
  if (Exit.isFailure(exit)) {
    const cause = exit.cause
    if (
      Cause.isDieType(cause) &amp;&amp;
      Cause.isRuntimeException(cause.defect)
    ) {
      yield* Console.log(
        `RuntimeException defect caught: ${cause.defect.message}`
      )
    } else {
      yield* Console.log(&quot;Unknown failure caught.&quot;)
    }
  }
})

// We get an Exit.Success because we caught all failures
Effect.runPromiseExit(program).then(console.log)
/*
Output:
RuntimeException defect caught: Boom!
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Success&quot;,
  value: undefined
}
*/
</code></pre>
<h3>catchAllDefect</h3>
<p>Recovers from all defects using a provided recovery function.</p>
<p><code>Effect.catchAllDefect</code> allows you to handle defects, which are unexpected errors
that usually cause the program to terminate. This function lets you recover
from these defects by providing a function that handles the error.</p>
<p>However, it does not handle expected errors (like those from <a href="/docs/getting-started/creating-effects/#fail">Effect.fail</a>) or
execution interruptions (like those from <a href="/docs/concurrency/basic-concurrency/#interrupt">Effect.interrupt</a>).</p>
<p><strong>Example</strong> (Handling All Defects)</p>
<pre><code class="language-ts">import { Effect, Cause, Console } from &quot;effect&quot;

// Simulating a runtime error
const task = Effect.dieMessage(&quot;Boom!&quot;)

const program = Effect.catchAllDefect(task, (defect) =&gt; {
  if (Cause.isRuntimeException(defect)) {
    return Console.log(
      `RuntimeException defect caught: ${defect.message}`
    )
  }
  return Console.log(&quot;Unknown defect caught.&quot;)
})

// We get an Exit.Success because we caught all defects
Effect.runPromiseExit(program).then(console.log)
/*
Output:
RuntimeException defect caught: Boom!
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Success&quot;,
  value: undefined
}
*/
</code></pre>
<Aside type="tip" title="When to Recover from Defects">
  Defects are unexpected errors that typically shouldn't be recovered
  from, as they often indicate serious issues. However, in some cases,
  such as dynamically loaded plugins, controlled recovery might be needed.
</Aside>

<h2>Catching Some Defects</h2>
<h3>catchSomeDefect</h3>
<p>Recovers from specific defects using a provided partial function.</p>
<p><code>Effect.catchSomeDefect</code> allows you to handle specific defects, which are
unexpected errors that can cause the program to stop. It uses a partial
function to catch only certain defects and ignores others.</p>
<p>However, it does not handle expected errors (like those from <a href="/docs/getting-started/creating-effects/#fail">Effect.fail</a>) or
execution interruptions (like those from <a href="/docs/concurrency/basic-concurrency/#interrupt">Effect.interrupt</a>).</p>
<p>The function provided to <code>Effect.catchSomeDefect</code> acts as a filter and a handler for defects:</p>
<ul>
<li>It receives the defect as an input.</li>
<li>If the defect matches a specific condition (e.g., a certain error type), the function returns
an <code>Option.some</code> containing the recovery logic.</li>
<li>If the defect does not match, the function returns <code>Option.none</code>, allowing the defect to propagate.</li>
</ul>
<p><strong>Example</strong> (Handling Specific Defects)</p>
<pre><code class="language-ts">import { Effect, Cause, Option, Console } from &quot;effect&quot;

// Simulating a runtime error
const task = Effect.dieMessage(&quot;Boom!&quot;)

const program = Effect.catchSomeDefect(task, (defect) =&gt; {
  if (Cause.isIllegalArgumentException(defect)) {
    return Option.some(
      Console.log(
        `Caught an IllegalArgumentException defect: ${defect.message}`
      )
    )
  }
  return Option.none()
})

// Since we are only catching IllegalArgumentException
// we will get an Exit.Failure because we simulated a runtime error.
Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Die&#39;,
    defect: { _tag: &#39;RuntimeException&#39; }
  }
}
*/
</code></pre>
<Aside type="tip" title="When to Recover from Defects">
  Defects are unexpected errors that typically shouldn't be recovered
  from, as they often indicate serious issues. However, in some cases,
  such as dynamically loaded plugins, controlled recovery might be needed.
</Aside>


<hr>
<hr>
<h2>title: Yieldable Errors
description: Explore yieldable errors in Effect programming for seamless error handling in generator functions using custom and tagged error constructors.
sidebar:
  order: 11</h2>
<p>Yieldable Errors are special types of errors that can be yielded directly within a generator function using <a href="/docs/getting-started/using-generators/">Effect.gen</a>.
These errors allow you to handle them intuitively, without needing to explicitly invoke <a href="/docs/getting-started/creating-effects/#fail">Effect.fail</a>. This simplifies how you manage custom errors in your code.</p>
<h2>Data.Error</h2>
<p>The <code>Data.Error</code> constructor provides a way to define a base class for yieldable errors.</p>
<p><strong>Example</strong> (Creating and Yielding a Custom Error)</p>
<pre><code class="language-ts">import { Effect, Data } from &quot;effect&quot;

// Define a custom error class extending Data.Error
class MyError extends Data.Error&lt;{ message: string }&gt; {}

export const program = Effect.gen(function* () {
  // Yield a custom error (equivalent to failing with MyError)
  yield* new MyError({ message: &quot;Oh no!&quot; })
})

Effect.runPromiseExit(program).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: { message: &#39;Oh no!&#39; } }
}
*/
</code></pre>
<h2>Data.TaggedError</h2>
<p>The <code>Data.TaggedError</code> constructor lets you define custom yieldable errors with unique tags. Each error has a <code>_tag</code> property, allowing you to easily distinguish between different error types. This makes it convenient to handle specific tagged errors using functions like <a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a> or <a href="/docs/error-management/expected-errors/#catchtags">Effect.catchTags</a>.</p>
<p><strong>Example</strong> (Handling Multiple Tagged Errors)</p>
<pre><code class="language-ts">import { Effect, Data, Random } from &quot;effect&quot;

// An error with _tag: &quot;Foo&quot;
class FooError extends Data.TaggedError(&quot;Foo&quot;)&lt;{
  message: string
}&gt; {}

// An error with _tag: &quot;Bar&quot;
class BarError extends Data.TaggedError(&quot;Bar&quot;)&lt;{
  randomNumber: number
}&gt; {}

const program = Effect.gen(function* () {
  const n = yield* Random.next
  return n &gt; 0.5
    ? &quot;yay!&quot;
    : n &lt; 0.2
    ? yield* new FooError({ message: &quot;Oh no!&quot; })
    : yield* new BarError({ randomNumber: n })
}).pipe(
  // Handle different tagged errors using catchTags
  Effect.catchTags({
    Foo: (error) =&gt; Effect.succeed(`Foo error: ${error.message}`),
    Bar: (error) =&gt; Effect.succeed(`Bar error: ${error.randomNumber}`)
  })
)

Effect.runPromise(program).then(console.log, console.error)
/*
Example Output (n &lt; 0.2):
Foo error: Oh no!
*/
</code></pre>
<hr>
<hr>
<h2>title: Building Pipelines
description: Learn to create modular, readable pipelines for composing and sequencing operations in Effect, enabling clear and efficient data transformations.
sidebar:
  order: 9</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Effect pipelines allow for the composition and sequencing of operations on values, enabling the transformation and manipulation of data in a concise and modular manner.</p>
<h2>Why Pipelines are Good for Structuring Your Application</h2>
<p>Pipelines are an excellent way to structure your application and handle data transformations in a concise and modular manner. They offer several benefits:</p>
<ol>
<li><p><strong>Readability</strong>: Pipelines allow you to compose functions in a readable and sequential manner. You can clearly see the flow of data and the operations applied to it, making it easier to understand and maintain the code.</p>
</li>
<li><p><strong>Code Organization</strong>: With pipelines, you can break down complex operations into smaller, manageable functions. Each function performs a specific task, making your code more modular and easier to reason about.</p>
</li>
<li><p><strong>Reusability</strong>: Pipelines promote the reuse of functions. By breaking down operations into smaller functions, you can reuse them in different pipelines or contexts, improving code reuse and reducing duplication.</p>
</li>
<li><p><strong>Type Safety</strong>: By leveraging the type system, pipelines help catch errors at compile-time. Functions in a pipeline have well-defined input and output types, ensuring that the data flows correctly through the pipeline and minimizing runtime errors.</p>
</li>
</ol>
<h2>Functions vs Methods</h2>
<p>The use of functions in the Effect ecosystem libraries is important for
achieving <strong>tree shakeability</strong> and ensuring <strong>extensibility</strong>.
Functions enable efficient bundling by eliminating unused code, and they
provide a flexible and modular approach to extending the libraries&#39;
functionality.</p>
<h3>Tree Shakeability</h3>
<p>Tree shakeability refers to the ability of a build system to eliminate unused code during the bundling process. Functions are tree shakeable, while methods are not.</p>
<p>When functions are used in the Effect ecosystem, only the functions that are actually imported and used in your application will be included in the final bundled code. Unused functions are automatically removed, resulting in a smaller bundle size and improved performance.</p>
<p>On the other hand, methods are attached to objects or prototypes, and they cannot be easily tree shaken. Even if you only use a subset of methods, all methods associated with an object or prototype will be included in the bundle, leading to unnecessary code bloat.</p>
<h3>Extensibility</h3>
<p>Another important advantage of using functions in the Effect ecosystem is the ease of extensibility. With methods, extending the functionality of an existing API often requires modifying the prototype of the object, which can be complex and error-prone.</p>
<p>In contrast, with functions, extending the functionality is much simpler. You can define your own &quot;extension methods&quot; as plain old functions without the need to modify the prototypes of objects. This promotes cleaner and more modular code, and it also allows for better compatibility with other libraries and modules.</p>
<h2>pipe</h2>
<p>The <code>pipe</code> function is a utility that allows us to compose functions in a readable and sequential manner. It takes the output of one function and passes it as the input to the next function in the pipeline. This enables us to build complex transformations by chaining multiple functions together.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">import { pipe } from &quot;effect&quot;

const result = pipe(input, func1, func2, ..., funcN)
</code></pre>
<p>In this syntax, <code>input</code> is the initial value, and <code>func1</code>, <code>func2</code>, ..., <code>funcN</code> are the functions to be applied in sequence. The result of each function becomes the input for the next function, and the final result is returned.</p>
<p>Here&#39;s an illustration of how <code>pipe</code> works:</p>
<pre><code class="language-text">┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌───────┐    ┌────────┐
│ input │───►│ func1 │───►│ func2 │───►│  ...  │───►│ funcN │───►│ result │
└───────┘    └───────┘    └───────┘    └───────┘    └───────┘    └────────┘
</code></pre>
<p>It&#39;s important to note that functions passed to <code>pipe</code> must have a <strong>single argument</strong> because they are only called with a single argument.</p>
<p>Let&#39;s see an example to better understand how <code>pipe</code> works:</p>
<p><strong>Example</strong> (Chaining Arithmetic Operations)</p>
<pre><code class="language-ts">import { pipe } from &quot;effect&quot;

// Define simple arithmetic operations
const increment = (x: number) =&gt; x + 1
const double = (x: number) =&gt; x * 2
const subtractTen = (x: number) =&gt; x - 10

// Sequentially apply these operations using `pipe`
const result = pipe(5, increment, double, subtractTen)

console.log(result)
// Output: 2
</code></pre>
<p>In the above example, we start with an input value of <code>5</code>. The <code>increment</code> function adds <code>1</code> to the initial value, resulting in <code>6</code>. Then, the <code>double</code> function doubles the value, giving us <code>12</code>. Finally, the <code>subtractTen</code> function subtracts <code>10</code> from <code>12</code>, resulting in the final output of <code>2</code>.</p>
<p>The result is equivalent to <code>subtractTen(double(increment(5)))</code>, but using <code>pipe</code> makes the code more readable because the operations are sequenced from left to right, rather than nesting them inside out.</p>
<h2>map</h2>
<p>Transforms the value inside an effect by applying a function to it.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))
</code></pre>
<p><code>Effect.map</code> takes a function and applies it to the value contained within an
effect, creating a new effect with the transformed value.</p>
<Aside type="note" title="Effects are Immutable">
  It's important to note that effects are immutable, meaning that the
  original effect is not modified. Instead, a new effect is returned with
  the updated value.
</Aside>

<p><strong>Example</strong> (Adding a Service Charge)</p>
<p>Here&#39;s a practical example where we apply a service charge to a transaction amount:</p>
<pre><code class="language-ts">import { pipe, Effect } from &quot;effect&quot;

// Function to add a small service charge to a transaction amount
const addServiceCharge = (amount: number) =&gt; amount + 1

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Apply service charge to the transaction amount
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.map(addServiceCharge)
)

Effect.runPromise(finalAmount).then(console.log) // Output: 101
</code></pre>
<h2>as</h2>
<p>Replaces the value inside an effect with a constant value.</p>
<p><code>Effect.as</code> allows you to ignore the original value inside an effect and replace it with a new constant value.</p>
<Aside type="note" title="Effects are Immutable">
  It's important to note that effects are immutable, meaning that the
  original effect is not modified. Instead, a new effect is returned with
  the updated value.
</Aside>

<p><strong>Example</strong> (Replacing a Value)</p>
<pre><code class="language-ts">import { pipe, Effect } from &quot;effect&quot;

// Replace the value 5 with the constant &quot;new value&quot;
const program = pipe(Effect.succeed(5), Effect.as(&quot;new value&quot;))

Effect.runPromise(program).then(console.log) // Output: &quot;new value&quot;
</code></pre>
<h2>flatMap</h2>
<p>Chains effects to produce new <code>Effect</code> instances, useful for combining operations that depend on previous results.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
</code></pre>
<p>In the code above, <code>transformation</code> is the function that takes a value and returns an <code>Effect</code>, and <code>myEffect</code> is the initial <code>Effect</code> being transformed.</p>
<p>Use <code>Effect.flatMap</code> when you need to chain multiple effects, ensuring that each
step produces a new <code>Effect</code> while flattening any nested effects that may
occur.</p>
<p>It is similar to <code>flatMap</code> used with arrays but works
specifically with <code>Effect</code> instances, allowing you to avoid deeply nested
effect structures.</p>
<Aside type="note" title="Effects are Immutable">
  It's important to note that effects are immutable, meaning that the
  original effect is not modified. Instead, a new effect is returned with
  the updated value.
</Aside>

<p><strong>Example</strong> (Applying a Discount)</p>
<pre><code class="language-ts">import { pipe, Effect } from &quot;effect&quot;

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Chaining the fetch and discount application using `flatMap`
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) =&gt; applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 95
</code></pre>
<h3>Ensure All Effects Are Considered</h3>
<p>Make sure that all effects within <code>Effect.flatMap</code> contribute to the final computation. If you ignore an effect, it can lead to unexpected behavior:</p>
<pre><code class="language-ts">Effect.flatMap((amount) =&gt; {
  // This effect will be ignored
  Effect.sync(() =&gt; console.log(`Apply a discount to: ${amount}`))
  return applyDiscount(amount, 5)
})
</code></pre>
<p>In this case, the <code>Effect.sync</code> call is ignored and does not affect the result of <code>applyDiscount(amount, 5)</code>. To handle effects correctly, make sure to explicitly chain them using functions like <code>Effect.map</code>, <code>Effect.flatMap</code>, <code>Effect.andThen</code>, or <code>Effect.tap</code>.</p>
<h2>andThen</h2>
<p>Chains two actions, where the second action can depend on the result of the first.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
</code></pre>
<p>Use <code>andThen</code> when you need to run multiple actions in sequence, with the
second action depending on the result of the first. This is useful for
combining effects or handling computations that must happen in order.</p>
<p>The second action can be:</p>
<ol>
<li>A value (similar to <code>Effect.as</code>)</li>
<li>A function returning a value (similar to <code>Effect.map</code>)</li>
<li>A <code>Promise</code></li>
<li>A function returning a <code>Promise</code></li>
<li>An <code>Effect</code></li>
<li>A function returning an <code>Effect</code> (similar to <code>Effect.flatMap</code>)</li>
</ol>
<p><strong>Example</strong> (Applying a Discount Based on Fetched Amount)</p>
<p>Let&#39;s look at an example comparing <code>Effect.andThen</code> with <code>Effect.map</code> and <code>Effect.flatMap</code>:</p>
<pre><code class="language-ts">import { pipe, Effect } from &quot;effect&quot;

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Using Effect.map and Effect.flatMap
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) =&gt; amount * 2),
  Effect.flatMap((amount) =&gt; applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log) // Output: 190

// Using Effect.andThen
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) =&gt; amount * 2),
  Effect.andThen((amount) =&gt; applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log) // Output: 190
</code></pre>
<h3>Option and Either with andThen</h3>
<p>Both <a href="/docs/data-types/option/#interop-with-effect">Option</a> and <a href="/docs/data-types/either/#interop-with-effect">Either</a> are commonly used for handling optional or missing values or simple error cases. These types integrate well with <code>Effect.andThen</code>. When used with <code>Effect.andThen</code>, the operations are categorized as scenarios 5 and 6 (as discussed earlier) because both <code>Option</code> and <code>Either</code> are treated as effects in this context.</p>
<p><strong>Example</strong> (with Option)</p>
<pre><code class="language-ts">import { pipe, Effect, Option } from &quot;effect&quot;

// Simulated asynchronous task fetching a number from a database
const fetchNumberValue = Effect.tryPromise(() =&gt; Promise.resolve(42))

//      ┌─── Effect&lt;number, UnknownException | NoSuchElementException, never&gt;
//      ▼
const program = pipe(
  fetchNumberValue,
  Effect.andThen((x) =&gt; (x &gt; 0 ? Option.some(x) : Option.none()))
)
</code></pre>
<p>You might expect the type of <code>program</code> to be <code>Effect&lt;Option&lt;number&gt;, UnknownException, never&gt;</code>, but it is actually <code>Effect&lt;number, UnknownException | NoSuchElementException, never&gt;</code>.</p>
<p>This is because <code>Option&lt;A&gt;</code> is treated as an effect of type <code>Effect&lt;A, NoSuchElementException&gt;</code>, and as a result, the possible errors are combined into a union type.</p>
<Aside type="tip" title="Option As Effect">
A value of type `Option<A>` is interpreted as an effect of type `Effect<A, NoSuchElementException>`.
</Aside>

<p><strong>Example</strong> (with Either)</p>
<pre><code class="language-ts">import { pipe, Effect, Either } from &quot;effect&quot;

// Function to parse an integer from a string that can fail
const parseInteger = (input: string): Either.Either&lt;number, string&gt; =&gt;
  isNaN(parseInt(input))
    ? Either.left(&quot;Invalid integer&quot;)
    : Either.right(parseInt(input))

// Simulated asynchronous task fetching a string from database
const fetchStringValue = Effect.tryPromise(() =&gt; Promise.resolve(&quot;42&quot;))

//      ┌─── Effect&lt;number, string | UnknownException, never&gt;
//      ▼
const program = pipe(
  fetchStringValue,
  Effect.andThen((str) =&gt; parseInteger(str))
)
</code></pre>
<p>Although one might expect the type of <code>program</code> to be <code>Effect&lt;Either&lt;number, string&gt;, UnknownException, never&gt;</code>, it is actually <code>Effect&lt;number, string | UnknownException, never&gt;</code>.</p>
<p>This is because <code>Either&lt;A, E&gt;</code> is treated as an effect of type <code>Effect&lt;A, E&gt;</code>, meaning the errors are combined into a union type.</p>
<Aside type="tip" title="Either As Effect">
A value of type `Either<A, E>` is interpreted as an effect of type `Effect<A, E>`.
</Aside>

<h2>tap</h2>
<p>Runs a side effect with the result of an effect without changing the original value.</p>
<p>Use <code>Effect.tap</code> when you want to perform a side effect, like logging or tracking,
without modifying the main value. This is useful when you need to observe or
record an action but want the original value to be passed to the next step.</p>
<p><code>Effect.tap</code> works similarly to <code>Effect.flatMap</code>, but it ignores the result of the function
passed to it. The value from the previous effect remains available for the
next part of the chain. Note that if the side effect fails, the entire chain
will fail too.</p>
<p><strong>Example</strong> (Logging a step in a pipeline)</p>
<pre><code class="language-ts">import { pipe, Effect, Console } from &quot;effect&quot;

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  // Log the fetched transaction amount
  Effect.tap((amount) =&gt; Console.log(`Apply a discount to: ${amount}`)),
  // `amount` is still available!
  Effect.flatMap((amount) =&gt; applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
/*
Output:
Apply a discount to: 100
95
*/
</code></pre>
<p>In this example, <code>Effect.tap</code> is used to log the transaction amount before applying the discount, without modifying the value itself. The original value (<code>amount</code>) remains available for the next operation (<code>applyDiscount</code>).</p>
<p>Using <code>Effect.tap</code> allows us to execute side effects during the computation without altering the result.
This can be useful for logging, performing additional actions, or observing the intermediate values without interfering with the main computation flow.</p>
<h2>all</h2>
<p>Combines multiple effects into one, returning results based on the input structure.</p>
<p>Use <code>Effect.all</code> when you need to run multiple effects and combine their results
into a single output. It supports tuples, iterables, structs, and records,
making it flexible for different input types.</p>
<p>For instance, if the input is a tuple:</p>
<pre><code class="language-ts">//         ┌─── a tuple of effects
//         ▼
Effect.all([effect1, effect2, ...])
</code></pre>
<p>the effects are executed in order, and the result is a new effect containing the results as a tuple. The results in the tuple match the order of the effects passed to <code>Effect.all</code>.</p>
<p>By default, <code>Effect.all</code> runs effects sequentially and produces a tuple or object
with the results. If any effect fails, it stops execution (short-circuiting)
and propagates the error.</p>
<p>See <a href="/docs/getting-started/control-flow/#all">Collecting</a> for more information on how to use <code>Effect.all</code>.</p>
<p><strong>Example</strong> (Combining Configuration and Database Checks)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Simulated function to read configuration from a file
const webConfig = Effect.promise(() =&gt;
  Promise.resolve({ dbConnection: &quot;localhost&quot;, port: 8080 })
)

// Simulated function to test database connectivity
const checkDatabaseConnectivity = Effect.promise(() =&gt;
  Promise.resolve(&quot;Connected to Database&quot;)
)

// Combine both effects to perform startup checks
const startupChecks = Effect.all([webConfig, checkDatabaseConnectivity])

Effect.runPromise(startupChecks).then(([config, dbStatus]) =&gt; {
  console.log(
    `Configuration: ${JSON.stringify(config)}\nDB Status: ${dbStatus}`
  )
})
/*
Output:
Configuration: {&quot;dbConnection&quot;:&quot;localhost&quot;,&quot;port&quot;:8080}
DB Status: Connected to Database
*/
</code></pre>
<h2>Build your first pipeline</h2>
<p>Let&#39;s now combine the <code>pipe</code> function, <code>Effect.all</code>, and <code>Effect.andThen</code> to create a pipeline that performs a sequence of transformations.</p>
<p><strong>Example</strong> (Building a Transaction Pipeline)</p>
<pre><code class="language-ts">import { Effect, pipe } from &quot;effect&quot;

// Function to add a small service charge to a transaction amount
const addServiceCharge = (amount: number) =&gt; amount + 1

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Simulated asynchronous task to fetch a discount rate
// from a configuration file
const fetchDiscountRate = Effect.promise(() =&gt; Promise.resolve(5))

// Assembling the program using a pipeline of effects
const program = pipe(
  // Combine both fetch effects to get the transaction amount
  // and discount rate
  Effect.all([fetchTransactionAmount, fetchDiscountRate]),

  // Apply the discount to the transaction amount
  Effect.andThen(([transactionAmount, discountRate]) =&gt;
    applyDiscount(transactionAmount, discountRate)
  ),

  // Add the service charge to the discounted amount
  Effect.andThen(addServiceCharge),

  // Format the final result for display
  Effect.andThen(
    (finalAmount) =&gt; `Final amount to charge: ${finalAmount}`
  )
)

// Execute the program and log the result
Effect.runPromise(program).then(console.log)
// Output: &quot;Final amount to charge: 96&quot;
</code></pre>
<p>This pipeline demonstrates how you can structure your code by combining different effects into a clear, readable flow.</p>
<h2>The pipe method</h2>
<p>Effect provides a <code>pipe</code> method that works similarly to the <code>pipe</code> method found in <a href="https://rxjs.dev/api/index/function/pipe">rxjs</a>. This method allows you to chain multiple operations together, making your code more concise and readable.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const result = effect.pipe(func1, func2, ..., funcN)
</code></pre>
<p>This is equivalent to using the <code>pipe</code> <strong>function</strong> like this:</p>
<pre><code class="language-ts">const result = pipe(effect, func1, func2, ..., funcN)
</code></pre>
<p>The <code>pipe</code> method is available on all effects and many other data types, eliminating the need to import the <code>pipe</code> function and saving you some keystrokes.</p>
<p><strong>Example</strong> (Using the <code>pipe</code> Method)</p>
<p>Let&#39;s rewrite an <a href="#build-your-first-pipeline">earlier example</a>, this time using the <code>pipe</code> method.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const addServiceCharge = (amount: number) =&gt; amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() =&gt; Promise.resolve(5))

const program = Effect.all([
  fetchTransactionAmount,
  fetchDiscountRate
]).pipe(
  Effect.andThen(([transactionAmount, discountRate]) =&gt;
    applyDiscount(transactionAmount, discountRate)
  ),
  Effect.andThen(addServiceCharge),
  Effect.andThen(
    (finalAmount) =&gt; `Final amount to charge: ${finalAmount}`
  )
)
</code></pre>
<h2>Cheatsheet</h2>
<p>Let&#39;s summarize the transformation functions we have seen so far:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>map</code></td>
<td><code>Effect&lt;A, E, R&gt;</code>, <code>A =&gt; B</code></td>
<td><code>Effect&lt;B, E, R&gt;</code></td>
</tr>
<tr>
<td><code>flatMap</code></td>
<td><code>Effect&lt;A, E, R&gt;</code>, <code>A =&gt; Effect&lt;B, E, R&gt;</code></td>
<td><code>Effect&lt;B, E, R&gt;</code></td>
</tr>
<tr>
<td><code>andThen</code></td>
<td><code>Effect&lt;A, E, R&gt;</code>, *</td>
<td><code>Effect&lt;B, E, R&gt;</code></td>
</tr>
<tr>
<td><code>tap</code></td>
<td><code>Effect&lt;A, E, R&gt;</code>, <code>A =&gt; Effect&lt;B, E, R&gt;</code></td>
<td><code>Effect&lt;A, E, R&gt;</code></td>
</tr>
<tr>
<td><code>all</code></td>
<td><code>[Effect&lt;A, E, R&gt;, Effect&lt;B, E, R&gt;, ...]</code></td>
<td><code>Effect&lt;[A, B, ...], E, R&gt;</code></td>
</tr>
</tbody></table>
<hr>
<hr>
<h2>title: Control Flow Operators
description: Learn to control execution flow in Effect programs using advanced constructs for conditional branching, iteration, and combining effects seamlessly.
sidebar:
  order: 10</h2>
<p>Even though JavaScript provides built-in control flow structures, Effect offers additional control flow functions that are useful in Effect applications. In this section, we will introduce different ways to control the flow of execution.</p>
<h2>if Expression</h2>
<p>When working with Effect values, we can use standard JavaScript if-then-else statements:</p>
<p><strong>Example</strong> (Returning None for Invalid Weight)</p>
<p>Here we are using the <a href="/docs/data-types/option/">Option</a> data type to represent the absence of a valid value.</p>
<pre><code class="language-ts">import { Effect, Option } from &quot;effect&quot;

// Function to validate weight and return an Option
const validateWeightOption = (
  weight: number
): Effect.Effect&lt;Option.Option&lt;number&gt;&gt; =&gt; {
  if (weight &gt;= 0) {
    // Return Some if the weight is valid
    return Effect.succeed(Option.some(weight))
  } else {
    // Return None if the weight is invalid
    return Effect.succeed(Option.none())
  }
}
</code></pre>
<p><strong>Example</strong> (Returning Error for Invalid Weight)</p>
<p>You can also handle invalid inputs by using the error channel, which allows you to return an error when the input is invalid:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Function to validate weight or fail with an error
const validateWeightOrFail = (
  weight: number
): Effect.Effect&lt;number, string&gt; =&gt; {
  if (weight &gt;= 0) {
    // Return the weight if valid
    return Effect.succeed(weight)
  } else {
    // Fail with an error if invalid
    return Effect.fail(`negative input: ${weight}`)
  }
}
</code></pre>
<h2>Conditional Operators</h2>
<h3>if</h3>
<p>Executes one of two effects based on a condition evaluated by an effectful predicate.</p>
<p>Use <code>Effect.if</code> to run one of two effects depending on whether the predicate effect
evaluates to <code>true</code> or <code>false</code>. If the predicate is <code>true</code>, the <code>onTrue</code> effect
is executed. If it is <code>false</code>, the <code>onFalse</code> effect is executed instead.</p>
<p><strong>Example</strong> (Simulating a Coin Flip)</p>
<p>In this example, we simulate a virtual coin flip using <code>Random.nextBoolean</code> to generate a random boolean value. If the value is <code>true</code>, the <code>onTrue</code> effect logs &quot;Head&quot;. If the value is <code>false</code>, the <code>onFalse</code> effect logs &quot;Tail&quot;.</p>
<pre><code class="language-ts">import { Effect, Random, Console } from &quot;effect&quot;

const flipTheCoin = Effect.if(Random.nextBoolean, {
  onTrue: () =&gt; Console.log(&quot;Head&quot;), // Runs if the predicate is true
  onFalse: () =&gt; Console.log(&quot;Tail&quot;) // Runs if the predicate is false
})

Effect.runFork(flipTheCoin)
</code></pre>
<h3>when</h3>
<p>Conditionally executes an effect based on a boolean condition.</p>
<p><code>Effect.when</code> allows you to conditionally execute an effect, similar to using
an <code>if (condition)</code> expression, but with the added benefit of handling
effects. If the condition is <code>true</code>, the effect is executed; otherwise, it
does nothing.</p>
<p>The result of the effect is wrapped in an <code>Option&lt;A&gt;</code> to indicate whether the
effect was executed. If the condition is <code>true</code>, the result of the effect is
wrapped in a <code>Some</code>. If the condition is <code>false</code>, the result is <code>None</code>,
representing that the effect was skipped.</p>
<p><strong>Example</strong> (Conditional Effect Execution)</p>
<pre><code class="language-ts">import { Effect, Option } from &quot;effect&quot;

const validateWeightOption = (
  weight: number
): Effect.Effect&lt;Option.Option&lt;number&gt;&gt; =&gt;
  // Conditionally execute the effect if the weight is non-negative
  Effect.succeed(weight).pipe(Effect.when(() =&gt; weight &gt;= 0))

// Run with a valid weight
Effect.runPromise(validateWeightOption(100)).then(console.log)
/*
Output:
{
  _id: &quot;Option&quot;,
  _tag: &quot;Some&quot;,
  value: 100
}
*/

// Run with an invalid weight
Effect.runPromise(validateWeightOption(-5)).then(console.log)
/*
Output:
{
  _id: &quot;Option&quot;,
  _tag: &quot;None&quot;
}
*/
</code></pre>
<p>In this example, the <a href="/docs/data-types/option/">Option</a> data type is used to represent the presence or absence of a valid value. If the condition evaluates to <code>true</code> (in this case, if the weight is non-negative), the effect is executed and wrapped in a <code>Some</code>. Otherwise, the result is <code>None</code>.</p>
<h3>whenEffect</h3>
<p>Executes an effect conditionally, based on the result of another effect.</p>
<p>Use <code>Effect.whenEffect</code> when the condition to determine whether to execute the effect
depends on the outcome of another effect that produces a boolean value.
If the condition effect evaluates to <code>true</code>, the specified effect is executed.
If it evaluates to <code>false</code>, no effect is executed.</p>
<p>The result of the effect is wrapped in an <code>Option&lt;A&gt;</code> to indicate whether the
effect was executed. If the condition is <code>true</code>, the result of the effect is
wrapped in a <code>Some</code>. If the condition is <code>false</code>, the result is <code>None</code>,
representing that the effect was skipped.</p>
<p><strong>Example</strong> (Using an Effect as a Condition)</p>
<p>The following function creates a random integer, but only if a randomly generated boolean is <code>true</code>.</p>
<pre><code class="language-ts">import { Effect, Random } from &quot;effect&quot;

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
/*
Example Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 8609104974198840 }
*/
</code></pre>
<h3>unless / unlessEffect</h3>
<p>The <code>Effect.unless</code> and <code>Effect.unlessEffect</code> functions are similar to the <code>when*</code> functions, but they are equivalent to the <code>if (!condition) expression</code> construct.</p>
<h2>Zipping</h2>
<h3>zip</h3>
<p>Combines two effects into a single effect, producing a tuple with the results of both effects.</p>
<p>The <code>Effect.zip</code> function executes the first effect (left) and then the second effect (right).
Once both effects succeed, their results are combined into a tuple.</p>
<p><strong>Example</strong> (Combining Two Effects Sequentially)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.succeed(1).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Effect.log(&quot;task1 done&quot;))
)

const task2 = Effect.succeed(&quot;hello&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Effect.log(&quot;task2 done&quot;))
)

// Combine the two effects together
//
//      ┌─── Effect&lt;[number, string], never, never&gt;
//      ▼
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;task1 done&quot;
timestamp=... level=INFO fiber=#0 message=&quot;task2 done&quot;
[ 1, &#39;hello&#39; ]
*/
</code></pre>
<p>By default, the effects are run sequentially. To run them concurrently, use the <code>{ concurrent: true }</code> option.</p>
<p><strong>Example</strong> (Combining Two Effects Concurrently)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.succeed(1).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Effect.log(&quot;task1 done&quot;))
)

const task2 = Effect.succeed(&quot;hello&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Effect.log(&quot;task2 done&quot;))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
/*
Output:
timestamp=... level=INFO fiber=#3 message=&quot;task2 done&quot;
timestamp=... level=INFO fiber=#2 message=&quot;task1 done&quot;
[ 1, &#39;hello&#39; ]
*/
</code></pre>
<p>In this concurrent version, both effects run in parallel. <code>task2</code> completes first, but both tasks can be logged and processed as soon as they&#39;re done.</p>
<h3>zipWith</h3>
<p>Combines two effects sequentially and applies a function to their results to produce a single value.</p>
<p>The <code>Effect.zipWith</code> function is similar to <a href="#zip">Effect.zip</a>, but instead of returning a tuple of results,
it applies a provided function to the results of the two effects, combining them into a single value.</p>
<p>By default, the effects are run sequentially. To run them concurrently, use the <code>{ concurrent: true }</code> option.</p>
<p><strong>Example</strong> (Combining Effects with a Custom Function)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const task1 = Effect.succeed(1).pipe(
  Effect.delay(&quot;200 millis&quot;),
  Effect.tap(Effect.log(&quot;task1 done&quot;))
)
const task2 = Effect.succeed(&quot;hello&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.tap(Effect.log(&quot;task2 done&quot;))
)

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const task3 = Effect.zipWith(
  task1,
  task2,
  // Combines results into a single value
  (number, string) =&gt; number + string.length
)

Effect.runPromise(task3).then(console.log)
/*
Output:
timestamp=... level=INFO fiber=#3 message=&quot;task1 done&quot;
timestamp=... level=INFO fiber=#2 message=&quot;task2 done&quot;
6
*/
</code></pre>
<h2>Looping</h2>
<h3>loop</h3>
<p>The <code>Effect.loop</code> function allows you to repeatedly update a state using a <code>step</code> function until a condition defined by the <code>while</code> function becomes <code>false</code>. It collects the intermediate states in an array and returns them as the final result.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Effect.loop(initial, {
  while: (state) =&gt; boolean,
  step: (state) =&gt; state,
  body: (state) =&gt; Effect
})
</code></pre>
<p>This function is similar to a <code>while</code> loop in JavaScript, with the addition of effectful computations:</p>
<pre><code class="language-ts">let state = initial
const result = []

while (options.while(state)) {
  result.push(options.body(state)) // Perform the effectful operation
  state = options.step(state) // Update the state
}

return result
</code></pre>
<p><strong>Example</strong> (Looping with Collected Results)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// A loop that runs 5 times, collecting each iteration&#39;s result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) =&gt; state &lt;= 5,
    // State update function
    step: (state) =&gt; state + 1,
    // Effect to be performed on each iteration
    body: (state) =&gt; Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]
</code></pre>
<p>In this example, the loop starts with the state <code>1</code> and continues until the state exceeds <code>5</code>. Each state is incremented by <code>1</code> and is collected into an array, which becomes the final result.</p>
<h4>Discarding Intermediate Results</h4>
<p>The <code>discard</code> option, when set to <code>true</code>, will discard the results of each effectful operation, returning <code>void</code> instead of an array.</p>
<p><strong>Example</strong> (Loop with Discarded Results)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) =&gt; state &lt;= 5,
    // State update function
    step: (state) =&gt; state + 1,
    // Effect to be performed on each iteration
    body: (state) =&gt; Console.log(`Currently at state ${state}`),
    // Discard intermediate results
    discard: true
  }
)

Effect.runPromise(result).then(console.log)
/*
Output:
Currently at state 1
Currently at state 2
Currently at state 3
Currently at state 4
Currently at state 5
undefined
*/
</code></pre>
<p>In this example, the loop performs a side effect of logging the current index on each iteration, but it discards all intermediate results. The final result is <code>undefined</code>.</p>
<h3>iterate</h3>
<p>The <code>Effect.iterate</code> function lets you repeatedly update a state through an effectful operation. It runs the <code>body</code> effect to update the state in each iteration and continues as long as the <code>while</code> condition evaluates to <code>true</code>.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Effect.iterate(initial, {
  while: (result) =&gt; boolean,
  body: (result) =&gt; Effect
})
</code></pre>
<p>This function is similar to a <code>while</code> loop in JavaScript, with the addition of effectful computations:</p>
<pre><code class="language-ts">let result = initial

while (options.while(result)) {
  result = options.body(result)
}

return result
</code></pre>
<p><strong>Example</strong> (Effectful Iteration)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const result = Effect.iterate(
  // Initial result
  1,
  {
    // Condition to continue iterating
    while: (result) =&gt; result &lt;= 5,
    // Operation to change the result
    body: (result) =&gt; Effect.succeed(result + 1)
  }
)

Effect.runPromise(result).then(console.log)
// Output: 6
</code></pre>
<h3>forEach</h3>
<p>Executes an effectful operation for each element in an <code>Iterable</code>.</p>
<p>The <code>Effect.forEach</code> function applies a provided operation to each element in the
iterable, producing a new effect that returns an array of results.
If any effect fails, the iteration stops immediately (short-circuiting), and
the error is propagated.</p>
<p>The <code>concurrency</code> option controls how many operations are performed
concurrently. By default, the operations are performed sequentially.</p>
<p><strong>Example</strong> (Applying Effects to Iterable Elements)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =&gt;
  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
)

Effect.runPromise(result).then(console.log)
/*
Output:
Currently at index 0
Currently at index 1
Currently at index 2
Currently at index 3
Currently at index 4
[ 2, 4, 6, 8, 10 ]
*/
</code></pre>
<p>In this example, we iterate over the array <code>[1, 2, 3, 4, 5]</code>, applying an effect that logs the current index. The <code>Effect.as(n * 2)</code> operation transforms each value, resulting in an array <code>[2, 4, 6, 8, 10]</code>. The final output is the result of collecting all the transformed values.</p>
<h4>Discarding Results</h4>
<p>The <code>discard</code> option, when set to <code>true</code>, will discard the results of each effectful operation, returning <code>void</code> instead of an array.</p>
<p><strong>Example</strong> (Using <code>discard</code> to Ignore Results)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Apply effects but discard the results
const result = Effect.forEach(
  [1, 2, 3, 4, 5],
  (n, index) =&gt;
    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
  { discard: true }
)

Effect.runPromise(result).then(console.log)
/*
Output:
Currently at index 0
Currently at index 1
Currently at index 2
Currently at index 3
Currently at index 4
undefined
*/
</code></pre>
<p>In this case, the effects still run for each element, but the results are discarded, so the final output is <code>undefined</code>.</p>
<h2>Collecting</h2>
<h3>all</h3>
<p>Combines multiple effects into one, returning results based on the input structure.</p>
<p>Use <code>Effect.all</code> when you need to run multiple effects and combine their results into a single output. It supports tuples, iterables, structs, and records, making it flexible for different input types.</p>
<p>If any effect fails, it stops execution (short-circuiting) and propagates the error. To change this behavior, you can use the <a href="#the-mode-option"><code>mode</code></a> option, which allows all effects to run and collect results as <a href="/docs/data-types/either/">Either</a> or <a href="/docs/data-types/option/">Option</a>.</p>
<p>You can control the execution order (e.g., sequential vs. concurrent) using the <a href="/docs/concurrency/basic-concurrency/#concurrency-options">Concurrency Options</a>.</p>
<p>For instance, if the input is a tuple:</p>
<pre><code class="language-ts">//         ┌─── a tuple of effects
//         ▼
Effect.all([effect1, effect2, ...])
</code></pre>
<p>the effects are executed sequentially, and the result is a new effect containing the results as a tuple. The results in the tuple match the order of the effects passed to <code>Effect.all</code>.</p>
<p>Let&#39;s explore examples for different types of structures: tuples, iterables, objects, and records.</p>
<p><strong>Example</strong> (Combining Effects in Tuples)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed(&quot;Hello&quot;).pipe(Effect.tap(Console.log))
] as const

//      ┌─── Effect&lt;[number, string], never, never&gt;
//      ▼
const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)
/*
Output:
42
Hello
[ 42, &#39;Hello&#39; ]
*/
</code></pre>
<p><strong>Example</strong> (Combining Effects in Iterables)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const iterableOfEffects: Iterable&lt;Effect.Effect&lt;number&gt;&gt; = [1, 2, 3].map(
  (n) =&gt; Effect.succeed(n).pipe(Effect.tap(Console.log))
)

//      ┌─── Effect&lt;number[], never, never&gt;
//      ▼
const resultsAsArray = Effect.all(iterableOfEffects)

Effect.runPromise(resultsAsArray).then(console.log)
/*
Output:
1
2
3
[ 1, 2, 3 ]
*/
</code></pre>
<p><strong>Example</strong> (Combining Effects in Structs)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed(&quot;Hello&quot;).pipe(Effect.tap(Console.log))
}

//      ┌─── Effect&lt;{ a: number; b: string; }, never, never&gt;
//      ▼
const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)
/*
Output:
42
Hello
{ a: 42, b: &#39;Hello&#39; }
*/
</code></pre>
<p><strong>Example</strong> (Combining Effects in Records)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const recordOfEffects: Record&lt;string, Effect.Effect&lt;number&gt;&gt; = {
  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
}

//      ┌─── Effect&lt;{ [x: string]: number; }, never, never&gt;
//      ▼
const resultsAsRecord = Effect.all(recordOfEffects)

Effect.runPromise(resultsAsRecord).then(console.log)
/*
Output:
1
2
{ key1: 1, key2: 2 }
*/
</code></pre>
<h4>Short-Circuiting Behavior</h4>
<p>The <code>Effect.all</code> function stops execution on the first error it encounters, this is called &quot;short-circuiting&quot;.
If any effect in the collection fails, the remaining effects will not run, and the error will be propagated.</p>
<p><strong>Example</strong> (Bail Out on First Failure)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Effect.all([
  Effect.succeed(&quot;Task1&quot;).pipe(Effect.tap(Console.log)),
  Effect.fail(&quot;Task2: Oh no!&quot;).pipe(Effect.tap(Console.log)),
  // Won&#39;t execute due to earlier failure
  Effect.succeed(&quot;Task3&quot;).pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Task1
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Task2: Oh no!&#39; }
}
*/
</code></pre>
<p>You can override this behavior by using the <code>mode</code> option.</p>
<h4>The <code>mode</code> option</h4>
<p>The <code>{ mode: &quot;either&quot; }</code> option changes the behavior of <code>Effect.all</code> to ensure all effects run, even if some fail. Instead of stopping on the first failure, this mode collects both successes and failures, returning an array of <code>Either</code> instances where each result is either a <code>Right</code> (success) or a <code>Left</code> (failure).</p>
<p><strong>Example</strong> (Collecting Results with <code>mode: &quot;either&quot;</code>)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const effects = [
  Effect.succeed(&quot;Task1&quot;).pipe(Effect.tap(Console.log)),
  Effect.fail(&quot;Task2: Oh no!&quot;).pipe(Effect.tap(Console.log)),
  Effect.succeed(&quot;Task3&quot;).pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: &quot;either&quot; })

Effect.runPromiseExit(program).then(console.log)
/*
Output:
Task1
Task3
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Success&#39;,
  value: [
    { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: &#39;Task1&#39; },
    { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;Task2: Oh no!&#39; },
    { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: &#39;Task3&#39; }
  ]
}
*/
</code></pre>
<p>Similarly, the <code>{ mode: &quot;validate&quot; }</code> option uses <code>Option</code> to indicate success or failure. Each effect returns <code>None</code> for success and <code>Some</code> with the error for failure.</p>
<p><strong>Example</strong> (Collecting Results with <code>mode: &quot;validate&quot;</code>)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const effects = [
  Effect.succeed(&quot;Task1&quot;).pipe(Effect.tap(Console.log)),
  Effect.fail(&quot;Task2: Oh no!&quot;).pipe(Effect.tap(Console.log)),
  Effect.succeed(&quot;Task3&quot;).pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: &quot;validate&quot; })

Effect.runPromiseExit(program).then((result) =&gt; console.log(&quot;%o&quot;, result))
/*
Output:
Task1
Task3
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: [
      { _id: &#39;Option&#39;, _tag: &#39;None&#39; },
      { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;Task2: Oh no!&#39; },
      { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
    ]
  }
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Create Effect App
description: Quickly set up a new Effect application with a customizable template or example, streamlining your development start.
sidebar:
  order: 3</h2>
<p>import { Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>create-effect-app</code> CLI allow you to create a new Effect application using a default template or an <a href="https://github.com/Effect-TS/examples">example</a> from a public Github repository.
It is the easiest way to get started with Effect.</p>
<h2>CLI</h2>
<p>To begin, run the <code>create-effect-app</code> command in your terminal using your preferred package manager:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npx create-effect-app@latest
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm create effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn create effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bunx create-effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno init --npm effect-app@latest
</code></pre>
</TabItem>

</Tabs>

<p>This command starts an interactive setup that guides you through the steps required to bootstrap your project:</p>
<p><img src="../_assets/create-effect-app.gif" alt="create-effect-app" title="Animated GIF demonstrating the interactive experience when create-effect-app is run in interactive mode"></p>
<p>After making your selections, <code>create-effect-app</code> will generate your new Effect project and configure it based on your choices.</p>
<p><strong>Example</strong></p>
<p>For instance, to create a new Effect project in a directory named <code>&quot;my-effect-app&quot;</code> using the basic template with ESLint integration, you can run:</p>
<pre><code class="language-sh">npx create-effect-app --template basic --eslint my-effect-app
</code></pre>
<h2>Non-Interactive Usage</h2>
<p>If you prefer, <code>create-effect-app</code> can also be used in a non-interactive mode:</p>
<pre><code class="language-sh">create-effect-app
  (-t, --template basic | cli | monorepo)
  [--changesets]
  [--flake]
  [--eslint]
  [--workflows]
  [&lt;project-name&gt;]
create-effect-app
  (-e, --example http-server)
  [&lt;project-name&gt;]
</code></pre>
<p>Below is a breakdown of the available options to customize an Effect project template:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--changesets</code></td>
<td>Initializes your project with the Changesets package for managing version control.</td>
</tr>
<tr>
<td><code>--flake</code></td>
<td>Initializes your project with a Nix flake for managing system dependencies.</td>
</tr>
<tr>
<td><code>--eslint</code></td>
<td>Includes ESLint for code formatting and linting.</td>
</tr>
<tr>
<td><code>--workflows</code></td>
<td>Sets up Effect&#39;s recommended GitHub Action workflows for automation.</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2>title: Creating Effects
description: Learn to create and manage effects for structured handling of success, failure, and side effects in synchronous and asynchronous workflows.
sidebar:
  order: 6</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Effect provides different ways to create effects, which are units of computation that encapsulate side effects.
In this guide, we will cover some of the common methods that you can use to create effects.</p>
<h2>Why Not Throw Errors?</h2>
<p>In traditional programming, when an error occurs, it is often handled by throwing an exception:</p>
<pre><code class="language-ts">// Type signature doesn&#39;t show possible exceptions
const divide = (a: number, b: number): number =&gt; {
  if (b === 0) {
    throw new Error(&quot;Cannot divide by zero&quot;)
  }
  return a / b
}
</code></pre>
<p>However, throwing errors can be problematic. The type signatures of functions do not indicate that they can throw exceptions, making it difficult to reason about potential errors.</p>
<p>To address this issue, Effect introduces dedicated constructors for creating effects that represent both success and failure: <code>Effect.succeed</code> and <code>Effect.fail</code>. These constructors allow you to explicitly handle success and failure cases while <strong>leveraging the type system to track errors</strong>.</p>
<h3>succeed</h3>
<p>Creates an <code>Effect</code> that always succeeds with a given value.</p>
<p>Use this function when you need an effect that completes successfully with a specific value
without any errors or external dependencies.</p>
<p><strong>Example</strong> (Creating a Successful Effect)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const success = Effect.succeed(42)
</code></pre>
<p>The type of <code>success</code> is <code>Effect&lt;number, never, never&gt;</code>, which means:</p>
<ul>
<li>It produces a value of type <code>number</code>.</li>
<li>It does not generate any errors (<code>never</code> indicates no errors).</li>
<li>It requires no additional data or dependencies (<code>never</code> indicates no requirements).</li>
</ul>
<pre><code class="language-text">         ┌─── Produces a value of type number
         │       ┌─── Does not generate any errors
         │       │      ┌─── Requires no dependencies
         ▼       ▼      ▼
Effect&lt;number, never, never&gt;
</code></pre>
<h3>fail</h3>
<p>Creates an <code>Effect</code> that represents an error that can be recovered from.</p>
<p>Use this function to explicitly signal an error in an <code>Effect</code>. The error
will keep propagating unless it is handled. You can handle the error with
functions like <a href="/docs/error-management/expected-errors/#catchall">Effect.catchAll</a> or
<a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a>.</p>
<p><strong>Example</strong> (Creating a Failed Effect)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;never, Error, never&gt;
//      ▼
const failure = Effect.fail(
  new Error(&quot;Operation failed due to network error&quot;)
)
</code></pre>
<p>The type of <code>failure</code> is <code>Effect&lt;never, Error, never&gt;</code>, which means:</p>
<ul>
<li>It never produces a value (<code>never</code> indicates that no successful result will be produced).</li>
<li>It fails with an error, specifically an <code>Error</code>.</li>
<li>It requires no additional data or dependencies (<code>never</code> indicates no requirements).</li>
</ul>
<pre><code class="language-text">         ┌─── Never produces a value
         │      ┌─── Fails with an Error
         │      │      ┌─── Requires no dependencies
         ▼      ▼      ▼
Effect&lt;never, Error, never&gt;
</code></pre>
<p>Although you can use <code>Error</code> objects with <code>Effect.fail</code>, you can also pass strings, numbers, or more complex objects depending on your error management strategy.</p>
<p>Using &quot;tagged&quot; errors (objects with a <code>_tag</code> field) can help identify error types and works well with standard Effect functions, like <a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a>.</p>
<p><strong>Example</strong> (Using Tagged Errors)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

//      ┌─── Effect&lt;never, HttpError, never&gt;
//      ▼
const program = Effect.fail(new HttpError())
</code></pre>
<h2>Error Tracking</h2>
<p>With <code>Effect.succeed</code> and <code>Effect.fail</code>, you can explicitly handle success and failure cases and the type system will ensure that errors are tracked and accounted for.</p>
<p><strong>Example</strong> (Rewriting a Division Function)</p>
<p>Here&#39;s how you can rewrite the <a href="#why-not-throw-errors"><code>divide</code></a> function using Effect, making error handling explicit.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (a: number, b: number): Effect.Effect&lt;number, Error&gt; =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)
</code></pre>
<p>In this example, the <code>divide</code> function indicates in its return type <code>Effect&lt;number, Error&gt;</code> that the operation can either succeed with a <code>number</code> or fail with an <code>Error</code>.</p>
<pre><code class="language-text">         ┌─── Produces a value of type number
         │       ┌─── Fails with an Error
         ▼       ▼
Effect&lt;number, Error&gt;
</code></pre>
<p>This clear type signature helps ensure that errors are handled properly and that anyone calling the function is aware of the possible outcomes.</p>
<p><strong>Example</strong> (Simulating a User Retrieval Operation)</p>
<p>Let&#39;s imagine another scenario where we use <code>Effect.succeed</code> and <code>Effect.fail</code> to model a simple user retrieval operation where the user data is hardcoded, which could be useful in testing scenarios or when mocking data:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define a User type
interface User {
  readonly id: number
  readonly name: string
}

// A mocked function to simulate fetching a user from a database
const getUser = (userId: number): Effect.Effect&lt;User, Error&gt; =&gt; {
  // Normally, you would access a database or API here, but we&#39;ll mock it
  const userDatabase: Record&lt;number, User&gt; = {
    1: { id: 1, name: &quot;John Doe&quot; },
    2: { id: 2, name: &quot;Jane Smith&quot; }
  }

  // Check if the user exists in our &quot;database&quot; and return appropriately
  const user = userDatabase[userId]
  if (user) {
    return Effect.succeed(user)
  } else {
    return Effect.fail(new Error(&quot;User not found&quot;))
  }
}

// When executed, this will successfully return the user with id 1
const exampleUserEffect = getUser(1)
</code></pre>
<p>In this example, <code>exampleUserEffect</code>, which has the type <code>Effect&lt;User, Error&gt;</code>, will either produce a <code>User</code> object or an <code>Error</code>, depending on whether the user exists in the mocked database.</p>
<p>For a deeper dive into managing errors in your applications, refer to the <a href="/docs/error-management/expected-errors/">Error Management Guide</a>.</p>
<h2>Modeling Synchronous Effects</h2>
<p>In JavaScript, you can delay the execution of synchronous computations using &quot;thunks&quot;.</p>
<Aside type="note" title="Thunks">
  A "thunk" is a function that takes no arguments and may return some
  value.
</Aside>

<p>Thunks are useful for delaying the computation of a value until it is needed.</p>
<p>To model synchronous side effects, Effect provides the <code>Effect.sync</code> and <code>Effect.try</code> constructors, which accept a thunk.</p>
<h3>sync</h3>
<p>Creates an <code>Effect</code> that represents a synchronous side-effectful computation.</p>
<p>Use <code>Effect.sync</code> when you are sure the operation will not fail.</p>
<p>The provided function (<code>thunk</code>) must not throw errors; if it does, the error will be treated as a <a href="/docs/error-management/unexpected-errors/">&quot;defect&quot;</a>.</p>
<p>This defect is not a standard error but indicates a flaw in the logic that was expected to be error-free.
You can think of it similar to an unexpected crash in the program, which can be further managed or logged using tools like <a href="/docs/error-management/unexpected-errors/#catchalldefect">Effect.catchAllDefect</a>.
This feature ensures that even unexpected failures in your application are not lost and can be handled appropriately.</p>
<p><strong>Example</strong> (Logging a Message)</p>
<p>In the example below, <code>Effect.sync</code> is used to defer the side-effect of writing to the console.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const log = (message: string) =&gt;
  Effect.sync(() =&gt; {
    console.log(message) // side effect
  })

//      ┌─── Effect&lt;void, never, never&gt;
//      ▼
const program = log(&quot;Hello, World!&quot;)
</code></pre>
<p>The side effect (logging to the console) encapsulated within <code>program</code> won&#39;t occur until the effect is explicitly run (see the <a href="/docs/getting-started/running-effects/">Running Effects</a> section for more details). This allows you to define side effects at one point in your code and control when they are activated, improving manageability and predictability of side effects in larger applications.</p>
<h3>try</h3>
<p>Creates an <code>Effect</code> that represents a synchronous computation that might fail.</p>
<p>In situations where you need to perform synchronous operations that might fail, such as parsing JSON, you can use the <code>Effect.try</code> constructor.
This constructor is designed to handle operations that could throw exceptions by capturing those exceptions and transforming them into manageable errors.</p>
<p><strong>Example</strong> (Safe JSON Parsing)</p>
<p>Suppose you have a function that attempts to parse a JSON string. This operation can fail and throw an error if the input string is not properly formatted as JSON:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const parse = (input: string) =&gt;
  // This might throw an error if input is not valid JSON
  Effect.try(() =&gt; JSON.parse(input))

//      ┌─── Effect&lt;any, UnknownException, never&gt;
//      ▼
const program = parse(&quot;&quot;)
</code></pre>
<p>In this example:</p>
<ul>
<li><code>parse</code> is a function that creates an effect encapsulating the JSON parsing operation.</li>
<li>If <code>JSON.parse(input)</code> throws an error due to invalid input, <code>Effect.try</code> catches this error and the effect represented by <code>program</code> will fail with an <code>UnknownException</code>. This ensures that errors are not silently ignored but are instead handled within the structured flow of effects.</li>
</ul>
<h4>Customizing Error Handling</h4>
<p>You might want to transform the caught exception into a more specific error or perform additional operations when catching an error. <code>Effect.try</code> supports an overload that allows you to specify how caught exceptions should be transformed:</p>
<p><strong>Example</strong> (Custom Error Handling)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const parse = (input: string) =&gt;
  Effect.try({
    // JSON.parse may throw for bad input
    try: () =&gt; JSON.parse(input),
    // remap the error
    catch: (unknown) =&gt; new Error(`something went wrong ${unknown}`)
  })

//      ┌─── Effect&lt;any, Error, never&gt;
//      ▼
const program = parse(&quot;&quot;)
</code></pre>
<p>You can think of this as a similar pattern to the traditional try-catch block in JavaScript:</p>
<pre><code class="language-ts">try {
  return JSON.parse(input)
} catch (unknown) {
  throw new Error(`something went wrong ${unknown}`)
}
</code></pre>
<h2>Modeling Asynchronous Effects</h2>
<p>In traditional programming, we often use <code>Promise</code>s to handle asynchronous computations. However, dealing with errors in promises can be problematic. By default, <code>Promise&lt;Value&gt;</code> only provides the type <code>Value</code> for the resolved value, which means errors are not reflected in the type system. This limits the expressiveness and makes it challenging to handle and track errors effectively.</p>
<p>To overcome these limitations, Effect introduces dedicated constructors for creating effects that represent both success and failure in an asynchronous context: <code>Effect.promise</code> and <code>Effect.tryPromise</code>. These constructors allow you to explicitly handle success and failure cases while <strong>leveraging the type system to track errors</strong>.</p>
<h3>promise</h3>
<p>Creates an <code>Effect</code> that represents an asynchronous computation guaranteed to succeed.</p>
<p>Use <code>Effect.promise</code> when you are sure the operation will not reject.</p>
<p>The provided function (<code>thunk</code>) returns a <code>Promise</code> that should never reject; if it does, the error will be treated as a <a href="/docs/error-management/unexpected-errors/">&quot;defect&quot;</a>.</p>
<p>This defect is not a standard error but indicates a flaw in the logic that was expected to be error-free.
You can think of it similar to an unexpected crash in the program, which can be further managed or logged using tools like <a href="/docs/error-management/unexpected-errors/#catchalldefect">Effect.catchAllDefect</a>.
This feature ensures that even unexpected failures in your application are not lost and can be handled appropriately.</p>
<p><strong>Example</strong> (Delayed Message)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const delay = (message: string) =&gt;
  Effect.promise&lt;string&gt;(
    () =&gt;
      new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          resolve(message)
        }, 2000)
      })
  )

//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const program = delay(&quot;Async operation completed successfully!&quot;)
</code></pre>
<p>The <code>program</code> value has the type <code>Effect&lt;string, never, never&gt;</code> and can be interpreted as an effect that:</p>
<ul>
<li>succeeds with a value of type <code>string</code></li>
<li>does not produce any expected error (<code>never</code>)</li>
<li>does not require any context (<code>never</code>)</li>
</ul>
<h3>tryPromise</h3>
<p>Creates an <code>Effect</code> that represents an asynchronous computation that might fail.</p>
<p>Unlike <code>Effect.promise</code>, this constructor is suitable when the underlying <code>Promise</code> might reject.
It provides a way to catch errors and handle them appropriately.
By default if an error occurs, it will be caught and propagated to the error channel as as an <code>UnknownException</code>.</p>
<p><strong>Example</strong> (Fetching a TODO Item)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const getTodo = (id: number) =&gt;
  // Will catch any errors and propagate them as UnknownException
  Effect.tryPromise(() =&gt;
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
  )

//      ┌─── Effect&lt;Response, UnknownException, never&gt;
//      ▼
const program = getTodo(1)
</code></pre>
<p>The <code>program</code> value has the type <code>Effect&lt;Response, UnknownException, never&gt;</code> and can be interpreted as an effect that:</p>
<ul>
<li>succeeds with a value of type <code>Response</code></li>
<li>might produce an error (<code>UnknownException</code>)</li>
<li>does not require any context (<code>never</code>)</li>
</ul>
<h4>Customizing Error Handling</h4>
<p>If you want more control over what gets propagated to the error channel, you can use an overload of <code>Effect.tryPromise</code> that takes a remapping function:</p>
<p><strong>Example</strong> (Custom Error Handling)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const getTodo = (id: number) =&gt;
  Effect.tryPromise({
    try: () =&gt; fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
    // remap the error
    catch: (unknown) =&gt; new Error(`something went wrong ${unknown}`)
  })

//      ┌─── Effect&lt;Response, Error, never&gt;
//      ▼
const program = getTodo(1)
</code></pre>
<h2>From a Callback</h2>
<p>Creates an <code>Effect</code> from a callback-based asynchronous function.</p>
<p>Sometimes you have to work with APIs that don&#39;t support <code>async/await</code> or <code>Promise</code> and instead use the callback style.
To handle callback-based APIs, Effect provides the <code>Effect.async</code> constructor.</p>
<p><strong>Example</strong> (Wrapping a Callback API)</p>
<p>Let&#39;s wrap the <code>readFile</code> function from Node.js&#39;s <code>fs</code> module into an Effect-based API (make sure <code>@types/node</code> is installed):</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import * as NodeFS from &quot;node:fs&quot;

const readFile = (filename: string) =&gt;
  Effect.async&lt;Buffer, Error&gt;((resume) =&gt; {
    NodeFS.readFile(filename, (error, data) =&gt; {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

//      ┌─── Effect&lt;Buffer, Error, never&gt;
//      ▼
const program = readFile(&quot;example.txt&quot;)
</code></pre>
<p>In the above example, we manually annotate the types when calling <code>Effect.async</code>:</p>
<pre><code class="language-ts">Effect.async&lt;Buffer, Error&gt;((resume) =&gt; {
  // ...
})
</code></pre>
<p>because TypeScript cannot infer the type parameters for a callback
based on the return value inside the callback body. Annotating the types ensures that the values provided to <code>resume</code> match the expected types.</p>
<p>The <code>resume</code> function inside <code>Effect.async</code> should be called exactly once. Calling it more than once will result in the extra calls being ignored.</p>
<p><strong>Example</strong> (Ignoring Subsequent <code>resume</code> Calls)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.async&lt;number&gt;((resume) =&gt; {
  resume(Effect.succeed(1))
  resume(Effect.succeed(2)) // This line will be ignored
})

// Run the program
Effect.runPromise(program).then(console.log) // Output: 1
</code></pre>
<h3>Advanced Usage</h3>
<p>For more advanced use cases, <code>resume</code> can optionally return an <code>Effect</code> that will be executed if the fiber running this effect is interrupted. This can be useful in scenarios where you need to handle resource cleanup if the operation is interrupted.</p>
<p><strong>Example</strong> (Handling Interruption with Cleanup)</p>
<p>In this example:</p>
<ul>
<li>The <code>writeFileWithCleanup</code> function writes data to a file.</li>
<li>If the fiber running this effect is interrupted, the cleanup effect (which deletes the file) is executed.</li>
<li>This ensures that resources like open file handles are cleaned up properly when the operation is canceled.</li>
</ul>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;
import * as NodeFS from &quot;node:fs&quot;

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename: string, data: string) =&gt;
  Effect.async&lt;void, Error&gt;((resume) =&gt; {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on(&quot;finish&quot;, () =&gt; resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on(&quot;error&quot;, (err) =&gt; resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() =&gt; {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    writeFileWithCleanup(&quot;example.txt&quot;, &quot;Some long data...&quot;)
  )
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
Effect.runPromise(program)
/*
Output:
Cleaning up example.txt
*/
</code></pre>
<p>If the operation you&#39;re wrapping supports interruption, the <code>resume</code> function can receive an <code>AbortSignal</code> to handle interruption requests directly.</p>
<p><strong>Example</strong> (Handling Interruption with <code>AbortSignal</code>)</p>
<pre><code class="language-ts">import { Effect, Fiber } from &quot;effect&quot;

// A task that supports interruption using AbortSignal
const interruptibleTask = Effect.async&lt;void, Error&gt;((resume, signal) =&gt; {
  // Handle interruption
  signal.addEventListener(&quot;abort&quot;, () =&gt; {
    console.log(&quot;Abort signal received&quot;)
    clearTimeout(timeoutId)
  })

  // Simulate a long-running task
  const timeoutId = setTimeout(() =&gt; {
    console.log(&quot;Operation completed&quot;)
    resume(Effect.void)
  }, 2000)
})

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(interruptibleTask)
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Fiber.interrupt(fiber)
})

// Run the program
Effect.runPromise(program)
/*
Output:
Abort signal received
*/
</code></pre>
<h2>Suspended Effects</h2>
<p><code>Effect.suspend</code> is used to delay the creation of an effect.
It allows you to defer the evaluation of an effect until it is actually needed.
The <code>Effect.suspend</code> function takes a thunk that represents the effect, and it wraps it in a suspended effect.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const suspendedEffect = Effect.suspend(() =&gt; effect)
</code></pre>
<p>Let&#39;s explore some common scenarios where <code>Effect.suspend</code> proves useful.</p>
<h3>Lazy Evaluation</h3>
<p>When you want to defer the evaluation of an effect until it is required. This can be useful for optimizing the execution of effects, especially when they are not always needed or when their computation is expensive.</p>
<p>Also, when effects with side effects or scoped captures are created, use <code>Effect.suspend</code> to re-execute on each invocation.</p>
<p><strong>Example</strong> (Lazy Evaluation with Side Effects)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

let i = 0

const bad = Effect.succeed(i++)

const good = Effect.suspend(() =&gt; Effect.succeed(i++))

console.log(Effect.runSync(bad)) // Output: 0
console.log(Effect.runSync(bad)) // Output: 0

console.log(Effect.runSync(good)) // Output: 1
console.log(Effect.runSync(good)) // Output: 2
</code></pre>
<Aside type="note" title="Running Effects">
  This example utilizes `Effect.runSync` to execute effects and display
  their results (refer to [Running
  Effects](/docs/getting-started/running-effects/#runsync) for more
  details).
</Aside>

<p>In this example, <code>bad</code> is the result of calling <code>Effect.succeed(i++)</code> a single time, which increments the scoped variable but <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment#postfix_increment">returns its original value</a>. <code>Effect.runSync(bad)</code> does not result in any new computation, because <code>Effect.succeed(i++)</code> has already been called. On the other hand, each time <code>Effect.runSync(good)</code> is called, the thunk passed to <code>Effect.suspend()</code> will be executed, outputting the scoped variable&#39;s most recent value.</p>
<h3>Handling Circular Dependencies</h3>
<p><code>Effect.suspend</code> is helpful in managing circular dependencies between effects, where one effect depends on another, and vice versa.
For example it&#39;s fairly common for <code>Effect.suspend</code> to be used in recursive functions to escape an eager call.</p>
<p><strong>Example</strong> (Recursive Fibonacci)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const blowsUp = (n: number): Effect.Effect&lt;number&gt; =&gt;
  n &lt; 2
    ? Effect.succeed(1)
    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) =&gt; a + b)

// console.log(Effect.runSync(blowsUp(32)))
// crash: JavaScript heap out of memory

const allGood = (n: number): Effect.Effect&lt;number&gt; =&gt;
  n &lt; 2
    ? Effect.succeed(1)
    : Effect.zipWith(
        Effect.suspend(() =&gt; allGood(n - 1)),
        Effect.suspend(() =&gt; allGood(n - 2)),
        (a, b) =&gt; a + b
      )

console.log(Effect.runSync(allGood(32))) // Output: 3524578
</code></pre>
<Aside type="note" title="Running Effects">
  This example utilizes `Effect.zipWith` to combine the results of two
  effects (refer to the documentation on
  [zipping](/docs/getting-started/control-flow/#zipwith) for more
  details).
</Aside>

<p>The <code>blowsUp</code> function creates a recursive Fibonacci sequence without deferring execution. Each call to <code>blowsUp</code> triggers further immediate recursive calls, rapidly increasing the JavaScript call stack size.</p>
<p>Conversely, <code>allGood</code> avoids stack overflow by using <code>Effect.suspend</code> to defer the recursive calls. This mechanism doesn&#39;t immediately execute the recursive effects but schedules them to be run later, thus keeping the call stack shallow and preventing a crash.</p>
<h3>Unifying Return Type</h3>
<p>In situations where TypeScript struggles to unify the returned effect type, <code>Effect.suspend</code> can be employed to resolve this issue.</p>
<p><strong>Example</strong> (Using <code>Effect.suspend</code> to Help TypeScript Infer Types)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

/*
  Without suspend, TypeScript may struggle with type inference.

  Inferred type:
    (a: number, b: number) =&gt;
      Effect&lt;never, Error, never&gt; | Effect&lt;number, never, never&gt;
*/
const withoutSuspend = (a: number, b: number) =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)

/*
  Using suspend to unify return types.

  Inferred type:
    (a: number, b: number) =&gt; Effect&lt;number, Error, never&gt;
*/
const withSuspend = (a: number, b: number) =&gt;
  Effect.suspend(() =&gt;
    b === 0
      ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
      : Effect.succeed(a / b)
  )
</code></pre>
<h2>Cheatsheet</h2>
<p>The table provides a summary of the available constructors, along with their input and output types, allowing you to choose the appropriate function based on your needs.</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Given</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td><code>succeed</code></td>
<td><code>A</code></td>
<td><code>Effect&lt;A&gt;</code></td>
</tr>
<tr>
<td><code>fail</code></td>
<td><code>E</code></td>
<td><code>Effect&lt;never, E&gt;</code></td>
</tr>
<tr>
<td><code>sync</code></td>
<td><code>() =&gt; A</code></td>
<td><code>Effect&lt;A&gt;</code></td>
</tr>
<tr>
<td><code>try</code></td>
<td><code>() =&gt; A</code></td>
<td><code>Effect&lt;A, UnknownException&gt;</code></td>
</tr>
<tr>
<td><code>try</code> (overload)</td>
<td><code>() =&gt; A</code>, <code>unknown =&gt; E</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
</tr>
<tr>
<td><code>promise</code></td>
<td><code>() =&gt; Promise&lt;A&gt;</code></td>
<td><code>Effect&lt;A&gt;</code></td>
</tr>
<tr>
<td><code>tryPromise</code></td>
<td><code>() =&gt; Promise&lt;A&gt;</code></td>
<td><code>Effect&lt;A, UnknownException&gt;</code></td>
</tr>
<tr>
<td><code>tryPromise</code> (overload)</td>
<td><code>() =&gt; Promise&lt;A&gt;</code>, <code>unknown =&gt; E</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
</tr>
<tr>
<td><code>async</code></td>
<td><code>(Effect&lt;A, E&gt; =&gt; void) =&gt; void</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
</tr>
<tr>
<td><code>suspend</code></td>
<td><code>() =&gt; Effect&lt;A, E, R&gt;</code></td>
<td><code>Effect&lt;A, E, R&gt;</code></td>
</tr>
</tbody></table>
<p>For the complete list of constructors, visit the <a href="https://effect-ts.github.io/effect/effect/Effect.ts.html#constructors">Effect Constructors Documentation</a>.</p>
<hr>
<hr>
<h2>title: Importing Effect
description: Get started with Effect by installing the package and importing essential modules and functions for building type-safe, modular applications.
sidebar:
  order: 4</h2>
<p>import { Aside, Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>If you&#39;re just getting started, you might feel overwhelmed by the variety of modules and functions that Effect offers.</p>
<p>However, rest assured that you don&#39;t need to worry about all of them right away.</p>
<p>This page will provide a simple introduction on how to import modules and functions, and explain that installing the <code>effect</code> package is generally all you need to begin.</p>
<h2>Installing Effect</h2>
<p>If you haven&#39;t already installed the <code>effect</code> package, you can do so by running the following command in your terminal:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install effect
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add effect
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn add effect
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun add effect
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno add npm:effect
</code></pre>
</TabItem>

</Tabs>

<p>By installing this package, you get access to the core functionality of Effect.</p>
<p>For detailed installation instructions for platforms like Deno or Bun, refer to the <a href="/docs/getting-started/installation/">Installation</a> guide, which provides step-by-step guidance.</p>
<p>You can also start a new Effect app using <a href="/docs/getting-started/create-effect-app/"><code>create-effect-app</code></a>, which automatically sets up everything for you.</p>
<h2>Importing Modules and Functions</h2>
<p>Once you have installed the <code>effect</code> package, you can start using its modules and functions in your projects.
Importing modules and functions is straightforward and follows the standard JavaScript/TypeScript import syntax.</p>
<p>To import a module or a function from the <code>effect</code> package, simply use the <code>import</code> statement at the top of your file. Here&#39;s how you can import the <code>Effect</code> module:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
</code></pre>
<p>Now, you have access to the Effect module, which is the heart of the Effect library. It provides various functions to create, compose, and manipulate effectful computations.</p>
<h2>Namespace imports</h2>
<p>In addition to importing the <code>Effect</code> module with a named import, as shown previously:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
</code></pre>
<p>You can also import it using a namespace import like this:</p>
<pre><code class="language-ts">import * as Effect from &quot;effect/Effect&quot;
</code></pre>
<p>Both forms of import allow you to access the functionalities provided by the <code>Effect</code> module.</p>
<p>However an important consideration is <strong>tree shaking</strong>, which refers to a process that eliminates unused code during the bundling of your application.
Named imports may generate tree shaking issues when a bundler doesn&#39;t support deep scope analysis.</p>
<p>Here are some bundlers that support deep scope analysis and thus don&#39;t have issues with named imports:</p>
<ul>
<li>Rollup</li>
<li>Webpack 5+</li>
</ul>
<h2>Functions vs Methods</h2>
<p>In the Effect ecosystem, libraries often expose functions rather than methods. This design choice is important for two key reasons: tree shakeability and extendibility.</p>
<h3>Tree Shakeability</h3>
<p>Tree shakeability refers to the ability of a build system to eliminate unused code during the bundling process. Functions are tree shakeable, while methods are not.</p>
<p>When functions are used in the Effect ecosystem, only the functions that are actually imported and used in your application will be included in the final bundled code. Unused functions are automatically removed, resulting in a smaller bundle size and improved performance.</p>
<p>On the other hand, methods are attached to objects or prototypes, and they cannot be easily tree shaken. Even if you only use a subset of methods, all methods associated with an object or prototype will be included in the bundle, leading to unnecessary code bloat.</p>
<h3>Extendibility</h3>
<p>Another important advantage of using functions in the Effect ecosystem is the ease of extendibility. With methods, extending the functionality of an existing API often requires modifying the prototype of the object, which can be complex and error-prone.</p>
<p>In contrast, with functions, extending the functionality is much simpler. You can define your own &quot;extension methods&quot; as plain old functions without the need to modify the prototypes of objects. This promotes cleaner and more modular code, and it also allows for better compatibility with other libraries and modules.</p>
<h2>Commonly Used Functions</h2>
<p>As you start your adventure with Effect, you don&#39;t need to dive into every function in the <code>effect</code> package right away. Instead, focus on some commonly used functions that will provide a solid foundation for your journey into the world of Effect.</p>
<p>In the upcoming guides, we will explore some of these essential functions, specifically those for creating and running <code>Effect</code>s and building pipelines.</p>
<p>But before we dive into those, let&#39;s start from the very heart of Effect: understanding the <code>Effect</code> type. This will lay the groundwork for your understanding of how Effect brings composability, type safety, and error handling into your applications.</p>
<p>So, let&#39;s take the first step and explore the fundamental concepts of the <a href="/docs/getting-started/the-effect-type/">The Effect Type</a>.</p>
<hr>
<hr>
<h2>title: Installation
description: Set up a new Effect project across different platforms like Node.js, Deno, Bun, and Vite + React with step-by-step installation guides.
sidebar:
  order: 2</h2>
<p>import { Steps, Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>Requirements:</p>
<ul>
<li>TypeScript 5.4 or newer.</li>
<li>Node.js, Deno, and Bun are supported.</li>
</ul>
<h2>Automatic Installation</h2>
<p>To quickly set up a new Effect application, we recommend using <code>create-effect-app</code>, which will handle all configurations for you. To create a new project, run:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npx create-effect-app@latest
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm create effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn create effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bunx create-effect-app@latest
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno init --npm effect-app@latest
</code></pre>
</TabItem>

</Tabs>

<p>Once you complete the prompts, <code>create-effect-app</code> will create a folder with your project name and install all required dependencies.</p>
<p>For more details on the CLI, see the <a href="/docs/getting-started/create-effect-app/">Create Effect App</a> documentation.</p>
<h2>Manual Installation</h2>
<h3>Node.js</h3>
<p>Follow these steps to create a new Effect project for <a href="https://nodejs.org/">Node.js</a>:</p>
<Steps>

<ol>
<li><p>Create a project directory and navigate into it:</p>
<pre><code class="language-sh">mkdir hello-effect
cd hello-effect
</code></pre>
</li>
<li><p>Initialize a TypeScript project:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm init -y
npm install --save-dev typescript
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm init
pnpm add --save-dev typescript
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn init -y
yarn add --dev typescript
</code></pre>
</TabItem>

</Tabs>

<p>This creates a <code>package.json</code> file with an initial setup for your TypeScript project.</p>
</li>
<li><p>Initialize TypeScript:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm tsc --init
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm tsc --init
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn tsc --init
</code></pre>
</TabItem>

</Tabs>

<p>When running this command, it will generate a <code>tsconfig.json</code> file that contains configuration options for TypeScript. One of the most important options to consider is the <code>strict</code> flag.</p>
<p>Make sure to open the <code>tsconfig.json</code> file and verify that the value of the <code>strict</code> option is set to <code>true</code>.</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true
  }
}
</code></pre>
</li>
<li><p>Install the necessary package as dependency:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install effect
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add effect
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn add effect
</code></pre>
</TabItem>

</Tabs>

<p>This package will provide the foundational functionality for your Effect project.</p>
</li>
</ol>
</Steps>

<p>Let&#39;s write and run a simple program to ensure that everything is set up correctly.</p>
<p>In your terminal, execute the following commands:</p>
<pre><code class="language-sh">mkdir src
touch src/index.ts
</code></pre>
<p>Open the <code>index.ts</code> file and add the following code:</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Console.log(&quot;Hello, World!&quot;)

Effect.runSync(program)
</code></pre>
<p>Run the <code>index.ts</code> file. Here we are using <a href="https://github.com/privatenumber/tsx">tsx</a> to run the <code>index.ts</code> file in the terminal:</p>
<pre><code class="language-sh">npx tsx src/index.ts
</code></pre>
<p>You should see the message <code>&quot;Hello, World!&quot;</code> printed. This confirms that the program is working correctly.</p>
<h3>Deno</h3>
<p>Follow these steps to create a new Effect project for <a href="https://deno.com/">Deno</a>:</p>
<Steps>

<ol>
<li><p>Create a project directory and navigate into it:</p>
<pre><code class="language-sh">mkdir hello-effect
cd hello-effect
</code></pre>
</li>
<li><p>Initialize Deno:</p>
<pre><code class="language-sh">deno init
</code></pre>
</li>
<li><p>Install the necessary package as dependency:</p>
<pre><code class="language-sh">deno add npm:effect
</code></pre>
<p>This package will provide the foundational functionality for your Effect project.</p>
</li>
</ol>
</Steps>

<p>Let&#39;s write and run a simple program to ensure that everything is set up correctly.</p>
<p>Open the <code>main.ts</code> file and replace the content with the following code:</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Console.log(&quot;Hello, World!&quot;)

Effect.runSync(program)
</code></pre>
<p>Run the <code>main.ts</code> file:</p>
<pre><code class="language-sh">deno run main.ts
</code></pre>
<p>You should see the message <code>&quot;Hello, World!&quot;</code> printed. This confirms that the program is working correctly.</p>
<h3>Bun</h3>
<p>Follow these steps to create a new Effect project for <a href="https://bun.sh/">Bun</a>:</p>
<Steps>

<ol>
<li><p>Create a project directory and navigate into it:</p>
<pre><code class="language-sh">mkdir hello-effect
cd hello-effect
</code></pre>
</li>
<li><p>Initialize Bun:</p>
<pre><code class="language-sh">bun init
</code></pre>
<p>When running this command, it will generate a <code>tsconfig.json</code> file that contains configuration options for TypeScript. One of the most important options to consider is the <code>strict</code> flag.</p>
<p>Make sure to open the <code>tsconfig.json</code> file and verify that the value of the <code>strict</code> option is set to <code>true</code>.</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true
  }
}
</code></pre>
</li>
<li><p>Install the necessary package as dependency:</p>
<pre><code class="language-sh">bun add effect
</code></pre>
<p>This package will provide the foundational functionality for your Effect project.</p>
</li>
</ol>
</Steps>

<p>Let&#39;s write and run a simple program to ensure that everything is set up correctly.</p>
<p>Open the <code>index.ts</code> file and replace the content with the following code:</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const program = Console.log(&quot;Hello, World!&quot;)

Effect.runSync(program)
</code></pre>
<p>Run the <code>index.ts</code> file:</p>
<pre><code class="language-sh">bun index.ts
</code></pre>
<p>You should see the message <code>&quot;Hello, World!&quot;</code> printed. This confirms that the program is working correctly.</p>
<h3>Vite + React</h3>
<p>Follow these steps to create a new Effect project for <a href="https://vitejs.dev/guide/">Vite</a> + <a href="https://react.dev/">React</a>:</p>
<Steps>

<ol>
<li><p>Scaffold your Vite project, open your terminal and run the following command:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh"># npm 6.x
npm create vite@latest hello-effect --template react-ts
# npm 7+, extra double-dash is needed
npm create vite@latest hello-effect -- --template react-ts
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm create vite@latest hello-effect -- --template react-ts
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn create vite@latest hello-effect -- --template react-ts
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun create vite@latest hello-effect -- --template react-ts
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno init --npm vite@latest hello-effect -- --template react-ts
</code></pre>
</TabItem>

</Tabs>

<p>This command will create a new Vite project with React and TypeScript template.</p>
</li>
<li><p>Navigate into the newly created project directory and install the required packages:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">cd hello-effect
npm install
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">cd hello-effect
pnpm install
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">cd hello-effect
yarn install
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">cd hello-effect
bun install
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">cd hello-effect
deno install
</code></pre>
</TabItem>

</Tabs>

<p>Once the packages are installed, open the <code>tsconfig.json</code> file and ensure that the value of the <code>strict</code> option is set to true.</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true
  }
}
</code></pre>
</li>
<li><p>Install the necessary package as dependency:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install effect
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add effect
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn add effect
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun add effect
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno add effect
</code></pre>
</TabItem>

</Tabs>

<p>This package will provide the foundational functionality for your Effect project.</p>
</li>
</ol>
</Steps>

<p>Now, let&#39;s write and run a simple program to ensure that everything is set up correctly.</p>
<p>Open the <code>src/App.tsx</code> file and replace its content with the following code:</p>
<pre><code class="language-diff">+import { useState, useMemo, useCallback } from &quot;react&quot;
import reactLogo from &quot;./assets/react.svg&quot;
import viteLogo from &quot;/vite.svg&quot;
import &quot;./App.css&quot;
+import { Effect } from &quot;effect&quot;

function App() {
  const [count, setCount] = useState(0)

+  const task = useMemo(
+    () =&gt; Effect.sync(() =&gt; setCount((current) =&gt; current + 1)),
+    [setCount]
+  )
+
+  const increment = useCallback(() =&gt; Effect.runSync(task), [task])

  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;a href=&quot;https://vitejs.dev&quot; target=&quot;_blank&quot;&gt;
          &lt;img src={viteLogo} className=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt;
        &lt;/a&gt;
        &lt;a href=&quot;https://react.dev&quot; target=&quot;_blank&quot;&gt;
          &lt;img src={reactLogo} className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt;
        &lt;/a&gt;
      &lt;/div&gt;
      &lt;h1&gt;Vite + React&lt;/h1&gt;
      &lt;div className=&quot;card&quot;&gt;
+        &lt;button onClick={increment}&gt;count is {count}&lt;/button&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to test HMR
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;p className=&quot;read-the-docs&quot;&gt;
        Click on the Vite and React logos to learn more
      &lt;/p&gt;
    &lt;/&gt;
  )
}

export default App
</code></pre>
<p>After making these changes, start the development server by running the following command:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm run dev
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm run dev
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn run dev
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun run dev
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno run dev
</code></pre>
</TabItem>

</Tabs>

<p>Then, press <strong>o</strong> to open the application in your browser.</p>
<p>When you click the button, you should see the counter increment. This confirms that the program is working correctly.</p>
<hr>
<hr>
<h2>title: Introduction
description: Explore Effect, a TypeScript library for building scalable, maintainable, and type-safe applications with advanced concurrency, error handling, and resource management.
sidebar:
  order: 0</h2>
<p>Welcome to the Effect documentation!</p>
<p>Effect is a powerful TypeScript library designed to help developers
easily create complex, synchronous, and asynchronous programs.</p>
<p>Some of the main Effect features include:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Concurrency</strong></td>
<td>Achieve highly-scalable, ultra low-latency applications through Effect&#39;s fiber-based concurrency model.</td>
</tr>
<tr>
<td><strong>Composability</strong></td>
<td>Construct highly maintainable, readable, and flexible software through the use of small, reusable building blocks.</td>
</tr>
<tr>
<td><strong>Resource Safety</strong></td>
<td>Safely manage acquisition and release of resources, even when your program fails.</td>
</tr>
<tr>
<td><strong>Type Safety</strong></td>
<td>Leverage the TypeScript type system to the fullest with Effect&#39;s focus on type inference and type safety.</td>
</tr>
<tr>
<td><strong>Error Handling</strong></td>
<td>Handle errors in a structured and reliable manner using Effect&#39;s built-in error handling capabilities.</td>
</tr>
<tr>
<td><strong>Asynchronicity</strong></td>
<td>Write code that looks the same, whether it is synchronous or asynchronous.</td>
</tr>
<tr>
<td><strong>Observability</strong></td>
<td>With full tracing capabilities, you can easily debug and monitor the execution of your Effect program.</td>
</tr>
</tbody></table>
<h2>How to Use These Docs</h2>
<p>The documentation is structured in a sequential manner, starting from the basics and progressing to more advanced topics. This allows you to follow along step-by-step as you build your Effect application. However, you have the flexibility to read the documentation in any order or jump directly to the pages that are relevant to your specific use case.</p>
<p>To facilitate navigation within a page, you will find a table of contents on the right side of the screen. This allows you to easily jump between different sections of the page.</p>
<h2>Join our Community</h2>
<p>If you have questions about anything related to Effect,
you&#39;re always welcome to ask our community on <a href="https://discord.gg/effect-ts">Discord</a>.</p>
<hr>
<hr>
<h2>title: Running Effects
description: Learn how to execute effects in Effect with various functions for synchronous and asynchronous execution, including handling results and managing error outcomes.
sidebar:
  order: 7</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>To execute an effect, you can use one of the many <code>run</code> functions provided by the <code>Effect</code> module.</p>
<Aside type="tip" title="Running Effects at the Program's Edge">
  The recommended approach is to design your program with the majority of
  its logic as Effects. It's advisable to use the `run*` functions closer
  to the "edge" of your program. This approach allows for greater
  flexibility in executing your program and building sophisticated
  effects.
</Aside>

<h2>runSync</h2>
<p>Executes an effect synchronously, running it immediately and returning the result.</p>
<p><strong>Example</strong> (Synchronous Logging)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.sync(() =&gt; {
  console.log(&quot;Hello, World!&quot;)
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1
</code></pre>
<p>Use <code>Effect.runSync</code> to run an effect that does not fail and does not include any asynchronous operations. If the effect fails or involves asynchronous work, it will throw an error, and execution will stop where the failure or async operation occurs.</p>
<p><strong>Example</strong> (Incorrect Usage with Failing or Async Effects)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

try {
  // Attempt to run an effect that fails
  Effect.runSync(Effect.fail(&quot;my error&quot;))
} catch (e) {
  console.error(e)
}
/*
Output:
(FiberFailure) Error: my error
*/

try {
  // Attempt to run an effect that involves async work
  Effect.runSync(Effect.promise(() =&gt; Promise.resolve(1)))
} catch (e) {
  console.error(e)
}
/*
Output:
(FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
*/
</code></pre>
<h2>runSyncExit</h2>
<p>Runs an effect synchronously and returns the result as an <a href="/docs/data-types/exit/">Exit</a> type, which represents the outcome (success or failure) of the effect.</p>
<p>Use <code>Effect.runSyncExit</code> to find out whether an effect succeeded or failed,
including any defects, without dealing with asynchronous operations.</p>
<p>The <code>Exit</code> type represents the result of the effect:</p>
<ul>
<li>If the effect succeeds, the result is wrapped in a <code>Success</code>.</li>
<li>If it fails, the failure information is provided as a <code>Failure</code> containing
a <a href="/docs/data-types/cause/">Cause</a> type.</li>
</ul>
<p><strong>Example</strong> (Handling Results as Exit)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

console.log(Effect.runSyncExit(Effect.succeed(1)))
/*
Output:
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Success&quot;,
  value: 1
}
*/

console.log(Effect.runSyncExit(Effect.fail(&quot;my error&quot;)))
/*
Output:
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Failure&quot;,
  cause: {
    _id: &quot;Cause&quot;,
    _tag: &quot;Fail&quot;,
    failure: &quot;my error&quot;
  }
}
*/
</code></pre>
<p>If the effect contains asynchronous operations, <code>Effect.runSyncExit</code> will
return an <code>Failure</code> with a <code>Die</code> cause, indicating that the effect cannot be
resolved synchronously.</p>
<p><strong>Example</strong> (Asynchronous Operation Resulting in Die)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

console.log(Effect.runSyncExit(Effect.promise(() =&gt; Promise.resolve(1))))
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Die&#39;,
    defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
      fiber: [FiberRuntime],
      _tag: &#39;AsyncFiberException&#39;,
      name: &#39;AsyncFiberException&#39;
    }
  }
}
*/
</code></pre>
<h2>runPromise</h2>
<p>Executes an effect and returns the result as a <code>Promise</code>.</p>
<p>Use <code>Effect.runPromise</code> when you need to execute an effect and work with the
result using <code>Promise</code> syntax, typically for compatibility with other
promise-based code.</p>
<p><strong>Example</strong> (Running a Successful Effect as a Promise)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

Effect.runPromise(Effect.succeed(1)).then(console.log)
// Output: 1
</code></pre>
<p>If the effect succeeds, the promise will resolve with the result. If the
effect fails, the promise will reject with an error.</p>
<p><strong>Example</strong> (Handling a Failing Effect as a Rejected Promise)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

Effect.runPromise(Effect.fail(&quot;my error&quot;)).catch(console.error)
/*
Output:
(FiberFailure) Error: my error
*/
</code></pre>
<h2>runPromiseExit</h2>
<p>Runs an effect and returns a <code>Promise</code> that resolves to an <a href="/docs/data-types/exit/">Exit</a>, which
represents the outcome (success or failure) of the effect.</p>
<p>Use <code>Effect.runPromiseExit</code> when you need to determine if an effect succeeded
or failed, including any defects, and you want to work with a <code>Promise</code>.</p>
<p>The <code>Exit</code> type represents the result of the effect:</p>
<ul>
<li>If the effect succeeds, the result is wrapped in a <code>Success</code>.</li>
<li>If it fails, the failure information is provided as a <code>Failure</code> containing
a <a href="/docs/data-types/cause/">Cause</a> type.</li>
</ul>
<p><strong>Example</strong> (Handling Results as Exit)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
/*
Output:
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Success&quot;,
  value: 1
}
*/

Effect.runPromiseExit(Effect.fail(&quot;my error&quot;)).then(console.log)
/*
Output:
{
  _id: &quot;Exit&quot;,
  _tag: &quot;Failure&quot;,
  cause: {
    _id: &quot;Cause&quot;,
    _tag: &quot;Fail&quot;,
    failure: &quot;my error&quot;
  }
}
*/
</code></pre>
<h2>runFork</h2>
<p>The foundational function for running effects, returning a &quot;fiber&quot; that can be observed or interrupted.</p>
<p><code>Effect.runFork</code> is used to run an effect in the background by creating a fiber. It is the base function
for all other run functions. It starts a fiber that can be observed or interrupted.</p>
<Aside type="tip" title="The Default for Effect Execution">
  Unless you specifically need a `Promise` or synchronous operation,
  `Effect.runFork` is a good default choice.
</Aside>

<p><strong>Example</strong> (Running an Effect in the Background)</p>
<pre><code class="language-ts">import { Effect, Console, Schedule, Fiber } from &quot;effect&quot;

//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const program = Effect.repeat(
  Console.log(&quot;running...&quot;),
  Schedule.spaced(&quot;200 millis&quot;)
)

//      ┌─── RuntimeFiber&lt;number, never&gt;
//      ▼
const fiber = Effect.runFork(program)

setTimeout(() =&gt; {
  Effect.runFork(Fiber.interrupt(fiber))
}, 500)
</code></pre>
<p>In this example, the <code>program</code> continuously logs &quot;running...&quot; with each repetition spaced 200 milliseconds apart. You can learn more about repetitions and scheduling in our <a href="/docs/scheduling/introduction/">Introduction to Scheduling</a> guide.</p>
<p>To stop the execution of the program, we use <code>Fiber.interrupt</code> on the fiber returned by <code>Effect.runFork</code>. This allows you to control the execution flow and terminate it when necessary.</p>
<p>For a deeper understanding of how fibers work and how to handle interruptions, check out our guides on <a href="/docs/concurrency/fibers/">Fibers</a> and <a href="/docs/concurrency/basic-concurrency/#interruptions">Interruptions</a>.</p>
<h2>Synchronous vs. Asynchronous Effects</h2>
<p>In the Effect library, there is no built-in way to determine in advance whether an effect will execute synchronously or asynchronously. While this idea was considered in earlier versions of Effect, it was ultimately not implemented for a few important reasons:</p>
<ol>
<li><p><strong>Complexity:</strong> Introducing this feature to track sync/async behavior in the type system would make Effect more complex to use and limit its composability.</p>
</li>
<li><p><strong>Safety Concerns:</strong> We experimented with different approaches to track asynchronous Effects, but they all resulted in a worse developer experience without significantly improving safety. Even with fully synchronous types, we needed to support a <code>fromCallback</code> combinator to work with APIs using Continuation-Passing Style (CPS). However, at the type level, it&#39;s impossible to guarantee that such a function is always called immediately and not deferred.</p>
</li>
</ol>
<h3>Best Practices for Running Effects</h3>
<p>In most cases, effects are run at the outermost parts of your application. Typically, an application built around Effect will involve a single call to the main effect. Here’s how you should approach effect execution:</p>
<ul>
<li><p>Use <code>runPromise</code> or <code>runFork</code>: For most cases, asynchronous execution should be the default. These methods provide the best way to handle Effect-based workflows.</p>
</li>
<li><p>Use <code>runSync</code> only when necessary: Synchronous execution should be considered an edge case, used only in scenarios where asynchronous execution is not feasible. For example, when you are sure the effect is purely synchronous and need immediate results.</p>
</li>
</ul>
<h2>Cheatsheet</h2>
<p>The table provides a summary of the available <code>run*</code> functions, along with their input and output types, allowing you to choose the appropriate function based on your needs.</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Given</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td><code>runSync</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
<td><code>A</code></td>
</tr>
<tr>
<td><code>runSyncExit</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
<td><code>Exit&lt;A, E&gt;</code></td>
</tr>
<tr>
<td><code>runPromise</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
<td><code>Promise&lt;A&gt;</code></td>
</tr>
<tr>
<td><code>runPromiseExit</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
<td><code>Promise&lt;Exit&lt;A, E&gt;&gt;</code></td>
</tr>
<tr>
<td><code>runFork</code></td>
<td><code>Effect&lt;A, E&gt;</code></td>
<td><code>RuntimeFiber&lt;A, E&gt;</code></td>
</tr>
</tbody></table>
<p>You can find the complete list of <code>run*</code> functions <a href="https://effect-ts.github.io/effect/effect/Effect.ts.html#running-effects">here</a>.</p>
<hr>
<hr>
<h2>title: The Effect Type
description: Understand the Effect type in the Effect ecosystem, which models immutable, lazy workflows with type-safe success, error, and requirement handling for effectful computations.
sidebar:
  order: 5</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>Effect</code> type is an <strong>immutable</strong> description of a workflow or operation that is <strong>lazily</strong> executed. This means that when you create an <code>Effect</code>, it doesn&#39;t run immediately, but instead defines a program that can succeed, fail, or require some additional context to complete.</p>
<p>Here is the general form of an <code>Effect</code>:</p>
<pre><code class="language-text">         ┌─── Represents the success type
         │        ┌─── Represents the error type
         │        │      ┌─── Represents required dependencies
         ▼        ▼      ▼
Effect&lt;Success, Error, Requirements&gt;
</code></pre>
<p>This type indicates that an effect:</p>
<ul>
<li>Succeeds and returns a value of type <code>Success</code></li>
<li>Fails with an error of type <code>Error</code></li>
<li>May need certain contextual dependencies of type <code>Requirements</code> to execute</li>
</ul>
<p>Conceptually, you can think of <code>Effect</code> as an effectful version of the following function type:</p>
<pre><code class="language-ts">type Effect&lt;Success, Error, Requirements&gt; = (
  context: Context&lt;Requirements&gt;
) =&gt; Error | Success
</code></pre>
<p>However, effects are not actually functions. They can model synchronous, asynchronous, concurrent, and resourceful computations.</p>
<p><strong>Immutability</strong>. <code>Effect</code> values are immutable, and every function in the Effect library produces a new <code>Effect</code> value.</p>
<p><strong>Modeling Interactions</strong>. These values do not perform any actions themselves, they simply model or describe effectful interactions.</p>
<p><strong>Execution</strong>. An <code>Effect</code> can be executed by the <a href="/docs/runtime/">Effect Runtime System</a>, which interprets it into actual interactions with the external world.
Ideally, this execution happens at a single entry point in your application, such as the main function where effectful operations are initiated.</p>
<h2>Type Parameters</h2>
<p>The <code>Effect</code> type has three type parameters with the following meanings:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Success</strong></td>
<td>Represents the type of value that an effect can succeed with when executed. If this type parameter is <code>void</code>, it means the effect produces no useful information, while if it is <code>never</code>, it means the effect runs forever (or until failure).</td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td>Represents the expected errors that can occur when executing an effect. If this type parameter is <code>never</code>, it means the effect cannot fail, because there are no values of type <code>never</code>.</td>
</tr>
<tr>
<td><strong>Requirements</strong></td>
<td>Represents the contextual data required by the effect to be executed. This data is stored in a collection named <code>Context</code>. If this type parameter is <code>never</code>, it means the effect has no requirements and the <code>Context</code> collection is empty.</td>
</tr>
</tbody></table>
<Aside type="note" title="Type Parameter Abbreviations">
  In the Effect ecosystem, you may often encounter the type parameters of
  `Effect` abbreviated as `A`, `E`, and `R` respectively. This is just
  shorthand for the success value of type **A**, **E**rror, and
  **R**equirements.
</Aside>

<h2>Extracting Inferred Types</h2>
<p>By using the utility types <code>Effect.Success</code>, <code>Effect.Error</code>, and <code>Effect.Context</code>, you can extract the corresponding types from an effect.</p>
<p><strong>Example</strong> (Extracting Success, Error, and Context Types)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

class SomeContext extends Context.Tag(&quot;SomeContext&quot;)&lt;SomeContext, {}&gt;() {}

// Assume we have an effect that succeeds with a number,
// fails with an Error, and requires SomeContext
declare const program: Effect.Effect&lt;number, Error, SomeContext&gt;

// Extract the success type, which is number
type A = Effect.Effect.Success&lt;typeof program&gt;

// Extract the error type, which is Error
type E = Effect.Effect.Error&lt;typeof program&gt;

// Extract the context type, which is SomeContext
type R = Effect.Effect.Context&lt;typeof program&gt;
</code></pre>
<hr>
<hr>
<h2>title: Using Generators
description: Learn how to use generators in Effect for writing effectful code, enhancing control flow, handling errors, and simplifying asynchronous operations with a syntax similar to async/await.
sidebar:
  order: 8</h2>
<p>import {
  Aside,
  Tabs,
  TabItem,
  Badge
} from &quot;@astrojs/starlight/components&quot;</p>
<p>Effect offers a convenient syntax, similar to <code>async</code>/<code>await</code>, to write effectful code using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator">generators</a>.</p>
<Aside type="note" title="Optional Feature">
  The use of generators is an optional feature in Effect. If you find
  generators unfamiliar or prefer a different coding style, you can
  explore the documentation about [Building
  Pipelines](/docs/getting-started/building-pipelines/) in Effect.
</Aside>

<h2>Understanding Effect.gen</h2>
<p>The <code>Effect.gen</code> utility simplifies the task of writing effectful code by utilizing JavaScript&#39;s generator functions. This method helps your code appear and behave more like traditional synchronous code, which enhances both readability and error management.</p>
<p><strong>Example</strong> (Performing Transactions with Discounts)</p>
<p>Let&#39;s explore a practical program that performs a series of data transformations commonly found in application logic:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Function to add a small service charge to a transaction amount
const addServiceCharge = (amount: number) =&gt; amount + 1

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from a
// database
const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Simulated asynchronous task to fetch a discount rate from a
// configuration file
const fetchDiscountRate = Effect.promise(() =&gt; Promise.resolve(5))

// Assembling the program using a generator function
const program = Effect.gen(function* () {
  // Retrieve the transaction amount
  const transactionAmount = yield* fetchTransactionAmount

  // Retrieve the discount rate
  const discountRate = yield* fetchDiscountRate

  // Calculate discounted amount
  const discountedAmount = yield* applyDiscount(
    transactionAmount,
    discountRate
  )

  // Apply service charge
  const finalAmount = addServiceCharge(discountedAmount)

  // Return the total amount after applying the charge
  return `Final amount to charge: ${finalAmount}`
})

// Execute the program and log the result
Effect.runPromise(program).then(console.log)
// Output: Final amount to charge: 96
</code></pre>
<p>Key steps to follow when using <code>Effect.gen</code>:</p>
<ul>
<li>Wrap your logic in <code>Effect.gen</code></li>
<li>Use <code>yield*</code> to handle effects</li>
<li>Return the final result</li>
</ul>
<Aside type="caution" title="Required TypeScript Configuration">
  The generator API is only available when using the `downlevelIteration`
  flag or with a `target` of `"es2015"` or higher in your `tsconfig.json`
  file.
</Aside>

<h2>Comparing Effect.gen with async/await</h2>
<p>If you are familiar with <code>async</code>/<code>await</code>, you may notice that the flow of writing code is similar.</p>
<p>Let&#39;s compare the two approaches:</p>
<Tabs syncKey="promises-vs-generators">

<TabItem label="Using Effect.gen">

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const addServiceCharge = (amount: number) =&gt; amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  discountRate === 0
    ? Effect.fail(new Error(&quot;Discount rate cannot be zero&quot;))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() =&gt; Promise.resolve(5))

export const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
  const discountRate = yield* fetchDiscountRate
  const discountedAmount = yield* applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
})
</code></pre>
</TabItem>

<TabItem label="Using Async / Await">

<pre><code class="language-ts">const addServiceCharge = (amount: number) =&gt; amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Promise&lt;number&gt; =&gt;
  discountRate === 0
    ? Promise.reject(new Error(&quot;Discount rate cannot be zero&quot;))
    : Promise.resolve(total - (total * discountRate) / 100)

const fetchTransactionAmount = Promise.resolve(100)

const fetchDiscountRate = Promise.resolve(5)

export const program = async function () {
  const transactionAmount = await fetchTransactionAmount
  const discountRate = await fetchDiscountRate
  const discountedAmount = await applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
}
</code></pre>
</TabItem>

</Tabs>

<p>It&#39;s important to note that although the code appears similar, the two programs are not identical. The purpose of comparing them side by side is just to highlight the resemblance in how they are written.</p>
<h2>Embracing Control Flow</h2>
<p>One significant advantage of using <code>Effect.gen</code> in conjunction with generators is its capability to employ standard control flow constructs within the generator function. These constructs include <code>if</code>/<code>else</code>, <code>for</code>, <code>while</code>, and other branching and looping mechanisms, enhancing your ability to express complex control flow logic in your code.</p>
<p><strong>Example</strong> (Using Control Flow)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const calculateTax = (
  amount: number,
  taxRate: number
): Effect.Effect&lt;number, Error&gt; =&gt;
  taxRate &gt; 0
    ? Effect.succeed((amount * taxRate) / 100)
    : Effect.fail(new Error(&quot;Invalid tax rate&quot;))

const program = Effect.gen(function* () {
  let i = 1

  while (true) {
    if (i === 10) {
      break // Break the loop when counter reaches 10
    } else {
      if (i % 2 === 0) {
        // Calculate tax for even numbers
        console.log(yield* calculateTax(100, i))
      }
      i++
      continue
    }
  }
})

Effect.runPromise(program)
/*
Output:
2
4
6
8
*/
</code></pre>
<h2>How to Raise Errors</h2>
<p>The <code>Effect.gen</code> API lets you integrate error handling directly into your workflow by yielding failed effects.
You can introduce errors with <code>Effect.fail</code>, as shown in the example below.</p>
<p><strong>Example</strong> (Introducing an Error into the Flow)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Console.log(&quot;task1...&quot;)
const task2 = Console.log(&quot;task2...&quot;)

const program = Effect.gen(function* () {
  // Perform some tasks
  yield* task1
  yield* task2
  // Introduce an error
  yield* Effect.fail(&quot;Something went wrong!&quot;)
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
task1...
task2...
(FiberFailure) Error: Something went wrong!
*/
</code></pre>
<h2>The Role of Short-Circuiting</h2>
<p>When working with <code>Effect.gen</code>, it is important to understand how it handles errors.
This API will stop execution at the <strong>first error</strong> it encounters and return that error.</p>
<p>How does this affect your code? If you have several operations in sequence, once any one of them fails, the remaining operations will not run, and the error will be returned.</p>
<p>In simpler terms, if something fails at any point, the program will stop right there and deliver the error to you.</p>
<p><strong>Example</strong> (Halting Execution at the First Error)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Console.log(&quot;task1...&quot;)
const task2 = Console.log(&quot;task2...&quot;)
const failure = Effect.fail(&quot;Something went wrong!&quot;)
const task4 = Console.log(&quot;task4...&quot;)

const program = Effect.gen(function* () {
  yield* task1
  yield* task2
  // The program stops here due to the error
  yield* failure
  // The following lines never run
  yield* task4
  return &quot;some result&quot;
})

Effect.runPromise(program).then(console.log, console.error)
/*
Output:
task1...
task2...
(FiberFailure) Error: Something went wrong!
*/
</code></pre>
<p>Even though execution never reaches code after a failure, TypeScript may still assume that the code below the error is reachable unless you explicitly return after the failure.</p>
<p>For example, consider the following scenario where you want to narrow the type of a variable:</p>
<p><strong>Example</strong> (Type Narrowing without Explicit Return)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

type User = {
  readonly name: string
}

// Imagine this function checks a database or an external service
declare function getUserById(id: string): Effect.Effect&lt;User | undefined&gt;

function greetUser(id: string) {
  return Effect.gen(function* () {
    const user = yield* getUserById(id)

    if (user === undefined) {
      // Even though we fail here, TypeScript still thinks
      // &#39;user&#39; might be undefined later
      yield* Effect.fail(`User with id ${id} not found`)
    }

    // @ts-expect-error user is possibly &#39;undefined&#39;.ts(18048)
    return `Hello, ${user.name}!`
  })
}
</code></pre>
<p>In this example, TypeScript still considers <code>user</code> possibly <code>undefined</code> because there is no explicit return after the failure.</p>
<p>To fix this, explicitly return right after calling <code>Effect.fail</code>:</p>
<p><strong>Example</strong> (Type Narrowing with Explicit Return)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

type User = {
  readonly name: string
}

declare function getUserById(id: string): Effect.Effect&lt;User | undefined&gt;

function greetUser(id: string) {
  return Effect.gen(function* () {
    const user = yield* getUserById(id)

    if (user === undefined) {
      // Explicitly return after failing
      return yield* Effect.fail(`User with id ${id} not found`)
    }

    // Now TypeScript knows that &#39;user&#39; is not undefined
    return `Hello, ${user.name}!`
  })
}
</code></pre>
<Aside type="note" title="Further Learning">
  To learn more about error handling in Effect, refer to the [Error
  Management](/docs/error-management/two-error-types/) section.
</Aside>

<h2>Passing <code>this</code></h2>
<p>In some cases, you might need to pass a reference to the current object (<code>this</code>) into the body of your generator function.
You can achieve this by utilizing an overload that accepts the reference as the first argument:</p>
<p><strong>Example</strong> (Passing <code>this</code> to Generator)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

class MyClass {
  readonly local = 1
  compute = Effect.gen(this, function* () {
    const n = this.local + 1

    yield* Effect.log(`Computed value: ${n}`)

    return n
  })
}

Effect.runPromise(new MyClass().compute).then(console.log)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Computed value: 2&quot;
2
*/
</code></pre>
<h2>Adapter <Badge text="Deprecated" variant="caution" /></h2>
<p>You may still come across some code snippets that use an adapter, typically indicated by <code>_</code> or <code>$</code> symbols.</p>
<p>In earlier versions of TypeScript, the generator &quot;adapter&quot; function was necessary to ensure correct type inference within generators. This adapter was used to facilitate the interaction between TypeScript&#39;s type system and generator functions.</p>
<p><strong>Example</strong> (Adapter in Older Code)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const fetchTransactionAmount = Effect.promise(() =&gt; Promise.resolve(100))

// Older usage with an adapter for proper type inference
const programWithAdapter = Effect.gen(function* ($) {
  const transactionAmount = yield* $(fetchTransactionAmount)
})

// Current usage without an adapter
const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
})
</code></pre>
<p>With advances in TypeScript (v5.5+), the adapter is no longer necessary for type inference. While it remains in the codebase for backward compatibility, it is anticipated to be removed in the upcoming major release of Effect.</p>
<hr>
<hr>
<h2>title: Why Effect?
description: Discover how Effect transforms TypeScript programming by using the type system to track errors, context, and success, offering practical solutions for building reliable, maintainable applications.
sidebar:
  order: 1</h2>
<p>Programming is challenging. When we build libraries and apps, we look to many tools to handle the complexity and make our day-to-day more manageable. Effect presents a new way of thinking about programming in TypeScript.</p>
<p>Effect is an ecosystem of tools that help you build better applications and libraries. As a result, you will also learn more about the TypeScript language and how to use the type system to make your programs more reliable and easier to maintain.</p>
<p>In &quot;typical&quot; TypeScript, without Effect, we write code that assumes that a function is either successful or throws an exception. For example:</p>
<pre><code class="language-ts">const divide = (a: number, b: number): number =&gt; {
  if (b === 0) {
    throw new Error(&quot;Cannot divide by zero&quot;)
  }
  return a / b
}
</code></pre>
<p>Based on the types, we have no idea that this function can throw an exception. We can only find out by reading the code. This may not seem like much of a problem when you only have one function in your codebase, but when you have hundreds or thousands, it really starts to add up. It&#39;s easy to forget that a function can throw an exception, and it&#39;s easy to forget to handle that exception.</p>
<p>Often, we will do the &quot;easiest&quot; thing and just wrap the function in a <code>try/catch</code> block. This is a good first step to prevent your program from crashing, but it doesn&#39;t make it any easier to manage or understand our complex application/library. We can do better.</p>
<p>One of the most important tools we have in TypeScript is the compiler. It is the first line of defense against bugs, domain errors, and general complexity.</p>
<h2>The Effect Pattern</h2>
<p>While Effect is a vast ecosystem of many different tools, if it had to be reduced down to just one idea, it would be the following:</p>
<p>Effect&#39;s major unique insight is that we can use the type system to track <strong>errors</strong> and <strong>context</strong>, not only <strong>success</strong> values as shown in the divide example above.</p>
<p>Here&#39;s the same divide function from above, but with the Effect pattern:</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const divide = (
  a: number,
  b: number
): Effect.Effect&lt;number, Error, never&gt; =&gt;
  b === 0
    ? Effect.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Effect.succeed(a / b)
</code></pre>
<p>With this approach, the function no longer throws exceptions. Instead, errors are handled as values, which can be passed along like success values. The type signature also makes it clear:</p>
<ul>
<li>What success value the function returns (<code>number</code>).</li>
<li>What error can occur (<code>Error</code>).</li>
<li>What additional context or dependencies are required (<code>never</code> indicates none).</li>
</ul>
<pre><code class="language-text">         ┌─── Produces a value of type number
         │       ┌─── Fails with an Error
         │       │      ┌─── Requires no dependencies
         ▼       ▼      ▼
Effect&lt;number, Error, never&gt;
</code></pre>
<p>Additionally, tracking context allows you to provide additional information to your functions without having to pass in everything as an argument. For example, you can swap out implementations of live external services with mocks during your tests without changing any core business logic.</p>
<h2>Don&#39;t Re-Invent the Wheel</h2>
<p>Application code in TypeScript often solves the same problems over and over again. Interacting with external services, filesystems, databases, etc. are common problems for all application developers. Effect provides a rich ecosystem of libraries that provide standardized solutions to many of these problems. You can use these libraries to build your application, or you can use them to build your own libraries.</p>
<p>Managing challenges like error handling, debugging, tracing, async/promises, retries, streaming, concurrency, caching, resource management, and a lot more are made manageable with Effect. You don&#39;t have to re-invent the solutions to these problems, or install tons of dependencies. Effect, under one umbrella, solves many of the problems that you would usually install many different dependencies with different APIs to solve.</p>
<h2>Solving Practical Problems</h2>
<p>Effect is heavily inspired by great work done in other languages, like Scala and Haskell. However, it&#39;s important to understand that Effect&#39;s goal is to be a practical toolkit, and it goes to great lengths to solve real, everyday problems that developers face when building applications and libraries in TypeScript.</p>
<h2>Enjoy Building and Learning</h2>
<p>Learning Effect is a lot of fun. Many developers in the Effect ecosystem are using Effect to solve real problems in their day-to-day work, and also experiment with cutting edge ideas for pushing TypeScript to be the most useful language it can be.</p>
<p>You don&#39;t have to use all aspects of Effect at once, and can start with the pieces of the ecosystem that make the most sense for the problems you are solving. Effect is a toolkit, and you can pick and choose the pieces that make the most sense for your use case. However, as more and more of your codebase is using Effect, you will probably find yourself wanting to utilize more of the ecosystem!</p>
<p>Effect&#39;s concepts may be new to you, and might not completely make sense at first. This is totally normal. Take your time with reading the docs and try to understand the core concepts - this will really pay off later on as you get into the more advanced tooling in the Effect ecosystem. The Effect community is always happy to help you learn and grow. Feel free to hop into our <a href="https://discord.gg/effect-ts">Discord</a> or discuss on <a href="https://github.com/Effect-TS">GitHub</a>! We are open to feedback and contributions, and are always looking for ways to improve Effect.</p>
<hr>
<hr>
<h2>title: Micro for Effect Users
description: Learn about the Micro module, a lightweight alternative to Effect for reducing bundle size while maintaining compatibility and functionality for TypeScript applications.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<Aside type="caution" title="Experimental Module">
  The Micro module is currently in its experimental stages. We encourage
  your feedback to further improve its features.
</Aside>

<p>The Micro module is designed as a lighter alternative to the standard Effect module, tailored for situations where it is beneficial to reduce the bundle size.</p>
<p>This module is standalone and does not include more complex functionalities such as <a href="/docs/requirements-management/layers/">Layer</a>, <a href="/docs/state-management/ref/">Ref</a>, <a href="/docs/concurrency/queue/">Queue</a>, and <a href="/docs/concurrency/deferred/">Deferred</a>. This feature set makes Micro especially suitable for libraries that wish to utilize Effect functionalities while keeping the bundle size to a minimum, particularly for those aiming to provide <code>Promise</code>-based APIs.</p>
<p>Micro also supports use cases where a client application uses Micro, and a server employs the full suite of Effect features, maintaining both compatibility and logical consistency across various application components.</p>
<p>Integrating Micro adds a minimal footprint to your bundle, starting at <strong>5kb gzipped</strong>, which may increase depending on the features you use.</p>
<Aside type="danger" title="Bundle Size">
  Utilizing major Effect modules beyond basic data modules like `Option`,
  `Either`, `Array`, will incorporate the Effect runtime into your bundle,
  negating the benefits of Micro.
</Aside>

<h2>Importing Micro</h2>
<p>Micro is a part of the Effect library and can be imported just like any other module:</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
</code></pre>
<p>You can also import it using a namespace import like this:</p>
<pre><code class="language-ts">import * as Micro from &quot;effect/Micro&quot;
</code></pre>
<p>Both forms of import allow you to access the functionalities provided by the <code>Micro</code> module.</p>
<p>However an important consideration is <strong>tree shaking</strong>, which refers to a process that eliminates unused code during the bundling of your application.
Named imports may generate tree shaking issues when a bundler doesn&#39;t support deep scope analysis.</p>
<p>Here are some bundlers that support deep scope analysis and thus don&#39;t have issues with named imports:</p>
<ul>
<li>Rollup</li>
<li>Webpack 5+</li>
</ul>
<h2>Main Types</h2>
<h3>Micro</h3>
<p>The <code>Micro</code> type uses three type parameters:</p>
<pre><code class="language-text">        ┌─── Represents the success type
        │        ┌─── Represents the error type
        │        │      ┌─── Represents required dependencies
        ▼        ▼      ▼
Micro&lt;Success, Error, Requirements&gt;
</code></pre>
<p>which mirror those of the <code>Effect</code> type.</p>
<h3>MicroExit</h3>
<p>The <code>MicroExit</code> type is a streamlined version of the <a href="/docs/data-types/exit/">Exit</a> type, designed to capture the outcome of a <code>Micro</code> computation.
It can either be successful, containing a value of type <code>A</code>, or it can fail, containing an error of type <code>E</code> wrapped in a <code>MicroCause</code>.</p>
<pre><code class="language-ts">type MicroExit&lt;A, E&gt; = MicroExit.Success&lt;A, E&gt; | MicroExit.Failure&lt;A, E&gt;
</code></pre>
<h3>MicroCause</h3>
<p>The <code>MicroCause</code> type is a streamlined version of the <a href="/docs/data-types/cause/">Cause</a> type.</p>
<p>Similar to how <code>Cause</code> is a union of types, <code>MicroCause</code> comes in three forms:</p>
<pre><code class="language-ts">type MicroCause&lt;E&gt; = Die | Fail&lt;E&gt; | Interrupt
</code></pre>
<table>
<thead>
<tr>
<th>Variant</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Die</code></td>
<td>Indicates an unforeseen defect that wasn&#39;t planned for in the system&#39;s logic.</td>
</tr>
<tr>
<td><code>Fail&lt;E&gt;</code></td>
<td>Covers anticipated errors that are recognized and typically handled within the application.</td>
</tr>
<tr>
<td><code>Interrupt</code></td>
<td>Signifies an operation that has been purposefully stopped.</td>
</tr>
</tbody></table>
<h3>MicroSchedule</h3>
<p>The <code>MicroSchedule</code> type is a streamlined version of the <a href="/docs/scheduling/introduction/">Schedule</a> type.</p>
<pre><code class="language-ts">type MicroSchedule = (attempt: number, elapsed: number) =&gt; Option&lt;number&gt;
</code></pre>
<p>Represents a function that can be used to calculate the delay between
repeats.</p>
<p>The function takes the current attempt number and the elapsed time since
the first attempt, and returns the delay for the next attempt. If the
function returns <code>None</code>, the repetition will stop.</p>
<h2>How to Use This Guide</h2>
<p>Below, you&#39;ll find a series of comparisons between the functionalities of <code>Effect</code> and <code>Micro</code>. Each table lists a functionality of <code>Effect</code> alongside its counterpart in <code>Micro</code>. The icons used have the following meanings:</p>
<ul>
<li>⚠️: The feature is available in <code>Micro</code>, but with some differences from <code>Effect</code>.</li>
<li>❌: The feature is not available in <code>Effect</code>.</li>
</ul>
<h2>Creating Effects</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.try</code></td>
<td><code>Micro.try</code></td>
<td>requires a <code>try</code> block</td>
</tr>
<tr>
<td><code>Effect.tryPromise</code></td>
<td><code>Micro.tryPromise</code></td>
<td>requires a <code>try</code> block</td>
</tr>
<tr>
<td><code>Effect.sleep</code></td>
<td><code>Micro.sleep</code></td>
<td>only handles milliseconds</td>
</tr>
<tr>
<td><code>Effect.failCause</code></td>
<td><code>Micro.failWith</code></td>
<td>uses <code>MicroCause</code> instead of <code>Cause</code></td>
</tr>
<tr>
<td><code>Effect.failCauseSync</code></td>
<td><code>Micro.failWithSync</code></td>
<td>uses <code>MicroCause</code> instead of <code>Cause</code></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.make</code></td>
<td></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.fromOption</code></td>
<td></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.fromEither</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Running Effects</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.runSyncExit</code></td>
<td><code>Micro.runSyncExit</code></td>
<td>returns a <code>MicroExit</code> instead of an <code>Exit</code></td>
</tr>
<tr>
<td><code>Effect.runPromiseExit</code></td>
<td><code>Micro.runPromiseExit</code></td>
<td>returns a <code>MicroExit</code> instead of an <code>Exit</code></td>
</tr>
<tr>
<td><code>Effect.runFork</code></td>
<td><code>Micro.runFork</code></td>
<td>returns a <code>MicroFiber</code> instead of a <code>RuntimeFiber</code></td>
</tr>
</tbody></table>
<h3>runSyncExit</h3>
<p>The <code>Micro.runSyncExit</code> function is used to execute an Effect synchronously, which means it runs immediately and returns the result as a <a href="#microexit">MicroExit</a>.</p>
<p><strong>Example</strong> (Handling Results as MicroExit)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const result1 = Micro.runSyncExit(Micro.succeed(1))
console.log(result1)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: 1
}
*/

const result2 = Micro.runSyncExit(Micro.fail(&quot;my error&quot;))
console.log(result2)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Fail&quot;,
    &quot;error&quot;: &quot;my error&quot;
  }
}
*/
</code></pre>
<h3>runPromiseExit</h3>
<p>The <code>Micro.runPromiseExit</code> function is used to execute an Effect and obtain the result as a <code>Promise</code> that resolves to a <a href="#microexit">MicroExit</a>.</p>
<p><strong>Example</strong> (Handling Results as MicroExit)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

Micro.runPromiseExit(Micro.succeed(1)).then(console.log)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: 1
}
*/

Micro.runPromiseExit(Micro.fail(&quot;my error&quot;)).then(console.log)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Fail&quot;,
    &quot;error&quot;: &quot;my error&quot;
  }
}
*/
</code></pre>
<h3>runFork</h3>
<p>The <code>Micro.runFork</code> function executes the effect and return a <code>MicroFiber</code> that can be awaited, joined, or aborted.</p>
<p>You can listen for the result by adding an observer using the <code>addObserver</code> method.</p>
<p><strong>Example</strong> (Observing an Asynchronous Effect)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

//      ┌─── MicroFiber&lt;number, never&gt;
//      ▼
const fiber = Micro.succeed(42).pipe(Micro.delay(1000), Micro.runFork)

// Attach an observer to log the result when the effect completes
fiber.addObserver((result) =&gt; {
  console.log(result)
})

console.log(&quot;observing...&quot;)
/*
Output:
observing...
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: 42
}
*/
</code></pre>
<h2>Building Pipelines</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.andThen</code></td>
<td><code>Micro.andThen</code></td>
<td>doesn&#39;t handle <code>Promise</code> or <code>() =&gt; Promise</code> as argument</td>
</tr>
<tr>
<td><code>Effect.tap</code></td>
<td><code>Micro.tap</code></td>
<td>doesn&#39;t handle <code>() =&gt; Promise</code> as argument</td>
</tr>
<tr>
<td><code>Effect.all</code></td>
<td><code>Micro.all</code></td>
<td>no <code>batching</code> and <code>mode</code> options</td>
</tr>
<tr>
<td><code>Effect.forEach</code></td>
<td><code>Micro.forEach</code></td>
<td>no <code>batching</code> option</td>
</tr>
<tr>
<td><code>Effect.filter</code></td>
<td><code>Micro.filter</code></td>
<td>no <code>batching</code> option</td>
</tr>
<tr>
<td><code>Effect.filterMap</code></td>
<td><code>Micro.filterMap</code></td>
<td>the filter is effectful</td>
</tr>
</tbody></table>
<h2>Expected Errors</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.exit</code></td>
<td><code>Micro.exit</code></td>
<td>returns a <code>MicroExit</code> instead of an <code>Exit</code></td>
</tr>
</tbody></table>
<h2>Unexpected Errors</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>❌</td>
<td><code>Micro.catchCauseIf</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Timing Out</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>❌</td>
<td><code>Micro.timeoutOrElse</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Requirements Management</h2>
<p>To access a service while using <code>Micro.gen</code>, you need to wrap the service tag using the <code>Micro.service</code> function:</p>
<p><strong>Example</strong> (Accessing a Service in <code>Micro.gen</code>)</p>
<pre><code class="language-ts">import { Micro, Context } from &quot;effect&quot;

class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Micro.Micro&lt;number&gt; }
&gt;() {}

const program = Micro.gen(function* () {
  // const random = yield* Random // this doesn&#39;t work
  const random = yield* Micro.service(Random)
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

const runnable = Micro.provideService(program, Random, {
  next: Micro.sync(() =&gt; Math.random())
})

Micro.runPromise(runnable)
/*
Example Output:
random number: 0.8241872233134417
*/
</code></pre>
<h2>Scope</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Scope</code></td>
<td><code>MicroScope</code></td>
<td>returns a <code>MicroScope</code> instead of a <code>Scope</code></td>
</tr>
<tr>
<td><code>Scope.make</code></td>
<td><code>Micro.scopeMake</code></td>
<td>returns a <code>MicroScope</code> instead of a <code>Scope</code></td>
</tr>
</tbody></table>
<h2>Retrying</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.retry</code></td>
<td><code>Micro.retry</code></td>
<td>different <code>options</code></td>
</tr>
</tbody></table>
<h2>Repetition</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.repeat</code></td>
<td><code>Micro.repeat</code></td>
<td>different <code>options</code></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.repeatExit</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Timing out</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>❌</td>
<td><code>Micro.timeoutOrElse</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Sandboxing</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.sandbox</code></td>
<td><code>Micro.sandbox</code></td>
<td>returns a <code>MicroCause&lt;E&gt;</code> instead of <code>Cause&lt;E&gt;</code></td>
</tr>
</tbody></table>
<h2>Error Channel Operations</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td>❌</td>
<td><code>Micro.filterOrFailWith</code></td>
<td></td>
</tr>
<tr>
<td><code>Effect.tapErrorCause</code></td>
<td><code>Micro.tapErrorCause</code></td>
<td><code>MicroCause&lt;E&gt;</code> instead of <code>Cause&lt;E&gt;</code></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.tapCauseIf</code></td>
<td></td>
</tr>
<tr>
<td><code>Effect.tapDefect</code></td>
<td><code>Micro.tapDefect</code></td>
<td><code>unknown</code> instead of <code>Cause&lt;never&gt;</code></td>
</tr>
</tbody></table>
<h2>Requirements Management</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.provide</code></td>
<td><code>Micro.provideContext</code></td>
<td>only handles <code>Context</code></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.provideScope</code></td>
<td></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.service</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Scoping, Resources and Finalization</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.addFinalizer</code></td>
<td><code>Micro.addFinalizer</code></td>
<td><code>MicroExit</code> instead of <code>Exit</code> and no <code>R</code></td>
</tr>
<tr>
<td><code>Effect.acquireRelease</code></td>
<td><code>Micro.acquireRelease</code></td>
<td><code>MicroExit</code> instead of <code>Exit</code></td>
</tr>
<tr>
<td><code>Effect.acquireUseRelease</code></td>
<td><code>Micro.acquireUseRelease</code></td>
<td><code>MicroExit</code> instead of <code>Exit</code></td>
</tr>
<tr>
<td><code>Effect.onExit</code></td>
<td><code>Micro.onExit</code></td>
<td><code>MicroExit</code> instead of <code>Exit</code></td>
</tr>
<tr>
<td><code>Effect.onError</code></td>
<td><code>Micro.onError</code></td>
<td>uses <code>MicroCause</code> instead of <code>Cause</code></td>
</tr>
<tr>
<td>❌</td>
<td><code>Micro.onExitIf</code></td>
<td></td>
</tr>
</tbody></table>
<h2>Concurrency</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Micro</th>
<th>⚠️</th>
</tr>
</thead>
<tbody><tr>
<td><code>Effect.fork</code></td>
<td><code>Micro.fork</code></td>
<td><code>MicroFiber</code> instead of <code>RuntimeFiber</code></td>
</tr>
<tr>
<td><code>Effect.forkDaemon</code></td>
<td><code>Micro.forkDaemon</code></td>
<td><code>MicroFiber</code> instead of <code>RuntimeFiber</code></td>
</tr>
<tr>
<td><code>Effect.forkIn</code></td>
<td><code>Micro.forkIn</code></td>
<td><code>MicroFiber</code> instead of <code>RuntimeFiber</code></td>
</tr>
<tr>
<td><code>Effect.forkScoped</code></td>
<td><code>Micro.forkScoped</code></td>
<td><code>MicroFiber</code> instead of <code>RuntimeFiber</code></td>
</tr>
</tbody></table>
<hr>
<hr>
<h2>title: Getting Started with Micro
description: Learn how to get started with the Micro module, a lightweight alternative to Effect for reducing bundle size while maintaining essential functionality in TypeScript applications.
sidebar:
  label: Getting Started
  order: 0</h2>
<p>import {
  Aside,
  Tabs,
  TabItem,
  Steps
} from &quot;@astrojs/starlight/components&quot;</p>
<Aside type="caution" title="Experimental Module">
  The Micro module is currently in its experimental stages. We encourage
  your feedback to further improve its features.
</Aside>

<p>The Micro module is designed as a lighter alternative to the standard Effect module, tailored for situations where it is beneficial to reduce the bundle size.</p>
<p>This module is standalone and does not include more complex functionalities such as <a href="/docs/requirements-management/layers/">Layer</a>, <a href="/docs/state-management/ref/">Ref</a>, <a href="/docs/concurrency/queue/">Queue</a>, and <a href="/docs/concurrency/deferred/">Deferred</a>. This feature set makes Micro especially suitable for libraries that wish to utilize Effect functionalities while keeping the bundle size to a minimum, particularly for those aiming to provide <code>Promise</code>-based APIs.</p>
<p>Micro also supports use cases where a client application uses Micro, and a server employs the full suite of Effect features, maintaining both compatibility and logical consistency across various application components.</p>
<p>Integrating Micro adds a minimal footprint to your bundle, starting at <strong>5kb gzipped</strong>, which may increase depending on the features you use.</p>
<Aside type="danger" title="Bundle Size">
  Utilizing major Effect modules beyond basic data modules like `Option`,
  `Either`, `Array`, will incorporate the Effect runtime into your bundle,
  negating the benefits of Micro.
</Aside>

<h2>Importing Micro</h2>
<p>Before you start, make sure you have completed the following setup:</p>
<p>Install the <code>effect</code> library in your project. If it is not already installed, you can add it using npm with the following command:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install effect
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add effect
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn add effect
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun add effect
</code></pre>
</TabItem>
<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno add npm:effect
</code></pre>
</TabItem>

</Tabs>

<p>Micro is a part of the Effect library and can be imported just like any other module:</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
</code></pre>
<p>You can also import it using a namespace import like this:</p>
<pre><code class="language-ts">import * as Micro from &quot;effect/Micro&quot;
</code></pre>
<p>Both forms of import allow you to access the functionalities provided by the <code>Micro</code> module.</p>
<p>However an important consideration is <strong>tree shaking</strong>, which refers to a process that eliminates unused code during the bundling of your application.
Named imports may generate tree shaking issues when a bundler doesn&#39;t support deep scope analysis.</p>
<p>Here are some bundlers that support deep scope analysis and thus don&#39;t have issues with named imports:</p>
<ul>
<li>Rollup</li>
<li>Webpack 5+</li>
</ul>
<h2>The Micro Type</h2>
<p>Here is the general form of a <code>Micro</code>:</p>
<pre><code class="language-text">        ┌─── Represents the success type
        │        ┌─── Represents the error type
        │        │      ┌─── Represents required dependencies
        ▼        ▼      ▼
Micro&lt;Success, Error, Requirements&gt;
</code></pre>
<p>which mirror those of the <code>Effect</code> type:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Success</strong></td>
<td>Represents the type of value that an effect can succeed with when executed. If this type parameter is <code>void</code>, it means the effect produces no useful information, while if it is <code>never</code>, it means the effect runs forever (or until failure).</td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td>Represents the expected errors that can occur when executing an effect. If this type parameter is <code>never</code>, it means the effect cannot fail, because there are no values of type <code>never</code>.</td>
</tr>
<tr>
<td><strong>Requirements</strong></td>
<td>Represents the contextual data required by the effect to be executed. This data is stored in a collection named <code>Context</code>. If this type parameter is <code>never</code>, it means the effect has no requirements and the <code>Context</code> collection is empty.</td>
</tr>
</tbody></table>
<h2>The MicroExit Type</h2>
<p>The <code>MicroExit</code> type is used to represent the result of a <code>Micro</code> computation.
It can either be successful, containing a value of type <code>A</code>, or it can fail, containing an error of type <code>E</code> wrapped in a <code>MicroCause</code>.</p>
<pre><code class="language-ts">type MicroExit&lt;A, E&gt; = MicroExit.Success&lt;A, E&gt; | MicroExit.Failure&lt;A, E&gt;
</code></pre>
<h2>The MicroCause Type</h2>
<p>The <code>MicroCause</code> type describes the different reasons why an effect may fail.</p>
<p><code>MicroCause</code> comes in three forms:</p>
<pre><code class="language-ts">type MicroCause&lt;E&gt; = Die | Fail&lt;E&gt; | Interrupt
</code></pre>
<table>
<thead>
<tr>
<th>Variant</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Die</code></td>
<td>Indicates an unforeseen defect that wasn&#39;t planned for in the system&#39;s logic.</td>
</tr>
<tr>
<td><code>Fail&lt;E&gt;</code></td>
<td>Covers anticipated errors that are recognized and typically handled within the application.</td>
</tr>
<tr>
<td><code>Interrupt</code></td>
<td>Signifies an operation that has been purposefully stopped.</td>
</tr>
</tbody></table>
<h2>Wrapping a Promise-based API with Micro</h2>
<p>This guide shows how to wrap a <code>Promise</code>-based API using the <code>Micro</code> library from Effect. We&#39;ll create a simple example that interacts with a hypothetical weather forecasting API, using Micro to handle structured error handling and execution flow.</p>
<Steps>

<ol>
<li><p><strong>Create a Promise-based API Function</strong></p>
<p>Start by defining a basic Promise-based function that simulates fetching weather data from an external service.</p>
<pre><code class="language-ts">// Simulate fetching weather data
function fetchWeather(city: string): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (city === &quot;London&quot;) {
        resolve(&quot;Sunny&quot;)
      } else {
        reject(new Error(&quot;Weather data not found for this location&quot;))
      }
    }, 1_000)
  })
}
</code></pre>
</li>
<li><p><strong>Wrap the Promise with Micro</strong></p>
<p>Now, wrap the <code>fetchWeather</code> function using Micro, converting the <code>Promise</code> to a Micro effect to manage both success and failure scenarios.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Simulate fetching weather data
function fetchWeather(city: string): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (city === &quot;London&quot;) {
        resolve(&quot;Sunny&quot;)
      } else {
        reject(new Error(&quot;Weather data not found for this location&quot;))
      }
    }, 1_000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() =&gt; fetchWeather(city))
}
</code></pre>
<p>Here, <code>Micro.promise</code> transforms the <code>Promise</code> returned by <code>fetchWeather</code> into a <code>Micro&lt;string, never, never&gt;</code> effect.</p>
</li>
<li><p><strong>Running the Micro Effect</strong></p>
<p>Once the function is wrapped, execute the Micro effect and handle the results.</p>
<p><strong>Example</strong> (Executing the Micro Effect)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Simulate fetching weather data
function fetchWeather(city: string): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (city === &quot;London&quot;) {
        resolve(&quot;Sunny&quot;)
      } else {
        reject(new Error(&quot;Weather data not found for this location&quot;))
      }
    }, 1_000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() =&gt; fetchWeather(city))
}

//      ┌─── Micro&lt;string, never, never&gt;
//      ▼
const weatherEffect = getWeather(&quot;London&quot;)

Micro.runPromise(weatherEffect)
  .then((data) =&gt; console.log(`The weather in London is: ${data}`))
  .catch((error) =&gt;
    console.error(`Failed to fetch weather data: ${error.message}`)
  )
/*
Output:
The weather in London is: Sunny
*/
</code></pre>
<p>In the example above, <code>Micro.runPromise</code> is used to execute the <code>weatherEffect</code>, converting it back into a <code>Promise</code>, which can be managed using familiar asynchronous handling methods.</p>
<p>For more detailed information on the effect&#39;s exit status, use <code>Micro.runPromiseExit</code>:</p>
<p><strong>Example</strong> (Inspecting Exit Status)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Simulate fetching weather data
function fetchWeather(city: string): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (city === &quot;London&quot;) {
        resolve(&quot;Sunny&quot;)
      } else {
        reject(new Error(&quot;Weather data not found for this location&quot;))
      }
    }, 1_000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() =&gt; fetchWeather(city))
}

//      ┌─── Micro&lt;string, never, never&gt;
//      ▼
const weatherEffect = getWeather(&quot;London&quot;)

Micro.runPromiseExit(weatherEffect).then(
  // ┌─── MicroExit&lt;string, never&gt;
  // ▼
  (exit) =&gt; console.log(exit)
)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: &quot;Sunny&quot;
}
*/
</code></pre>
</li>
<li><p><strong>Adding Error Handling</strong></p>
<p>To further enhance the function, you might want to handle specific errors differently.
Micro provides functions like <code>Micro.tryPromise</code> to handle anticipated errors gracefully.</p>
<p><strong>Example</strong> (Handling Specific Errors)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Simulate fetching weather data
function fetchWeather(city: string): Promise&lt;string&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      if (city === &quot;London&quot;) {
        resolve(&quot;Sunny&quot;)
      } else {
        reject(new Error(&quot;Weather data not found for this location&quot;))
      }
    }, 1_000)
  })
}

class WeatherError {
  readonly _tag = &quot;WeatherError&quot;
  constructor(readonly message: string) {}
}

function getWeather(city: string) {
  return Micro.tryPromise({
    try: () =&gt; fetchWeather(city),
    // remap the error
    catch: (error) =&gt; new WeatherError(String(error))
  })
}

//      ┌─── Micro&lt;string, WeatherError, never&gt;
//      ▼
const weatherEffect = getWeather(&quot;Paris&quot;)

Micro.runPromise(weatherEffect)
  .then((data) =&gt; console.log(`The weather in London is: ${data}`))
  .catch((error) =&gt;
    console.error(`Failed to fetch weather data: ${error}`)
  )
/*
Output:
Failed to fetch weather data: MicroCause.Fail: {&quot;_tag&quot;:&quot;WeatherError&quot;,&quot;message&quot;:&quot;Error: Weather data not found for this location&quot;}
*/
</code></pre>
</li>
</ol>
</Steps>

<h2>Expected Errors</h2>
<p>These errors, also referred to as <em>failures</em>, <em>typed errors</em>
or <em>recoverable errors</em>, are errors that developers anticipate as part of the normal program execution.
They serve a similar purpose to checked exceptions and play a role in defining the program&#39;s domain and control flow.</p>
<p>Expected errors <strong>are tracked</strong> at the type level by the <code>Micro</code> data type in the &quot;Error&quot; channel:</p>
<pre><code class="language-text">        ┌─── Represents the success type
        │        ┌─── Represents the error type
        │        │      ┌─── Represents required dependencies
        ▼        ▼      ▼
Micro&lt;Success, Error, Requirements&gt;
</code></pre>
<h3>either</h3>
<p>The <code>Micro.either</code> function transforms an <code>Micro&lt;A, E, R&gt;</code> into an effect that encapsulates both potential failure and success within an <a href="/docs/data-types/either/">Either</a> data type:</p>
<pre><code class="language-ts">Micro&lt;A, E, R&gt; -&gt; Micro&lt;Either&lt;A, E&gt;, never, R&gt;
</code></pre>
<p>This means if you have an effect with the following type:</p>
<pre><code class="language-ts">Micro&lt;string, HttpError, never&gt;
</code></pre>
<p>and you call <code>Micro.either</code> on it, the type becomes:</p>
<pre><code class="language-ts">Micro&lt;Either&lt;string, HttpError&gt;, never, never&gt;
</code></pre>
<p>The resulting effect cannot fail because the potential failure is now represented within the <code>Either</code>&#39;s <code>Left</code> type.
The error type of the returned <code>Micro</code> is specified as <code>never</code>, confirming that the effect is structured to not fail.</p>
<p>By yielding an <code>Either</code>, we gain the ability to &quot;pattern match&quot; on this type to handle both failure and success cases within the generator function.</p>
<p><strong>Example</strong> (Using <code>Micro.either</code> to Handle Errors)</p>
<pre><code class="language-ts">import { Micro, Either } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Micro&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Micro.gen(function* () {
  // Simulate http and validation errors
  if (Math.random() &gt; 0.5) yield* Micro.fail(new HttpError())
  if (Math.random() &gt; 0.5) yield* Micro.fail(new ValidationError())
  return &quot;some result&quot;
})

//      ┌─── Micro&lt;string, never, never&gt;
//      ▼
const recovered = Micro.gen(function* () {
  //      ┌─── Either&lt;string, HttpError | ValidationError&gt;
  //      ▼
  const failureOrSuccess = yield* Micro.either(program)
  return Either.match(failureOrSuccess, {
    // Failure case
    onLeft: (error) =&gt; `Recovering from ${error._tag}`,
    // Success case
    onRight: (value) =&gt; `Result is: ${value}`
  })
})

Micro.runPromiseExit(recovered).then(console.log)
/*
Example Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: &quot;Recovering from ValidationError&quot;
}
*/
</code></pre>
<p>As you can see since all errors are handled, the error type of the resulting effect <code>recovered</code> is <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Micro&lt;string, never, never&gt;
</code></pre>
<h3>catchAll</h3>
<p>The <code>Micro.catchAll</code> function allows you to catch any error that occurs in the program and provide a fallback.</p>
<p><strong>Example</strong> (Catching All Errors with <code>Micro.catchAll</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Micro&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Micro.gen(function* () {
  // Simulate http and validation errors
  if (Math.random() &gt; 0.5) yield* Micro.fail(new HttpError())
  if (Math.random() &gt; 0.5) yield* Micro.fail(new ValidationError())
  return &quot;some result&quot;
})

//      ┌─── Micro&lt;string, never, never&gt;
//      ▼
const recovered = program.pipe(
  Micro.catchAll((error) =&gt;
    Micro.succeed(`Recovering from ${error._tag}`)
  )
)

Micro.runPromiseExit(recovered).then(console.log)
/*
Example Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: &quot;Recovering from HttpError&quot;
}
*/
</code></pre>
<p>We can observe that the type in the error channel of our program has changed to <code>never</code>:</p>
<pre><code class="language-ts">const recovered: Micro&lt;string, never, never&gt;
</code></pre>
<p>indicating that all errors have been handled.</p>
<h3>catchTag</h3>
<p>If your program&#39;s errors are <strong>all tagged</strong> with a <code>_tag</code> field that acts as a discriminator you can use the <code>Effect.catchTag</code> function to catch and handle specific errors with precision.</p>
<p><strong>Example</strong> (Handling Errors by Tag with <code>Micro.catchTag</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

class HttpError {
  readonly _tag = &quot;HttpError&quot;
}

class ValidationError {
  readonly _tag = &quot;ValidationError&quot;
}

//      ┌─── Micro&lt;string, HttpError | ValidationError, never&gt;
//      ▼
const program = Micro.gen(function* () {
  // Simulate http and validation errors
  if (Math.random() &gt; 0.5) yield* Micro.fail(new HttpError())
  if (Math.random() &gt; 0.5) yield* Micro.fail(new ValidationError())
  return &quot;Success&quot;
})

//      ┌─── Micro&lt;string, ValidationError, never&gt;
//      ▼
const recovered = program.pipe(
  Micro.catchTag(&quot;HttpError&quot;, (_HttpError) =&gt;
    Micro.succeed(&quot;Recovering from HttpError&quot;)
  )
)

Micro.runPromiseExit(recovered).then(console.log)
/*
Example Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: &quot;Recovering from HttpError&quot;
}
*/
</code></pre>
<p>In the example above, the <code>Micro.catchTag</code> function allows us to handle <code>HttpError</code> specifically.
If a <code>HttpError</code> occurs during the execution of the program, the provided error handler function will be invoked,
and the program will proceed with the recovery logic specified within the handler.</p>
<p>We can observe that the type in the error channel of our program has changed to only show <code>ValidationError</code>:</p>
<pre><code class="language-ts">const recovered: Micro&lt;string, ValidationError, never&gt;
</code></pre>
<p>indicating that <code>HttpError</code> has been handled.</p>
<h2>Unexpected Errors</h2>
<p>Unexpected errors, also referred to as <em>defects</em>, <em>untyped errors</em>, or <em>unrecoverable errors</em>, are errors that developers
do not anticipate occurring during normal program execution.
Unlike expected errors, which are considered part of a program&#39;s domain and control flow,
unexpected errors resemble unchecked exceptions and lie outside the expected behavior of the program.</p>
<p>Since these errors are not expected, Effect <strong>does not track</strong> them at the type level.
However, the Effect runtime does keep track of these errors and provides several methods to aid in recovering from unexpected errors.</p>
<h3>die</h3>
<p>The <code>Micro.die</code> function returns an effect that throws a specified error. This function is useful for terminating a program when a defect, a critical and unexpected error, is detected in the code.</p>
<p><strong>Example</strong> (Terminating on Division by Zero with <code>Effect.die</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const divide = (a: number, b: number): Micro.Micro&lt;number&gt; =&gt;
  b === 0
    ? Micro.die(new Error(&quot;Cannot divide by zero&quot;))
    : Micro.succeed(a / b)

Micro.runPromise(divide(1, 0))
/*
throws:
Die [(MicroCause.Die) Error]: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h3>orDie</h3>
<p>The <code>Micro.orDie</code> function converts an effect&#39;s failure into a termination of the program, removing the error from the type of the effect. It is useful when you encounter failures that you do not intend to handle or recover from.</p>
<p><strong>Example</strong> (Converting Failure to Defect with <code>Micro.orDie</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const divide = (a: number, b: number): Micro.Micro&lt;number, Error&gt; =&gt;
  b === 0
    ? Micro.fail(new Error(&quot;Cannot divide by zero&quot;))
    : Micro.succeed(a / b)

//      ┌─── Micro&lt;number, never, never&gt;
//      ▼
const program = Micro.orDie(divide(1, 0))

Micro.runPromise(program)
/*
throws:
Die [(MicroCause.Die) Error]: Cannot divide by zero
  ...stack trace...
*/
</code></pre>
<h3>catchAllDefect</h3>
<p>The <code>Micro.catchAllDefect</code> function allows you to recover from all defects using a provided function.</p>
<p><strong>Example</strong> (Handling All Defects with <code>Micro.catchAllDefect</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

// Simulating a runtime error
const task = Micro.die(&quot;Boom!&quot;)

const program = Micro.catchAllDefect(task, (defect) =&gt;
  log(`Unknown defect caught: ${defect}`)
)

// We get a Right because we caught all defects
Micro.runPromiseExit(program).then((exit) =&gt; console.log(exit))
/*
Output:
Unknown defect caught: Boom!
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;
}
*/
</code></pre>
<p>It&#39;s important to understand that <code>Micro.catchAllDefect</code> can only handle defects, not expected errors (such as those caused by <code>Micro.fail</code>) or interruptions in execution (such as when using <code>Micro.interrupt</code>).</p>
<p>A defect refers to an error that cannot be anticipated in advance, and there is no reliable way to respond to it. As a general rule, it&#39;s recommended to let defects crash the application, as they often indicate serious issues that need to be addressed.</p>
<p>However, in some specific cases, such as when dealing with dynamically loaded plugins, a controlled recovery approach might be necessary. For example, if our application supports runtime loading of plugins and a defect occurs within a plugin, we may choose to log the defect and then reload only the affected plugin instead of crashing the entire application. This allows for a more resilient and uninterrupted operation of the application.</p>
<h2>Fallback</h2>
<h3>orElseSucceed</h3>
<p>The <code>Effect.orElseSucceed</code> function will replace the original failure with a success value, ensuring the effect cannot fail:</p>
<p><strong>Example</strong> (Replacing Failure with Success using <code>Micro.orElseSucceed</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const validate = (age: number): Micro.Micro&lt;number, string&gt; =&gt; {
  if (age &lt; 0) {
    return Micro.fail(&quot;NegativeAgeError&quot;)
  } else if (age &lt; 18) {
    return Micro.fail(&quot;IllegalAgeError&quot;)
  } else {
    return Micro.succeed(age)
  }
}

const program = Micro.orElseSucceed(validate(-1), () =&gt; 18)

console.log(Micro.runSyncExit(program))
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: 18
}
*/
</code></pre>
<h2>Matching</h2>
<h3>match</h3>
<p>The <code>Micro.match</code> function lets you handle both success and failure cases without performing side effects. You provide a handler for each case.</p>
<p><strong>Example</strong> (Handling Both Success and Failure Cases)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const success: Micro.Micro&lt;number, Error&gt; = Micro.succeed(42)

const program1 = Micro.match(success, {
  onFailure: (error) =&gt; `failure: ${error.message}`,
  onSuccess: (value) =&gt; `success: ${value}`
})

// Run and log the result of the successful effect
Micro.runPromise(program1).then(console.log)
// Output: &quot;success: 42&quot;

const failure: Micro.Micro&lt;number, Error&gt; = Micro.fail(
  new Error(&quot;Uh oh!&quot;)
)

const program2 = Micro.match(failure, {
  onFailure: (error) =&gt; `failure: ${error.message}`,
  onSuccess: (value) =&gt; `success: ${value}`
})

// Run and log the result of the failed effect
Micro.runPromise(program2).then(console.log)
// Output: &quot;failure: Uh oh!&quot;
</code></pre>
<h3>matchEffect</h3>
<p>The <code>Micro.matchEffect</code> function, similar to <code>Micro.match</code>, allows you to handle both success and failure cases, but it also enables you to perform additional side effects within those handlers.</p>
<p><strong>Example</strong> (Handling Success and Failure with Side Effects)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

const success: Micro.Micro&lt;number, Error&gt; = Micro.succeed(42)
const failure: Micro.Micro&lt;number, Error&gt; = Micro.fail(
  new Error(&quot;Uh oh!&quot;)
)

const program1 = Micro.matchEffect(success, {
  onFailure: (error) =&gt;
    Micro.succeed(`failure: ${error.message}`).pipe(Micro.tap(log)),
  onSuccess: (value) =&gt;
    Micro.succeed(`success: ${value}`).pipe(Micro.tap(log))
})

Micro.runSync(program1)
/*
Output:
success: 42
*/

const program2 = Micro.matchEffect(failure, {
  onFailure: (error) =&gt;
    Micro.succeed(`failure: ${error.message}`).pipe(Micro.tap(log)),
  onSuccess: (value) =&gt;
    Micro.succeed(`success: ${value}`).pipe(Micro.tap(log))
})

Micro.runSync(program2)
/*
Output:
failure: Uh oh!
*/
</code></pre>
<h3>matchCause / matchCauseEffect</h3>
<p>The <code>Micro.matchCause</code> and <code>Micro.matchCauseEffect</code> functions allow you to handle failures more precisely by providing access to the complete cause of failure within a fiber. This makes it possible to differentiate between various failure types and respond accordingly.</p>
<p><strong>Example</strong> (Handling Different Failure Causes with <code>Micro.matchCauseEffect</code>)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

const task: Micro.Micro&lt;number, Error&gt; = Micro.die(&quot;Uh oh!&quot;)

const program = Micro.matchCauseEffect(task, {
  onFailure: (cause) =&gt; {
    switch (cause._tag) {
      case &quot;Fail&quot;:
        // Handle standard failure with a logged message
        return log(`Fail: ${cause.error.message}`)
      case &quot;Die&quot;:
        // Handle defects (unexpected errors) by logging the defect
        return log(`Die: ${cause.defect}`)
      case &quot;Interrupt&quot;:
        // Handle interruption
        return log(&quot;Interrupt&quot;)
    }
  },
  onSuccess: (value) =&gt;
    // Log success if the task completes successfully
    log(`succeeded with ${value} value`)
})

Micro.runSync(program)
// Output: &quot;Die: Uh oh!&quot;
</code></pre>
<h2>Retrying</h2>
<h3>retry</h3>
<p>The <code>Micro.retry</code> function allows you to retry a failing effect according to a defined policy.</p>
<p><strong>Example</strong> (Retrying with a Fixed Delay)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

let count = 0

// Simulates an effect with possible failures
const effect = Micro.async&lt;string, Error&gt;((resume) =&gt; {
  if (count &lt;= 2) {
    count++
    console.log(&quot;failure&quot;)
    resume(Micro.fail(new Error()))
  } else {
    console.log(&quot;success&quot;)
    resume(Micro.succeed(&quot;yay!&quot;))
  }
})

// Define a repetition policy using a spaced delay between retries
const policy = Micro.scheduleSpaced(100)

const repeated = Micro.retry(effect, { schedule: policy })

Micro.runPromise(repeated).then(console.log)
/*
Output:
failure
failure
failure
success
yay!
*/
</code></pre>
<h2>Timing out</h2>
<p>When an operation does not finish within the specified duration, the behavior of the <code>Micro.timeout</code> depends on whether the operation is &quot;uninterruptible&quot;.</p>
<Aside type="note" title="Uninterruptible Effects">
  An uninterruptible effect is one that, once started, cannot be stopped
  mid-execution by the timeout mechanism directly. This could be because
  the operations within the effect need to run to completion to avoid
  leaving the system in an inconsistent state.
</Aside>

<ol>
<li><p><strong>Interruptible Operation</strong>: If the operation can be interrupted, it is terminated immediately once the timeout threshold is reached, resulting in a <code>TimeoutException</code>.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const task = Micro.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Micro.sleep(2_000) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const timedEffect = task.pipe(Micro.timeout(1_000))

Micro.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;(MicroCause.Fail) TimeoutException&quot;,
    &quot;error&quot;: {
      &quot;_tag&quot;: &quot;TimeoutException&quot;
    }
  }
}
*/
</code></pre>
</li>
<li><p><strong>Uninterruptible Operation</strong>: If the operation is uninterruptible, it continues until completion before the <code>TimeoutException</code> is assessed.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const task = Micro.gen(function* () {
  console.log(&quot;Start processing...&quot;)
  yield* Micro.sleep(2_000) // Simulates a delay in processing
  console.log(&quot;Processing complete.&quot;)
  return &quot;Result&quot;
})

const timedEffect = task.pipe(
  Micro.uninterruptible,
  Micro.timeout(1_000)
)

// Outputs a TimeoutException after the task completes,
// because the task is uninterruptible
Micro.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
Processing complete.
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;(MicroCause.Fail) TimeoutException&quot;,
    &quot;error&quot;: {
      &quot;_tag&quot;: &quot;TimeoutException&quot;
    }
  }
}
*/
</code></pre>
</li>
</ol>
<h2>Sandboxing</h2>
<p>The <code>Micro.sandbox</code> function allows you to encapsulate all the potential causes of an error in an effect. It exposes the full cause of an effect, whether it&#39;s due to a failure, defect or interruption.</p>
<p>In simple terms, it takes an effect <code>Micro&lt;A, E, R&gt;</code> and transforms it into an effect <code>Micro&lt;A, MicroCause&lt;E&gt;, R&gt;</code> where the error channel now contains a detailed cause of the error.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

//      ┌─── Micro&lt;string, Error, never&gt;
//      ▼
const task = Micro.fail(new Error(&quot;Oh uh!&quot;)).pipe(
  Micro.as(&quot;primary result&quot;)
)

//      ┌─── Effect&lt;string, MicroCause&lt;Error&gt;, never&gt;
//      ▼
const sandboxed = Micro.sandbox(task)

const program = sandboxed.pipe(
  Micro.catchTag(&quot;Fail&quot;, (cause) =&gt;
    log(`Caught a defect: ${cause.error}`).pipe(
      Micro.as(&quot;fallback result on expected error&quot;)
    )
  ),
  Micro.catchTag(&quot;Interrupt&quot;, () =&gt;
    log(`Caught a defect`).pipe(
      Micro.as(&quot;fallback result on fiber interruption&quot;)
    )
  ),
  Micro.catchTag(&quot;Die&quot;, (cause) =&gt;
    log(`Caught a defect: ${cause.defect}`).pipe(
      Micro.as(&quot;fallback result on unexpected error&quot;)
    )
  )
)

Micro.runPromise(program).then(console.log)
/*
Output:
Caught a defect: Error: Oh uh!
fallback result on expected error
*/
</code></pre>
<h2>Inspecting Errors</h2>
<h3>tapError</h3>
<p>Executes an effectful operation to inspect the failure of an effect without altering it.</p>
<p><strong>Example</strong> (Inspecting Errors)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

// Simulate a task that fails with an error
const task: Micro.Micro&lt;number, string&gt; = Micro.fail(&quot;NetworkError&quot;)

// Use tapError to log the error message when the task fails
const tapping = Micro.tapError(task, (error) =&gt;
  log(`expected error: ${error}`)
)

Micro.runFork(tapping)
/*
Output:
expected error: NetworkError
*/
</code></pre>
<h3>tapErrorCause</h3>
<p>This function inspects the complete cause of an error, including failures and defects.</p>
<p><strong>Example</strong> (Inspecting Error Causes)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

// Create a task that fails with a NetworkError
const task1: Micro.Micro&lt;number, string&gt; = Micro.fail(&quot;NetworkError&quot;)

const tapping1 = Micro.tapErrorCause(task1, (cause) =&gt;
  log(`error cause: ${cause}`)
)

Micro.runFork(tapping1)
/*
Output:
error cause: MicroCause.Fail: NetworkError
*/

// Simulate a severe failure in the system
const task2: Micro.Micro&lt;number, string&gt; = Micro.die(
  &quot;Something went wrong&quot;
)

const tapping2 = Micro.tapErrorCause(task2, (cause) =&gt;
  log(`error cause: ${cause}`)
)

Micro.runFork(tapping2)
/*
Output:
error cause: MicroCause.Die: Something went wrong
*/
</code></pre>
<h3>tapDefect</h3>
<p>Specifically inspects non-recoverable failures or defects in an effect (i.e., one or more <a href="/docs/data-types/cause/#die">Die</a> causes).</p>
<p><strong>Example</strong> (Inspecting Defects)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

// Simulate a task that fails with a recoverable error
const task1: Micro.Micro&lt;number, string&gt; = Micro.fail(&quot;NetworkError&quot;)

// tapDefect won&#39;t log anything because NetworkError is not a defect
const tapping1 = Micro.tapDefect(task1, (cause) =&gt;
  log(`defect: ${cause}`)
)

Micro.runFork(tapping1)
/*
No Output
*/

// Simulate a severe failure in the system
const task2: Micro.Micro&lt;number, string&gt; = Micro.die(
  &quot;Something went wrong&quot;
)

// Log the defect using tapDefect
const tapping2 = Micro.tapDefect(task2, (cause) =&gt;
  log(`defect: ${cause}`)
)

Micro.runFork(tapping2)
/*
Output:
defect: Something went wrong
*/
</code></pre>
<h2>Yieldable Errors</h2>
<p>Yieldable Errors are special types of errors that can be yielded directly within a generator function using <code>Micro.gen</code>.
These errors allow you to handle them intuitively, without needing to explicitly invoke <code>Micro.fail</code>. This simplifies how you manage custom errors in your code.</p>
<h3>Error</h3>
<p>The <code>Error</code> constructor provides a way to define a base class for yieldable errors.</p>
<p><strong>Example</strong> (Creating and Yielding a Custom Error)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Define a custom error class extending Error
class MyError extends Micro.Error&lt;{ message: string }&gt; {}

export const program = Micro.gen(function* () {
  // Yield a custom error (equivalent to failing with MyError)
  yield* new MyError({ message: &quot;Oh no!&quot; })
})

Micro.runPromiseExit(program).then(console.log)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;(MicroCause.Fail) Error&quot;,
    &quot;error&quot;: {
      &quot;message&quot;: &quot;Oh no!&quot;
    }
  }
}
*/
</code></pre>
<h3>TaggedError</h3>
<p>The <code>TaggedError</code> constructor lets you define custom yieldable errors with unique tags. Each error has a <code>_tag</code> property, allowing you to easily distinguish between different error types. This makes it convenient to handle specific tagged errors using functions like <code>Micro.catchTag</code>.</p>
<p><strong>Example</strong> (Handling Multiple Tagged Errors)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// An error with _tag: &quot;Foo&quot;
class FooError extends Micro.TaggedError(&quot;Foo&quot;)&lt;{
  message: string
}&gt; {}

// An error with _tag: &quot;Bar&quot;
class BarError extends Micro.TaggedError(&quot;Bar&quot;)&lt;{
  randomNumber: number
}&gt; {}

export const program = Micro.gen(function* () {
  const n = Math.random()
  return n &gt; 0.5
    ? &quot;yay!&quot;
    : n &lt; 0.2
    ? yield* new FooError({ message: &quot;Oh no!&quot; })
    : yield* new BarError({ randomNumber: n })
}).pipe(
  // Handle different tagged errors using catchTag
  Micro.catchTag(&quot;Foo&quot;, (error) =&gt;
    Micro.succeed(`Foo error: ${error.message}`)
  ),
  Micro.catchTag(&quot;Bar&quot;, (error) =&gt;
    Micro.succeed(`Bar error: ${error.randomNumber}`)
  )
)

Micro.runPromise(program).then(console.log, console.error)
/*
Example Output (n &lt; 0.2):
Foo error: Oh no!
*/
</code></pre>
<h2>Requirements Management</h2>
<p>In the context of programming, a <strong>service</strong> refers to a reusable component or functionality that can be used by different parts of an application.
Services are designed to provide specific capabilities and can be shared across multiple modules or components.</p>
<p>Services often encapsulate common tasks or operations that are needed by different parts of an application.
They can handle complex operations, interact with external systems or APIs, manage data, or perform other specialized tasks.</p>
<p>Services are typically designed to be modular and decoupled from the rest of the application.
This allows them to be easily maintained, tested, and replaced without affecting the overall functionality of the application.</p>
<p>To create a new service, you need two things:</p>
<ul>
<li>A unique identifier.</li>
<li>A type describing the possible operations of the service.</li>
</ul>
<pre><code class="language-ts">import { Micro, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Micro.Micro&lt;number&gt; }
&gt;() {}
</code></pre>
<p>Now that we have our service tag defined, let&#39;s see how we can use it by building a simple program.</p>
<p><strong>Example</strong> (Using a Custom Service in a Program)</p>
<pre><code class="language-ts">import * as Context from &quot;effect/Context&quot;
import { Micro } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Micro.Micro&lt;number&gt; }
&gt;() {}

// Using the service
//
//      ┌─── Micro&lt;void, never, Random&gt;
//      ▼
const program = Micro.gen(function* () {
  // Access the Random service
  const random = yield* Micro.service(Random)

  // Retrieve a random number from the service
  const randomNumber = yield* random.next

  console.log(`random number: ${randomNumber}`)
})
</code></pre>
<p>It&#39;s worth noting that the type of the <code>program</code> variable includes <code>Random</code> in the <code>Requirements</code> type parameter:</p>
<pre><code class="language-ts">const program: Micro&lt;void, never, Random&gt;
</code></pre>
<p>This indicates that our program requires the <code>Random</code> service to be provided in order to execute successfully.</p>
<p>To successfully execute the program, we need to provide an actual implementation of the <code>Random</code> service.</p>
<p><strong>Example</strong> (Providing and Using a Service)</p>
<pre><code class="language-ts">import { Micro, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Micro.Micro&lt;number&gt; }
&gt;() {}

// Using the service
const program = Micro.gen(function* () {
  // Access the Random service
  const random = yield* Micro.service(Random)

  // Retrieve a random number from the service
  const randomNumber = yield* random.next

  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//      ┌─── Micro&lt;void, never, never&gt;
//      ▼
const runnable = Micro.provideService(program, Random, {
  next: Micro.sync(() =&gt; Math.random())
})

Micro.runPromise(runnable)
/*
Example Output:
random number: 0.8241872233134417
*/
</code></pre>
<h2>Resource Management</h2>
<h3>MicroScope</h3>
<p>In simple terms, a <code>MicroScope</code> represents the lifetime of one or more resources. When a scope is closed, the resources associated with it are guaranteed to be released.</p>
<p>With the <code>MicroScope</code> data type, you can:</p>
<ul>
<li><strong>Add finalizers</strong>: A finalizer specifies the cleanup logic for a resource.</li>
<li><strong>Close the scope</strong>: When the scope is closed, all resources are released, and the finalizers are executed.</li>
</ul>
<p><strong>Example</strong> (Managing a Scope)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

const program =
  // create a new scope
  Micro.scopeMake.pipe(
    // add finalizer 1
    Micro.tap((scope) =&gt; scope.addFinalizer(() =&gt; log(&quot;finalizer 1&quot;))),
    // add finalizer 2
    Micro.tap((scope) =&gt; scope.addFinalizer(() =&gt; log(&quot;finalizer 2&quot;))),
    // close the scope
    Micro.andThen((scope) =&gt;
      scope.close(Micro.exitSucceed(&quot;scope closed successfully&quot;))
    )
  )

Micro.runPromise(program)
/*
Output:
finalizer 2 &lt;-- finalizers are closed in reverse order
finalizer 1
*/
</code></pre>
<p>In the above example, finalizers are added to the scope, and when the scope is closed, the finalizers are <strong>executed in the reverse order</strong>.</p>
<p>This reverse order is important because it ensures that resources are released in the correct sequence.</p>
<p>For instance, if you acquire a network connection and then access a file on a remote server, the file must be closed before the network connection to avoid errors.</p>
<h3>addFinalizer</h3>
<p>The <code>Micro.addFinalizer</code> function is a high-level API that allows you to add finalizers to the scope of an effect. A finalizer is a piece of code that is guaranteed to run when the associated scope is closed. The behavior of the finalizer can vary based on the <code>MicroExit</code> value, which represents how the scope was closed—whether successfully or with an error.</p>
<p><strong>Example</strong> (Adding a Finalizer on Success)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

//      ┌─── Micro&lt;string, never, MicroScope&gt;
//      ▼
const program = Micro.gen(function* () {
  yield* Micro.addFinalizer((exit) =&gt; log(`finalizer after ${exit._tag}`))
  return &quot;some result&quot;
})

//      ┌─── Micro&lt;string, never, never&gt;
//      ▼
const runnable = Micro.scoped(program)

Micro.runPromise(runnable).then(console.log, console.error)
/*
Output:
finalizer after Success
some result
*/
</code></pre>
<p>Next, let&#39;s explore how things behave in the event of a failure:</p>
<p><strong>Example</strong> (Adding a Finalizer on Failure)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Helper function to log a message
const log = (message: string) =&gt; Micro.sync(() =&gt; console.log(message))

const program = Micro.gen(function* () {
  yield* Micro.addFinalizer((exit) =&gt; log(`finalizer after ${exit._tag}`))
  return yield* Micro.fail(&quot;Uh oh!&quot;)
})

const runnable = Micro.scoped(program)

Micro.runPromiseExit(runnable).then(console.log)
/*
Output:
finalizer after Failure
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Fail&quot;,
    &quot;error&quot;: &quot;Uh oh!&quot;
  }
}
*/
</code></pre>
<h3>Defining Resources</h3>
<p>We can define a resource using operators like <code>Micro.acquireRelease(acquire, release)</code>, which allows us to create a scoped value from an <code>acquire</code> and <code>release</code> workflow.</p>
<p>Every acquire release requires three actions:</p>
<ul>
<li><strong>Acquiring Resource</strong>. An effect describing the acquisition of resource. For example, opening a file.</li>
<li><strong>Using Resource</strong>. An effect describing the actual process to produce a result. For example, counting the number of lines in a file.</li>
<li><strong>Releasing Resource</strong>. An effect describing the final step of releasing or cleaning up the resource. For example, closing a file.</li>
</ul>
<p>The <code>Micro.acquireRelease</code> operator performs the <code>acquire</code> workflow <strong>uninterruptibly</strong>.
This is important because if we allowed interruption during resource acquisition we could be interrupted when the resource was partially acquired.</p>
<p>The guarantee of the <code>Micro.acquireRelease</code> operator is that if the <code>acquire</code> workflow successfully completes execution then the <code>release</code> workflow is guaranteed to be run when the <code>Scope</code> is closed.</p>
<p><strong>Example</strong> (Defining a Simple Resource)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate resource acquisition
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Micro.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define how the resource is released
const release = (res: MyResource) =&gt; Micro.promise(() =&gt; res.close())

// Create the resource management workflow
//
//      ┌─── Micro&lt;MyResource, Error, MicroScope&gt;
//      ▼
const resource = Micro.acquireRelease(acquire, release)

//      ┌─── Micro&lt;void, Error, never&gt;
//      ▼
const program = Micro.scoped(
  Micro.gen(function* () {
    const res = yield* resource
    console.log(`content is ${res.contents}`)
  })
)

Micro.runPromise(program)
/*
Resource acquired
content is lorem ipsum
Resource released
*/
</code></pre>
<p>The <code>Micro.scoped</code> operator removes the <code>MicroScope</code> from the context, indicating that there are no longer any resources used by this workflow which require a scope.</p>
<h3>acquireUseRelease</h3>
<p>The <code>Micro.acquireUseRelease(acquire, use, release)</code> function is a specialized version of the <code>Micro.acquireRelease</code> function that simplifies resource management by automatically handling the scoping of resources.</p>
<p>The main difference is that <code>acquireUseRelease</code> eliminates the need to manually call <code>Micro.scoped</code> to manage the resource&#39;s scope. It has additional knowledge about when you are done using the resource created with the <code>acquire</code> step. This is achieved by providing a <code>use</code> argument, which represents the function that operates on the acquired resource. As a result, <code>acquireUseRelease</code> can automatically determine when it should execute the release step.</p>
<p><strong>Example</strong> (Automatically Managing Resource Lifetime)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Define the interface for the resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate getting the resource
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define the acquisition of the resource with error handling
const acquire = Micro.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define the release of the resource
const release = (res: MyResource) =&gt; Micro.promise(() =&gt; res.close())

const use = (res: MyResource) =&gt;
  Micro.sync(() =&gt; console.log(`content is ${res.contents}`))

//      ┌─── Micro&lt;void, Error, never&gt;
//      ▼
const program = Micro.acquireUseRelease(acquire, use, release)

Micro.runPromise(program)
/*
Resource acquired
content is lorem ipsum
Resource released
*/
</code></pre>
<h2>Scheduling</h2>
<h3>MicroSchedule</h3>
<p>The <code>MicroSchedule</code> type represents a function that can be used to calculate the delay between
repeats.</p>
<pre><code class="language-ts">type MicroSchedule = (attempt: number, elapsed: number) =&gt; Option&lt;number&gt;
</code></pre>
<p>The function takes the current attempt number and the elapsed time since
the first attempt, and returns the delay for the next attempt. If the
function returns <code>None</code>, the repetition will stop.</p>
<h3>repeat</h3>
<p>The <code>Micro.repeat</code> function returns a new effect that repeats the given effect according to a specified schedule or until the first failure.</p>
<Aside type="note" title="Initial Execution Included">
  The scheduled recurrences are in addition to the initial execution, so
  `Micro.repeat(action, Micro.scheduleRecurs(1))` executes `action` once
  initially, and if it succeeds, repeats it an additional time.
</Aside>

<p><strong>Example</strong> (Repeating a Successful Effect)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

// Define an effect that logs a message to the console
const action = Micro.sync(() =&gt; console.log(&quot;success&quot;))

// Define a schedule that repeats the action 2 more times with a delay
const policy = Micro.scheduleAddDelay(Micro.scheduleRecurs(2), () =&gt; 100)

// Repeat the action according to the schedule
const program = Micro.repeat(action, { schedule: policy })

Micro.runPromise(program)
/*
Output:
success
success
success
*/
</code></pre>
<p><strong>Example</strong> (Handling Failures in Repetition)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

let count = 0

// Define an async effect that simulates an action with potential failure
const action = Micro.async&lt;string, string&gt;((resume) =&gt; {
  if (count &gt; 1) {
    console.log(&quot;failure&quot;)
    resume(Micro.fail(&quot;Uh oh!&quot;))
  } else {
    count++
    console.log(&quot;success&quot;)
    resume(Micro.succeed(&quot;yay!&quot;))
  }
})

// Define a schedule that repeats the action 2 more times with a delay
const policy = Micro.scheduleAddDelay(Micro.scheduleRecurs(2), () =&gt; 100)

// Repeat the action according to the schedule
const program = Micro.repeat(action, { schedule: policy })

// Run the program and observe the result on failure
Micro.runPromiseExit(program).then(console.log)
/*
Output:
success
success
failure
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Fail&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Fail&quot;,
    &quot;error&quot;: &quot;Uh oh!&quot;
  }
}
*/
</code></pre>
<h3>Simulating Schedule Behavior</h3>
<p>This helper function, <code>dryRun</code>, demonstrates how different scheduling policies control repetition timing without executing an actual effect. By returning an array of delay intervals, it visualizes how a schedule would space repetitions.</p>
<pre><code class="language-ts">import { Option, Micro } from &quot;effect&quot;

// Helper function to simulate and visualize a schedule&#39;s behavior
const dryRun = (
  schedule: Micro.MicroSchedule, // The scheduling policy to simulate
  maxAttempt: number = 7 // Maximum number of repetitions to simulate
): Array&lt;number&gt; =&gt; {
  let attempt = 1 // Track the current attempt number
  let elapsed = 0 // Track the total elapsed time
  const out: Array&lt;number&gt; = [] // Array to store each delay duration
  let duration = schedule(attempt, elapsed)

  // Continue until the schedule returns no delay or maxAttempt is reached
  while (Option.isSome(duration) &amp;&amp; attempt &lt;= maxAttempt) {
    const value = duration.value
    out.push(value)
    attempt++
    elapsed += value

    // Get the next duration based on the current attempt
    // and total elapsed time
    duration = schedule(attempt, elapsed)
  }

  return out
}
</code></pre>
<h3>scheduleSpaced</h3>
<p>A schedule that repeats indefinitely, each repetition spaced the specified duration from the last run.</p>
<p><strong>Example</strong> (Recurring with Delay Between Executions)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
import * as Option from &quot;effect/Option&quot;

// Helper function to simulate and visualize a schedule&#39;s behavior
const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array&lt;number&gt; =&gt; {
  let attempt = 1
  let elapsed = 0
  const out: Array&lt;number&gt; = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) &amp;&amp; attempt &lt;= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleSpaced(10)

console.log(dryRun(policy))
/*
Output:
[
  10, 10, 10, 10,
  10, 10, 10
]
*/
</code></pre>
<h3>scheduleExponential</h3>
<p>A schedule that recurs using exponential backoff, with each delay increasing exponentially.</p>
<p><strong>Example</strong> (Exponential Backoff Schedule)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
import * as Option from &quot;effect/Option&quot;

// Helper function to simulate and visualize a schedule&#39;s behavior
const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array&lt;number&gt; =&gt; {
  let attempt = 1
  let elapsed = 0
  const out: Array&lt;number&gt; = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) &amp;&amp; attempt &lt;= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleExponential(10)

console.log(dryRun(policy))
/*
Output:
[
    20,  40,  80,
   160, 320, 640,
  1280
]
*/
</code></pre>
<h3>scheduleUnion</h3>
<p>Combines two schedules using union. The schedule recurs as long as one of the schedules wants to, using the minimum delay between recurrences.</p>
<p><strong>Example</strong> (Union of Exponential and Spaced Schedules)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
import * as Option from &quot;effect/Option&quot;

// Helper function to simulate and visualize a schedule&#39;s behavior
const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array&lt;number&gt; =&gt; {
  let attempt = 1
  let elapsed = 0
  const out: Array&lt;number&gt; = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) &amp;&amp; attempt &lt;= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleUnion(
  Micro.scheduleExponential(10),
  Micro.scheduleSpaced(300)
)

console.log(dryRun(policy))
/*
Output:
[
  20,  &lt; exponential
  40,
  80,
  160,
  300, &lt; spaced
  300,
  300
]
*/
</code></pre>
<h3>scheduleIntersect</h3>
<p>Combines two schedules using intersection. The schedule recurs only if both schedules want to continue, using the maximum delay between them.</p>
<p><strong>Example</strong> (Intersection of Exponential and Recurs Schedules)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;
import * as Option from &quot;effect/Option&quot;

// Helper function to simulate and visualize a schedule&#39;s behavior
const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array&lt;number&gt; =&gt; {
  let attempt = 1
  let elapsed = 0
  const out: Array&lt;number&gt; = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) &amp;&amp; attempt &lt;= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleIntersect(
  Micro.scheduleExponential(10),
  Micro.scheduleSpaced(300)
)

console.log(dryRun(policy))
/*
Output:
[
  300, &lt; spaced
  300,
  300,
  300,
  320, &lt; exponential
  640,
  1280
]
*/
</code></pre>
<h2>Concurrency</h2>
<h3>Forking Effects</h3>
<p>One of the fundamental ways to create a fiber is by forking an existing effect.
When you fork an effect, it starts executing the effect on a new fiber, giving you a reference to this newly-created fiber.</p>
<p>The following code demonstrates how to create a single fiber using the <code>Micro.fork</code> function. This fiber will execute the function <code>fib(100)</code> independently of the main fiber:</p>
<p><strong>Example</strong> (Forking a Fiber)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const fib = (n: number): Micro.Micro&lt;number&gt; =&gt;
  n &lt; 2
    ? Micro.succeed(n)
    : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Micro&lt;MicroFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Micro.fork(fib(10))
</code></pre>
<h3>Joining Fibers</h3>
<p>A common operation with fibers is joining them using the <code>Micro.fiberJoin</code> function.
This function returns a <code>Micro</code> that will succeed or fail based on the outcome of the fiber it joins:</p>
<p><strong>Example</strong> (Joining a Fiber)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const fib = (n: number): Micro.Micro&lt;number&gt; =&gt;
  n &lt; 2
    ? Micro.succeed(n)
    : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Micro&lt;MicroFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Micro.fork(fib(10))

const program = Micro.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Join the fiber and get the result
  const n = yield* Micro.fiberJoin(fiber)
  console.log(n)
})

Micro.runPromise(program)
// Output: 55
</code></pre>
<h3>Awaiting Fibers</h3>
<p>Another useful function for fibers is <code>Micro.fiberAwait</code>.
This function returns an effect containing a <code>MicroExit</code> value, which provides detailed information about how the fiber completed.</p>
<p><strong>Example</strong> (Awaiting Fiber Completion)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const fib = (n: number): Micro.Micro&lt;number&gt; =&gt;
  n &lt; 2
    ? Micro.succeed(n)
    : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) =&gt; a + b)

//      ┌─── Micro&lt;MicroFiber&lt;number, never&gt;, never, never&gt;
//      ▼
const fib10Fiber = Micro.fork(fib(10))

const program = Micro.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Await its completion and get the MicroExit result
  const exit = yield* Micro.fiberAwait(fiber)
  console.log(exit)
})

Micro.runPromise(program)
/*
Output:
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;,
  &quot;value&quot;: 55
}
*/
</code></pre>
<h2>Interruptions</h2>
<p>All effects in Effect are executed by fibers. If you didn&#39;t create the fiber yourself, it was created by an operation you&#39;re using (if it&#39;s concurrent) or by the Effect runtime system.</p>
<p>A fiber is created any time an effect is run. When running effects concurrently, a fiber is created for each concurrent effect.</p>
<p>To summarize:</p>
<ul>
<li>A <code>Micro</code> is a higher-level concept that describes an effectful computation. It is lazy and immutable, meaning it represents a computation that may produce a value or fail but does not immediately execute.</li>
<li>A fiber, on the other hand, represents the running execution of a <code>Micro</code>. It can be interrupted or awaited to retrieve its result. Think of it as a way to control and interact with the ongoing computation.</li>
</ul>
<p>Fibers can be interrupted in various ways. Let&#39;s explore some of these scenarios and see examples of how to interrupt fibers in Effect.</p>
<h3>Interrupting Fibers</h3>
<p>If a fiber&#39;s result is no longer needed, it can be interrupted, which immediately terminates the fiber and safely releases all resources by running all finalizers.</p>
<p>Similar to <code>.await</code>, <code>.interrupt</code> returns a <code>MicroExit</code> value describing how the fiber completed.</p>
<p><strong>Example</strong> (Interrupting a Fiber)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const program = Micro.gen(function* () {
  // Fork a fiber that runs indefinitely, printing &quot;Hi!&quot;
  const fiber = yield* Micro.fork(
    Micro.forever(
      Micro.sync(() =&gt; console.log(&quot;Hi!&quot;)).pipe(Micro.delay(10))
    )
  )
  yield* Micro.sleep(30)
  // Interrupt the fiber
  yield* Micro.fiberInterrupt(fiber)
})

Micro.runPromise(program)
/*
Output:
Hi!
Hi!
*/
</code></pre>
<h3>Micro.interrupt</h3>
<p>A fiber can be interrupted using the <code>Micro.interrupt</code> effect on that particular fiber.</p>
<p><strong>Example</strong> (Without Interruption)</p>
<p>In this case, the program runs without any interruption, logging the start and completion of the task.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const program = Micro.gen(function* () {
  console.log(&quot;start&quot;)
  yield* Micro.sleep(2_000)
  console.log(&quot;done&quot;)
})

Micro.runPromiseExit(program).then(console.log)
/*
Output:
start
done
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Success&quot;
}
*/
</code></pre>
<p><strong>Example</strong> (With Interruption)</p>
<p>Here, the fiber is interrupted after the log <code>&quot;start&quot;</code> but before the <code>&quot;done&quot;</code> log. The <code>Effect.interrupt</code> stops the fiber, and it never reaches the final log.</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const program = Micro.gen(function* () {
  console.log(&quot;start&quot;)
  yield* Micro.sleep(2_000)
  yield* Micro.interrupt
  console.log(&quot;done&quot;)
})

Micro.runPromiseExit(program).then(console.log)
/*
Output:
start
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Interrupt&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Interrupt&quot;
  }
}
*/
</code></pre>
<p>When a fiber is interrupted, the cause of the interruption is captured, including details like the fiber&#39;s ID and when it started.</p>
<h3>Interruption of Concurrent Effects</h3>
<p>When running multiple effects concurrently, such as with <code>Micro.forEach</code>, if one of the effects is interrupted, it causes all concurrent effects to be interrupted as well.</p>
<p><strong>Example</strong> (Interrupting Concurrent Effects)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const program = Micro.forEach(
  [1, 2, 3],
  (n) =&gt;
    Micro.gen(function* () {
      console.log(`start #${n}`)
      yield* Micro.sleep(2 * 1_000)
      if (n &gt; 1) {
        yield* Micro.interrupt
      }
      console.log(`done #${n}`)
    }),
  { concurrency: &quot;unbounded&quot; }
)

Micro.runPromiseExit(program).then((exit) =&gt;
  console.log(JSON.stringify(exit, null, 2))
)
/*
Output:
start #1
start #2
start #3
done #1
{
  &quot;_id&quot;: &quot;MicroExit&quot;,
  &quot;_tag&quot;: &quot;Failure&quot;,
  &quot;cause&quot;: {
    &quot;_tag&quot;: &quot;Interrupt&quot;,
    &quot;traces&quot;: [],
    &quot;name&quot;: &quot;MicroCause.Interrupt&quot;
  }
}
*/
</code></pre>
<h2>Racing</h2>
<p>The <code>Effect.race</code> function allows you to run multiple effects concurrently, returning the result of the first one that successfully completes.</p>
<p><strong>Example</strong> (Basic Race Between Effects)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const task1 = Micro.delay(Micro.fail(&quot;task1&quot;), 1_000)
const task2 = Micro.delay(Micro.succeed(&quot;task2&quot;), 2_000)

// Run both tasks concurrently and return
// the result of the first to complete
const program = Micro.race(task1, task2)

Micro.runPromise(program).then(console.log)
/*
Output:
task2
*/
</code></pre>
<p>If you want to handle the result of whichever task completes first, whether it succeeds or fails, you can use the <code>Micro.either</code> function. This function wraps the result in an <a href="/docs/data-types/either/">Either</a> type, allowing you to see if the result was a success (<code>Right</code>) or a failure (<code>Left</code>):</p>
<p><strong>Example</strong> (Handling Success or Failure with Either)</p>
<pre><code class="language-ts">import { Micro } from &quot;effect&quot;

const task1 = Micro.delay(Micro.fail(&quot;task1&quot;), 1_000)
const task2 = Micro.delay(Micro.succeed(&quot;task2&quot;), 2_000)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Micro.race(Micro.either(task1), Micro.either(task2))

Micro.runPromise(program).then(console.log)
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;task1&#39; }
*/
</code></pre>
<hr>
<hr>
<h2>title: Logging
description: Discover Effect&#39;s logging utilities for dynamic log levels, custom outputs, and fine-grained control over logs.
sidebar:
  order: 0</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Logging is an important aspect of software development, especially for debugging and monitoring the behavior of your applications. In this section, we&#39;ll explore Effect&#39;s logging utilities and see how they compare to traditional logging methods.</p>
<h2>Advantages Over Traditional Logging</h2>
<p>Effect&#39;s logging utilities provide several benefits over conventional logging approaches:</p>
<ol>
<li><p><strong>Dynamic Log Level Control</strong>: With Effect&#39;s logging, you have the ability to change the log level dynamically. This means you can control which log messages get displayed based on their severity. For example, you can configure your application to log only warnings or errors, which can be extremely helpful in production environments to reduce noise.</p>
</li>
<li><p><strong>Custom Logging Output</strong>: Effect&#39;s logging utilities allow you to change how logs are handled. You can direct log messages to various destinations, such as a service or a file, using a <a href="#custom-loggers">custom logger</a>. This flexibility ensures that logs are stored and processed in a way that best suits your application&#39;s requirements.</p>
</li>
<li><p><strong>Fine-Grained Logging</strong>: Effect enables fine-grained control over logging on a per-part basis of your program. You can set different log levels for different parts of your application, tailoring the level of detail to each specific component. This can be invaluable for debugging and troubleshooting, as you can focus on the information that matters most.</p>
</li>
<li><p><strong>Environment-Based Logging</strong>: Effect&#39;s logging utilities can be combined with deployment environments to achieve granular logging strategies. For instance, during development, you might choose to log everything at a trace level and above for detailed debugging. In contrast, your production version could be configured to log only errors or critical issues, minimizing the impact on performance and noise in production logs.</p>
</li>
<li><p><strong>Additional Features</strong>: Effect&#39;s logging utilities come with additional features such as the ability to measure time spans, alter log levels on a per-effect basis, and integrate spans for performance monitoring.</p>
</li>
</ol>
<h2>log</h2>
<p>The <code>Effect.log</code> function allows you to log a message at the default <code>INFO</code> level.</p>
<p><strong>Example</strong> (Logging a Simple Message)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.log(&quot;Application started&quot;)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Application started&quot;
*/
</code></pre>
<p>The default logger in Effect adds several useful details to each log entry:</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>timestamp</code></td>
<td>The timestamp when the log message was generated.</td>
</tr>
<tr>
<td><code>level</code></td>
<td>The log level at which the message is logged (e.g., <code>INFO</code>, <code>ERROR</code>).</td>
</tr>
<tr>
<td><code>fiber</code></td>
<td>The identifier of the <a href="/docs/concurrency/fibers/">fiber</a> executing the program.</td>
</tr>
<tr>
<td><code>message</code></td>
<td>The log message content, which can include multiple strings or values.</td>
</tr>
<tr>
<td><code>span</code></td>
<td>(Optional) The duration of a span in milliseconds, providing insight into the timing of operations.</td>
</tr>
</tbody></table>
<Aside type="tip" title="Customizing Loggers">
  For information on how to tailor the logging setup to meet specific
  needs, such as integrating a custom logging framework or adjusting log
  formats, please consult the section on [Custom
  Loggers](#custom-loggers).
</Aside>

<p>You can also log multiple messages at once.</p>
<p><strong>Example</strong> (Logging Multiple Messages)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.log(&quot;message1&quot;, &quot;message2&quot;, &quot;message3&quot;)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=message1 message=message2 message=message3
*/
</code></pre>
<p>For added context, you can also include one or more <a href="/docs/data-types/cause/">Cause</a> instances in your logs,
which provide detailed error information under an additional <code>cause</code> annotation:</p>
<p><strong>Example</strong> (Logging with Causes)</p>
<pre><code class="language-ts">import { Effect, Cause } from &quot;effect&quot;

const program = Effect.log(
  &quot;message1&quot;,
  &quot;message2&quot;,
  Cause.die(&quot;Oh no!&quot;),
  Cause.die(&quot;Oh uh!&quot;)
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause=&quot;Error: Oh no!
Error: Oh uh!&quot;
*/
</code></pre>
<h2>Log Levels</h2>
<h3>logDebug</h3>
<p>By default, <code>DEBUG</code> messages <strong>are not displayed</strong>. To enable <code>DEBUG</code> logs, you can adjust the logging configuration using <code>Logger.withMinimumLogLevel</code>, setting the minimum level to <code>LogLevel.Debug</code>.</p>
<p><strong>Example</strong> (Enabling Debug Logs)</p>
<pre><code class="language-ts">import { Effect, Logger, LogLevel } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.logDebug(&quot;task1 done&quot;) // Log a debug message
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug)) // Enable DEBUG level

const task2 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Effect.logDebug(&quot;task2 done&quot;) // This message won&#39;t be logged
})

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;start&quot;)
  yield* task1
  yield* task2
  yield* Effect.log(&quot;done&quot;)
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO message=start
timestamp=... level=DEBUG message=&quot;task1 done&quot; &lt;-- 2 seconds later
timestamp=... level=INFO message=done &lt;-- 1 second later
*/
</code></pre>
<Aside type="tip" title="Controlling Log Levels Per Effect">
  By using `Logger.withMinimumLogLevel(effect, level)`, you can enable
  different log levels for specific parts of your program, providing
  fine-grained control over logging behavior.
</Aside>

<h3>logInfo</h3>
<p>The <code>INFO</code> log level is displayed by default. This level is typically used for general application events or progress updates.</p>
<p><strong>Example</strong> (Logging at the Info Level)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.logInfo(&quot;start&quot;)
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Effect.logInfo(&quot;done&quot;)
})

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO message=start
timestamp=... level=INFO message=done &lt;-- 3 seconds later
*/
</code></pre>
<h3>logWarning</h3>
<p>The <code>WARN</code> log level is displayed by default. This level is intended for potential issues or warnings that do not immediately disrupt the flow of the program but should be monitored.</p>
<p><strong>Example</strong> (Logging at the Warning Level)</p>
<pre><code class="language-ts">import { Effect, Either } from &quot;effect&quot;

const task = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logWarning(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
Output:
timestamp=... level=WARN fiber=#0 message=&quot;Oh uh!&quot;
*/
</code></pre>
<h3>logError</h3>
<p>The <code>ERROR</code> log level is displayed by default. These messages represent issues that need to be addressed.</p>
<p><strong>Example</strong> (Logging at the Error Level)</p>
<pre><code class="language-ts">import { Effect, Either } from &quot;effect&quot;

const task = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logError(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
Output:
timestamp=... level=ERROR fiber=#0 message=&quot;Oh uh!&quot;
*/
</code></pre>
<h3>logFatal</h3>
<p>The <code>FATAL</code> log level is displayed by default. This log level is typically reserved for unrecoverable errors.</p>
<p><strong>Example</strong> (Logging at the Fatal Level)</p>
<pre><code class="language-ts">import { Effect, Either } from &quot;effect&quot;

const task = Effect.fail(&quot;Oh uh!&quot;).pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logFatal(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
Output:
timestamp=... level=FATAL fiber=#0 message=&quot;Oh uh!&quot;
*/
</code></pre>
<h2>Custom Annotations</h2>
<p>You can enhance your log outputs by adding custom annotations using the <code>Effect.annotateLogs</code> function. This allows you to attach extra metadata to each log entry, making it easier to trace and add context to your logs.</p>
<p>Enhance your log outputs by incorporating custom annotations with the <code>Effect.annotateLogs</code> function.
This function allows you to append additional metadata to each log entry of an effect, enhancing traceability and context.</p>
<h3>Adding a Single Annotation</h3>
<p>You can apply a single annotation as a key/value pair to all log entries within an effect.</p>
<p><strong>Example</strong> (Single Key/Value Annotation)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;message1&quot;)
  yield* Effect.log(&quot;message2&quot;)
}).pipe(
  // Annotation as key/value pair
  Effect.annotateLogs(&quot;key&quot;, &quot;value&quot;)
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=message1 key=value
timestamp=... level=INFO fiber=#0 message=message2 key=value
*/
</code></pre>
<p>In this example, all logs generated within the <code>program</code> will include the annotation <code>key=value</code>.</p>
<Aside type="tip" title="Scope of Annotations">
  Annotations applied with `Effect.annotateLogs` are automatically added
  to all logs generated within the annotated effect's scope, including
  logs from nested effects.
</Aside>

<h3>Annotations with Nested Effects</h3>
<p>Annotations propagate to all logs generated within nested or downstream effects. This ensures that logs from any child effects inherit the parent effect&#39;s annotations.</p>
<p><strong>Example</strong> (Propagating Annotations to Nested Effects)</p>
<p>In this example, the annotation <code>key=value</code> is included in all logs, even those from the nested <code>anotherProgram</code> effect.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define a child program that logs an error
const anotherProgram = Effect.gen(function* () {
  yield* Effect.logError(&quot;error1&quot;)
})

// Define the main program
const program = Effect.gen(function* () {
  yield* Effect.log(&quot;message1&quot;)
  yield* Effect.log(&quot;message2&quot;)
  yield* anotherProgram // Call the nested program
}).pipe(
  // Attach an annotation to all logs in the scope
  Effect.annotateLogs(&quot;key&quot;, &quot;value&quot;)
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=message1 key=value
timestamp=... level=INFO fiber=#0 message=message2 key=value
timestamp=... level=ERROR fiber=#0 message=error1 key=value
*/
</code></pre>
<h3>Adding Multiple Annotations</h3>
<p>You can also apply multiple annotations at once by passing an object with key/value pairs. Each key/value pair will be added to every log entry within the effect.</p>
<p><strong>Example</strong> (Multiple Annotations)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;message1&quot;)
  yield* Effect.log(&quot;message2&quot;)
}).pipe(
  // Add multiple annotations
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; })
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=message1 key2=value2 key1=value1
timestamp=... level=INFO fiber=#0 message=message2 key2=value2 key1=value1
*/
</code></pre>
<p>In this case, each log will contain both <code>key1=value1</code> and <code>key2=value2</code>.</p>
<h3>Scoped Annotations</h3>
<p>If you want to limit the scope of your annotations so that they only apply to certain log entries, you can use <code>Effect.annotateLogsScoped</code>. This function confines the annotations to logs produced within a specific scope.</p>
<p><strong>Example</strong> (Scoped Annotations)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;no annotations&quot;) // No annotations
  yield* Effect.annotateLogsScoped({ key: &quot;value&quot; }) // Scoped annotation
  yield* Effect.log(&quot;message1&quot;) // Annotation applied
  yield* Effect.log(&quot;message2&quot;) // Annotation applied
}).pipe(
  Effect.scoped,
  // Outside scope, no annotations
  Effect.andThen(Effect.log(&quot;no annotations again&quot;))
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;no annotations&quot;
timestamp=... level=INFO fiber=#0 message=message1 key=value
timestamp=... level=INFO fiber=#0 message=message2 key=value
timestamp=... level=INFO fiber=#0 message=&quot;no annotations again&quot;
*/
</code></pre>
<h2>Log Spans</h2>
<p>Effect provides built-in support for log spans, which allow you to measure and log the duration of specific tasks or sections of your code. This feature is helpful for tracking how long certain operations take, giving you better insights into the performance of your application.</p>
<p><strong>Example</strong> (Measuring Task Duration with a Log Span)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Simulate a delay to represent a task taking time
  yield* Effect.sleep(&quot;1 second&quot;)
  // Log a message indicating the job is done
  yield* Effect.log(&quot;The job is finished!&quot;)
}).pipe(
  // Apply a log span labeled &quot;myspan&quot; to measure
  // the duration of this operation
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;The job is finished!&quot; myspan=1011ms
*/
</code></pre>
<h2>Disabling Default Logging</h2>
<p>Sometimes, perhaps during test execution, you might want to disable default logging in your application. Effect provides several ways to turn off logging when needed. In this section, we&#39;ll look at different methods to disable logging in the Effect framework.</p>
<p><strong>Example</strong> (Using <code>Logger.withMinimumLogLevel</code>)</p>
<p>One convenient way to disable logging is by using the <code>Logger.withMinimumLogLevel</code> function. This allows you to set the minimum log level to <code>None</code>, effectively turning off all log output.</p>
<pre><code class="language-ts">import { Effect, Logger, LogLevel } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;Executing task...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task done&quot;)
})

// Default behavior: logging enabled
Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Executing task...&quot;
task done
*/

// Disable logging by setting minimum log level to &#39;None&#39;
Effect.runFork(program.pipe(Logger.withMinimumLogLevel(LogLevel.None)))
/*
Output:
task done
*/
</code></pre>
<p><strong>Example</strong> (Using a Layer)</p>
<p>Another approach to disable logging is by creating a layer that sets the minimum log level to <code>LogLevel.None</code>, effectively turning off all log output.</p>
<pre><code class="language-ts">import { Effect, Logger, LogLevel } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;Executing task...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task done&quot;)
})

// Create a layer that disables logging
const layer = Logger.minimumLogLevel(LogLevel.None)

// Apply the layer to disable logging
Effect.runFork(program.pipe(Effect.provide(layer)))
/*
Output:
task done
*/
</code></pre>
<p><strong>Example</strong> (Using a Custom Runtime)</p>
<p>You can also disable logging by creating a custom runtime that includes the configuration to turn off logging:</p>
<pre><code class="language-ts">import { Effect, Logger, LogLevel, ManagedRuntime } from &quot;effect&quot;

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;Executing task...&quot;)
  yield* Effect.sleep(&quot;100 millis&quot;)
  console.log(&quot;task done&quot;)
})

// Create a custom runtime that disables logging
const customRuntime = ManagedRuntime.make(
  Logger.minimumLogLevel(LogLevel.None)
)

// Run the program using the custom runtime
customRuntime.runFork(program)
/*
Output:
task done
*/
</code></pre>
<h2>Loading the Log Level from Configuration</h2>
<p>To dynamically load the log level from a <a href="/docs/configuration/">configuration</a> and apply it to your program, you can use the <code>Logger.minimumLogLevel</code> layer. This allows your application to adjust its logging behavior based on external configuration.</p>
<p><strong>Example</strong> (Loading Log Level from Configuration)</p>
<pre><code class="language-ts">import {
  Effect,
  Config,
  Logger,
  Layer,
  ConfigProvider,
  LogLevel
} from &quot;effect&quot;

// Simulate a program with logs
const program = Effect.gen(function* () {
  yield* Effect.logError(&quot;ERROR!&quot;)
  yield* Effect.logWarning(&quot;WARNING!&quot;)
  yield* Effect.logInfo(&quot;INFO!&quot;)
  yield* Effect.logDebug(&quot;DEBUG!&quot;)
})

// Load the log level from the configuration and apply it as a layer
const LogLevelLive = Config.logLevel(&quot;LOG_LEVEL&quot;).pipe(
  Effect.andThen((level) =&gt;
    // Set the minimum log level
    Logger.minimumLogLevel(level)
  ),
  Layer.unwrapEffect // Convert the effect into a layer
)

// Provide the loaded log level to the program
const configured = Effect.provide(program, LogLevelLive)

// Test the program using a mock configuration provider
const test = Effect.provide(
  configured,
  Layer.setConfigProvider(
    ConfigProvider.fromMap(
      new Map([[&quot;LOG_LEVEL&quot;, LogLevel.Warning.label]])
    )
  )
)

Effect.runFork(test)
/*
Output:
... level=ERROR fiber=#0 message=ERROR!
... level=WARN fiber=#0 message=WARNING!
*/
</code></pre>
<Aside type="tip" title="Using ConfigProvider for Testing">
  The `ConfigProvider.fromMap` function is useful for testing by
  simulating configuration values. You can also refer to [Testing
  Services](/docs/configuration/#testing-configurable-services) for more
  details on using mock configuration during tests.
</Aside>

<h2>Custom loggers</h2>
<p>In this section, you&#39;ll learn how to define a custom logger and set it as the default logger in your application. Custom loggers give you control over how log messages are handled, such as routing them to external services, writing to files, or formatting logs in a specific way.</p>
<h3>Defining a Custom Logger</h3>
<p>You can define your own logger using the <code>Logger.make</code> function. This function allows you to specify how log messages should be processed.</p>
<p><strong>Example</strong> (Defining a Simple Custom Logger)</p>
<pre><code class="language-ts">import { Logger } from &quot;effect&quot;

// Custom logger that outputs log messages to the console
const logger = Logger.make(({ logLevel, message }) =&gt; {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})
</code></pre>
<p>In this example, the custom logger logs messages to the console with the log level and message formatted as <code>[LogLevel] Message</code>.</p>
<h3>Using a Custom Logger in a Program</h3>
<p>Let&#39;s assume you have the following tasks and a program where you log some messages:</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

// Custom logger that outputs log messages to the console
const logger = Logger.make(({ logLevel, message }) =&gt; {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

const task1 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.logDebug(&quot;task1 done&quot;)
})

const task2 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Effect.logDebug(&quot;task2 done&quot;)
})

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;start&quot;)
  yield* task1
  yield* task2
  yield* Effect.log(&quot;done&quot;)
})
</code></pre>
<p>To replace the default logger with your custom logger, you can use the <code>Logger.replace</code> function. After creating a layer that replaces the default logger, you provide it to your program using <code>Effect.provide</code>.</p>
<p><strong>Example</strong> (Replacing the Default Logger with a Custom Logger)</p>
<pre><code class="language-ts">import { Effect, Logger, LogLevel } from &quot;effect&quot;

// Custom logger that outputs log messages to the console
const logger = Logger.make(({ logLevel, message }) =&gt; {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

const task1 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;2 seconds&quot;)
  yield* Effect.logDebug(&quot;task1 done&quot;)
})

const task2 = Effect.gen(function* () {
  yield* Effect.sleep(&quot;1 second&quot;)
  yield* Effect.logDebug(&quot;task2 done&quot;)
})

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;start&quot;)
  yield* task1
  yield* task2
  yield* Effect.log(&quot;done&quot;)
})

// Replace the default logger with the custom logger
const layer = Logger.replace(Logger.defaultLogger, logger)

Effect.runFork(
  program.pipe(
    Logger.withMinimumLogLevel(LogLevel.Debug),
    Effect.provide(layer)
  )
)
</code></pre>
<p>When you run the above program, the following log messages are printed to the console:</p>
<pre><code class="language-ansi">[INFO] start
[DEBUG] task1 done
[DEBUG] task2 done
[INFO] done
</code></pre>
<h2>Built-in Loggers</h2>
<p>Effect provides several built-in loggers that you can use depending on your logging needs. These loggers offer different formats, each suited for different environments or purposes, such as development, production, or integration with external logging services.</p>
<p>Each logger is available in two forms: the logger itself, and a layer that uses the logger and sends its output to the <code>Console</code> <a href="/docs/requirements-management/default-services/">default service</a>. For example, the <code>structuredLogger</code> logger generates logs in a detailed object-based format, while the <code>structured</code> layer uses the same logger and writes the output to the <code>Console</code> service.</p>
<h3>stringLogger (default)</h3>
<p>The <code>stringLogger</code> logger produces logs in a human-readable key-value style. This format is commonly used in development and production because it is simple and easy to read in the console.</p>
<p>This logger does not have a corresponding layer because it is the default logger.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

const program = Effect.log(&quot;msg1&quot;, &quot;msg2&quot;, [&quot;msg3&quot;, &quot;msg4&quot;]).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; }),
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program)
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">timestamp=2024-12-28T10:44:31.281Z level=INFO fiber=#0 message=msg1 message=msg2 message=&quot;[
  \&quot;msg3\&quot;,
  \&quot;msg4\&quot;
]&quot; myspan=102ms key2=value2 key1=value1
</code></pre>
<h3>logfmtLogger</h3>
<p>The <code>logfmtLogger</code> logger produces logs in a human-readable key-value format, similar to the <a href="#stringlogger-default">stringLogger</a> logger. The main difference is that <code>logfmtLogger</code> removes extra spaces to make logs more compact.</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

const program = Effect.log(&quot;msg1&quot;, &quot;msg2&quot;, [&quot;msg3&quot;, &quot;msg4&quot;]).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; }),
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">timestamp=2024-12-28T10:44:31.281Z level=INFO fiber=#0 message=msg1 message=msg2 message=&quot;[\&quot;msg3\&quot;,\&quot;msg4\&quot;]&quot; myspan=102ms key2=value2 key1=value1
</code></pre>
<h3>prettyLogger</h3>
<p>The <code>prettyLogger</code> logger enhances log output by using color and indentation for better readability, making it particularly useful during development when visually scanning logs in the console.</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

const program = Effect.log(&quot;msg1&quot;, &quot;msg2&quot;, [&quot;msg3&quot;, &quot;msg4&quot;]).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; }),
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">[11:37:14.265] [32mINFO[0m (#0) myspan=101ms: [1;36mmsg1[0m
  msg2
  [ [32m&#39;msg3&#39;[0m, [32m&#39;msg4&#39;[0m ]
  key2: value2
  key1: value1
</code></pre>
<h3>structuredLogger</h3>
<p>The <code>structuredLogger</code> logger produces logs in a detailed object-based format. This format is helpful when you need more traceable logs, especially if other systems analyze them or store them for later review.</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

const program = Effect.log(&quot;msg1&quot;, &quot;msg2&quot;, [&quot;msg3&quot;, &quot;msg4&quot;]).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; }),
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">{
  message: [ &#39;msg1&#39;, &#39;msg2&#39;, [ &#39;msg3&#39;, &#39;msg4&#39; ] ],
  logLevel: &#39;INFO&#39;,
  timestamp: &#39;2024-12-28T10:44:31.281Z&#39;,
  cause: undefined,
  annotations: { key2: &#39;value2&#39;, key1: &#39;value1&#39; },
  spans: { myspan: 102 },
  fiberId: &#39;#0&#39;
}
</code></pre>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>message</code></td>
<td>Either a single processed value or an array of processed values, depending on how many messages are logged.</td>
</tr>
<tr>
<td><code>logLevel</code></td>
<td>A string that indicates the log level label (for example, &quot;INFO&quot; or &quot;DEBUG&quot;).</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>An ISO 8601 timestamp for when the log was generated (for example, &quot;2024-01-01T00:00:00.000Z&quot;).</td>
</tr>
<tr>
<td><code>cause</code></td>
<td>A string that shows detailed error information, or <code>undefined</code> if no cause was provided.</td>
</tr>
<tr>
<td><code>annotations</code></td>
<td>An object where each key is an annotation label and the corresponding value is parsed into a structured format (for instance, <code>{&quot;key&quot;: &quot;value&quot;}</code>).</td>
</tr>
<tr>
<td><code>spans</code></td>
<td>An object mapping each span label to its duration in milliseconds, measured from its start time until the moment the logger was called (for example, <code>{&quot;myspan&quot;: 102}</code>).</td>
</tr>
<tr>
<td><code>fiberId</code></td>
<td>The identifier of the fiber that generated this log (for example, &quot;#0&quot;).</td>
</tr>
</tbody></table>
<h3>jsonLogger</h3>
<p>The <code>jsonLogger</code> logger produces logs in JSON format. This can be useful for tools or services that parse and store JSON logs.
It calls <code>JSON.stringify</code> on the object created by the <a href="#structuredlogger">structuredLogger</a> logger.</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

const program = Effect.log(&quot;msg1&quot;, &quot;msg2&quot;, [&quot;msg3&quot;, &quot;msg4&quot;]).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.annotateLogs({ key1: &quot;value1&quot;, key2: &quot;value2&quot; }),
  Effect.withLogSpan(&quot;myspan&quot;)
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
</code></pre>
<p>Output:</p>
<pre><code class="language-ansi">{&quot;message&quot;:[&quot;msg1&quot;,&quot;msg2&quot;,[&quot;msg3&quot;,&quot;msg4&quot;]],&quot;logLevel&quot;:&quot;INFO&quot;,&quot;timestamp&quot;:&quot;2024-12-28T10:44:31.281Z&quot;,&quot;annotations&quot;:{&quot;key2&quot;:&quot;value2&quot;,&quot;key1&quot;:&quot;value1&quot;},&quot;spans&quot;:{&quot;myspan&quot;:102},&quot;fiberId&quot;:&quot;#0&quot;}
</code></pre>
<h2>Combine Loggers</h2>
<h3>zip</h3>
<p>The <code>Logger.zip</code> function combines two loggers into a new logger. This new logger forwards log messages to both the original loggers.</p>
<p><strong>Example</strong> (Combining Two Loggers)</p>
<pre><code class="language-ts">import { Effect, Logger } from &quot;effect&quot;

// Define a custom logger that logs to the console
const logger = Logger.make(({ logLevel, message }) =&gt; {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

// Combine the default logger and the custom logger
//
//      ┌─── Logger&lt;unknown, [void, void]&gt;
//      ▼
const combined = Logger.zip(Logger.defaultLogger, logger)

const program = Effect.log(&quot;something&quot;)

Effect.runFork(
  program.pipe(
    // Replace the default logger with the combined logger
    Effect.provide(Logger.replace(Logger.defaultLogger, combined))
  )
)
/*
Output:
timestamp=2025-01-09T13:50:58.655Z level=INFO fiber=#0 message=something
[INFO] something
*/
</code></pre>
<hr>
<hr>
<h2>title: Metrics in Effect
description: Effect Metrics provides powerful monitoring tools, including counters, gauges, histograms, summaries, and frequencies, to track your application&#39;s performance and behavior.
sidebar:
  label: Metrics
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In complex and highly concurrent applications, managing various interconnected components can be quite challenging. Ensuring that everything runs smoothly and avoiding application downtime becomes crucial in such setups.</p>
<p>Now, let&#39;s imagine we have a sophisticated infrastructure with numerous services. These services are replicated and distributed across our servers. However, we often lack insight into what&#39;s happening across these services, including error rates, response times, and service uptime. This lack of visibility can make it challenging to identify and address issues effectively. This is where Effect Metrics comes into play; it allows us to capture and analyze various metrics, providing valuable data for later investigation.</p>
<p>Effect Metrics offers support for five different types of metrics:</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Counter</strong></td>
<td>Counters are used to track values that increase over time, such as request counts. They help us keep tabs on how many times a specific event or action has occurred.</td>
</tr>
<tr>
<td><strong>Gauge</strong></td>
<td>Gauges represent a single numerical value that can fluctuate up and down over time. They are often used to monitor metrics like memory usage, which can vary continuously.</td>
</tr>
<tr>
<td><strong>Histogram</strong></td>
<td>Histograms are useful for tracking the distribution of observed values across different buckets. They are commonly used for metrics like request latencies, allowing us to understand how response times are distributed.</td>
</tr>
<tr>
<td><strong>Summary</strong></td>
<td>Summaries provide insight into a sliding window of a time series and offer metrics for specific percentiles of the time series, often referred to as quantiles. This is particularly helpful for understanding latency-related metrics, such as request response times.</td>
</tr>
<tr>
<td><strong>Frequency</strong></td>
<td>Frequency metrics count the occurrences of distinct string values. They are useful when you want to keep track of how often different events or conditions are happening in your application.</td>
</tr>
</tbody></table>
<h2>Counter</h2>
<p>In the world of metrics, a Counter is a metric that represents a single numerical value that can be both incremented and decremented over time. Think of it like a tally that keeps track of changes, such as the number of a particular type of request received by your application, whether it&#39;s increasing or decreasing.</p>
<p>Unlike some other types of metrics (like <a href="#gauge">gauges</a>), where we&#39;re interested in the value at a specific moment, with counters, we care about the cumulative value over time. This means it provides a running total of changes, which can go up and down, reflecting the dynamic nature of certain metrics.</p>
<p>Some typical use cases for counters include:</p>
<ul>
<li><strong>Request Counts</strong>: Monitoring the number of incoming requests to your server.</li>
<li><strong>Completed Tasks</strong>: Keeping track of how many tasks or processes have been successfully completed.</li>
<li><strong>Error Counts</strong>: Counting the occurrences of errors in your application.</li>
</ul>
<h3>How to Create a Counter</h3>
<p>To create a counter, you can use the <code>Metric.counter</code> constructor.</p>
<p><strong>Example</strong> (Creating a Counter)</p>
<pre><code class="language-ts">import { Metric, Effect } from &quot;effect&quot;

const requestCount = Metric.counter(&quot;request_count&quot;, {
  // Optional
  description: &quot;A counter for tracking requests&quot;
})
</code></pre>
<p>Once created, the counter can accept an effect that returns a <code>number</code>, which will increment or decrement the counter.</p>
<p><strong>Example</strong> (Using a Counter)</p>
<pre><code class="language-ts">import { Metric, Effect } from &quot;effect&quot;

const requestCount = Metric.counter(&quot;request_count&quot;)

const program = Effect.gen(function* () {
  // Increment the counter by 1
  const a = yield* requestCount(Effect.succeed(1))
  // Increment the counter by 2
  const b = yield* requestCount(Effect.succeed(2))
  // Decrement the counter by 4
  const c = yield* requestCount(Effect.succeed(-4))

  // Get the current state of the counter
  const state = yield* Metric.value(requestCount)
  console.log(state)

  return a * b * c
})

Effect.runPromise(program).then(console.log)
/*
Output:
CounterState {
  count: -1,
  ...
}
-8
*/
</code></pre>
<Aside type="note" title="Type Preservation">
  Applying a counter to an effect doesn't change its original type. The
  metric simply adds tracking without affecting the effect's output type.
</Aside>

<h3>Counter Types</h3>
<p>You can specify whether the counter tracks a <code>number</code> or <code>bigint</code>.</p>
<pre><code class="language-ts">import { Metric } from &quot;effect&quot;

const numberCounter = Metric.counter(&quot;request_count&quot;, {
  description: &quot;A counter for tracking requests&quot;
  // bigint: false // default
})

const bigintCounter = Metric.counter(&quot;error_count&quot;, {
  description: &quot;A counter for tracking errors&quot;,
  bigint: true
})
</code></pre>
<h3>Increment-Only Counters</h3>
<p>If you need a counter that only increments, you can use the <code>incremental: true</code> option.</p>
<p><strong>Example</strong> (Using an Increment-Only Counter)</p>
<pre><code class="language-ts">import { Metric, Effect } from &quot;effect&quot;

const incrementalCounter = Metric.counter(&quot;count&quot;, {
  description: &quot;a counter that only increases its value&quot;,
  incremental: true
})

const program = Effect.gen(function* () {
  const a = yield* incrementalCounter(Effect.succeed(1))
  const b = yield* incrementalCounter(Effect.succeed(2))
  // This will have no effect on the counter
  const c = yield* incrementalCounter(Effect.succeed(-4))

  const state = yield* Metric.value(incrementalCounter)
  console.log(state)

  return a * b * c
})

Effect.runPromise(program).then(console.log)
/*
Output:
CounterState {
  count: 3,
  ...
}
-8
*/
</code></pre>
<p>In this configuration, the counter only accepts positive values. Any attempts to decrement will have no effect, ensuring the counter strictly counts upwards.</p>
<h3>Counters With Constant Input</h3>
<p>You can configure a counter to always increment by a fixed value each time it is invoked.</p>
<p><strong>Example</strong> (Constant Input)</p>
<pre><code class="language-ts">import { Metric, Effect } from &quot;effect&quot;

const taskCount = Metric.counter(&quot;task_count&quot;).pipe(
  Metric.withConstantInput(1) // Automatically increments by 1
)

const task1 = Effect.succeed(1).pipe(Effect.delay(&quot;100 millis&quot;))
const task2 = Effect.succeed(2).pipe(Effect.delay(&quot;200 millis&quot;))
const task3 = Effect.succeed(-4).pipe(Effect.delay(&quot;300 millis&quot;))

const program = Effect.gen(function* () {
  const a = yield* taskCount(task1)
  const b = yield* taskCount(task2)
  const c = yield* taskCount(task3)

  const state = yield* Metric.value(taskCount)
  console.log(state)

  return a * b * c
})

Effect.runPromise(program).then(console.log)
/*
Output:
CounterState {
  count: 3,
  ...
}
-8
*/
</code></pre>
<h2>Gauge</h2>
<p>In the world of metrics, a Gauge is a metric that represents a single numerical value that can be set or adjusted. Think of it as a dynamic variable that can change over time. One common use case for a gauge is to monitor something like the current memory usage of your application.</p>
<p>Unlike counters, where we&#39;re interested in cumulative values over time, with gauges, our focus is on the current value at a specific point in time.</p>
<p>Gauges are the best choice when you want to monitor values that can both increase and decrease, and you&#39;re not interested in tracking their rates of change. In other words, gauges help us measure things that have a specific value at a particular moment.</p>
<p>Some typical use cases for gauges include:</p>
<ul>
<li><strong>Memory Usage</strong>: Keeping an eye on how much memory your application is using right now.</li>
<li><strong>Queue Size</strong>: Monitoring the current size of a queue where tasks are waiting to be processed.</li>
<li><strong>In-Progress Request Counts</strong>: Tracking the number of requests currently being handled by your server.</li>
<li><strong>Temperature</strong>: Measuring the current temperature, which can fluctuate up and down.</li>
</ul>
<h3>How to Create a Gauge</h3>
<p>To create a gauge, you can use the <code>Metric.gauge</code> constructor.</p>
<p><strong>Example</strong> (Creating a Gauge)</p>
<pre><code class="language-ts">import { Metric } from &quot;effect&quot;

const memory = Metric.gauge(&quot;memory_usage&quot;, {
  // Optional
  description: &quot;A gauge for memory usage&quot;
})
</code></pre>
<p>Once created, a gauge can be updated by passing an effect that produces the value you want to set for the gauge.</p>
<p><strong>Example</strong> (Using a Gauge)</p>
<pre><code class="language-ts">import { Metric, Effect, Random } from &quot;effect&quot;

// Create a gauge to track temperature
const temperature = Metric.gauge(&quot;temperature&quot;)

// Simulate fetching a random temperature
const getTemperature = Effect.gen(function* () {
  // Get a random temperature between -10 and 10
  const t = yield* Random.nextIntBetween(-10, 10)
  console.log(`new temperature: ${t}`)
  return t
})

// Program that updates the gauge multiple times
const program = Effect.gen(function* () {
  const series: Array&lt;number&gt; = []
  // Update the gauge with new temperature readings
  series.push(yield* temperature(getTemperature))
  series.push(yield* temperature(getTemperature))
  series.push(yield* temperature(getTemperature))

  // Retrieve the current state of the gauge
  const state = yield* Metric.value(temperature)
  console.log(state)

  return series
})

Effect.runPromise(program).then(console.log)
/*
Example Output:
new temperature: 9
new temperature: -9
new temperature: 2
GaugeState {
  value: 2, // the most recent value set in the gauge
  ...
}
[ 9, -9, 2 ]
*/
</code></pre>
<Aside type="note" title="Gauge Behavior">
  Gauges capture the most recent value set, so if you're tracking a
  sequence of updates, the final state will show only the last recorded
  value, not the entire series.
</Aside>

<h3>Gauge Types</h3>
<p>You can specify whether the gauge tracks a <code>number</code> or <code>bigint</code>.</p>
<pre><code class="language-ts">import { Metric } from &quot;effect&quot;

const numberGauge = Metric.gauge(&quot;memory_usage&quot;, {
  description: &quot;A gauge for memory usage&quot;
  // bigint: false // default
})

const bigintGauge = Metric.gauge(&quot;cpu_load&quot;, {
  description: &quot;A gauge for CPU load&quot;,
  bigint: true
})
</code></pre>
<h2>Histogram</h2>
<p>A Histogram is a metric used to analyze how numerical values are distributed over time. Instead of focusing on individual data points, a histogram groups values into predefined ranges, called <strong>buckets</strong>, and tracks how many values fall into each range.</p>
<p>When a value is recorded, it gets assigned to one of the histogram&#39;s buckets based on its range. Each bucket has an upper boundary, and the count for that bucket is increased if the value is less than or equal to its boundary. Once recorded, the individual value is discarded, and the focus shifts to how many values have fallen into each bucket.</p>
<p>Histograms also track:</p>
<ul>
<li><strong>Total Count</strong>: The number of values that have been observed.</li>
<li><strong>Sum</strong>: The sum of all the observed values.</li>
<li><strong>Min</strong>: The smallest observed value.</li>
<li><strong>Max</strong>: The largest observed value.</li>
</ul>
<p>Histograms are especially useful for calculating percentiles, which can help you estimate specific points in a dataset by analyzing how many values are in each bucket.</p>
<p>This concept is inspired by <a href="https://prometheus.io/docs/concepts/metric_types#histogram">Prometheus</a>, a well-known monitoring and alerting toolkit.</p>
<p>Histograms are particularly useful in performance analysis and system monitoring. By examining how response times, latencies, or other metrics are distributed, you can gain valuable insights into your system&#39;s behavior. This data helps you identify outliers, performance bottlenecks, or trends that may require optimization.</p>
<p>Common use cases for histograms include:</p>
<ul>
<li><strong>Percentile Estimation</strong>: Histograms allow you to approximate percentiles of observed values, like the 95th percentile of response times.</li>
<li><strong>Known Ranges</strong>: If you can estimate the range of values in advance, histograms can organize the data into predefined buckets for better analysis.</li>
<li><strong>Performance Metrics</strong>: Use histograms to track metrics like request latencies, memory usage, or throughput over time.</li>
<li><strong>Aggregation</strong>: Histograms can be aggregated across multiple instances, making them ideal for distributed systems where you need to collect data from different sources.</li>
</ul>
<Aside type="note" title="Histogram Buckets and Precision">
  Keep in mind that histograms don't retain exact values. Instead, they
  group values into buckets, so the precision of your data depends on how
  you define these buckets.
</Aside>

<p><strong>Example</strong> (Histogram With Linear Buckets)</p>
<p>In this example, we define a histogram with linear buckets, where the values range from <code>0</code> to <code>100</code> in increments of <code>10</code>. Additionally, we include a final bucket for values greater than <code>100</code>, referred to as the &quot;Infinity&quot; bucket. This configuration is useful for tracking numeric values, like request latencies, within specific ranges.</p>
<p>The program generates random numbers between <code>1</code> and <code>120</code>, records them in the histogram, and then prints the histogram&#39;s state, showing the count of values that fall into each bucket.</p>
<pre><code class="language-ts">import { Effect, Metric, MetricBoundaries, Random } from &quot;effect&quot;

// Define a histogram to track request latencies, with linear buckets
const latency = Metric.histogram(
  &quot;request_latency&quot;,
  // Buckets from 0-100, with an extra Infinity bucket
  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),
  // Optional
  &quot;Measures the distribution of request latency.&quot;
)

const program = Effect.gen(function* () {
  // Generate 100 random values and record them in the histogram
  yield* latency(Random.nextIntBetween(1, 120)).pipe(Effect.repeatN(99))

  // Fetch and display the histogram&#39;s state
  const state = yield* Metric.value(latency)
  console.log(state)
})

Effect.runPromise(program)
/*
Example Output:
HistogramState {
  buckets: [
    [ 0, 0 ],    // No values in the 0-10 range
    [ 10, 7 ],   // 7 values in the 10-20 range
    [ 20, 11 ],  // 11 values in the 20-30 range
    [ 30, 20 ],  // 20 values in the 30-40 range
    [ 40, 27 ],  // and so on...
    [ 50, 38 ],
    [ 60, 53 ],
    [ 70, 64 ],
    [ 80, 73 ],
    [ 90, 84 ],
    [ Infinity, 100 ] // All 100 values have been recorded
  ],
  count: 100,  // Total count of observed values
  min: 1,      // Smallest observed value
  max: 119,    // Largest observed value
  sum: 5980,   // Sum of all observed values
  ...
}
*/
</code></pre>
<h3>Timer Metric</h3>
<p>In this example, we demonstrate how to use a timer metric to track the duration of specific workflows. The timer captures how long certain tasks take to execute, storing this information in a histogram, which provides insights into the distribution of these durations.</p>
<p>We generate random values to simulate varying wait times, record the durations in the timer, and then print out the histogram&#39;s state.</p>
<p><strong>Example</strong> (Tracking Workflow Durations with a Timer Metric)</p>
<pre><code class="language-ts">import { Metric, Array, Random, Effect } from &quot;effect&quot;

// Create a timer metric with predefined boundaries from 1 to 10
const timer = Metric.timerWithBoundaries(&quot;timer&quot;, Array.range(1, 10))

// Define a task that simulates random wait times
const task = Effect.gen(function* () {
  // Generate a random value between 1 and 10
  const n = yield* Random.nextIntBetween(1, 10)
  // Simulate a delay based on the random value
  yield* Effect.sleep(`${n} millis`)
})

const program = Effect.gen(function* () {
  // Track the duration of the task and repeat it 100 times
  yield* Metric.trackDuration(task, timer).pipe(Effect.repeatN(99))

  // Retrieve and print the current state of the timer histogram
  const state = yield* Metric.value(timer)
  console.log(state)
})

Effect.runPromise(program)
/*
Example Output:
HistogramState {
  buckets: [
    [ 1, 3 ],   // 3 tasks completed in &lt;= 1 ms
    [ 2, 13 ],  // 13 tasks completed in &lt;= 2 ms
    [ 3, 17 ],  // and so on...
    [ 4, 26 ],
    [ 5, 35 ],
    [ 6, 43 ],
    [ 7, 53 ],
    [ 8, 56 ],
    [ 9, 65 ],
    [ 10, 72 ],
    [ Infinity, 100 ]      // All 100 tasks have completed
  ],
  count: 100,              // Total number of tasks observed
  min: 0.25797,            // Shortest task duration in milliseconds
  max: 12.25421,           // Longest task duration in milliseconds
  sum: 683.0266810000002,  // Total time spent across all tasks
  ...
}
*/
</code></pre>
<h2>Summary</h2>
<p>A Summary is a metric that gives insights into a series of data points by calculating specific percentiles. Percentiles help us understand how data is distributed. For instance, if you&#39;re tracking response times for requests over the past hour, you may want to examine key percentiles such as the 50th, 90th, 95th, or 99th to better understand your system&#39;s performance.</p>
<p>Summaries are similar to histograms in that they observe <code>number</code> values, but with a different approach. Instead of immediately sorting values into buckets and discarding them, a summary holds onto the observed values in memory. However, to avoid storing too much data, summaries use two parameters:</p>
<ul>
<li><strong>maxAge</strong>: The maximum age a value can have before it&#39;s discarded.</li>
<li><strong>maxSize</strong>: The maximum number of values stored in the summary.</li>
</ul>
<p>This creates a sliding window of recent values, so the summary always represents a fixed number of the most recent observations.</p>
<p>Summaries are commonly used to calculate <strong>quantiles</strong> over this sliding window. A <strong>quantile</strong> is a number between <code>0</code> and <code>1</code> that represents the percentage of values less than or equal to a certain threshold. For example, a quantile of <code>0.5</code> (or 50th percentile) is the <strong>median</strong> value, while <code>0.95</code> (or 95th percentile) would represent the value below which 95% of the observed data falls.</p>
<p>Quantiles are helpful for monitoring important performance metrics, such as latency, and for ensuring that your system meets performance goals (like Service Level Agreements, or SLAs).</p>
<p>The Effect Metrics API also allows you to configure summaries with an <strong>error margin</strong>. This margin introduces a range of acceptable values for quantiles, improving the accuracy of the result.</p>
<p>Summaries are particularly useful in cases where:</p>
<ul>
<li>The range of values you&#39;re observing is not known or estimated in advance, making histograms less practical.</li>
<li>You don&#39;t need to aggregate data across multiple instances or average results. Summaries calculate their results on the application side, meaning they focus on the specific instance where they are used.</li>
</ul>
<p><strong>Example</strong> (Creating and Using a Summary)</p>
<p>In this example, we will create a summary to track response times. The summary will:</p>
<ul>
<li>Hold up to <code>100</code> samples.</li>
<li>Discard samples older than <code>1 day</code>.</li>
<li>Have a <code>3%</code> error margin when calculating quantiles.</li>
<li>Report the <code>10%</code>, <code>50%</code>, and <code>90%</code> quantiles, which help track response time distributions.</li>
</ul>
<p>We&#39;ll apply the summary to an effect that generates random integers, simulating response times.</p>
<pre><code class="language-ts">import { Metric, Random, Effect } from &quot;effect&quot;

// Define the summary for response times
const responseTimeSummary = Metric.summary({
  name: &quot;response_time_summary&quot;, // Name of the summary metric
  maxAge: &quot;1 day&quot;, // Maximum sample age
  maxSize: 100, // Maximum number of samples to retain
  error: 0.03, // Error margin for quantile calculation
  quantiles: [0.1, 0.5, 0.9], // Quantiles to observe (10%, 50%, 90%)
  // Optional
  description: &quot;Measures the distribution of response times&quot;
})

const program = Effect.gen(function* () {
  // Record 100 random response times between 1 and 120 ms
  yield* responseTimeSummary(Random.nextIntBetween(1, 120)).pipe(
    Effect.repeatN(99)
  )

  // Retrieve and log the current state of the summary
  const state = yield* Metric.value(responseTimeSummary)
  console.log(&quot;%o&quot;, state)
})

Effect.runPromise(program)
/*
Example Output:
SummaryState {
  error: 0.03,    // Error margin used for quantile calculation
  quantiles: [
    [ 0.1, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 17 } ],   // 10th percentile: 17 ms
    [ 0.5, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 62 } ],   // 50th percentile (median): 62 ms
    [ 0.9, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 109 } ]   // 90th percentile: 109 ms
  ],
  count: 100,    // Total number of samples recorded
  min: 4,        // Minimum observed value
  max: 119,      // Maximum observed value
  sum: 6058,     // Sum of all recorded values
  ...
}
*/
</code></pre>
<h2>Frequency</h2>
<p>Frequencies are metrics that help count the occurrences of specific values. Think of them as a set of counters, each associated with a unique value. When new values are observed, the frequency metric automatically creates new counters for those values.</p>
<p>Frequencies are particularly useful for tracking how often distinct string values occur. Some example use cases include:</p>
<ul>
<li>Counting the number of invocations for each service in an application, where each service has a logical name.</li>
<li>Monitoring how frequently different types of failures occur.</li>
</ul>
<p><strong>Example</strong> (Tracking Error Occurrences)</p>
<p>In this example, we&#39;ll create a <code>Frequency</code> to observe how often different error codes occur. This can be applied to effects that return a <code>string</code> value:</p>
<pre><code class="language-ts">import { Metric, Random, Effect } from &quot;effect&quot;

// Define a frequency metric to track errors
const errorFrequency = Metric.frequency(&quot;error_frequency&quot;, {
  // Optional
  description: &quot;Counts the occurrences of errors.&quot;
})

const task = Effect.gen(function* () {
  const n = yield* Random.nextIntBetween(1, 10)
  return `Error-${n}`
})

// Program that simulates random errors and tracks their occurrences
const program = Effect.gen(function* () {
  yield* errorFrequency(task).pipe(Effect.repeatN(99))

  // Retrieve and log the current state of the summary
  const state = yield* Metric.value(errorFrequency)
  console.log(&quot;%o&quot;, state)
})

Effect.runPromise(program)
/*
Example Output:
FrequencyState {
  occurrences: Map(9) {
    &#39;Error-7&#39; =&gt; 12,
    &#39;Error-2&#39; =&gt; 12,
    &#39;Error-4&#39; =&gt; 14,
    &#39;Error-1&#39; =&gt; 14,
    &#39;Error-9&#39; =&gt; 8,
    &#39;Error-6&#39; =&gt; 11,
    &#39;Error-5&#39; =&gt; 9,
    &#39;Error-3&#39; =&gt; 14,
    &#39;Error-8&#39; =&gt; 6
  },
  ...
}
*/
</code></pre>
<h2>Tagging Metrics</h2>
<p>Tags are key-value pairs you can add to metrics to provide additional context. They help categorize and filter metrics, making it easier to analyze specific aspects of your application&#39;s performance or behavior.</p>
<p>When creating metrics, you can add tags to them. Tags are key-value pairs that provide additional context, helping in categorizing and filtering metrics. This makes it easier to analyze and monitor specific aspects of your application.</p>
<h3>Tagging a Specific Metric</h3>
<p>You can tag individual metrics using the <code>Metric.tagged</code> function.
This allows you to add specific tags to a single metric, providing detailed context without applying tags globally.</p>
<p><strong>Example</strong> (Tagging an Individual Metric)</p>
<pre><code class="language-ts">import { Metric } from &quot;effect&quot;

// Create a counter metric for request count
// and tag it with &quot;environment: production&quot;
const counter = Metric.counter(&quot;request_count&quot;).pipe(
  Metric.tagged(&quot;environment&quot;, &quot;production&quot;)
)
</code></pre>
<p>Here, the <code>request_count</code> metric is tagged with <code>&quot;environment&quot;: &quot;production&quot;</code>, allowing you to filter or analyze metrics by this tag later.</p>
<h3>Tagging Multiple Metrics</h3>
<p>You can use <code>Effect.tagMetrics</code> to apply tags to all metrics within the same context. This is useful when you want to apply common tags, like the environment (e.g., &quot;production&quot; or &quot;development&quot;), across multiple metrics.</p>
<p><strong>Example</strong> (Tagging Multiple Metrics)</p>
<pre><code class="language-ts">import { Metric, Effect } from &quot;effect&quot;

// Create two separate counters
const counter1 = Metric.counter(&quot;counter1&quot;)
const counter2 = Metric.counter(&quot;counter2&quot;)

// Define a task that simulates some work with a slight delay
const task = Effect.succeed(1).pipe(Effect.delay(&quot;100 millis&quot;))

// Apply the environment tag to both counters in the same context
Effect.gen(function* () {
  yield* counter1(task)
  yield* counter2(task)
}).pipe(Effect.tagMetrics(&quot;environment&quot;, &quot;production&quot;))
</code></pre>
<p>If you only want to apply tags within a specific <a href="/docs/resource-management/scope/">scope</a>, you can use <code>Effect.tagMetricsScoped</code>. This limits the tag application to metrics within that scope, allowing for more precise tagging control.</p>
<hr>
<hr>
<h2>title: Supervisor
description: Effect&#39;s Supervisor manages fiber lifecycles, enabling tracking, monitoring, and controlling fibers&#39; behavior within an application.
sidebar:
  order: 3</h2>
<p>A <code>Supervisor&lt;A&gt;</code> is a utility for managing fibers in Effect, allowing you to track their lifecycle (creation and termination) and producing a value of type <code>A</code> that reflects this supervision. Supervisors are useful when you need insight into or control over the behavior of fibers within your application.</p>
<p>To create a supervisor, you can use the <code>Supervisor.track</code> function. This generates a new supervisor that keeps track of its child fibers, maintaining them in a set. This allows you to observe and monitor their status during execution.</p>
<p>You can supervise an effect by using the <code>Effect.supervised</code> function. This function takes a supervisor as an argument and returns an effect where all child fibers forked within it are supervised by the provided supervisor. This enables you to capture detailed information about these child fibers, such as their status, through the supervisor.</p>
<p><strong>Example</strong> (Monitoring Fiber Count)</p>
<p>In this example, we&#39;ll periodically monitor the number of fibers running in the application using a supervisor. The program calculates a Fibonacci number, spawning multiple fibers in the process, while a separate monitor tracks the fiber count.</p>
<pre><code class="language-ts">import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from &quot;effect&quot;

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced(&quot;500 millis&quot;).pipe(
    Schedule.whileInputEffect((_) =&gt;
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) =&gt; status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy),
    // Fork the monitoring into its own fiber
    Effect.fork
  )

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber)
  const result = yield* Fiber.join(fibFiber)

  console.log(`fibonacci result: ${result}`)
})

// Function to monitor and log the number of active fibers
const monitorFibers = (
  supervisor: Supervisor.Supervisor&lt;Array&lt;Fiber.RuntimeFiber&lt;any, any&gt;&gt;&gt;
): Effect.Effect&lt;void&gt; =&gt;
  Effect.gen(function* () {
    const fibers = yield* supervisor.value // Get the current set of fibers
    console.log(`number of fibers: ${fibers.length}`)
  })

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect&lt;number&gt; =&gt;
  Effect.gen(function* () {
    if (n &lt;= 1) {
      return 1
    }
    yield* Effect.sleep(&quot;500 millis&quot;) // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2))
    const fiber2 = yield* Effect.fork(fib(n - 1))

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1)
    const v2 = yield* Fiber.join(fiber2)

    return v1 + v2 // Combine the results
  })

Effect.runPromise(program)
/*
Output:
number of fibers: 0
number of fibers: 2
number of fibers: 6
number of fibers: 14
number of fibers: 30
number of fibers: 62
number of fibers: 126
number of fibers: 254
number of fibers: 510
number of fibers: 1022
number of fibers: 2034
number of fibers: 3795
number of fibers: 5810
number of fibers: 6474
number of fibers: 4942
number of fibers: 2515
number of fibers: 832
number of fibers: 170
number of fibers: 18
number of fibers: 0
fibonacci result: 10946
*/
</code></pre>
<hr>
<hr>
<h2>title: Tracing in Effect
description: Explore tracing in distributed systems to track request lifecycles across services using spans and traces for debugging and performance optimization.
sidebar:
  label: Tracing
  order: 2</h2>
<p>import {
  Tabs,
  TabItem,
  Steps,
  Aside
} from &quot;@astrojs/starlight/components&quot;</p>
<p>Although logs and metrics are useful to understand the behavior of individual services, they are not enough to provide a complete overview of the lifetime of a request in a distributed system.</p>
<p>In a distributed system, a request can span multiple services and each service can make multiple requests to other services to fulfill the request. In such a scenario, we need to have a way to track the lifetime of a request across multiple services to diagnose what services are the bottlenecks and where the request is spending most of its time.</p>
<h2>Spans</h2>
<p>A <strong>span</strong> represents a single unit of work or operation within a request. It provides a detailed view of what happened during the execution of that specific operation.</p>
<p>Each span typically contains the following information:</p>
<table>
<thead>
<tr>
<th>Span Component</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Name</strong></td>
<td>Describes the specific operation being tracked.</td>
</tr>
<tr>
<td><strong>Timing Data</strong></td>
<td>Timestamps indicating when the operation started and its duration.</td>
</tr>
<tr>
<td><strong>Log Messages</strong></td>
<td>Structured logs capturing important events during the operation.</td>
</tr>
<tr>
<td><strong>Attributes</strong></td>
<td>Metadata providing additional context about the operation.</td>
</tr>
</tbody></table>
<p>Spans are key building blocks in tracing, helping you visualize and understand the flow of requests through various services.</p>
<h2>Traces</h2>
<p>A trace records the paths taken by requests (made by an application or end-user) as they propagate through multi-service architectures, like microservice and serverless applications.</p>
<p>Without tracing, it is challenging to pinpoint the cause of performance problems in a distributed system.</p>
<p>A trace is made of one or more spans. The first span represents the root span. Each root span represents a request from start to finish. The spans underneath the parent provide a more in-depth context of what occurs during a request (or what steps make up a request).</p>
<p>Many Observability back-ends visualize traces as waterfall diagrams that may look something like this:</p>
<p><img src="../_assets/waterfall-trace.svg" alt="Trace Waterfall Diagram" title="An image displaying an application trace visualized as a waterfall diagram"></p>
<p>Waterfall diagrams show the parent-child relationship between a root span and its child spans. When a span encapsulates another span, this also represents a nested relationship.</p>
<h2>Creating Spans</h2>
<p>You can add tracing to an effect by creating a span using the <code>Effect.withSpan</code> API. This helps you track specific operations within the effect.</p>
<p><strong>Example</strong> (Adding a Span to an Effect)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define an effect that delays for 100 milliseconds
const program = Effect.void.pipe(Effect.delay(&quot;100 millis&quot;))

// Instrument the effect with a span for tracing
const instrumented = program.pipe(Effect.withSpan(&quot;myspan&quot;))
</code></pre>
<p>Instrumenting an effect with a span does not change its type. If you start with an <code>Effect&lt;A, E, R&gt;</code>, the result remains an <code>Effect&lt;A, E, R&gt;</code>.</p>
<h2>Printing Spans</h2>
<p>To print spans for debugging or analysis, you&#39;ll need to install the required tracing tools. Here’s how to set them up for your project.</p>
<h3>Installing Dependencies</h3>
<p>Choose your package manager and install the necessary libraries:</p>
   <Tabs syncKey="package-manager">

   <TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh"># Install the main library for integrating OpenTelemetry with Effect
npm install @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
npm install @opentelemetry/sdk-trace-base
npm install @opentelemetry/sdk-trace-node
npm install @opentelemetry/sdk-trace-web
npm install @opentelemetry/sdk-metrics
</code></pre>
   </TabItem>

   <TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh"># Install the main library for integrating OpenTelemetry with Effect
pnpm add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
pnpm add @opentelemetry/sdk-trace-base
pnpm add @opentelemetry/sdk-trace-node
pnpm add @opentelemetry/sdk-trace-web
pnpm add @opentelemetry/sdk-metrics
</code></pre>
   </TabItem>

   <TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh"># Install the main library for integrating OpenTelemetry with Effect
yarn add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
yarn add @opentelemetry/sdk-trace-base
yarn add @opentelemetry/sdk-trace-node
yarn add @opentelemetry/sdk-trace-web
yarn add @opentelemetry/sdk-metrics
</code></pre>
   </TabItem>

   <TabItem label="Bun" icon="bun">

<pre><code class="language-sh"># Install the main library for integrating OpenTelemetry with Effect
bun add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
bun add @opentelemetry/sdk-trace-base
bun add @opentelemetry/sdk-trace-node
bun add @opentelemetry/sdk-trace-web
bun add @opentelemetry/sdk-metrics
</code></pre>
   </TabItem>

   </Tabs>

<Aside type="note" title="Peer Dependency">
  The `@opentelemetry/api` package is a peer dependency of
  `@effect/opentelemetry`. If your package manager does not automatically
  install peer dependencies, you must add it manually.
</Aside>

<h3>Printing a Span to the Console</h3>
<p>Once the dependencies are installed, you can set up span printing using OpenTelemetry. Here&#39;s an example showing how to print a span for an effect.</p>
<p><strong>Example</strong> (Setting Up and Printing a Span)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from &quot;@opentelemetry/sdk-trace-base&quot;

// Define an effect that delays for 100 milliseconds
const program = Effect.void.pipe(Effect.delay(&quot;100 millis&quot;))

// Instrument the effect with a span for tracing
const instrumented = program.pipe(Effect.withSpan(&quot;myspan&quot;))

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(instrumented.pipe(Effect.provide(NodeSdkLive)))
/*
Example Output:
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;673c06608bd815f7a75bf897ef87e186&#39;,
  parentId: undefined,
  traceState: undefined,
  name: &#39;myspan&#39;,
  id: &#39;401b2846170cd17b&#39;,
  kind: 0,
  timestamp: 1733220735529855.5,
  duration: 102079.958,
  attributes: {},
  status: { code: 1 },
  events: [],
  links: []
}
*/
</code></pre>
<h3>Understanding the Span Output</h3>
<p>The output provides detailed information about the span:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>traceId</code></td>
<td>A unique identifier for the entire trace, helping trace requests or operations as they move through an application.</td>
</tr>
<tr>
<td><code>parentId</code></td>
<td>Identifies the parent span of the current span, marked as <code>undefined</code> in the output when there is no parent span, making it a root span.</td>
</tr>
<tr>
<td><code>name</code></td>
<td>Describes the name of the span, indicating the operation being tracked (e.g., &quot;myspan&quot;).</td>
</tr>
<tr>
<td><code>id</code></td>
<td>A unique identifier for the current span, distinguishing it from other spans within a trace.</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>A timestamp representing when the span started, measured in microseconds since the Unix epoch.</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>Specifies the duration of the span, representing the time taken to complete the operation (e.g., <code>2895.769</code> microseconds).</td>
</tr>
<tr>
<td><code>attributes</code></td>
<td>Spans may contain attributes, which are key-value pairs providing additional context or information about the operation. In this output, it&#39;s an empty object, indicating no specific attributes in this span.</td>
</tr>
<tr>
<td><code>status</code></td>
<td>The status field provides information about the span&#39;s status. In this case, it has a code of 1, which typically indicates an OK status (whereas a code of 2 signifies an ERROR status)</td>
</tr>
<tr>
<td><code>events</code></td>
<td>Spans can include events, which are records of specific moments during the span&#39;s lifecycle. In this output, it&#39;s an empty array, suggesting no specific events recorded.</td>
</tr>
<tr>
<td><code>links</code></td>
<td>Links can be used to associate this span with other spans in different traces. In the output, it&#39;s an empty array, indicating no specific links for this span.</td>
</tr>
</tbody></table>
<h3>Span Capturing an Error</h3>
<p>Here&#39;s how a span looks when the effect encounters an error:</p>
<p><strong>Example</strong> (Span for an Effect that Fails)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from &quot;@opentelemetry/sdk-trace-base&quot;

const program = Effect.fail(&quot;Oh no!&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.withSpan(&quot;myspan&quot;)
)

const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runPromiseExit(program.pipe(Effect.provide(NodeSdkLive))).then(
  console.log
)
/*
Example Output:
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;eee9619866179f209b7aae277283e71f&#39;,
  parentId: undefined,
  traceState: undefined,
  name: &#39;myspan&#39;,
  id: &#39;3a5725c91884c9e1&#39;,
  kind: 0,
  timestamp: 1733220830575626,
  duration: 106578.042,
  attributes: {
    &#39;code.stacktrace&#39;: &#39;at &lt;anonymous&gt; (/Users/giuliocanti/Documents/GitHub/website/content/dev/index.ts:10:10)&#39;
  },
  status: { code: 2, message: &#39;Oh no!&#39; },
  events: [
    {
      name: &#39;exception&#39;,
      attributes: {
        &#39;exception.type&#39;: &#39;Error&#39;,
        &#39;exception.message&#39;: &#39;Oh no!&#39;,
        &#39;exception.stacktrace&#39;: &#39;Error: Oh no!&#39;
      },
      time: [ 1733220830, 682204083 ],
      droppedAttributesCount: 0
    }
  ],
  links: []
}
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Oh no!&#39; }
}
*/
</code></pre>
<p>In this example, the span&#39;s status code is <code>2</code>, indicating an error. The message in the status provides more details about the failure.</p>
<h2>Adding Annotations</h2>
<p>You can provide extra information to a span by utilizing the <code>Effect.annotateCurrentSpan</code> function.
This function allows you to attach key-value pairs, offering more context about the execution of the span.</p>
<p><strong>Example</strong> (Annotating a Span)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from &quot;@opentelemetry/sdk-trace-base&quot;

const program = Effect.void.pipe(
  Effect.delay(&quot;100 millis&quot;),
  // Annotate the span with a key-value pair
  Effect.tap(() =&gt; Effect.annotateCurrentSpan(&quot;key&quot;, &quot;value&quot;)),
  // Wrap the effect in a span named &#39;myspan&#39;
  Effect.withSpan(&quot;myspan&quot;)
)

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(program.pipe(Effect.provide(NodeSdkLive)))
/*
Example Output:
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;c8120e01c0f1ea83ccc1d388e5cdebd3&#39;,
  parentId: undefined,
  traceState: undefined,
  name: &#39;myspan&#39;,
  id: &#39;81c430ba4979f1db&#39;,
  kind: 0,
  timestamp: 1733220874356084,
  duration: 102821.417,
  attributes: { key: &#39;value&#39; },
  status: { code: 1 },
  events: [],
  links: []
}
*/
</code></pre>
<h2>Logs as events</h2>
<p>In the context of tracing, logs are converted into &quot;Span Events.&quot; These events offer structured insights into your application&#39;s activities and provide a timeline of when specific operations occurred.</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from &quot;@opentelemetry/sdk-trace-base&quot;

// Define a program that logs a message and delays for 100 milliseconds
const program = Effect.log(&quot;Hello&quot;).pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.withSpan(&quot;myspan&quot;)
)

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(program.pipe(Effect.provide(NodeSdkLive)))
/*
Example Output:
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;b0f4f012b5b13c0a040f7002a1d7b020&#39;,
  parentId: undefined,
  traceState: undefined,
  name: &#39;myspan&#39;,
  id: &#39;b9ba8472002715a8&#39;,
  kind: 0,
  timestamp: 1733220905504162.2,
  duration: 103790,
  attributes: {},
  status: { code: 1 },
  events: [
    {
      name: &#39;Hello&#39;,
      attributes: { &#39;effect.fiberId&#39;: &#39;#0&#39;, &#39;effect.logLevel&#39;: &#39;INFO&#39; }, // Log attributes
      time: [ 1733220905, 607761042 ], // Event timestamp
      droppedAttributesCount: 0
    }
  ],
  links: []
}
*/
</code></pre>
<p>Each span can include events, which capture specific moments during the execution of a span. In this example, a log message <code>&quot;Hello&quot;</code> is recorded as an event within the span. Key details of the event include:</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>The name of the event, which corresponds to the logged message (e.g., <code>&#39;Hello&#39;</code>).</td>
</tr>
<tr>
<td><code>attributes</code></td>
<td>Key-value pairs that provide additional context about the event, such as <code>fiberId</code> and log level.</td>
</tr>
<tr>
<td><code>time</code></td>
<td>The timestamp of when the event occurred, shown in a high-precision format.</td>
</tr>
<tr>
<td><code>droppedAttributesCount</code></td>
<td>Indicates how many attributes were discarded, if any. In this case, no attributes were dropped.</td>
</tr>
</tbody></table>
<h2>Nesting Spans</h2>
<p>Spans can be nested to represent a hierarchy of operations. This allows you to track how different parts of your application relate to one another during execution. The following example demonstrates how to create and manage nested spans.</p>
<p><strong>Example</strong> (Nesting Spans in a Trace)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from &quot;@opentelemetry/sdk-trace-base&quot;

const child = Effect.void.pipe(
  Effect.delay(&quot;100 millis&quot;),
  Effect.withSpan(&quot;child&quot;)
)

const parent = Effect.gen(function* () {
  yield* Effect.sleep(&quot;20 millis&quot;)
  yield* child
  yield* Effect.sleep(&quot;10 millis&quot;)
}).pipe(Effect.withSpan(&quot;parent&quot;))

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(parent.pipe(Effect.provide(NodeSdkLive)))
/*
Example Output:
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;a9cd69ad70698a0c7b7b774597c77d39&#39;,
  parentId: &#39;a09e5c3fdfdbbc1d&#39;, // This indicates the span is a child of &#39;parent&#39;
  traceState: undefined,
  name: &#39;child&#39;,
  id: &#39;210d2f9b648389a4&#39;, // Unique ID for the child span
  kind: 0,
  timestamp: 1733220970590126.2,
  duration: 101579.875,
  attributes: {},
  status: { code: 1 },
  events: [],
  links: []
}
{
  resource: {
    attributes: {
      &#39;service.name&#39;: &#39;example&#39;,
      &#39;telemetry.sdk.language&#39;: &#39;nodejs&#39;,
      &#39;telemetry.sdk.name&#39;: &#39;@effect/opentelemetry&#39;,
      &#39;telemetry.sdk.version&#39;: &#39;1.28.0&#39;
    }
  },
  instrumentationScope: { name: &#39;example&#39;, version: undefined, schemaUrl: undefined },
  traceId: &#39;a9cd69ad70698a0c7b7b774597c77d39&#39;,
  parentId: undefined, // Indicates this is the root span
  traceState: undefined,
  name: &#39;parent&#39;,
  id: &#39;a09e5c3fdfdbbc1d&#39;, // Unique ID for the parent span
  kind: 0,
  timestamp: 1733220970569015.2,
  duration: 132612.208,
  attributes: {},
  status: { code: 1 },
  events: [],
  links: []
}
*/
</code></pre>
<p>The parent-child relationship is evident in the span output, where the <code>parentId</code> of the <code>child</code> span matches the <code>id</code> of the <code>parent</code> span. This structure helps track how operations are related within a single trace.</p>
<h2>Tutorial: Visualizing Traces with Docker, Prometheus, Grafana, and Tempo</h2>
<p>In this tutorial, we&#39;ll guide you through simulating and visualizing traces using a sample instrumented Node.js application. We will use Docker, Prometheus, Grafana, and Tempo to create, collect, and visualize traces.</p>
<h3>Tools Explained</h3>
<p>Let&#39;s understand the tools we&#39;ll be using in simple terms:</p>
<ul>
<li><p><strong>Docker</strong>: Docker allows us to run applications in containers. Think of a container as a lightweight and isolated environment where your application can run consistently, regardless of the host system. It&#39;s a bit like a virtual machine but more efficient.</p>
</li>
<li><p><strong>Prometheus</strong>: Prometheus is a monitoring and alerting toolkit. It collects metrics and data about your applications and stores them for further analysis. This helps in identifying performance issues and understanding the behavior of your applications.</p>
</li>
<li><p><strong>Grafana</strong>: Grafana is a visualization and analytics platform. It helps in creating beautiful and interactive dashboards to visualize your application&#39;s data. You can use it to graphically represent metrics collected by Prometheus.</p>
</li>
<li><p><strong>Tempo</strong>: Tempo is a distributed tracing system that allows you to trace the journey of a request as it flows through your application. It provides insights into how requests are processed and helps in debugging and optimizing your applications.</p>
</li>
</ul>
<h3>Getting Docker</h3>
<p>To get Docker, follow these steps:</p>
<ol>
<li><p>Visit the Docker website at <a href="https://www.docker.com/">https://www.docker.com/</a>.</p>
</li>
<li><p>Download Docker Desktop for your operating system (Windows or macOS) and install it.</p>
</li>
<li><p>After installation, open Docker Desktop, and it will run in the background.</p>
</li>
</ol>
<h3>Simulating Traces</h3>
<p>Now, let&#39;s simulate traces using a sample Node.js application. We&#39;ll provide you with the code and guide you on setting up the necessary components.</p>
<Steps>

<ol>
<li><p><strong>Download Docker Files</strong>. Download the required Docker files: <a href="/tracing/docker.zip">docker.zip</a></p>
</li>
<li><p><strong>Set Up docker</strong>. Unzip the downloaded file, navigate to the <code>/docker/local</code> directory in your terminal or command prompt and run the following command to start the necessary services:</p>
<pre><code class="language-sh">docker-compose up
</code></pre>
</li>
<li><p><strong>Simulate Traces</strong>. Run the following example code in your Node.js environment.
This code simulates a set of tasks and generates traces.</p>
<p>Before proceeding, you&#39;ll need to install additional libraries in addition to the latest version of <code>effect</code>. Here are the required libraries:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install @effect/opentelemetry
npm install @opentelemetry/exporter-trace-otlp-http
npm install @opentelemetry/sdk-trace-base
npm install @opentelemetry/sdk-trace-web
npm install @opentelemetry/sdk-trace-node
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add @effect/opentelemetry
pnpm add @opentelemetry/exporter-trace-otlp-http
pnpm add @opentelemetry/sdk-trace-base
# For NodeJS applications
pnpm add @opentelemetry/sdk-trace-node
# For browser applications
pnpm add @opentelemetry/sdk-trace-web
# If you also need to export metrics
pnpm add @opentelemetry/sdk-metrics
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn add @effect/opentelemetry
yarn add @opentelemetry/exporter-trace-otlp-http
yarn add @opentelemetry/sdk-trace-base
# For NodeJS applications
yarn add @opentelemetry/sdk-trace-node
# For browser applications
yarn add @opentelemetry/sdk-trace-web
# If you also need to export metrics
yarn add @opentelemetry/sdk-metrics
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun add @effect/opentelemetry
bun add @opentelemetry/exporter-trace-otlp-http
bun add @opentelemetry/sdk-trace-base
# For NodeJS applications
bun add @opentelemetry/sdk-trace-node
# For browser applications
bun add @opentelemetry/sdk-trace-web
# If you also need to export metrics
bun add @opentelemetry/sdk-metrics
</code></pre>
</TabItem>

</Tabs>

<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import { BatchSpanProcessor } from &quot;@opentelemetry/sdk-trace-base&quot;
import { OTLPTraceExporter } from &quot;@opentelemetry/exporter-trace-otlp-http&quot;

// Function to simulate a task with possible subtasks
const task = (
  name: string,
  delay: number,
  children: ReadonlyArray&lt;Effect.Effect&lt;void&gt;&gt; = []
) =&gt;
  Effect.gen(function* () {
    yield* Effect.log(name)
    yield* Effect.sleep(`${delay} millis`)
    for (const child of children) {
      yield* child
    }
    yield* Effect.sleep(`${delay} millis`)
  }).pipe(Effect.withSpan(name))

const poll = task(&quot;/poll&quot;, 1)

// Create a program with tasks and subtasks
const program = task(&quot;client&quot;, 2, [
  task(&quot;/api&quot;, 3, [
    task(&quot;/authN&quot;, 4, [task(&quot;/authZ&quot;, 5)]),
    task(&quot;/payment Gateway&quot;, 6, [
      task(&quot;DB&quot;, 7),
      task(&quot;Ext. Merchant&quot;, 8)
    ]),
    task(&quot;/dispatch&quot;, 9, [
      task(&quot;/dispatch/search&quot;, 10),
      Effect.all([poll, poll, poll], { concurrency: &quot;inherit&quot; }),
      task(&quot;/pollDriver/{id}&quot;, 11)
    ])
  ])
])

const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new BatchSpanProcessor(new OTLPTraceExporter())
}))

Effect.runPromise(
  program.pipe(
    Effect.provide(NodeSdkLive),
    Effect.catchAllCause(Effect.logError)
  )
)
/*
Output:
timestamp=... level=INFO fiber=#0 message=client
timestamp=... level=INFO fiber=#0 message=/api
timestamp=... level=INFO fiber=#0 message=/authN
timestamp=... level=INFO fiber=#0 message=/authZ
timestamp=... level=INFO fiber=#0 message=&quot;/payment Gateway&quot;
timestamp=... level=INFO fiber=#0 message=DB
timestamp=... level=INFO fiber=#0 message=&quot;Ext. Merchant&quot;
timestamp=... level=INFO fiber=#0 message=/dispatch
timestamp=... level=INFO fiber=#0 message=/dispatch/search
timestamp=... level=INFO fiber=#3 message=/poll
timestamp=... level=INFO fiber=#4 message=/poll
timestamp=... level=INFO fiber=#5 message=/poll
timestamp=... level=INFO fiber=#0 message=/pollDriver/{id}
*/
</code></pre>
</li>
<li><p><strong>Visualize Traces</strong>. Now, open your web browser and go to <code>http://localhost:3000/explore</code>. You will see a generated <code>Trace ID</code> on the web page. Click on it to see the details of the trace.</p>
<p><img src="../_assets/trace.png" alt="Traces in Grafana Tempo" title="An image displaying an application trace visualized as a waterfall diagram in Grafana Tempo"></p>
</li>
</ol>
</Steps>

<h2>Integrations</h2>
<h3>Sentry</h3>
<p>To send span data directly to Sentry for analysis, replace the default span processor with Sentry&#39;s implementation. This allows you to use Sentry as a backend for tracing and debugging.</p>
<p><strong>Example</strong> (Configuring Sentry for Tracing)</p>
<pre><code class="language-ts">import { NodeSdk } from &quot;@effect/opentelemetry&quot;
import { SentrySpanProcessor } from &quot;@sentry/opentelemetry&quot;

const NodeSdkLive = NodeSdk.layer(() =&gt; ({
  resource: { serviceName: &quot;example&quot; },
  spanProcessor: new SentrySpanProcessor()
}))
</code></pre>
<hr>
<hr>
<h2>title: Command
description: Learn how to create, run, and manage commands with custom arguments, environment variables, and input/output handling in Effect.
sidebar:
  order: 1</h2>
<p>The <code>@effect/platform/Command</code> module provides a way to create and run commands with the specified process name and an optional list of arguments.</p>
<h2>Creating Commands</h2>
<p>The <code>Command.make</code> function generates a command object, which includes details such as the process name, arguments, and environment.</p>
<p><strong>Example</strong> (Defining a Command for Directory Listing)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;

const command = Command.make(&quot;ls&quot;, &quot;-al&quot;)
console.log(command)
/*
{
  _id: &#39;@effect/platform/Command&#39;,
  _tag: &#39;StandardCommand&#39;,
  command: &#39;ls&#39;,
  args: [ &#39;-al&#39; ],
  env: {},
  cwd: { _id: &#39;Option&#39;, _tag: &#39;None&#39; },
  shell: false,
  gid: { _id: &#39;Option&#39;, _tag: &#39;None&#39; },
  uid: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
}
*/
</code></pre>
<p>This command object does not execute until run by an executor.</p>
<h2>Running Commands</h2>
<p>You need a <code>CommandExecutor</code> to run the command, which can capture output in various formats such as strings, lines, or streams.</p>
<p><strong>Example</strong> (Running a Command and Printing Output)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const command = Command.make(&quot;ls&quot;, &quot;-al&quot;)

// The program depends on a CommandExecutor
const program = Effect.gen(function* () {
  // Runs the command returning the output as a string
  const output = yield* Command.string(command)
  console.log(output)
})

// Provide the necessary CommandExecutor
NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
</code></pre>
<h3>Output Formats</h3>
<p>You can choose different methods to handle command output:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>string</code></td>
<td>Runs the command returning the output as a string (with the specified encoding)</td>
</tr>
<tr>
<td><code>lines</code></td>
<td>Runs the command returning the output as an array of lines (with the specified encoding)</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>Runs the command returning the output as a stream of <code>Uint8Array</code> chunks</td>
</tr>
<tr>
<td><code>streamLines</code></td>
<td>Runs the command returning the output as a stream of lines (with the specified encoding)</td>
</tr>
</tbody></table>
<h3>exitCode</h3>
<p>If you only need the exit code of a command, use <code>Command.exitCode</code>.</p>
<p><strong>Example</strong> (Getting the Exit Code)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const command = Command.make(&quot;ls&quot;, &quot;-al&quot;)

const program = Effect.gen(function* () {
  const exitCode = yield* Command.exitCode(command)
  console.log(exitCode)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
// Output: 0
</code></pre>
<h2>Custom Environment Variables</h2>
<p>You can customize environment variables in a command by using <code>Command.env</code>. This is useful when you need specific variables for the command&#39;s execution.</p>
<p><strong>Example</strong> (Setting Environment Variables)</p>
<p>In this example, the command runs in a shell to ensure environment variables are correctly processed.</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const command = Command.make(&quot;echo&quot;, &quot;-n&quot;, &quot;$MY_CUSTOM_VAR&quot;).pipe(
  Command.env({
    MY_CUSTOM_VAR: &quot;Hello, this is a custom environment variable!&quot;
  }),
  // Use shell to interpret variables correctly
  // on Windows and Unix-like systems
  Command.runInShell(true)
)

const program = Effect.gen(function* () {
  const output = yield* Command.string(command)
  console.log(output)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
// Output: Hello, this is a custom environment variable!
</code></pre>
<h2>Feeding Input to a Command</h2>
<p>You can send input directly to a command&#39;s standard input using the <code>Command.feed</code> function.</p>
<p><strong>Example</strong> (Sending Input to a Command&#39;s Standard Input)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const command = Command.make(&quot;cat&quot;).pipe(Command.feed(&quot;Hello&quot;))

const program = Effect.gen(function* () {
  console.log(yield* Command.string(command))
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
// Output: Hello
</code></pre>
<h2>Fetching Process Details</h2>
<p>You can access details about a running process, such as <code>exitCode</code>, <code>stdout</code>, and <code>stderr</code>.</p>
<p><strong>Example</strong> (Accessing Exit Code and Streams from a Running Process)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect, Stream, String, pipe } from &quot;effect&quot;

// Helper function to collect stream output as a string
const runString = &lt;E, R&gt;(
  stream: Stream.Stream&lt;Uint8Array, E, R&gt;
): Effect.Effect&lt;string, E, R&gt; =&gt;
  stream.pipe(
    Stream.decodeText(),
    Stream.runFold(String.empty, String.concat)
  )

const program = Effect.gen(function* () {
  const command = Command.make(&quot;ls&quot;)

  const [exitCode, stdout, stderr] = yield* pipe(
    // Start running the command and return a handle to the running process
    Command.start(command),
    Effect.flatMap((process) =&gt;
      Effect.all(
        [
          // Waits for the process to exit and returns
          // the ExitCode of the command that was run
          process.exitCode,
          // The standard output stream of the process
          runString(process.stdout),
          // The standard error stream of the process
          runString(process.stderr)
        ],
        { concurrency: 3 }
      )
    )
  )
  console.log({ exitCode, stdout, stderr })
})

NodeRuntime.runMain(
  Effect.scoped(program).pipe(Effect.provide(NodeContext.layer))
)
</code></pre>
<h2>Streaming stdout to process.stdout</h2>
<p>To stream a command&#39;s <code>stdout</code> directly to <code>process.stdout</code>, you can use the following approach:</p>
<p><strong>Example</strong> (Streaming Command Output Directly to Standard Output)</p>
<pre><code class="language-ts">import { Command } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

// Create a command to run `cat` on a file and inherit stdout
const program = Command.make(&quot;cat&quot;, &quot;./some-file.txt&quot;).pipe(
  Command.stdout(&quot;inherit&quot;), // Stream stdout to process.stdout
  Command.exitCode // Get the exit code
)

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
</code></pre>
<hr>
<hr>
<h2>title: FileSystem
description: Explore file system operations for reading, writing, and managing files and directories in Effect.
sidebar:
  order: 2</h2>
<p>The <code>@effect/platform/FileSystem</code> module provides a set of operations for reading and writing from/to the file system.</p>
<h2>Basic Usage</h2>
<p>The module provides a single <code>FileSystem</code> <a href="/docs/requirements-management/services/">tag</a>, which acts as the gateway for interacting with the filesystem.</p>
<p><strong>Example</strong> (Accessing File System Operations)</p>
<pre><code class="language-ts">import { FileSystem } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  // Use `fs` to perform file system operations
})
</code></pre>
<p>The <code>FileSystem</code> interface includes the following operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>access</strong></td>
<td>Check if a file can be accessed. You can optionally specify the level of access to check for.</td>
</tr>
<tr>
<td><strong>copy</strong></td>
<td>Copy a file or directory from <code>fromPath</code> to <code>toPath</code>. Equivalent to <code>cp -r</code>.</td>
</tr>
<tr>
<td><strong>copyFile</strong></td>
<td>Copy a file from <code>fromPath</code> to <code>toPath</code>.</td>
</tr>
<tr>
<td><strong>chmod</strong></td>
<td>Change the permissions of a file.</td>
</tr>
<tr>
<td><strong>chown</strong></td>
<td>Change the owner and group of a file.</td>
</tr>
<tr>
<td><strong>exists</strong></td>
<td>Check if a path exists.</td>
</tr>
<tr>
<td><strong>link</strong></td>
<td>Create a hard link from <code>fromPath</code> to <code>toPath</code>.</td>
</tr>
<tr>
<td><strong>makeDirectory</strong></td>
<td>Create a directory at <code>path</code>. You can optionally specify the mode and whether to recursively create nested directories.</td>
</tr>
<tr>
<td><strong>makeTempDirectory</strong></td>
<td>Create a temporary directory. By default, the directory will be created inside the system&#39;s default temporary directory.</td>
</tr>
<tr>
<td><strong>makeTempDirectoryScoped</strong></td>
<td>Create a temporary directory inside a scope. Functionally equivalent to <code>makeTempDirectory</code>, but the directory will be automatically deleted when the scope is closed.</td>
</tr>
<tr>
<td><strong>makeTempFile</strong></td>
<td>Create a temporary file. The directory creation is functionally equivalent to <code>makeTempDirectory</code>. The file name will be a randomly generated string.</td>
</tr>
<tr>
<td><strong>makeTempFileScoped</strong></td>
<td>Create a temporary file inside a scope. Functionally equivalent to <code>makeTempFile</code>, but the file will be automatically deleted when the scope is closed.</td>
</tr>
<tr>
<td><strong>open</strong></td>
<td>Open a file at <code>path</code> with the specified <code>options</code>. The file handle will be automatically closed when the scope is closed.</td>
</tr>
<tr>
<td><strong>readDirectory</strong></td>
<td>List the contents of a directory. You can recursively list the contents of nested directories by setting the <code>recursive</code> option.</td>
</tr>
<tr>
<td><strong>readFile</strong></td>
<td>Read the contents of a file.</td>
</tr>
<tr>
<td><strong>readFileString</strong></td>
<td>Read the contents of a file as a string.</td>
</tr>
<tr>
<td><strong>readLink</strong></td>
<td>Read the destination of a symbolic link.</td>
</tr>
<tr>
<td><strong>realPath</strong></td>
<td>Resolve a path to its canonicalized absolute pathname.</td>
</tr>
<tr>
<td><strong>remove</strong></td>
<td>Remove a file or directory. By setting the <code>recursive</code> option to <code>true</code>, you can recursively remove nested directories.</td>
</tr>
<tr>
<td><strong>rename</strong></td>
<td>Rename a file or directory.</td>
</tr>
<tr>
<td><strong>sink</strong></td>
<td>Create a writable <code>Sink</code> for the specified <code>path</code>.</td>
</tr>
<tr>
<td><strong>stat</strong></td>
<td>Get information about a file at <code>path</code>.</td>
</tr>
<tr>
<td><strong>stream</strong></td>
<td>Create a readable <code>Stream</code> for the specified <code>path</code>.</td>
</tr>
<tr>
<td><strong>symlink</strong></td>
<td>Create a symbolic link from <code>fromPath</code> to <code>toPath</code>.</td>
</tr>
<tr>
<td><strong>truncate</strong></td>
<td>Truncate a file to a specified length. If the <code>length</code> is not specified, the file will be truncated to length <code>0</code>.</td>
</tr>
<tr>
<td><strong>utimes</strong></td>
<td>Change the file system timestamps of the file at <code>path</code>.</td>
</tr>
<tr>
<td><strong>watch</strong></td>
<td>Watch a directory or file for changes.</td>
</tr>
<tr>
<td><strong>writeFile</strong></td>
<td>Write data to a file at <code>path</code>.</td>
</tr>
<tr>
<td><strong>writeFileString</strong></td>
<td>Write a string to a file at <code>path</code>.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Reading a File as a String)</p>
<pre><code class="language-ts">import { FileSystem } from &quot;@effect/platform&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  // Reading the content of the same file where this code is written
  const content = yield* fs.readFileString(&quot;./index.ts&quot;, &quot;utf8&quot;)
  console.log(content)
})

// Provide the necessary context and run the program
NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
</code></pre>
<hr>
<hr>
<h2>title: Introduction to Effect Platform
description: Build cross-platform applications with unified abstractions for Node.js, Deno, Bun, and browsers using @effect/platform.
sidebar:
  label: Introduction
  order: 0</h2>
<p>import {
  Aside,
  Tabs,
  TabItem,
  Badge
} from &quot;@astrojs/starlight/components&quot;</p>
<p><code>@effect/platform</code> is a library for building platform-independent abstractions in environments such as Node.js, Deno, Bun, and browsers.</p>
<p>With <code>@effect/platform</code>, you can integrate abstract services like <a href="/docs/platform/file-system/">FileSystem</a> or <a href="/docs/platform/terminal/">Terminal</a> into your program.
When assembling your final application, you can provide specific <a href="/docs/requirements-management/layers/">layers</a> for the target platform using the corresponding packages:</p>
<ul>
<li><code>@effect/platform-node</code> for Node.js or Deno</li>
<li><code>@effect/platform-bun</code> for Bun</li>
<li><code>@effect/platform-browser</code> for browsers</li>
</ul>
<h3>Stable Modules</h3>
<p>The following modules are stable and their documentation is available on this website:</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Description</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td><a href="/docs/platform/command/">Command</a></td>
<td>Provides a way to interact with the command line.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
<tr>
<td><a href="/docs/platform/file-system/">FileSystem</a></td>
<td>A module for file system operations.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
<tr>
<td><a href="/docs/platform/key-value-store/">KeyValueStore</a></td>
<td>Manages key-value pairs for data storage.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
<tr>
<td><a href="/docs/platform/path/">Path</a></td>
<td>Utilities for working with file paths.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
<tr>
<td><a href="/docs/platform/platformlogger/">PlatformLogger</a></td>
<td>Log messages to a file using the FileSystem APIs.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
<tr>
<td><a href="/docs/platform/terminal/">Terminal</a></td>
<td>Tools for terminal interaction.</td>
<td><Badge text="Stable" variant="success" /></td>
</tr>
</tbody></table>
<h3>Unstable Modules</h3>
<p>Some modules in <code>@effect/platform</code> are still in development or marked as experimental.
These features are subject to change.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Description</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/Effect-TS/effect/blob/main/packages/platform/README.md#http-api">Http API</a></td>
<td>Provide a declarative way to define HTTP APIs.</td>
<td><Badge text="Unstable" variant="caution" /></td>
</tr>
<tr>
<td><a href="https://github.com/Effect-TS/effect/blob/main/packages/platform/README.md#http-client">Http Client</a></td>
<td>A client for making HTTP requests.</td>
<td><Badge text="Unstable" variant="caution" /></td>
</tr>
<tr>
<td><a href="https://github.com/Effect-TS/effect/blob/main/packages/platform/README.md#http-server">Http Server</a></td>
<td>A server for handling HTTP requests.</td>
<td><Badge text="Unstable" variant="caution" /></td>
</tr>
<tr>
<td><a href="https://effect-ts.github.io/effect/platform/Socket.ts.html">Socket</a></td>
<td>A module for socket-based communication.</td>
<td><Badge text="Unstable" variant="caution" /></td>
</tr>
<tr>
<td><a href="https://effect-ts.github.io/effect/platform/Worker.ts.html">Worker</a></td>
<td>A module for running tasks in separate workers.</td>
<td><Badge text="Unstable" variant="caution" /></td>
</tr>
</tbody></table>
<p>For the most up-to-date documentation and details, please refer to the official <a href="https://github.com/Effect-TS/effect/blob/main/packages/platform/README.md">README</a> of the package.</p>
<h2>Installation</h2>
<p>To install the <strong>beta</strong> version:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install @effect/platform
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add @effect/platform
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="yarn">

<pre><code class="language-sh">yarn add @effect/platform
</code></pre>
</TabItem>

<TabItem label="Bun" icon="bun">

<pre><code class="language-sh">bun add @effect/platform
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno add npm:@effect/platform
</code></pre>
</TabItem>

</Tabs>

<h2>Getting Started with Cross-Platform Programming</h2>
<p>Here&#39;s a basic example using the <code>Path</code> module to create a file path, which can run across different environments:</p>
<p><strong>Example</strong> (Cross-Platform Path Handling)</p>
<pre><code class="language-ts">import { Path } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  // Access the Path service
  const path = yield* Path.Path

  // Join parts of a path to create a complete file path
  const mypath = path.join(&quot;tmp&quot;, &quot;file.txt&quot;)

  console.log(mypath)
})
</code></pre>
<h3>Running the Program in Node.js or Deno</h3>
<p>First, install the Node.js-specific package:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npm install @effect/platform-node
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm add @effect/platform-node
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="yarn">

<pre><code class="language-sh">yarn add @effect/platform-node
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno add npm:@effect/platform-node
</code></pre>
</TabItem>

</Tabs>

<p>Update the program to load the Node.js-specific context:</p>
<p><strong>Example</strong> (Providing Node.js Context)</p>
<pre><code class="language-ts">import { Path } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;

const program = Effect.gen(function* () {
  // Access the Path service
  const path = yield* Path.Path

  // Join parts of a path to create a complete file path
  const mypath = path.join(&quot;tmp&quot;, &quot;file.txt&quot;)

  console.log(mypath)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
</code></pre>
<p>Finally, run the program in Node.js using <code>tsx</code>, or directly in Deno:</p>
<Tabs syncKey="package-manager">

<TabItem label="npm" icon="seti:npm">

<pre><code class="language-sh">npx tsx index.ts
# Output: tmp/file.txt
</code></pre>
</TabItem>

<TabItem label="pnpm" icon="pnpm">

<pre><code class="language-sh">pnpm dlx tsx index.ts
# Output: tmp/file.txt
</code></pre>
</TabItem>

<TabItem label="Yarn" icon="seti:yarn">

<pre><code class="language-sh">yarn dlx tsx index.ts
# Output: tmp/file.txt
</code></pre>
</TabItem>

<TabItem label="Deno" icon="deno">

<pre><code class="language-sh">deno run index.ts
# Output: tmp/file.txt

# or

deno run -RE index.ts
# Output: tmp/file.txt
# (granting required Read and Environment permissions without being prompted)
</code></pre>
</TabItem>

</Tabs>

<h3>Running the Program in Bun</h3>
<p>To run the same program in Bun, first install the Bun-specific package:</p>
<pre><code class="language-sh">bun add @effect/platform-bun
</code></pre>
<p>Update the program to use the Bun-specific context:</p>
<p><strong>Example</strong> (Providing Bun Context)</p>
<pre><code class="language-ts">import { Path } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;
import { BunContext, BunRuntime } from &quot;@effect/platform-bun&quot;

const program = Effect.gen(function* () {
  // Access the Path service
  const path = yield* Path.Path

  // Join parts of a path to create a complete file path
  const mypath = path.join(&quot;tmp&quot;, &quot;file.txt&quot;)

  console.log(mypath)
})

BunRuntime.runMain(program.pipe(Effect.provide(BunContext.layer)))
</code></pre>
<p>Run the program in Bun:</p>
<pre><code class="language-sh">bun index.ts
tmp/file.txt
</code></pre>
<hr>
<hr>
<h2>title: KeyValueStore
description: Manage key-value pairs with asynchronous, consistent storage, supporting in-memory, file system, and schema-based implementations.
sidebar:
  order: 3</h2>
<p>The <code>@effect/platform/KeyValueStore</code> module provides a robust and effectful interface for managing key-value pairs.
It supports asynchronous operations, ensuring data integrity and consistency, and includes built-in implementations for in-memory, file system-based, and schema-validated stores.</p>
<h2>Basic Usage</h2>
<p>The module provides a single <code>KeyValueStore</code> <a href="/docs/requirements-management/services/">tag</a>, which acts as the gateway for interacting with the store.</p>
<p><strong>Example</strong> (Accessing the KeyValueStore Service)</p>
<pre><code class="language-ts">import { KeyValueStore } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const kv = yield* KeyValueStore.KeyValueStore

  // Use `kv` to perform operations on the store
})
</code></pre>
<p>The <code>KeyValueStore</code> interface includes the following operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>get</strong></td>
<td>Returns the value as <code>string</code> of the specified key if it exists.</td>
</tr>
<tr>
<td><strong>getUint8Array</strong></td>
<td>Returns the value as <code>Uint8Array</code> of the specified key if it exists.</td>
</tr>
<tr>
<td><strong>set</strong></td>
<td>Sets the value of the specified key.</td>
</tr>
<tr>
<td><strong>remove</strong></td>
<td>Removes the specified key.</td>
</tr>
<tr>
<td><strong>clear</strong></td>
<td>Removes all entries.</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>Returns the number of entries.</td>
</tr>
<tr>
<td><strong>modify</strong></td>
<td>Updates the value of the specified key if it exists.</td>
</tr>
<tr>
<td><strong>modifyUint8Array</strong></td>
<td>Updates the value of the specified key if it exists.</td>
</tr>
<tr>
<td><strong>has</strong></td>
<td>Check if a key exists.</td>
</tr>
<tr>
<td><strong>isEmpty</strong></td>
<td>Check if the store is empty.</td>
</tr>
<tr>
<td><strong>forSchema</strong></td>
<td>Create a <a href="#schemastore">SchemaStore</a> for the specified schema.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Working with Key-Value Pairs)</p>
<pre><code class="language-ts">import {
  KeyValueStore,
  layerMemory
} from &quot;@effect/platform/KeyValueStore&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const kv = yield* KeyValueStore

  // Initially, the store is empty
  console.log(yield* kv.size)

  // Set a key-value pair
  yield* kv.set(&quot;key&quot;, &quot;value&quot;)
  console.log(yield* kv.size)

  // Retrieve the value for the specified key
  const value = yield* kv.get(&quot;key&quot;)
  console.log(value)

  // Remove the key-value pair
  yield* kv.remove(&quot;key&quot;)
  console.log(yield* kv.size)
})

// Provide an in-memory KeyValueStore implementation
Effect.runPromise(program.pipe(Effect.provide(layerMemory)))
/*
Output:
0
1
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;value&#39; }
0
*/
</code></pre>
<h2>Built-in Implementations</h2>
<p>The module provides several built-in implementations of the <code>KeyValueStore</code> interface, available as <a href="/docs/requirements-management/layers/">layers</a>, to suit different needs:</p>
<table>
<thead>
<tr>
<th>Implementation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>In-Memory Store</strong></td>
<td><code>layerMemory</code> provides a simple, in-memory key-value store, ideal for lightweight or testing scenarios.</td>
</tr>
<tr>
<td><strong>File System Store</strong></td>
<td><code>layerFileSystem</code> offers a file-based store for persistent storage needs.</td>
</tr>
<tr>
<td><strong>Schema Store</strong></td>
<td><code>layerSchema</code> enables schema-based validation for stored values, ensuring data integrity and type safety.</td>
</tr>
</tbody></table>
<h2>SchemaStore</h2>
<p>The <code>SchemaStore</code> interface allows you to validate and parse values according to a defined <a href="/docs/schema/introduction/">schema</a>.
This ensures that all data stored in the key-value store adheres to the specified structure, enhancing data integrity and type safety.</p>
<p><strong>Example</strong> (Using Schema Validation in KeyValueStore)</p>
<pre><code class="language-ts">import {
  KeyValueStore,
  layerMemory
} from &quot;@effect/platform/KeyValueStore&quot;
import { Effect, Schema } from &quot;effect&quot;

// Define a schema for the values
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const program = Effect.gen(function* () {
  // Create a SchemaStore based on the Person schema
  const kv = (yield* KeyValueStore).forSchema(Person)

  // Add a value that adheres to the schema
  const value = { name: &quot;Alice&quot;, age: 30 }
  yield* kv.set(&quot;user1&quot;, value)
  console.log(yield* kv.size)

  // Retrieve and log the value
  console.log(yield* kv.get(&quot;user1&quot;))
})

// Use the in-memory store implementation
Effect.runPromise(program.pipe(Effect.provide(layerMemory)))
/*
Output:
1
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: { name: &#39;Alice&#39;, age: 30 } }
*/
</code></pre>
<hr>
<hr>
<h2>title: Path
description: Perform file path operations such as joining, resolving, and normalizing across platforms.
sidebar:
  order: 4</h2>
<p>The <code>@effect/platform/Path</code> module provides a set of operations for working with file paths.</p>
<h2>Basic Usage</h2>
<p>The module provides a single <code>Path</code> <a href="/docs/requirements-management/services/">tag</a>, which acts as the gateway for interacting with paths.</p>
<p><strong>Example</strong> (Accessing the Path Service)</p>
<pre><code class="language-ts">import { Path } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const path = yield* Path.Path

  // Use `path` to perform various path operations
})
</code></pre>
<p>The <code>Path</code> interface includes the following operations:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>basename</strong></td>
<td>Returns the last part of a path, optionally removing a given suffix.</td>
</tr>
<tr>
<td><strong>dirname</strong></td>
<td>Returns the directory part of a path.</td>
</tr>
<tr>
<td><strong>extname</strong></td>
<td>Returns the file extension from a path.</td>
</tr>
<tr>
<td><strong>format</strong></td>
<td>Formats a path object into a path string.</td>
</tr>
<tr>
<td><strong>fromFileUrl</strong></td>
<td>Converts a file URL to a path.</td>
</tr>
<tr>
<td><strong>isAbsolute</strong></td>
<td>Checks if a path is absolute.</td>
</tr>
<tr>
<td><strong>join</strong></td>
<td>Joins multiple path segments into one.</td>
</tr>
<tr>
<td><strong>normalize</strong></td>
<td>Normalizes a path by resolving <code>.</code> and <code>..</code> segments.</td>
</tr>
<tr>
<td><strong>parse</strong></td>
<td>Parses a path string into an object with its segments.</td>
</tr>
<tr>
<td><strong>relative</strong></td>
<td>Computes the relative path from one path to another.</td>
</tr>
<tr>
<td><strong>resolve</strong></td>
<td>Resolves a sequence of paths to an absolute path.</td>
</tr>
<tr>
<td><strong>sep</strong></td>
<td>Returns the platform-specific path segment separator (e.g., <code>/</code> on POSIX).</td>
</tr>
<tr>
<td><strong>toFileUrl</strong></td>
<td>Converts a path to a file URL.</td>
</tr>
<tr>
<td><strong>toNamespacedPath</strong></td>
<td>Converts a path to a namespaced path (specific to Windows).</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Joining Path Segments)</p>
<pre><code class="language-ts">import { Path } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;
import { NodeContext, NodeRuntime } from &quot;@effect/platform-node&quot;

const program = Effect.gen(function* () {
  const path = yield* Path.Path

  const mypath = path.join(&quot;tmp&quot;, &quot;file.txt&quot;)
  console.log(mypath)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
// Output: &quot;tmp/file.txt&quot;
</code></pre>
<hr>
<hr>
<h2>title: PlatformLogger
description: Log messages to a file using the FileSystem APIs.
sidebar:
  order: 6</h2>
<p>Effect&#39;s logging system generally writes messages to the console by default. However, you might prefer to store logs in a file for easier debugging or archiving. The <code>PlatformLogger.toFile</code> function creates a logger that sends log messages to a file on disk.</p>
<h3>toFile</h3>
<p>Creates a new logger from an existing string-based logger, writing its output to the specified file.</p>
<p>If you include a <code>batchWindow</code> duration when calling <code>toFile</code>, logs are batched for that period before being written. This can reduce overhead if your application produces many log entries. Without a <code>batchWindow</code>, logs are written as they arrive.</p>
<p>Note that <code>toFile</code> returns an <code>Effect</code> that may fail with a <code>PlatformError</code> if the file cannot be opened or written to. Be sure to handle this possibility if you need to react to file I/O issues.</p>
<p><strong>Example</strong> (Directing Logs to a File)</p>
<p>This logger requires a <code>FileSystem</code> implementation to open and write to the file. For Node.js, you can use <code>NodeFileSystem.layer</code>.</p>
<pre><code class="language-ts">import { PlatformLogger } from &quot;@effect/platform&quot;
import { NodeFileSystem } from &quot;@effect/platform-node&quot;
import { Effect, Layer, Logger } from &quot;effect&quot;

// Create a string-based logger (logfmtLogger in this case)
const myStringLogger = Logger.logfmtLogger

// Apply toFile to write logs to &quot;/tmp/log.txt&quot;
const fileLogger = myStringLogger.pipe(
  PlatformLogger.toFile(&quot;/tmp/log.txt&quot;)
)

// Replace the default logger, providing NodeFileSystem
// to access the file system
const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  fileLogger
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.log(&quot;Hello&quot;)

// Run the program, writing logs to /tmp/log.txt
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
/*
Logs will be written to &quot;/tmp/log.txt&quot; in the logfmt format,
and won&#39;t appear on the console.
*/
</code></pre>
<p>In the following example, logs are written to both the console and a file. The console uses the pretty logger, while the file uses the logfmt format.</p>
<p><strong>Example</strong> (Directing Logs to Both a File and the Console)</p>
<pre><code class="language-ts">import { PlatformLogger } from &quot;@effect/platform&quot;
import { NodeFileSystem } from &quot;@effect/platform-node&quot;
import { Effect, Layer, Logger } from &quot;effect&quot;

const fileLogger = Logger.logfmtLogger.pipe(
  PlatformLogger.toFile(&quot;/tmp/log.txt&quot;)
)

// Combine the pretty logger for console output with the file logger
const bothLoggers = Effect.map(fileLogger, (fileLogger) =&gt;
  Logger.zip(Logger.prettyLoggerDefault, fileLogger)
)

const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  bothLoggers
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.log(&quot;Hello&quot;)

// Run the program, writing logs to both the console (pretty format)
// and &quot;/tmp/log.txt&quot; (logfmt)
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
</code></pre>
<hr>
<hr>
<h2>title: Terminal
description: Interact with standard input and output to read user input and display messages on the terminal.
sidebar:
  order: 6</h2>
<p>The <code>@effect/platform/Terminal</code> module provides an abstraction for interacting with standard input and output, including reading user input and displaying messages on the terminal.</p>
<h2>Basic Usage</h2>
<p>The module provides a single <code>Terminal</code> <a href="/docs/requirements-management/services/">tag</a>, which serves as the entry point to reading from and writing to standard input and standard output.</p>
<p><strong>Example</strong> (Using the Terminal Service)</p>
<pre><code class="language-ts">import { Terminal } from &quot;@effect/platform&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal

  // Use `terminal` to interact with standard input and output
})
</code></pre>
<h2>Writing to standard output</h2>
<p><strong>Example</strong> (Displaying a Message on the Terminal)</p>
<pre><code class="language-ts">import { Terminal } from &quot;@effect/platform&quot;
import { NodeRuntime, NodeTerminal } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal
  yield* terminal.display(&quot;a message\n&quot;)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeTerminal.layer)))
// Output: &quot;a message&quot;
</code></pre>
<h2>Reading from standard input</h2>
<p><strong>Example</strong> (Reading a Line from Standard Input)</p>
<pre><code class="language-ts">import { Terminal } from &quot;@effect/platform&quot;
import { NodeRuntime, NodeTerminal } from &quot;@effect/platform-node&quot;
import { Effect } from &quot;effect&quot;

const program = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal
  const input = yield* terminal.readLine
  console.log(`input: ${input}`)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeTerminal.layer)))
// Input: &quot;hello&quot;
// Output: &quot;input: hello&quot;
</code></pre>
<h2>Example: Number guessing game</h2>
<p>This example demonstrates how to create a complete number-guessing game by reading input from the terminal and providing feedback to the user. The game continues until the user guesses the correct number.</p>
<p><strong>Example</strong> (Interactive Number Guessing Game)</p>
<pre><code class="language-ts">import { Terminal } from &quot;@effect/platform&quot;
import type { PlatformError } from &quot;@effect/platform/Error&quot;
import { Effect, Option, Random } from &quot;effect&quot;
import { NodeRuntime, NodeTerminal } from &quot;@effect/platform-node&quot;

// Generate a secret random number between 1 and 100
const secret = Random.nextIntBetween(1, 100)

// Parse the user&#39;s input into a valid number
const parseGuess = (input: string) =&gt; {
  const n = parseInt(input, 10)
  return isNaN(n) || n &lt; 1 || n &gt; 100 ? Option.none() : Option.some(n)
}

// Display a message on the terminal
const display = (message: string) =&gt;
  Effect.gen(function* () {
    const terminal = yield* Terminal.Terminal
    yield* terminal.display(`${message}\n`)
  })

// Prompt the user for a guess
const prompt = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal
  yield* terminal.display(&quot;Enter a guess: &quot;)
  return yield* terminal.readLine
})

// Get the user&#39;s guess, validating it as an integer between 1 and 100
const answer: Effect.Effect&lt;
  number,
  Terminal.QuitException | PlatformError,
  Terminal.Terminal
&gt; = Effect.gen(function* () {
  const input = yield* prompt
  const guess = parseGuess(input)
  if (Option.isNone(guess)) {
    yield* display(&quot;You must enter an integer from 1 to 100&quot;)
    return yield* answer
  }
  return guess.value
})

// Check if the guess is too high, too low, or correct
const check = &lt;A, E, R&gt;(
  secret: number,
  guess: number,
  ok: Effect.Effect&lt;A, E, R&gt;,
  ko: Effect.Effect&lt;A, E, R&gt;
) =&gt;
  Effect.gen(function* () {
    if (guess &gt; secret) {
      yield* display(&quot;Too high&quot;)
      return yield* ko
    } else if (guess &lt; secret) {
      yield* display(&quot;Too low&quot;)
      return yield* ko
    } else {
      return yield* ok
    }
  })

// End the game with a success message
const end = display(&quot;You guessed it!&quot;)

// Main game loop
const loop = (
  secret: number
): Effect.Effect&lt;
  void,
  Terminal.QuitException | PlatformError,
  Terminal.Terminal
&gt; =&gt;
  Effect.gen(function* () {
    const guess = yield* answer
    return yield* check(
      secret,
      guess,
      end,
      Effect.suspend(() =&gt; loop(secret))
    )
  })

// Full game setup and execution
const game = Effect.gen(function* () {
  yield* display(
    `We have selected a random number between 1 and 100.
See if you can guess it in 10 turns or fewer.
We&#39;ll tell you if your guess was too high or too low.`
  )
  yield* loop(yield* secret)
})

// Run the game
NodeRuntime.runMain(game.pipe(Effect.provide(NodeTerminal.layer)))
</code></pre>
<hr>
<hr>
<h2>title: Default Services
description: Learn about the default services in Effect, including Clock, Console, Random, ConfigProvider, and Tracer, and how they are automatically provided for your programs.
sidebar:
  order: 1</h2>
<p>Effect comes equipped with five pre-built services:</p>
<pre><code class="language-ts">type DefaultServices = Clock | ConfigProvider | Console | Random | Tracer
</code></pre>
<p>When we employ these services, there&#39;s no need to explicitly provide their implementations. Effect automatically supplies live versions of these services to our effects, sparing us from manual setup.</p>
<p><strong>Example</strong> (Using Clock and Console)</p>
<pre><code class="language-ts">import { Effect, Clock, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;void, never, never&gt;
//      ▼
const program = Effect.gen(function* () {
  const now = yield* Clock.currentTimeMillis
  yield* Console.log(`Application started at ${new Date(now)}`)
})
</code></pre>
<p>As you can observe, even if our program utilizes both <code>Clock</code> and <code>Console</code>, the <code>Requirements</code> parameter, representing the services required for the effect to execute, remains set to <code>never</code>.
Effect takes care of handling these services seamlessly for us.</p>
<hr>
<hr>
<h2>title: Layer Memoization
description: Learn how layer memoization optimizes performance in Effect by reusing layers and controlling their instantiation.
sidebar:
  order: 3</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Layer memoization allows a layer to be created once and used multiple times in the dependency graph. If we use the same layer twice:</p>
<pre><code class="language-ts">Layer.merge(Layer.provide(L2, L1), Layer.provide(L3, L1))
</code></pre>
<p>then the <code>L1</code> layer will be allocated only once.</p>
<Aside type="caution" title="Avoid Duplicate Layer Creation">
  Layers are memoized using **reference equality**. Therefore, if you have
  a layer that is created by calling a function like `f()`, you should
  _only_ call that `f` once and re-use the resulting layer so that you are
  always using the same instance.
</Aside>

<h2>Memoization When Providing Globally</h2>
<p>One important feature of an Effect application is that layers are shared by default. This means that if the same layer is used twice, and if we provide the layer globally, the layer will only be allocated a single time. For every layer in our dependency graph, there is only one instance of it that is shared between all the layers that depend on it.</p>
<p><strong>Example</strong></p>
<p>For example, assume we have the three services <code>A</code>, <code>B</code>, and <code>C</code>. The implementation of both <code>B</code> and <code>C</code> is dependent on the <code>A</code> service:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

class A extends Context.Tag(&quot;A&quot;)&lt;A, { readonly a: number }&gt;() {}

class B extends Context.Tag(&quot;B&quot;)&lt;B, { readonly b: string }&gt;() {}

class C extends Context.Tag(&quot;C&quot;)&lt;C, { readonly c: boolean }&gt;() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() =&gt; Effect.log(&quot;initialized&quot;))
  )
)

const BLive = Layer.effect(
  B,
  Effect.gen(function* () {
    const { a } = yield* A
    return { b: String(a) }
  })
)

const CLive = Layer.effect(
  C,
  Effect.gen(function* () {
    const { a } = yield* A
    return { c: a &gt; 0 }
  })
)

const program = Effect.gen(function* () {
  yield* B
  yield* C
})

const runnable = Effect.provide(
  program,
  Layer.merge(Layer.provide(BLive, ALive), Layer.provide(CLive, ALive))
)

Effect.runPromise(runnable)
/*
Output:
timestamp=... level=INFO fiber=#2 message=initialized
*/
</code></pre>
<p>Although both <code>BLive</code> and <code>CLive</code> layers require the <code>ALive</code> layer, the <code>ALive</code> layer is instantiated only once. It is shared with both <code>BLive</code> and <code>CLive</code>.</p>
<h2>Acquiring a Fresh Version</h2>
<p>If we don&#39;t want to share a module, we should create a fresh, non-shared version of it through <code>Layer.fresh</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

class A extends Context.Tag(&quot;A&quot;)&lt;A, { readonly a: number }&gt;() {}

class B extends Context.Tag(&quot;B&quot;)&lt;B, { readonly b: string }&gt;() {}

class C extends Context.Tag(&quot;C&quot;)&lt;C, { readonly c: boolean }&gt;() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() =&gt; Effect.log(&quot;initialized&quot;))
  )
)

const BLive = Layer.effect(
  B,
  Effect.gen(function* () {
    const { a } = yield* A
    return { b: String(a) }
  })
)

const CLive = Layer.effect(
  C,
  Effect.gen(function* () {
    const { a } = yield* A
    return { c: a &gt; 0 }
  })
)

const program = Effect.gen(function* () {
  yield* B
  yield* C
})

const runnable = Effect.provide(
  program,
  Layer.merge(
    Layer.provide(BLive, Layer.fresh(ALive)),
    Layer.provide(CLive, Layer.fresh(ALive))
  )
)

Effect.runPromise(runnable)
/*
Output:
timestamp=... level=INFO fiber=#2 message=initialized
timestamp=... level=INFO fiber=#3 message=initialized
*/
</code></pre>
<h2>No Memoization When Providing Locally</h2>
<p>If we don&#39;t provide a layer globally but instead provide them locally, that layer doesn&#39;t support memoization by default.</p>
<p><strong>Example</strong></p>
<p>In the following example, we provided the <code>ALive</code> layer two times locally, and Effect doesn&#39;t memoize the construction of the <code>ALive</code> layer.
So, it will be initialized two times:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

class A extends Context.Tag(&quot;A&quot;)&lt;A, { readonly a: number }&gt;() {}

const Alive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() =&gt; Effect.log(&quot;initialized&quot;))
  )
)

const program = Effect.gen(function* () {
  yield* Effect.provide(A, Alive)
  yield* Effect.provide(A, Alive)
})

Effect.runPromise(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=initialized
timestamp=... level=INFO fiber=#0 message=initialized
*/
</code></pre>
<h2>Manual Memoization</h2>
<p>We can memoize a layer manually using the <code>Layer.memoize</code> function.
It will return a scoped effect that, if evaluated, will return the lazily computed result of this layer.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

class A extends Context.Tag(&quot;A&quot;)&lt;A, { readonly a: number }&gt;() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() =&gt; Effect.log(&quot;initialized&quot;))
  )
)

const program = Effect.scoped(
  Layer.memoize(ALive).pipe(
    Effect.andThen((memoized) =&gt;
      Effect.gen(function* () {
        yield* Effect.provide(A, memoized)
        yield* Effect.provide(A, memoized)
      })
    )
  )
)

Effect.runPromise(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=initialized
*/
</code></pre>
<hr>
<hr>
<h2>title: Managing Layers
description: Learn how to use layers in Effect to manage service dependencies and build efficient, clean dependency graphs for your applications.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In the <a href="/docs/requirements-management/services/">Managing Services</a> page, you learned how to create effects which depend on some service to be provided in order to execute, as well as how to provide that service to an effect.</p>
<p>However, what if we have a service within our effect program that has dependencies on other services in order to be built? We want to avoid leaking these implementation details into the service interface.</p>
<p>To represent the &quot;dependency graph&quot; of our program and manage these dependencies more effectively, we can utilize a powerful abstraction called &quot;Layer&quot;.</p>
<p>Layers act as <strong>constructors for creating services</strong>, allowing us to manage dependencies during construction rather than at the service level. This approach helps to keep our service interfaces clean and focused.</p>
<p>Let&#39;s review some key concepts before diving into the details:</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>service</strong></td>
<td>A reusable component providing specific functionality, used across different parts of an application.</td>
</tr>
<tr>
<td><strong>tag</strong></td>
<td>A unique identifier representing a <strong>service</strong>, allowing Effect to locate and use it.</td>
</tr>
<tr>
<td><strong>context</strong></td>
<td>A collection storing services, functioning like a map with <strong>tags</strong> as keys and <strong>services</strong> as values.</td>
</tr>
<tr>
<td><strong>layer</strong></td>
<td>An abstraction for constructing <strong>services</strong>, managing dependencies during construction rather than at the service level.</td>
</tr>
</tbody></table>
<h2>Designing the Dependency Graph</h2>
<p>Let&#39;s imagine that we are building a web application. We could imagine that the dependency graph for an application where we need to manage configuration, logging, and database access might look something like this:</p>
<ul>
<li>The <code>Config</code> service provides application configuration.</li>
<li>The <code>Logger</code> service depends on the <code>Config</code> service.</li>
<li>The <code>Database</code> service depends on both the <code>Config</code> and <code>Logger</code> services.</li>
</ul>
<p>Our goal is to build the <code>Database</code> service along with its direct and indirect dependencies. This means we need to ensure that the <code>Config</code> service is available for both <code>Logger</code> and <code>Database</code>, and then provide these dependencies to the <code>Database</code> service.</p>
<h2>Avoiding Requirement Leakage</h2>
<p>When constructing the <code>Database</code> service, it&#39;s important to avoid exposing the dependencies on <code>Config</code> and <code>Logger</code> within the <code>Database</code> interface.</p>
<p>You might be tempted to define the <code>Database</code> service as follows:</p>
<p><strong>Example</strong> (Leaking Dependencies in the Service Interface)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;Config, {}&gt;() {}

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;Logger, {}&gt;() {}

// Declaring a tag for the Database service
class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  {
    // ❌ Avoid exposing Config and Logger as a requirement
    readonly query: (
      sql: string
    ) =&gt; Effect.Effect&lt;unknown, never, Config | Logger&gt;
  }
&gt;() {}
</code></pre>
<p>Here, the <code>query</code> function of the <code>Database</code> service requires both <code>Config</code> and <code>Logger</code>. This design leaks implementation details, making the <code>Database</code> service aware of its dependencies, which complicates testing and makes it difficult to mock.</p>
<Aside type="tip" title="Keep Service Interfaces Simple">
  Service functions should avoid requiring dependencies directly. In practice, service operations should have the `Requirements` parameter set to `never`:

<pre><code class="language-text">                         ┌─── No dependencies required
                         ▼
Effect&lt;Success, Error, never&gt;
</code></pre>
</Aside>

<p>To demonstrate the problem, let&#39;s create a test instance of the <code>Database</code> service:</p>
<p><strong>Example</strong> (Creating a Test Instance with Leaked Dependencies)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;Config, {}&gt;() {}

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;Logger, {}&gt;() {}

// Declaring a tag for the Database service
class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  {
    readonly query: (
      sql: string
    ) =&gt; Effect.Effect&lt;unknown, never, Config | Logger&gt;
  }
&gt;() {}

// Declaring a test instance of the Database service
const DatabaseTest = Database.of({
  // Simulating a simple response
  query: (sql: string) =&gt; Effect.succeed([])
})

import * as assert from &quot;node:assert&quot;

// A test that uses the Database service
const test = Effect.gen(function* () {
  const database = yield* Database
  const result = yield* database.query(&quot;SELECT * FROM users&quot;)
  assert.deepStrictEqual(result, [])
})

//      ┌─── Effect&lt;unknown, never, Config | Logger&gt;
//      ▼
const incompleteTestSetup = test.pipe(
  // Attempt to provide only the Database service without Config and Logger
  Effect.provideService(Database, DatabaseTest)
)
</code></pre>
<p>Because the <code>Database</code> service interface directly includes dependencies on <code>Config</code> and <code>Logger</code>, it forces any test setup to include these services, even if they&#39;re irrelevant to the test. This adds unnecessary complexity and makes it difficult to write simple, isolated unit tests.</p>
<p>Instead of directly tying dependencies to the <code>Database</code> service interface, dependencies should be managed at the construction phase.</p>
<p>We can use <strong>layers</strong> to properly construct the <code>Database</code> service and manage its dependencies without leaking details into the interface.</p>
<Aside type="tip" title="Use Layers for Dependencies">
  When a service has its own requirements, it's best to separate
  implementation details into layers. Layers act as **constructors for
  creating the service**, allowing us to handle dependencies at the
  construction level rather than the service level.
</Aside>

<h2>Creating Layers</h2>
<p>The <code>Layer</code> type is structured as follows:</p>
<pre><code class="language-text">        ┌─── The service to be created
        │                ┌─── The possible error
        │                │      ┌─── The required dependencies
        ▼                ▼      ▼
Layer&lt;RequirementsOut, Error, RequirementsIn&gt;
</code></pre>
<p>A <code>Layer</code> represents a blueprint for constructing a <code>RequirementsOut</code> (the service). It requires a <code>RequirementsIn</code> (dependencies) as input and may result in an error of type <code>Error</code> during the construction process.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>RequirementsOut</code></td>
<td>The service or resource to be created.</td>
</tr>
<tr>
<td><code>Error</code></td>
<td>The type of error that might occur during the construction of the service.</td>
</tr>
<tr>
<td><code>RequirementsIn</code></td>
<td>The dependencies required to construct the service.</td>
</tr>
</tbody></table>
<p>By using layers, you can better organize your services, ensuring that their dependencies are clearly defined and separated from their implementation details.</p>
<p>For simplicity, let&#39;s assume that we won&#39;t encounter any errors during the value construction (meaning <code>Error = never</code>).</p>
<p>Now, let&#39;s determine how many layers we need to implement our dependency graph:</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Dependencies</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td><code>ConfigLive</code></td>
<td>The <code>Config</code> service does not depend on any other services</td>
<td><code>Layer&lt;Config&gt;</code></td>
</tr>
<tr>
<td><code>LoggerLive</code></td>
<td>The <code>Logger</code> service depends on the <code>Config</code> service</td>
<td><code>Layer&lt;Logger, never, Config&gt;</code></td>
</tr>
<tr>
<td><code>DatabaseLive</code></td>
<td>The <code>Database</code> service depends on <code>Config</code> and <code>Logger</code></td>
<td><code>Layer&lt;Database, never, Config | Logger&gt;</code></td>
</tr>
</tbody></table>
<Aside type="tip" title="Naming Conventions">
  A common convention when naming the `Layer` for a particular service is
  to add a `Live` suffix for the "live" implementation and a `Test` suffix
  for the "test" implementation. For example, for a `Database` service,
  the `DatabaseLive` would be the layer you provide in your application
  and the `DatabaseTest` would be the layer you provide in your tests.
</Aside>

<p>When a service has multiple dependencies, they are represented as a <strong>union type</strong>. In our case, the <code>Database</code> service depends on both the <code>Config</code> and <code>Logger</code> services. Therefore, the type for the <code>DatabaseLive</code> layer will be:</p>
<pre><code class="language-ts">Layer&lt;Database, never, Config | Logger&gt;
</code></pre>
<h3>Config</h3>
<p>The <code>Config</code> service does not depend on any other services, so <code>ConfigLive</code> will be the simplest layer to implement. Just like in the <a href="/docs/requirements-management/services/">Managing Services</a> page, we must create a tag for the service. And because the service has no dependencies, we can create the layer directly using the <code>Layer.succeed</code> constructor:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(
  Config,
  Config.of({
    getConfig: Effect.succeed({
      logLevel: &quot;INFO&quot;,
      connection: &quot;mysql://username:password@hostname:port/database_name&quot;
    })
  })
)
</code></pre>
<p>Looking at the type of <code>ConfigLive</code> we can observe:</p>
<ul>
<li><code>RequirementsOut</code> is <code>Config</code>, indicating that constructing the layer will produce a <code>Config</code> service</li>
<li><code>Error</code> is <code>never</code>, indicating that layer construction cannot fail</li>
<li><code>RequirementsIn</code> is <code>never</code>, indicating that the layer has no dependencies</li>
</ul>
<p>Note that, to construct <code>ConfigLive</code>, we used the <code>Config.of</code>
constructor. However, this is merely a helper to ensure correct type inference
for the implementation. It&#39;s possible to skip this helper and construct the
implementation directly as a simple object:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})
</code></pre>
<h3>Logger</h3>
<p>Now we can move on to the implementation of the <code>Logger</code> service, which depends on the <code>Config</code> service to retrieve some configuration.</p>
<p>Just like we did in the <a href="/docs/requirements-management/services/#using-the-service">Managing Services</a> page, we can yield the <code>Config</code> tag to &quot;extract&quot; the service from the context.</p>
<p>Given that using the <code>Config</code> tag is an effectful operation, we use <code>Layer.effect</code> to create a layer from the resulting effect.</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

// Layer&lt;Logger, never, Config&gt;
const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)
</code></pre>
<p>Looking at the type of <code>LoggerLive</code>:</p>
<pre><code class="language-ts">Layer&lt;Logger, never, Config&gt;
</code></pre>
<p>we can observe that:</p>
<ul>
<li><code>RequirementsOut</code> is <code>Logger</code></li>
<li><code>Error</code> is <code>never</code>, indicating that layer construction cannot fail</li>
<li><code>RequirementsIn</code> is <code>Config</code>, indicating that the layer has a requirement</li>
</ul>
<h3>Database</h3>
<p>Finally, we can use our <code>Config</code> and <code>Logger</code> services to implement the <code>Database</code> service.</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

// Layer&lt;Logger, never, Config&gt;
const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)

// Declaring a tag for the Database service
class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  { readonly query: (sql: string) =&gt; Effect.Effect&lt;unknown&gt; }
&gt;() {}

// Layer&lt;Database, never, Config | Logger&gt;
const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const config = yield* Config
    const logger = yield* Logger
    return {
      query: (sql: string) =&gt;
        Effect.gen(function* () {
          yield* logger.log(`Executing query: ${sql}`)
          const { connection } = yield* config.getConfig
          return { result: `Results from ${connection}` }
        })
    }
  })
)
</code></pre>
<p>Looking at the type of <code>DatabaseLive</code>:</p>
<pre><code class="language-ts">Layer&lt;Database, never, Config | Logger&gt;
</code></pre>
<p>we can observe that the <code>RequirementsIn</code> type is <code>Config | Logger</code>, i.e., the <code>Database</code> service requires both <code>Config</code> and <code>Logger</code> services.</p>
<h2>Combining Layers</h2>
<p>Layers can be combined in two primary ways: <strong>merging</strong> and <strong>composing</strong>.</p>
<h3>Merging Layers</h3>
<p>Layers can be combined through merging using the <code>Layer.merge</code> function:</p>
<pre><code class="language-ts">import { Layer } from &quot;effect&quot;

declare const layer1: Layer.Layer&lt;&quot;Out1&quot;, never, &quot;In1&quot;&gt;
declare const layer2: Layer.Layer&lt;&quot;Out2&quot;, never, &quot;In2&quot;&gt;

// Layer&lt;&quot;Out1&quot; | &quot;Out2&quot;, never, &quot;In1&quot; | &quot;In2&quot;&gt;
const merging = Layer.merge(layer1, layer2)
</code></pre>
<p>When we merge two layers, the resulting layer:</p>
<ul>
<li>requires all the services that both of them require (<code>&quot;In1&quot; | &quot;In2&quot;</code>).</li>
<li>produces all services that both of them produce (<code>&quot;Out1&quot; | &quot;Out2&quot;</code>).</li>
</ul>
<p>For example, in our web application above, we can merge our <code>ConfigLive</code> and <code>LoggerLive</code> layers into a single <code>AppConfigLive</code> layer, which retains the requirements of both layers (<code>never | Config = Config</code>) and the outputs of both layers (<code>Config | Logger</code>):</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

// Layer&lt;Logger, never, Config&gt;
const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)

// Layer&lt;Config | Logger, never, Config&gt;
const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)
</code></pre>
<h3>Composing Layers</h3>
<p>Layers can be composed using the <code>Layer.provide</code> function:</p>
<pre><code class="language-ts">import { Layer } from &quot;effect&quot;

declare const inner: Layer.Layer&lt;&quot;OutInner&quot;, never, &quot;InInner&quot;&gt;
declare const outer: Layer.Layer&lt;&quot;InInner&quot;, never, &quot;InOuter&quot;&gt;

// Layer&lt;&quot;OutInner&quot;, never, &quot;InOuter&quot;&gt;
const composition = Layer.provide(inner, outer)
</code></pre>
<p>Sequential composition of layers implies that the output of one layer is supplied as the input for the inner layer,
resulting in a single layer with the requirements of the outer layer and the output of the inner.</p>
<p>Now we can compose the <code>AppConfigLive</code> layer with the <code>DatabaseLive</code> layer:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

// Layer&lt;Config, never, never&gt;
const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

// Layer&lt;Logger, never, Config&gt;
const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)

// Declaring a tag for the Database service
class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  { readonly query: (sql: string) =&gt; Effect.Effect&lt;unknown&gt; }
&gt;() {}

// Layer&lt;Database, never, Config | Logger&gt;
const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const config = yield* Config
    const logger = yield* Logger
    return {
      query: (sql: string) =&gt;
        Effect.gen(function* () {
          yield* logger.log(`Executing query: ${sql}`)
          const { connection } = yield* config.getConfig
          return { result: `Results from ${connection}` }
        })
    }
  })
)

// Layer&lt;Config | Logger, never, Config&gt;
const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)

// Layer&lt;Database, never, never&gt;
const MainLive = DatabaseLive.pipe(
  // provides the config and logger to the database
  Layer.provide(AppConfigLive),
  // provides the config to AppConfigLive
  Layer.provide(ConfigLive)
)
</code></pre>
<p>We obtained a <code>MainLive</code> layer that produces the <code>Database</code> service:</p>
<pre><code class="language-ts">Layer&lt;Database, never, never&gt;
</code></pre>
<p>This layer is the fully resolved layer for our application.</p>
<h3>Merging and Composing Layers</h3>
<p>Let&#39;s say we want our <code>MainLive</code> layer to return both the <code>Config</code> and <code>Database</code> services. We can achieve this with <code>Layer.provideMerge</code>:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

// Declaring a tag for the Logger service
class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)

// Declaring a tag for the Database service
class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  { readonly query: (sql: string) =&gt; Effect.Effect&lt;unknown&gt; }
&gt;() {}

const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const config = yield* Config
    const logger = yield* Logger
    return {
      query: (sql: string) =&gt;
        Effect.gen(function* () {
          yield* logger.log(`Executing query: ${sql}`)
          const { connection } = yield* config.getConfig
          return { result: `Results from ${connection}` }
        })
    }
  })
)

// Layer&lt;Config | Logger, never, Config&gt;
const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)

// Layer&lt;Config | Database, never, never&gt;
const MainLive = DatabaseLive.pipe(
  Layer.provide(AppConfigLive),
  Layer.provideMerge(ConfigLive)
)
</code></pre>
<h2>Providing a Layer to an Effect</h2>
<p>Now that we have assembled the fully resolved <code>MainLive</code> for our application,
we can provide it to our program to satisfy the program&#39;s requirements using <code>Effect.provide</code>:</p>
<pre><code class="language-ts">import { Effect, Context, Layer } from &quot;effect&quot;

class Config extends Context.Tag(&quot;Config&quot;)&lt;
  Config,
  {
    readonly getConfig: Effect.Effect&lt;{
      readonly logLevel: string
      readonly connection: string
    }&gt;
  }
&gt;() {}

const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: &quot;INFO&quot;,
    connection: &quot;mysql://username:password@hostname:port/database_name&quot;
  })
})

class Logger extends Context.Tag(&quot;Logger&quot;)&lt;
  Logger,
  { readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

const LoggerLive = Layer.effect(
  Logger,
  Effect.gen(function* () {
    const config = yield* Config
    return {
      log: (message) =&gt;
        Effect.gen(function* () {
          const { logLevel } = yield* config.getConfig
          console.log(`[${logLevel}] ${message}`)
        })
    }
  })
)

class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  { readonly query: (sql: string) =&gt; Effect.Effect&lt;unknown&gt; }
&gt;() {}

const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const config = yield* Config
    const logger = yield* Logger
    return {
      query: (sql: string) =&gt;
        Effect.gen(function* () {
          yield* logger.log(`Executing query: ${sql}`)
          const { connection } = yield* config.getConfig
          return { result: `Results from ${connection}` }
        })
    }
  })
)

const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)

const MainLive = DatabaseLive.pipe(
  Layer.provide(AppConfigLive),
  Layer.provide(ConfigLive)
)

//      ┌─── Effect&lt;unknown, never, Database&gt;
//      ▼
const program = Effect.gen(function* () {
  const database = yield* Database
  const result = yield* database.query(&quot;SELECT * FROM users&quot;)
  return result
})

//      ┌─── Effect&lt;unknown, never, never&gt;
//      ▼
const runnable = Effect.provide(program, MainLive)

Effect.runPromise(runnable).then(console.log)
/*
Output:
[INFO] Executing query: SELECT * FROM users
{
  result: &#39;Results from mysql://username:password@hostname:port/database_name&#39;
}
*/
</code></pre>
<p>Note that the <code>runnable</code> requirements type is <code>never</code>, indicating that the program does not require any additional services to run.</p>
<h2>Converting a Layer to an Effect</h2>
<p>Sometimes your entire application might be a Layer, for example, an HTTP server. You can convert that layer to an effect with <code>Layer.launch</code>. It constructs the layer and keeps it alive until interrupted.</p>
<p><strong>Example</strong> (Launching an HTTP Server Layer)</p>
<pre><code class="language-ts">import { Console, Context, Effect, Layer } from &quot;effect&quot;

class HTTPServer extends Context.Tag(&quot;HTTPServer&quot;)&lt;HTTPServer, void&gt;() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  // Log a message to simulate a server starting
  Console.log(&quot;Listening on http://localhost:3000&quot;)
)

// Converts the layer to an effect and runs it
Effect.runFork(Layer.launch(server))
/*
Output:
Listening on http://localhost:3000
...
*/
</code></pre>
<h2>Tapping</h2>
<p>The <code>Layer.tap</code> and <code>Layer.tapError</code> functions allow you to perform additional effects based on the success or failure of a layer. These operations do not modify the layer&#39;s signature but are useful for logging or performing side effects during layer construction.</p>
<ul>
<li><code>Layer.tap</code>: Executes a specified effect when the layer is successfully acquired.</li>
<li><code>Layer.tapError</code>: Executes a specified effect when the layer fails to acquire.</li>
</ul>
<p><strong>Example</strong> (Logging Success and Failure During Layer Acquisition)</p>
<pre><code class="language-ts">import { Config, Context, Effect, Layer, Console } from &quot;effect&quot;

class HTTPServer extends Context.Tag(&quot;HTTPServer&quot;)&lt;HTTPServer, void&gt;() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  Effect.gen(function* () {
    const host = yield* Config.string(&quot;HOST&quot;)
    console.log(`Listening on http://localhost:${host}`)
  })
).pipe(
  // Log a message if the layer acquisition succeeds
  Layer.tap((ctx) =&gt;
    Console.log(`layer acquisition succeeded with:\n${ctx}`)
  ),
  // Log a message if the layer acquisition fails
  Layer.tapError((err) =&gt;
    Console.log(`layer acquisition failed with:\n${err}`)
  )
)

Effect.runFork(Layer.launch(server))
/*
Output:
layer acquisition failed with:
(Missing data at HOST: &quot;Expected HOST to exist in the process context&quot;)
*/
</code></pre>
<h2>Error Handling</h2>
<p>When constructing layers, it is important to handle potential errors. The Effect library provides tools like <code>Layer.catchAll</code> and <code>Layer.orElse</code> to manage errors and define fallback layers in case of failure.</p>
<h3>catchAll</h3>
<p>The <code>Layer.catchAll</code> function allows you to recover from errors during layer construction by specifying a fallback layer. This can be useful for handling specific error cases and ensuring the application can continue with an alternative setup.</p>
<p><strong>Example</strong> (Recovering from Errors During Layer Construction)</p>
<pre><code class="language-ts">import { Config, Context, Effect, Layer } from &quot;effect&quot;

class HTTPServer extends Context.Tag(&quot;HTTPServer&quot;)&lt;HTTPServer, void&gt;() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  Effect.gen(function* () {
    const host = yield* Config.string(&quot;HOST&quot;)
    console.log(`Listening on http://localhost:${host}`)
  })
).pipe(
  // Recover from errors during layer construction
  Layer.catchAll((configError) =&gt;
    Layer.effect(
      HTTPServer,
      Effect.gen(function* () {
        console.log(`Recovering from error:\n${configError}`)
        console.log(`Listening on http://localhost:3000`)
      })
    )
  )
)

Effect.runFork(Layer.launch(server))
/*
Output:
Recovering from error:
(Missing data at HOST: &quot;Expected HOST to exist in the process context&quot;)
Listening on http://localhost:3000
...
*/
</code></pre>
<h3>orElse</h3>
<p>The <code>Layer.orElse</code> function provides a simpler way to fall back to an alternative layer if the initial layer fails. Unlike <code>Layer.catchAll</code>, it does not receive the error as input. Use this when you only need to provide a default layer without reacting to specific errors.</p>
<p><strong>Example</strong> (Fallback to an Alternative Layer)</p>
<pre><code class="language-ts">import { Config, Context, Effect, Layer } from &quot;effect&quot;

class Database extends Context.Tag(&quot;Database&quot;)&lt;Database, void&gt;() {}

// Simulating a database connection
const postgresDatabaseLayer = Layer.effect(
  Database,
  Effect.gen(function* () {
    const databaseConnectionString = yield* Config.string(
      &quot;CONNECTION_STRING&quot;
    )
    console.log(
      `Connecting to database with: ${databaseConnectionString}`
    )
  })
)

// Simulating an in-memory database connection
const inMemoryDatabaseLayer = Layer.effect(
  Database,
  Effect.gen(function* () {
    console.log(`Connecting to in-memory database`)
  })
)

// Fallback to in-memory database if PostgreSQL connection fails
const database = postgresDatabaseLayer.pipe(
  Layer.orElse(() =&gt; inMemoryDatabaseLayer)
)

Effect.runFork(Layer.launch(database))
/*
Output:
Connecting to in-memory database
...
*/
</code></pre>
<hr>
<hr>
<h2>title: Managing Services
description: Learn how to manage reusable services in Effect, handle dependencies efficiently, and ensure clean, decoupled architecture in your applications.
sidebar:
  order: 0</h2>
<p>import { Aside, Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>In the context of programming, a <strong>service</strong> refers to a reusable component or functionality that can be used by different parts of an application.
Services are designed to provide specific capabilities and can be shared across multiple modules or components.</p>
<p>Services often encapsulate common tasks or operations that are needed by different parts of an application.
They can handle complex operations, interact with external systems or APIs, manage data, or perform other specialized tasks.</p>
<p>Services are typically designed to be modular and decoupled from the rest of the application.
This allows them to be easily maintained, tested, and replaced without affecting the overall functionality of the application.</p>
<p>When diving into services and their integration in application development, it helps to start from the basic principles of function management and dependency handling without relying on advanced constructs. Imagine having to manually pass a service around to every function that needs it:</p>
<pre><code class="language-ts">const processData = (data: Data, databaseService: DatabaseService) =&gt; {
  // Operations using the database service
}
</code></pre>
<p>This approach becomes cumbersome and unmanageable as your application grows, with services needing to be passed through multiple layers of functions.</p>
<p>To streamline this, you might consider using an environment object that bundles various services:</p>
<pre><code class="language-ts">type Context = {
  databaseService: DatabaseService
  loggingService: LoggingService
}

const processData = (data: Data, context: Context) =&gt; {
  // Using multiple services from the context
}
</code></pre>
<p>However, this introduces a new complexity: you must ensure that the environment is correctly set up with all necessary services before it&#39;s used, which can lead to tightly coupled code and makes functional composition and testing more difficult.</p>
<h2>Managing Services with Effect</h2>
<p>The Effect library simplifies managing these dependencies by leveraging the type system.
Instead of manually passing services or environment objects around, Effect allows you to declare service dependencies directly in the function&#39;s type signature using the <code>Requirements</code> parameter in the <code>Effect</code> type:</p>
<pre><code class="language-ts">                         ┌─── Represents required dependencies
                         ▼
Effect&lt;Success, Error, Requirements&gt;
</code></pre>
<p>This is how it works in practice when using Effect:</p>
<p><strong>Dependency Declaration</strong>: You specify what services a function needs directly in its type, pushing the complexity of dependency management into the type system.</p>
<p><strong>Service Provision</strong>: <code>Effect.provideService</code> is used to make a service implementation available to the functions that need it. By providing services at the start, you ensure that all parts of your application have consistent access to the required services, thus maintaining a clean and decoupled architecture.</p>
<p>This approach abstracts away manual service handling, letting developers focus on business logic while the compiler ensures all dependencies are correctly managed. It also makes code more maintainable and scalable.</p>
<p>Let&#39;s walk through managing services in Effect step by step:</p>
<ol>
<li><strong>Creating a Service</strong>: Define a service with its unique functionality and interface.</li>
<li><strong>Using the Service</strong>: Access and utilize the service within your application’s functions.</li>
<li><strong>Providing a Service Implementation</strong>: Supply an actual implementation of the service to fulfill the declared requirements.</li>
</ol>
<h2>How It Works</h2>
<p>Up to this point, our examples with the Effect framework have dealt with effects that operate independently of external services.
This means the <code>Requirements</code> parameter in our <code>Effect</code> type signature has been set to <code>never</code>, indicating no dependencies.</p>
<p>However, real-world applications often need effects that rely on specific services to function correctly. These services are managed and accessed through a construct known as <code>Context</code>.</p>
<p>The <code>Context</code> serves as a repository or container for all services an effect may require.
It acts like a store that maintains these services, allowing various parts of your application to access and use them as needed.</p>
<p>The services stored within the <code>Context</code> are directly reflected in the <code>Requirements</code> parameter of the <code>Effect</code> type.
Each service within the <code>Context</code> is identified by a unique &quot;tag,&quot; which is essentially a unique identifier for the service.</p>
<p>When an effect needs to use a specific service, the service&#39;s tag is included in the <code>Requirements</code> type parameter.</p>
<h2>Creating a Service</h2>
<p>To create a new service, you need two things:</p>
<ol>
<li>A unique <strong>identifier</strong>.</li>
<li>A <strong>type</strong> describing the possible operations of the service.</li>
</ol>
<p><strong>Example</strong> (Defining a Random Number Generator Service)</p>
<p>Let&#39;s create a service for generating random numbers.</p>
<ol>
<li><strong>Identifier</strong>. We&#39;ll use the string <code>&quot;MyRandomService&quot;</code> as the unique identifier.</li>
<li><strong>Type</strong>. The service type will have a single operation called <code>next</code> that returns a random number.</li>
</ol>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}
</code></pre>
<p>The exported <code>Random</code> value is known as a <strong>tag</strong> in Effect. It acts as a representation of the service and allows Effect to locate and use this service at runtime.</p>
<p>The service will be stored in a collection called <code>Context</code>, which can be thought of as a <code>Map</code> where the keys are tags and the values are services:</p>
<pre><code class="language-ts">type Context = Map&lt;Tag, Service&gt;
</code></pre>
<Aside type="note" title="Why Use Identifiers?">
  You need to specify an identifier to make the tag global. This ensures that two tags with the same identifier refer to the same instance.

<p>Using a unique identifier is particularly useful in scenarios where live reloads can occur, as it helps preserve the instance across reloads. It ensures there is no duplication of instances (although it shouldn&#39;t happen, some bundlers and frameworks can behave unpredictably).</p>
</Aside>

<p>Let&#39;s summarize the concepts we&#39;ve covered so far:</p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>service</strong></td>
<td>A reusable component providing specific functionality, used across different parts of an application.</td>
</tr>
<tr>
<td><strong>tag</strong></td>
<td>A unique identifier representing a <strong>service</strong>, allowing Effect to locate and use it.</td>
</tr>
<tr>
<td><strong>context</strong></td>
<td>A collection storing service, functioning like a map with <strong>tags</strong> as keys and <strong>services</strong> as values.</td>
</tr>
</tbody></table>
<h2>Using the Service</h2>
<p>Now that we have our service tag defined, let&#39;s see how we can use it by building a simple program.</p>
<p><strong>Example</strong> (Using the Random Service)</p>
<Tabs syncKey="pipe-vs-gen">

<TabItem label="Using Effect.gen">

<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

// Using the service
//
//      ┌─── Effect&lt;void, never, Random&gt;
//      ▼
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})
</code></pre>
<p>In the code above, we can observe that we are able to yield the <code>Random</code> tag as if it were an effect itself.
This allows us to access the <code>next</code> operation of the service.</p>
</TabItem>

<TabItem label="Using pipe">

<pre><code class="language-ts">import { Effect, Context, Console } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

// Using the service
//
//      ┌─── Effect&lt;void, never, Random&gt;
//      ▼
const program = Random.pipe(
  Effect.andThen((random) =&gt; random.next),
  Effect.andThen((randomNumber) =&gt;
    Console.log(`random number: ${randomNumber}`)
  )
)
</code></pre>
<p>In the code above, we can observe that we are able to flat-map over the <code>Random</code> tag as if it were an effect itself.
This allows us to access the <code>next</code> operation of the service within the <code>Effect.andThen</code> callback.</p>
</TabItem>

</Tabs>

<p>It&#39;s worth noting that the type of the <code>program</code> variable includes <code>Random</code> in the <code>Requirements</code> type parameter:</p>
<pre><code class="language-ts">const program: Effect&lt;void, never, Random&gt;
</code></pre>
<p>This indicates that our program requires the <code>Random</code> service to be provided in order to execute successfully.</p>
<p>If we attempt to execute the effect without providing the necessary service we will encounter a type-checking error:</p>
<p><strong>Example</strong> (Type Error Without Service Provision)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// @ts-expect-error
Effect.runSync(program)
/*
Argument of type &#39;Effect&lt;void, never, Random&gt;&#39; is not assignable to parameter of type &#39;Effect&lt;void, never, never&gt;&#39;.
  Type &#39;Random&#39; is not assignable to type &#39;never&#39;.ts(2345)
*/
</code></pre>
<p>To resolve this error and successfully execute the program, we need to provide an actual implementation of the <code>Random</code> service.</p>
<p>In the next section, we will explore how to implement and provide the <code>Random</code> service to our program, enabling us to run it successfully.</p>
<h2>Providing a Service Implementation</h2>
<p>In order to provide an actual implementation of the <code>Random</code> service, we can utilize the <code>Effect.provideService</code> function.</p>
<p><strong>Example</strong> (Providing a Random Number Implementation)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//      ┌─── Effect&lt;void, never, never&gt;
//      ▼
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() =&gt; Math.random())
})

// Run successfully
Effect.runPromise(runnable)
/*
Example Output:
random number: 0.8241872233134417
*/
</code></pre>
<p>In the code above, we provide the <code>program</code> we defined earlier with an implementation of the <code>Random</code> service.</p>
<p>We use the <code>Effect.provideService</code> function to associate the <code>Random</code> tag with its implementation, an object with a <code>next</code> operation that generates a random number.</p>
<p>Notice that the <code>Requirements</code> type parameter of the <code>runnable</code> effect is now <code>never</code>. This indicates that the effect no longer requires any service to be provided.</p>
<p>With the implementation of the <code>Random</code> service in place, we are able to run the program without any further requirements.</p>
<h2>Extracting the Service Type</h2>
<p>To retrieve the service type from a tag, use the <code>Context.Tag.Service</code> utility type.</p>
<p><strong>Example</strong> (Extracting Service Type)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

// Extracting the type
type RandomShape = Context.Tag.Service&lt;Random&gt;
/*
This is equivalent to:
type RandomShape = {
    readonly next: Effect.Effect&lt;number&gt;;
}
*/
</code></pre>
<h2>Using Multiple Services</h2>
<p>When we require the usage of more than one service, the process remains similar to what we&#39;ve learned in defining a service, repeated for each service needed.</p>
<p><strong>Example</strong> (Using Random and Logger Services)</p>
<p>Let&#39;s examine an example where we need two services, namely <code>Random</code> and <code>Logger</code>:</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  {
    readonly next: Effect.Effect&lt;number&gt;
  }
&gt;() {}

// Declaring a tag for the logging service
class Logger extends Context.Tag(&quot;MyLoggerService&quot;)&lt;
  Logger,
  {
    readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

const program = Effect.gen(function* () {
  // Acquire instances of the &#39;Random&#39; and &#39;Logger&#39; services
  const random = yield* Random
  const logger = yield* Logger

  const randomNumber = yield* random.next

  yield* logger.log(String(randomNumber))
})
</code></pre>
<p>The <code>program</code> effect now has a <code>Requirements</code> type parameter of <code>Random | Logger</code>:</p>
<pre><code class="language-ts">const program: Effect&lt;void, never, Random | Logger&gt;
</code></pre>
<p>indicating that it requires both the <code>Random</code> and <code>Logger</code> services to be provided.</p>
<p>To execute the <code>program</code>, we need to provide implementations for both services:</p>
<p><strong>Example</strong> (Providing Multiple Services)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  {
    readonly next: Effect.Effect&lt;number&gt;
  }
&gt;() {}

// Declaring a tag for the logging service
class Logger extends Context.Tag(&quot;MyLoggerService&quot;)&lt;
  Logger,
  {
    readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// Provide service implementations for &#39;Random&#39; and &#39;Logger&#39;
const runnable = program.pipe(
  Effect.provideService(Random, {
    next: Effect.sync(() =&gt; Math.random())
  }),
  Effect.provideService(Logger, {
    log: (message) =&gt; Effect.sync(() =&gt; console.log(message))
  })
)
</code></pre>
<p>Alternatively, instead of calling <code>provideService</code> multiple times, we can combine the service implementations into a single <code>Context</code> and then provide the entire context using the <code>Effect.provide</code> function:</p>
<p><strong>Example</strong> (Combining Service Implementations)</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  {
    readonly next: Effect.Effect&lt;number&gt;
  }
&gt;() {}

// Declaring a tag for the logging service
class Logger extends Context.Tag(&quot;MyLoggerService&quot;)&lt;
  Logger,
  {
    readonly log: (message: string) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// Combine service implementations into a single &#39;Context&#39;
const context = Context.empty().pipe(
  Context.add(Random, { next: Effect.sync(() =&gt; Math.random()) }),
  Context.add(Logger, {
    log: (message) =&gt; Effect.sync(() =&gt; console.log(message))
  })
)

// Provide the entire context
const runnable = Effect.provide(program, context)
</code></pre>
<h2>Optional Services</h2>
<p>There are situations where we may want to access a service implementation only if it is available.
In such cases, we can use the <code>Effect.serviceOption</code> function to handle this scenario.</p>
<p>The <code>Effect.serviceOption</code> function returns an implementation that is available only if it is actually provided before executing this effect.
To represent this optionality it returns an <a href="/docs/data-types/option/">Option</a> of the implementation.</p>
<p><strong>Example</strong> (Handling Optional Services)</p>
<p>To determine what action to take, we can use the <code>Option.isNone</code> function provided by the Option module. This function allows us to check if the service is available or not by returning <code>true</code> when the service is not available.</p>
<pre><code class="language-ts">import { Effect, Context, Option } from &quot;effect&quot;

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag(&quot;MyRandomService&quot;)&lt;
  Random,
  { readonly next: Effect.Effect&lt;number&gt; }
&gt;() {}

const program = Effect.gen(function* () {
  const maybeRandom = yield* Effect.serviceOption(Random)
  const randomNumber = Option.isNone(maybeRandom)
    ? // the service is not available, return a default value
      -1
    : // the service is available
      yield* maybeRandom.value.next
  console.log(randomNumber)
})
</code></pre>
<p>In the code above, we can observe that the <code>Requirements</code> type parameter of the <code>program</code> effect is <code>never</code>, even though we are working with a service. This allows us to access something from the context only if it is actually provided before executing this effect.</p>
<p>When we run the <code>program</code> effect without providing the <code>Random</code> service:</p>
<pre><code class="language-ts">Effect.runPromise(program).then(console.log)
// Output: -1
</code></pre>
<p>We see that the log message contains <code>-1</code>, which is the default value we provided when the service was not available.</p>
<p>However, if we provide the <code>Random</code> service implementation:</p>
<pre><code class="language-ts">Effect.runPromise(
  Effect.provideService(program, Random, {
    next: Effect.sync(() =&gt; Math.random())
  })
).then(console.log)
// Example Output: 0.9957979486841035
</code></pre>
<p>We can observe that the log message now contains a random number generated by the <code>next</code> operation of the <code>Random</code> service.</p>
<h2>Handling Services with Dependencies</h2>
<p>Sometimes a service in your application may depend on other services. To maintain a clean architecture, it&#39;s important to manage these dependencies without making them explicit in the service interface. Instead, you can use <strong>layers</strong> to handle these dependencies during the service construction phase.</p>
<p><strong>Example</strong> (Defining a Logger Service with a Configuration Dependency)</p>
<p>Consider a scenario where multiple services depend on each other. In this case, the <code>Logger</code> service requires access to a configuration service (<code>Config</code>).</p>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

// Declaring a tag for the Config service
class Config extends Context.Tag(&quot;Config&quot;)&lt;Config, {}&gt;() {}

// Declaring a tag for the logging service
class Logger extends Context.Tag(&quot;MyLoggerService&quot;)&lt;
  Logger,
  {
    // ❌ Avoid exposing Config as a requirement
    readonly log: (message: string) =&gt; Effect.Effect&lt;void, never, Config&gt;
  }
&gt;() {}
</code></pre>
<p>To handle these dependencies in a structured way and prevent them from leaking into the service interfaces, you can use the <code>Layer</code> abstraction. For more details on managing dependencies with layers, refer to the <a href="/docs/requirements-management/layers/">Managing Layers</a> page.</p>
<Aside type="tip" title="Use Layers for Dependencies">
  When a service has its own requirements, it's best to separate
  implementation details into layers. Layers act as **constructors for
  creating the service**, allowing us to handle dependencies at the
  construction level rather than the service level.
</Aside>


<hr>
<hr>
<h2>title: Patterns
description: Learn how to handle sequential operations in Effect, ensuring either full success or rollback on failure, with efficient error handling and resource management.
sidebar:
  order: 1</h2>
<h2>Sequencing Operations</h2>
<p>In certain scenarios, you might need to perform a sequence of chained operations where the success of each operation depends on the previous one. However, if any of the operations fail, you would want to reverse the effects of all previous successful operations. This pattern is valuable when you need to ensure that either all operations succeed, or none of them have any effect at all.</p>
<p>Effect offers a way to achieve this pattern using the <a href="/docs/resource-management/scope/#defining-resources">Effect.acquireRelease</a> function in combination with the <a href="/docs/data-types/exit/">Exit</a> type.
The <a href="/docs/resource-management/scope/#defining-resources">Effect.acquireRelease</a> function allows you to acquire a resource, perform operations with it, and release the resource when you&#39;re done.
The <a href="/docs/data-types/exit/">Exit</a> type represents the outcome of an effectful computation, indicating whether it succeeded or failed.</p>
<p>Let&#39;s go through an example of implementing this pattern. Suppose we want to create a &quot;Workspace&quot; in our application, which involves creating an S3 bucket, an ElasticSearch index, and a Database entry that relies on the previous two.</p>
<p>To begin, we define the domain model for the required <a href="/docs/requirements-management/services/">services</a>:</p>
<ul>
<li><code>S3</code></li>
<li><code>ElasticSearch</code></li>
<li><code>Database</code></li>
</ul>
<pre><code class="language-ts">import { Effect, Context } from &quot;effect&quot;

class S3Error {
  readonly _tag = &quot;S3Error&quot;
}

interface Bucket {
  readonly name: string
}

class S3 extends Context.Tag(&quot;S3&quot;)&lt;
  S3,
  {
    readonly createBucket: Effect.Effect&lt;Bucket, S3Error&gt;
    readonly deleteBucket: (bucket: Bucket) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class ElasticSearchError {
  readonly _tag = &quot;ElasticSearchError&quot;
}

interface Index {
  readonly id: string
}

class ElasticSearch extends Context.Tag(&quot;ElasticSearch&quot;)&lt;
  ElasticSearch,
  {
    readonly createIndex: Effect.Effect&lt;Index, ElasticSearchError&gt;
    readonly deleteIndex: (index: Index) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class DatabaseError {
  readonly _tag = &quot;DatabaseError&quot;
}

interface Entry {
  readonly id: string
}

class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  {
    readonly createEntry: (
      bucket: Bucket,
      index: Index
    ) =&gt; Effect.Effect&lt;Entry, DatabaseError&gt;
    readonly deleteEntry: (entry: Entry) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}
</code></pre>
<p>Next, we define the three create actions and the overall transaction (<code>make</code>) for the</p>
<pre><code class="language-ts">import { Effect, Context, Exit } from &quot;effect&quot;

class S3Error {
  readonly _tag = &quot;S3Error&quot;
}

interface Bucket {
  readonly name: string
}

class S3 extends Context.Tag(&quot;S3&quot;)&lt;
  S3,
  {
    readonly createBucket: Effect.Effect&lt;Bucket, S3Error&gt;
    readonly deleteBucket: (bucket: Bucket) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class ElasticSearchError {
  readonly _tag = &quot;ElasticSearchError&quot;
}

interface Index {
  readonly id: string
}

class ElasticSearch extends Context.Tag(&quot;ElasticSearch&quot;)&lt;
  ElasticSearch,
  {
    readonly createIndex: Effect.Effect&lt;Index, ElasticSearchError&gt;
    readonly deleteIndex: (index: Index) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class DatabaseError {
  readonly _tag = &quot;DatabaseError&quot;
}

interface Entry {
  readonly id: string
}

class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  {
    readonly createEntry: (
      bucket: Bucket,
      index: Index
    ) =&gt; Effect.Effect&lt;Entry, DatabaseError&gt;
    readonly deleteEntry: (entry: Entry) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

// Create a bucket, and define the release function that deletes the
// bucket if the operation fails.
const createBucket = Effect.gen(function* () {
  const { createBucket, deleteBucket } = yield* S3
  return yield* Effect.acquireRelease(createBucket, (bucket, exit) =&gt;
    // The release function for the Effect.acquireRelease operation is
    // responsible for handling the acquired resource (bucket) after the
    // main effect has completed. It is called regardless of whether the
    // main effect succeeded or failed. If the main effect failed,
    // Exit.isFailure(exit) will be true, and the function will perform
    // a rollback by calling deleteBucket(bucket). If the main effect
    // succeeded, Exit.isFailure(exit) will be false, and the function
    // will return Effect.void, representing a successful, but
    // do-nothing effect.
    Exit.isFailure(exit) ? deleteBucket(bucket) : Effect.void
  )
})

// Create an index, and define the release function that deletes the
// index if the operation fails.
const createIndex = Effect.gen(function* () {
  const { createIndex, deleteIndex } = yield* ElasticSearch
  return yield* Effect.acquireRelease(createIndex, (index, exit) =&gt;
    Exit.isFailure(exit) ? deleteIndex(index) : Effect.void
  )
})

// Create an entry in the database, and define the release function that
// deletes the entry if the operation fails.
const createEntry = (bucket: Bucket, index: Index) =&gt;
  Effect.gen(function* () {
    const { createEntry, deleteEntry } = yield* Database
    return yield* Effect.acquireRelease(
      createEntry(bucket, index),
      (entry, exit) =&gt;
        Exit.isFailure(exit) ? deleteEntry(entry) : Effect.void
    )
  })

const make = Effect.scoped(
  Effect.gen(function* () {
    const bucket = yield* createBucket
    const index = yield* createIndex
    return yield* createEntry(bucket, index)
  })
)
</code></pre>
<p>We then create simple service implementations to test the behavior of our Workspace code.
To achieve this, we will utilize <a href="/docs/requirements-management/layers/">layers</a> to construct test
These layers will be able to handle various scenarios, including errors, which we can control using the <code>FailureCase</code> type.</p>
<pre><code class="language-ts">import { Effect, Context, Layer, Console, Exit } from &quot;effect&quot;

class S3Error {
  readonly _tag = &quot;S3Error&quot;
}

interface Bucket {
  readonly name: string
}

class S3 extends Context.Tag(&quot;S3&quot;)&lt;
  S3,
  {
    readonly createBucket: Effect.Effect&lt;Bucket, S3Error&gt;
    readonly deleteBucket: (bucket: Bucket) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class ElasticSearchError {
  readonly _tag = &quot;ElasticSearchError&quot;
}

interface Index {
  readonly id: string
}

class ElasticSearch extends Context.Tag(&quot;ElasticSearch&quot;)&lt;
  ElasticSearch,
  {
    readonly createIndex: Effect.Effect&lt;Index, ElasticSearchError&gt;
    readonly deleteIndex: (index: Index) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

class DatabaseError {
  readonly _tag = &quot;DatabaseError&quot;
}

interface Entry {
  readonly id: string
}

class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  {
    readonly createEntry: (
      bucket: Bucket,
      index: Index
    ) =&gt; Effect.Effect&lt;Entry, DatabaseError&gt;
    readonly deleteEntry: (entry: Entry) =&gt; Effect.Effect&lt;void&gt;
  }
&gt;() {}

// Create a bucket, and define the release function that deletes the
// bucket if the operation fails.
const createBucket = Effect.gen(function* () {
  const { createBucket, deleteBucket } = yield* S3
  return yield* Effect.acquireRelease(createBucket, (bucket, exit) =&gt;
    // The release function for the Effect.acquireRelease operation is
    // responsible for handling the acquired resource (bucket) after the
    // main effect has completed. It is called regardless of whether the
    // main effect succeeded or failed. If the main effect failed,
    // Exit.isFailure(exit) will be true, and the function will perform
    // a rollback by calling deleteBucket(bucket). If the main effect
    // succeeded, Exit.isFailure(exit) will be false, and the function
    // will return Effect.void, representing a successful, but
    // do-nothing effect.
    Exit.isFailure(exit) ? deleteBucket(bucket) : Effect.void
  )
})

// Create an index, and define the release function that deletes the
// index if the operation fails.
const createIndex = Effect.gen(function* () {
  const { createIndex, deleteIndex } = yield* ElasticSearch
  return yield* Effect.acquireRelease(createIndex, (index, exit) =&gt;
    Exit.isFailure(exit) ? deleteIndex(index) : Effect.void
  )
})

// Create an entry in the database, and define the release function that
// deletes the entry if the operation fails.
const createEntry = (bucket: Bucket, index: Index) =&gt;
  Effect.gen(function* () {
    const { createEntry, deleteEntry } = yield* Database
    return yield* Effect.acquireRelease(
      createEntry(bucket, index),
      (entry, exit) =&gt;
        Exit.isFailure(exit) ? deleteEntry(entry) : Effect.void
    )
  })

const make = Effect.scoped(
  Effect.gen(function* () {
    const bucket = yield* createBucket
    const index = yield* createIndex
    return yield* createEntry(bucket, index)
  })
)

// The `FailureCaseLiterals` type allows us to provide different error
// scenarios while testing our
//
// For example, by providing the value &quot;S3&quot;, we can simulate an error
// scenario specific to the S3 service. This helps us ensure that our
// program handles errors correctly and behaves as expected in various
// situations.
//
// Similarly, we can provide other values like &quot;ElasticSearch&quot; or
// &quot;Database&quot; to simulate error scenarios for those  In cases
// where we want to test the absence of errors, we can provide
// `undefined`. By using this parameter, we can thoroughly test our
// services and verify their behavior under different error conditions.
type FailureCaseLiterals = &quot;S3&quot; | &quot;ElasticSearch&quot; | &quot;Database&quot; | undefined

class FailureCase extends Context.Tag(&quot;FailureCase&quot;)&lt;
  FailureCase,
  FailureCaseLiterals
&gt;() {}

// Create a test layer for the S3 service

const S3Test = Layer.effect(
  S3,
  Effect.gen(function* () {
    const failureCase = yield* FailureCase
    return {
      createBucket: Effect.gen(function* () {
        console.log(&quot;[S3] creating bucket&quot;)
        if (failureCase === &quot;S3&quot;) {
          return yield* Effect.fail(new S3Error())
        } else {
          return { name: &quot;&lt;bucket.name&gt;&quot; }
        }
      }),
      deleteBucket: (bucket) =&gt;
        Console.log(`[S3] delete bucket ${bucket.name}`)
    }
  })
)

// Create a test layer for the ElasticSearch service

const ElasticSearchTest = Layer.effect(
  ElasticSearch,
  Effect.gen(function* () {
    const failureCase = yield* FailureCase
    return {
      createIndex: Effect.gen(function* () {
        console.log(&quot;[ElasticSearch] creating index&quot;)
        if (failureCase === &quot;ElasticSearch&quot;) {
          return yield* Effect.fail(new ElasticSearchError())
        } else {
          return { id: &quot;&lt;index.id&gt;&quot; }
        }
      }),
      deleteIndex: (index) =&gt;
        Console.log(`[ElasticSearch] delete index ${index.id}`)
    }
  })
)

// Create a test layer for the Database service

const DatabaseTest = Layer.effect(
  Database,
  Effect.gen(function* () {
    const failureCase = yield* FailureCase
    return {
      createEntry: (bucket, index) =&gt;
        Effect.gen(function* () {
          console.log(
            &quot;[Database] creating entry for bucket&quot; +
              `${bucket.name} and index ${index.id}`
          )
          if (failureCase === &quot;Database&quot;) {
            return yield* Effect.fail(new DatabaseError())
          } else {
            return { id: &quot;&lt;entry.id&gt;&quot; }
          }
        }),
      deleteEntry: (entry) =&gt;
        Console.log(`[Database] delete entry ${entry.id}`)
    }
  })
)

// Merge all the test layers for S3, ElasticSearch, and Database
// services into a single layer
const layer = Layer.mergeAll(S3Test, ElasticSearchTest, DatabaseTest)

// Create a runnable effect to test the Workspace code. The effect is
// provided with the test layer and a FailureCase service with undefined
// value (no failure case).
const runnable = make.pipe(
  Effect.provide(layer),
  Effect.provideService(FailureCase, undefined)
)

Effect.runPromise(Effect.either(runnable)).then(console.log)
</code></pre>
<p>Let&#39;s examine the test results for the scenario where <code>FailureCase</code> is set to <code>undefined</code> (happy path):</p>
<pre><code class="language-ansi">[S3] creating bucket
[ElasticSearch] creating index
[Database] creating entry for bucket &lt;bucket.name&gt; and index &lt;index.id&gt;
{
  _id: &quot;Either&quot;,
  _tag: &quot;Right&quot;,
  right: {
    id: &quot;&lt;entry.id&gt;&quot;
  }
}
</code></pre>
<p>In this case, all operations succeed, and we see a successful result with <code>right({ id: &#39;&lt;entry.id&gt;&#39; })</code>.</p>
<p>Now, let&#39;s simulate a failure in the <code>Database</code>:</p>
<pre><code class="language-ts">const runnable = make.pipe(
  Effect.provide(layer),
  Effect.provideService(FailureCase, &quot;Database&quot;)
)
</code></pre>
<p>The console output will be:</p>
<pre><code class="language-ansi">[S3] creating bucket
[ElasticSearch] creating index
[Database] creating entry for bucket &lt;bucket.name&gt; and index &lt;index.id&gt;
[ElasticSearch] delete index &lt;index.id&gt;
[S3] delete bucket &lt;bucket.name&gt;
{
  _id: &quot;Either&quot;,
  _tag: &quot;Left&quot;,
  left: {
    _tag: &quot;DatabaseError&quot;
  }
}
</code></pre>
<p>You can observe that once the <code>Database</code> error occurs, there is a complete rollback that deletes the <code>ElasticSearch</code> index first and then the associated <code>S3</code> bucket. The result is a failure with <code>left(new DatabaseError())</code>.</p>
<p>Let&#39;s now make the index creation fail instead:</p>
<pre><code class="language-ts">const runnable = make.pipe(
  Effect.provide(layer),
  Effect.provideService(FailureCase, &quot;ElasticSearch&quot;)
)
</code></pre>
<p>In this case, the console output will be:</p>
<pre><code class="language-ansi">[S3] creating bucket
[ElasticSearch] creating index
[S3] delete bucket &lt;bucket.name&gt;
{
  _id: &quot;Either&quot;,
  _tag: &quot;Left&quot;,
  left: {
    _tag: &quot;ElasticSearchError&quot;
  }
}
</code></pre>
<p>As expected, once the <code>ElasticSearch</code> index creation fails, there is a rollback that deletes the <code>S3</code> bucket. The result is a failure with <code>left(new ElasticSearchError())</code>.</p>
<hr>
<hr>
<h2>title: Scope
description: Learn how Effect simplifies resource management with Scopes, ensuring efficient cleanup and safe resource handling in long-running applications.
sidebar:
  order: 0</h2>
<p>import { Aside, Tabs, TabItem } from &quot;@astrojs/starlight/components&quot;</p>
<p>In long-running applications, managing resources efficiently is essential, particularly when building large-scale systems. If resources like socket connections, database connections, or file descriptors are not properly managed, it can lead to resource leaks, which degrade application performance and reliability. Effect provides constructs that help ensure resources are properly managed and released, even in cases where exceptions occur.</p>
<p>By ensuring that every time a resource is acquired, there is a corresponding mechanism to release it, Effect simplifies the process of resource management in your application.</p>
<h2>The Scope Data Type</h2>
<p>The <code>Scope</code> data type is a core construct in Effect for managing resources in a safe and composable way.</p>
<p>A scope represents the lifetime of one or more resources. When the scope is closed, all the resources within it are released, ensuring that no resources are leaked. Scopes also allow the addition of <strong>finalizers</strong>, which define how to release resources.</p>
<p>With the <code>Scope</code> data type, you can:</p>
<ul>
<li><strong>Add finalizers</strong>: A finalizer specifies the cleanup logic for a resource.</li>
<li><strong>Close the scope</strong>: When the scope is closed, all resources are released, and the finalizers are executed.</li>
</ul>
<p><strong>Example</strong> (Managing a Scope)</p>
<pre><code class="language-ts">import { Scope, Effect, Console, Exit } from &quot;effect&quot;

const program =
  // create a new scope
  Scope.make().pipe(
    // add finalizer 1
    Effect.tap((scope) =&gt;
      Scope.addFinalizer(scope, Console.log(&quot;finalizer 1&quot;))
    ),
    // add finalizer 2
    Effect.tap((scope) =&gt;
      Scope.addFinalizer(scope, Console.log(&quot;finalizer 2&quot;))
    ),
    // close the scope
    Effect.andThen((scope) =&gt;
      Scope.close(scope, Exit.succeed(&quot;scope closed successfully&quot;))
    )
  )

Effect.runPromise(program)
/*
Output:
finalizer 2 &lt;-- finalizers are closed in reverse order
finalizer 1
*/
</code></pre>
<p>In the above example, finalizers are added to the scope, and when the scope is closed, the finalizers are <strong>executed in the reverse order</strong>.</p>
<p>This reverse order is important because it ensures that resources are released in the correct sequence.</p>
<p>For instance, if you acquire a network connection and then access a file on a remote server, the file must be closed before the network connection to avoid errors.</p>
<Aside type="tip" title="High-Level Resource Management">
  Although managing scopes directly with `Scope` is possible, it's more
  common to use higher-level functions like
  [Effect.addFinalizer](#addfinalizer) or
  [Effect.acquireUseRelease](#acquireuserelease), which handle much of the
  complexity for you.
</Aside>

<h2>addFinalizer</h2>
<p>The <code>Effect.addFinalizer</code> function is a high-level API that allows you to add finalizers to the scope of an effect. A finalizer is a piece of code that is guaranteed to run when the associated scope is closed. The behavior of the finalizer can vary based on the <a href="/docs/data-types/exit/">Exit</a> value, which represents how the scope was closed—whether successfully or with an error.</p>
<p><strong>Example</strong> (Adding a Finalizer on Success)</p>
<Tabs syncKey="pipe-vs-gen">

<TabItem label="Using Effect.gen">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;string, never, Scope&gt;
//      ▼
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =&gt;
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return &quot;some result&quot;
})

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Success
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;some result&#39; }
*/
</code></pre>
</TabItem>

<TabItem label="Using pipe">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;string, never, Scope&gt;
//      ▼
const program = Effect.addFinalizer((exit) =&gt;
  Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
).pipe(Effect.andThen(Effect.succeed(&quot;some result&quot;)))

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;string, never, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Success
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;some result&#39; }
*/
</code></pre>
</TabItem>

</Tabs>

<p>In this example, we use <code>Effect.addFinalizer</code> to add a finalizer that logs the exit state after the scope is closed. The finalizer will execute when the effect finishes, and it will log whether the effect completed successfully or failed.</p>
<p>The type signature:</p>
<pre><code class="language-ts">const program: Effect&lt;string, never, Scope&gt;
</code></pre>
<p>shows that the workflow requires a <code>Scope</code> to run. You can provide this <code>Scope</code> using the <code>Effect.scoped</code> function, which creates a new scope, runs the effect within it, and ensures the finalizers are executed when the scope is closed.</p>
<Aside type="note" title="Finalizer Execution Order">
  Finalizers are executed in reverse order of how they were added,
  ensuring that resources are released in the proper sequence, just like
  in stack unwinding.
</Aside>

<p><strong>Example</strong> (Adding a Finalizer on Failure)</p>
<Tabs syncKey="pipe-vs-gen">

<TabItem label="Using Effect.gen">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;never, string, Scope&gt;
//      ▼
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =&gt;
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.fail(&quot;Uh oh!&quot;)
})

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;never, string, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Failure
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Uh oh!&#39; }
}
*/
</code></pre>
</TabItem>

<TabItem label="Using pipe">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;never, string, Scope&gt;
//      ▼
const program = Effect.addFinalizer((exit) =&gt;
  Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
).pipe(Effect.andThen(Effect.fail(&quot;Uh oh!&quot;)))

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;never, string, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Failure
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Uh oh!&#39; }
}
*/
</code></pre>
</TabItem>

</Tabs>

<p>In this case, the finalizer is executed even when the effect fails. The log output reflects that the finalizer runs after the failure, and it logs the failure details.</p>
<p><strong>Example</strong> (Adding a Finalizer on <a href="/docs/concurrency/basic-concurrency/#interruptions">Interruption</a>)</p>
<Tabs syncKey="pipe-vs-gen">

<TabItem label="Using Effect.gen">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;never, never, Scope&gt;
//      ▼
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =&gt;
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.interrupt
})

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;never, never, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Failure
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Interrupt&#39;,
    fiberId: {
      _id: &#39;FiberId&#39;,
      _tag: &#39;Runtime&#39;,
      id: 0,
      startTimeMillis: ...
    }
  }
}
*/
</code></pre>
</TabItem>

<TabItem label="Using pipe">

<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

//      ┌─── Effect&lt;never, never, Scope&gt;
//      ▼
const program = Effect.addFinalizer((exit) =&gt;
  Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
).pipe(Effect.andThen(Effect.interrupt))

// Wrapping the effect in a scope
//
//      ┌─── Effect&lt;never, never, never&gt;
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
/*
Output:
Finalizer executed. Exit status: Failure
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Interrupt&#39;,
    fiberId: {
      _id: &#39;FiberId&#39;,
      _tag: &#39;Runtime&#39;,
      id: 0,
      startTimeMillis: ...
    }
  }
}
*/
</code></pre>
</TabItem>

</Tabs>

<p>This example shows how a finalizer behaves when the effect is interrupted. The finalizer runs after the interruption, and the exit status reflects that the effect was stopped mid-execution.</p>
<h2>Manually Create and Close Scopes</h2>
<p>When you&#39;re working with multiple scoped resources within a single operation, it&#39;s important to understand how their scopes interact.
By default, these scopes are merged into one, but you can have more fine-grained control over when each scope is closed by manually creating and closing them.</p>
<p>Let&#39;s start by looking at how scopes are merged by default:</p>
<p><strong>Example</strong> (Merging Scopes)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;task 1&quot;)
  yield* Effect.addFinalizer(() =&gt; Console.log(&quot;finalizer after task 1&quot;))
})

const task2 = Effect.gen(function* () {
  console.log(&quot;task 2&quot;)
  yield* Effect.addFinalizer(() =&gt; Console.log(&quot;finalizer after task 2&quot;))
})

const program = Effect.gen(function* () {
  // The scopes of both tasks are merged into one
  yield* task1
  yield* task2
})

Effect.runPromise(Effect.scoped(program))
/*
Output:
task 1
task 2
finalizer after task 2
finalizer after task 1
*/
</code></pre>
<p>In this case, the scopes of <code>task1</code> and <code>task2</code> are merged into a single scope, and when the program is run, it outputs the tasks and their finalizers in a specific order.</p>
<p>If you want more control over when each scope is closed, you can manually create and close them:</p>
<p><strong>Example</strong> (Manually Creating and Closing Scopes)</p>
<pre><code class="language-ts">import { Console, Effect, Exit, Scope } from &quot;effect&quot;

const task1 = Effect.gen(function* () {
  console.log(&quot;task 1&quot;)
  yield* Effect.addFinalizer(() =&gt; Console.log(&quot;finalizer after task 1&quot;))
})

const task2 = Effect.gen(function* () {
  console.log(&quot;task 2&quot;)
  yield* Effect.addFinalizer(() =&gt; Console.log(&quot;finalizer after task 2&quot;))
})

const program = Effect.gen(function* () {
  const scope1 = yield* Scope.make()
  const scope2 = yield* Scope.make()

  // Extend the scope of task1 into scope1
  yield* task1.pipe(Scope.extend(scope1))

  // Extend the scope of task2 into scope2
  yield* task2.pipe(Scope.extend(scope2))

  // Manually close scope1 and scope2
  yield* Scope.close(scope1, Exit.void)
  yield* Console.log(&quot;doing something else&quot;)
  yield* Scope.close(scope2, Exit.void)
})

Effect.runPromise(program)
/*
Output:
task 1
task 2
finalizer after task 1
doing something else
finalizer after task 2
*/
</code></pre>
<p>In this example, we create two separate scopes, <code>scope1</code> and <code>scope2</code>, and extend the scope of each task into its respective scope. When you run the program, it outputs the tasks and their finalizers in a different order.</p>
<Aside type="note" title="Extending a Scope">
  The `Scope.extend` function allows you to extend the scope of an effect
  workflow that requires a scope into another scope without closing the
  scope when the workflow finishes executing. This allows you to extend a
  scoped value into a larger scope.
</Aside>

<p>You might wonder what happens when a scope is closed, but a task within that scope hasn&#39;t completed yet.
The key point to note is that the scope closing doesn&#39;t force the task to be interrupted.</p>
<p><strong>Example</strong> (Closing a Scope with Pending Tasks)</p>
<pre><code class="language-ts">import { Console, Effect, Exit, Scope } from &quot;effect&quot;

const task = Effect.gen(function* () {
  yield* Effect.sleep(&quot;1 second&quot;)
  console.log(&quot;Executed&quot;)
  yield* Effect.addFinalizer(() =&gt; Console.log(&quot;Task Finalizer&quot;))
})

const program = Effect.gen(function* () {
  const scope = yield* Scope.make()

  // Close the scope immediately
  yield* Scope.close(scope, Exit.void)
  console.log(&quot;Scope closed&quot;)

  // This task will be executed even if the scope is closed
  yield* task.pipe(Scope.extend(scope))
})

Effect.runPromise(program)
/*
Output:
Scope closed
Executed &lt;-- after 1 second
Task Finalizer
*/
</code></pre>
<h2>Finalization</h2>
<p>In many languages, the <code>try</code> / <code>finally</code> construct provides a way to ensure that, when the try block finishes (normally or with an error), the code in the finally block always runs. Effect offers a similar feature through the <code>Effect.ensuring</code> function.</p>
<p>For higher-level approaches with automatic acquisition and release, see the <a href="#acquirerelease">acquireRelease</a> family of functions.</p>
<h3>ensuring</h3>
<p>This function makes sure a finalizer effect always runs once the main effect begins, whether the effect succeeds, fails, or is interrupted.</p>
<p>This can be helpful when you need cleanup steps or final actions in all situations, such as releasing resources or logging messages.</p>
<p>If you need access to the effect&#39;s result, consider using <a href="#onexit">onExit</a>.</p>
<p><strong>Example</strong> (Running a Finalizer in All Outcomes)</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

const handler = Effect.ensuring(Console.log(&quot;Cleanup completed&quot;))

const success = Console.log(&quot;Task completed&quot;).pipe(
  Effect.as(&quot;some result&quot;),
  handler
)

Effect.runFork(success)
/*
Output:
Task completed
Cleanup completed
*/

const failure = Console.log(&quot;Task failed&quot;).pipe(
  Effect.andThen(Effect.fail(&quot;some error&quot;)),
  handler
)

Effect.runFork(failure)
/*
Output:
Task failed
Cleanup completed
*/

const interruption = Console.log(&quot;Task interrupted&quot;).pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
/*
Output:
Task interrupted
Cleanup completed
*/
</code></pre>
<h3>onExit</h3>
<p>This function runs a cleanup step once the main effect finishes, regardless of whether it succeeds, fails, or is interrupted.</p>
<p>It passes the <a href="/docs/data-types/exit/">Exit</a> value to the cleanup function, which reveals how the effect ended:</p>
<ul>
<li>If the effect succeeds, the <code>Exit</code> holds the success value.</li>
<li>If it fails, the <code>Exit</code> includes the error or failure cause.</li>
<li>If it is interrupted, the <code>Exit</code> reflects that interruption.</li>
</ul>
<p>The cleanup step itself is uninterruptible, which can help manage resources in complex or high-concurrency cases.</p>
<p><strong>Example</strong> (Running a Cleanup Function in All Outcomes)</p>
<pre><code class="language-ts">import { Console, Effect, Exit } from &quot;effect&quot;

// Define a cleanup function that logs the outcome of the effect
const handler = Effect.onExit((exit) =&gt;
  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
)

const success = Console.log(&quot;Task completed&quot;).pipe(
  Effect.as(&quot;some result&quot;),
  handler
)

Effect.runFork(success)
/*
Output:
Task completed
Cleanup completed: some result
*/

const failure = Console.log(&quot;Task failed&quot;).pipe(
  Effect.andThen(Effect.fail(&quot;some error&quot;)),
  handler
)

Effect.runFork(failure)
/*
Output:
Task failed
Cleanup completed: Error: some error
*/

const interruption = Console.log(&quot;Task interrupted&quot;).pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
/*
Output:
Task interrupted
Cleanup completed: All fibers interrupted without errors.
*/
</code></pre>
<h3>onError</h3>
<p>This function lets you attach a cleanup effect that runs whenever the calling effect fails, passing the cause of the failure to the cleanup effect.</p>
<p>You can use it to perform actions such as logging, releasing resources, or applying additional recovery steps.</p>
<p>The cleanup effect will also run if the failure is caused by interruption, and it is uninterruptible, so it always finishes once it starts.</p>
<p><strong>Example</strong> (Cleanup on Failure)</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

// This handler logs the failure cause when the effect fails
const handler = Effect.onError((cause) =&gt;
  Console.log(`Cleanup completed: ${cause}`)
)

const success = Console.log(&quot;Task completed&quot;).pipe(
  Effect.as(&quot;some result&quot;),
  handler
)

Effect.runFork(success)
/*
Output:
Task completed
*/

const failure = Console.log(&quot;Task failed&quot;).pipe(
  Effect.andThen(Effect.fail(&quot;some error&quot;)),
  handler
)

Effect.runFork(failure)
/*
Output:
Task failed
Cleanup completed: Error: some error
*/

const interruption = Console.log(&quot;Task interrupted&quot;).pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
/*
Output:
Task interrupted
Cleanup completed: All fibers interrupted without errors.
*/
</code></pre>
<h2>Defining Resources</h2>
<h3>acquireRelease</h3>
<p>The <code>Effect.acquireRelease(acquire, release)</code> function allows you to define resources that are acquired and safely released when they are no longer needed. This is useful for managing resources such as file handles, database connections, or network sockets.</p>
<p>To use <code>Effect.acquireRelease</code>, you need to define three actions:</p>
<ol>
<li><strong>Acquiring the Resource</strong>: An effect describing the acquisition of the resource, e.g., opening a file or establishing a database connection.</li>
<li><strong>Using the Resource</strong>: An effect describing the actual process to produce a result, e.g., reading from the file or querying the database.</li>
<li><strong>Releasing the Resource</strong>: The clean-up effect that ensures the resource is properly released, e.g., closing the file or the connection.</li>
</ol>
<p>The acquisition process is <strong>uninterruptible</strong> to ensure that partial resource acquisition doesn&#39;t leave your system in an inconsistent state.</p>
<p>The <code>Effect.acquireRelease</code> function guarantees that once a resource is successfully acquired, its release step is always executed when the <code>Scope</code> is closed.</p>
<p><strong>Example</strong> (Defining a Simple Resource)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate resource acquisition
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define how the resource is released
const release = (res: MyResource) =&gt; Effect.promise(() =&gt; res.close())

// Create the resource management workflow
//
//      ┌─── Effect&lt;MyResource, Error, Scope&gt;
//      ▼
const resource = Effect.acquireRelease(acquire, release)
</code></pre>
<p>In the code above, the <code>Effect.acquireRelease</code> function creates a resource workflow that requires a <code>Scope</code>:</p>
<pre><code class="language-ts">const resource: Effect&lt;MyResource, Error, Scope&gt;
</code></pre>
<p>This means that the workflow needs a <code>Scope</code> to run, and the resource will automatically be released when the scope is closed.</p>
<p>You can now use the resource by chaining operations using <code>Effect.andThen</code> or similar functions.</p>
<p>We can continue working with the resource for as long as we want by using <code>Effect.andThen</code> or other Effect operators. For example, here&#39;s how we can read the contents:</p>
<p><strong>Example</strong> (Using the Resource)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate resource acquisition
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define how the resource is released
const release = (res: MyResource) =&gt; Effect.promise(() =&gt; res.close())

// Create the resource management workflow
const resource = Effect.acquireRelease(acquire, release)

//      ┌─── Effect&lt;void, Error, Scope&gt;
//      ▼
const program = Effect.gen(function* () {
  const res = yield* resource
  console.log(`content is ${res.contents}`)
})
</code></pre>
<p>To ensure proper resource management, the <code>Scope</code> should be closed when you&#39;re done with the resource. The <code>Effect.scoped</code> function handles this for you by creating a <code>Scope</code>, running the effect, and then closing the <code>Scope</code> when the effect finishes.</p>
<p><strong>Example</strong> (Providing the <code>Scope</code> with <code>Effect.scoped</code>)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate resource acquisition
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define how the resource is released
const release = (res: MyResource) =&gt; Effect.promise(() =&gt; res.close())

// Create the resource management workflow
const resource = Effect.acquireRelease(acquire, release)

//      ┌─── Effect&lt;void, Error, never&gt;
//      ▼
const program = Effect.scoped(
  Effect.gen(function* () {
    const res = yield* resource
    console.log(`content is ${res.contents}`)
  })
)

// We now have a workflow that is ready to run
Effect.runPromise(program)
/*
Resource acquired
content is lorem ipsum
Resource released
*/
</code></pre>
<h3>acquireUseRelease</h3>
<p>The <code>Effect.acquireUseRelease</code> function is a specialized version of the <code>Effect.acquireRelease</code> function that simplifies resource management by automatically handling the scoping of resources.</p>
<pre><code class="language-ts">Effect.acquireUseRelease(acquire, use, release)
</code></pre>
<p>The main difference is that <code>Effect.acquireUseRelease</code> eliminates the need to manually call <code>Effect.scoped</code> to manage the resource&#39;s scope. It has additional knowledge about when you are done using the resource created with the <code>acquire</code> step. This is achieved by providing a <code>use</code> argument, which represents the function that operates on the acquired resource. As a result, <code>Effect.acquireUseRelease</code> can automatically determine when it should execute the release step.</p>
<p><strong>Example</strong> (Automatically Managing Resource Lifetime)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () =&gt; Promise&lt;void&gt;
}

// Simulate resource acquisition
const getMyResource = (): Promise&lt;MyResource&gt; =&gt;
  Promise.resolve({
    contents: &quot;lorem ipsum&quot;,
    close: () =&gt;
      new Promise((resolve) =&gt; {
        console.log(&quot;Resource released&quot;)
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =&gt;
    getMyResource().then((res) =&gt; {
      console.log(&quot;Resource acquired&quot;)
      return res
    }),
  catch: () =&gt; new Error(&quot;getMyResourceError&quot;)
})

// Define how the resource is released
const release = (res: MyResource) =&gt; Effect.promise(() =&gt; res.close())

const use = (res: MyResource) =&gt; Console.log(`content is ${res.contents}`)

//      ┌─── Effect&lt;void, Error, never&gt;
//      ▼
const program = Effect.acquireUseRelease(acquire, use, release)

Effect.runPromise(program)
/*
Output:
Resource acquired
content is lorem ipsum
Resource released
*/
</code></pre>
<hr>
<hr>
<h2>title: Introduction to Runtime
description: Learn how Effect&#39;s runtime system executes concurrent programs, manages resources, and handles configuration with flexibility and efficiency.
sidebar:
  label: Runtime
  order: 6</h2>
<p>The <code>Runtime&lt;R&gt;</code> data type represents a runtime system that can <strong>execute effects</strong>. To run an effect, <code>Effect&lt;A, E, R&gt;</code>, we need a <code>Runtime&lt;R&gt;</code> that contains the required resources, denoted by the <code>R</code> type parameter.</p>
<p>A <code>Runtime&lt;R&gt;</code> consists of three main components:</p>
<ul>
<li>A value of type <code>Context&lt;R&gt;</code></li>
<li>A value of type <code>FiberRefs</code></li>
<li>A value of type <code>RuntimeFlags</code></li>
</ul>
<h2>What is a Runtime System?</h2>
<p>When we write an Effect program, we construct an <code>Effect</code> using constructors and combinators.
Essentially, we are creating a blueprint of a program.
An <code>Effect</code> is merely a data structure that describes the execution of a concurrent program.
It represents a tree-like structure that combines various primitives to define what the effect should do.</p>
<p>However, this data structure itself does not perform any actions, it is solely a description of a concurrent program.</p>
<p>To execute this program, the Effect runtime system comes into play. The <code>Runtime.run*</code> functions (e.g., <code>Runtime.runPromise</code>, <code>Runtime.runFork</code>) are responsible for taking this blueprint and executing it.</p>
<p>When the runtime system runs an effect, it creates a root fiber, initializing it with:</p>
<ul>
<li>The initial <a href="/docs/requirements-management/services/#how-it-works">context</a></li>
<li>The initial <code>FiberRefs</code></li>
<li>The initial effect</li>
</ul>
<p>It then starts a loop, executing the instructions described by the <code>Effect</code> step by step.</p>
<p>You can think of the runtime as a system that takes an <a href="/docs/getting-started/the-effect-type/"><code>Effect&lt;A, E, R&gt;</code></a> and its associated context <code>Context&lt;R&gt;</code> and produces an <a href="/docs/data-types/exit/"><code>Exit&lt;A, E&gt;</code></a> result.</p>
<pre><code class="language-text">┌────────────────────────────────┐
│  Context&lt;R&gt; + Effect&lt;A, E, R&gt;  │
└────────────────────────────────┘
               │
               ▼
┌────────────────────────────────┐
│      Effect Runtime System     │
└────────────────────────────────┘
               │
               ▼
┌────────────────────────────────┐
│          Exit&lt;A, E&gt;            │
└────────────────────────────────┘
</code></pre>
<p>Runtime Systems have a lot of responsibilities:</p>
<table>
<thead>
<tr>
<th>Responsibility</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Executing the program</strong></td>
<td>The runtime must execute every step of the effect in a loop until the program completes.</td>
</tr>
<tr>
<td><strong>Handling errors</strong></td>
<td>It handles both expected and unexpected errors that occur during execution.</td>
</tr>
<tr>
<td><strong>Managing concurrency</strong></td>
<td>The runtime spawns new fibers when <code>Effect.fork</code> is called to handle concurrent operations.</td>
</tr>
<tr>
<td><strong>Cooperative yielding</strong></td>
<td>It ensures fibers don&#39;t monopolize resources, yielding control when necessary.</td>
</tr>
<tr>
<td><strong>Ensuring resource cleanup</strong></td>
<td>The runtime guarantees finalizers run properly to clean up resources when needed.</td>
</tr>
<tr>
<td><strong>Handling async callbacks</strong></td>
<td>The runtime deals with asynchronous operations transparently, allowing you to write async and sync code uniformly.</td>
</tr>
</tbody></table>
<h2>The Default Runtime</h2>
<p>When we use <a href="/docs/getting-started/running-effects/">functions that run effects</a> like <code>Effect.runPromise</code> or <code>Effect.runFork</code>, we are actually using the <strong>default runtime</strong> without explicitly mentioning it. These functions are designed as convenient shortcuts for executing our effects using the default runtime.</p>
<p>Each of the <code>Effect.run*</code> functions internally calls the corresponding <code>Runtime.run*</code> function, passing in the default runtime. For example, <code>Effect.runPromise</code> is just an alias for <code>Runtime.runPromise(defaultRuntime)</code>.</p>
<p>Both of the following executions are functionally equivalent:</p>
<p><strong>Example</strong> (Running an Effect Using the Default Runtime)</p>
<pre><code class="language-ts">import { Effect, Runtime } from &quot;effect&quot;

const program = Effect.log(&quot;Application started!&quot;)

Effect.runPromise(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Application started!&quot;
*/

Runtime.runPromise(Runtime.defaultRuntime)(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Application started!&quot;
*/
</code></pre>
<p>In both cases, the program runs using the default runtime, producing the same output.</p>
<p>The default runtime includes:</p>
<ul>
<li>An empty <a href="/docs/requirements-management/services/#how-it-works">context</a></li>
<li>A set of <code>FiberRefs</code> that include the <a href="/docs/requirements-management/default-services/">default services</a></li>
<li>A default configuration for <code>RuntimeFlags</code> that enables <code>Interruption</code> and <code>CooperativeYielding</code></li>
</ul>
<p>In most scenarios, using the default runtime is sufficient for effect execution.
However, there are cases where it&#39;s helpful to create a custom runtime, particularly when you need to reuse specific configurations or contexts.</p>
<p>For example, in a React app or when executing operations on a server in response to API requests, you might create a <code>Runtime&lt;R&gt;</code> by initializing a <a href="/docs/requirements-management/layers/">layer</a> <code>Layer&lt;R, Err, RIn&gt;</code>. This allows you to maintain a consistent context across different execution boundaries.</p>
<h2>Locally Scoped Runtime Configuration</h2>
<p>In Effect, runtime configurations are typically <strong>inherited</strong> from their parent workflows.
This means that when we access a runtime configuration or obtain a runtime inside a workflow, we are essentially using the configuration of the parent workflow.</p>
<p>However, there are cases where we want to temporarily <strong>override the runtime configuration for a specific part</strong> of our code.
This concept is known as locally scoped runtime configuration.
Once the execution of that code region is completed, the runtime configuration <strong>reverts</strong> to its original settings.</p>
<p>To achieve this, we make use of the <code>Effect.provide</code> function, which allow us to provide a new runtime configuration to a specific section of our code.</p>
<p><strong>Example</strong> (Overriding the Logger Configuration)</p>
<p>In this example, we create a simple logger using <code>Logger.replace</code>, which replaces the default logger with a custom one that logs messages without timestamps or levels. We then use <code>Effect.provide</code> to apply this custom logger to the program.</p>
<pre><code class="language-ts">import { Logger, Effect } from &quot;effect&quot;

const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  // Custom logger implementation
  Logger.make(({ message }) =&gt; console.log(message))
)

const program = Effect.gen(function* () {
  yield* Effect.log(&quot;Application started!&quot;)
  yield* Effect.log(&quot;Application is about to exit!&quot;)
})

// Running with the default logger
Effect.runFork(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Application started!&quot;
timestamp=... level=INFO fiber=#0 message=&quot;Application is about to exit!&quot;
*/

// Overriding the default logger with a custom one
Effect.runFork(program.pipe(Effect.provide(addSimpleLogger)))
/*
Output:
[ &#39;Application started!&#39; ]
[ &#39;Application is about to exit!&#39; ]
*/
</code></pre>
<p>To ensure that the runtime configuration is only applied to a specific part of an Effect application, we should provide the configuration layer exclusively to that particular section.</p>
<p><strong>Example</strong> (Providing a configuration layer to a nested workflow)</p>
<p>In this example, we demonstrate how to apply a custom logger configuration only to a specific section of the program. The default logger is used for most of the program, but when we apply the <code>Effect.provide(addSimpleLogger)</code> call, it overrides the logger within that specific nested block. After that, the configuration reverts to its original state.</p>
<pre><code class="language-ts">import { Logger, Effect } from &quot;effect&quot;

const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  // Custom logger implementation
  Logger.make(({ message }) =&gt; console.log(message))
)

const removeDefaultLogger = Logger.remove(Logger.defaultLogger)

const program = Effect.gen(function* () {
  // Logs with default logger
  yield* Effect.log(&quot;Application started!&quot;)

  yield* Effect.gen(function* () {
    // This log is suppressed
    yield* Effect.log(&quot;I&#39;m not going to be logged!&quot;)

    // Custom logger applied here
    yield* Effect.log(&quot;I will be logged by the simple logger.&quot;).pipe(
      Effect.provide(addSimpleLogger)
    )

    // This log is suppressed
    yield* Effect.log(
      &quot;Reset back to the previous configuration, so I won&#39;t be logged.&quot;
    )
  }).pipe(
    // Remove the default logger temporarily
    Effect.provide(removeDefaultLogger)
  )

  // Logs with default logger again
  yield* Effect.log(&quot;Application is about to exit!&quot;)
})

Effect.runSync(program)
/*
Output:
timestamp=... level=INFO fiber=#0 message=&quot;Application started!&quot;
[ &#39;I will be logged by the simple logger.&#39; ]
timestamp=... level=INFO fiber=#0 message=&quot;Application is about to exit!&quot;
*/
</code></pre>
<h2>ManagedRuntime</h2>
<p>When developing an Effect application and using <code>Effect.run*</code> functions to execute it, the application is automatically run using the default runtime behind the scenes. While it’s possible to adjust specific parts of the application by providing locally scoped configuration layers using <code>Effect.provide</code>, there are scenarios where you might want to <strong>customize the runtime configuration for the entire application</strong> from the top level.</p>
<p>In these cases, you can create a top-level runtime by converting a configuration layer into a runtime using the <code>ManagedRuntime.make</code> constructor.</p>
<p><strong>Example</strong> (Creating and Using a Custom Managed Runtime)</p>
<p>In this example, we first create a custom configuration layer called <code>appLayer</code>, which replaces the default logger with a simple one that logs messages to the console. Next, we use <code>ManagedRuntime.make</code> to turn this configuration layer into a runtime.</p>
<pre><code class="language-ts">import { Effect, ManagedRuntime, Logger } from &quot;effect&quot;

// Define a configuration layer that replaces the default logger
const appLayer = Logger.replace(
  Logger.defaultLogger,
  // Custom logger implementation
  Logger.make(({ message }) =&gt; console.log(message))
)

// Create a custom runtime from the configuration layer
const runtime = ManagedRuntime.make(appLayer)

const program = Effect.log(&quot;Application started!&quot;)

// Execute the program using the custom runtime
runtime.runSync(program)

// Clean up resources associated with the custom runtime
Effect.runFork(runtime.disposeEffect)
/*
Output:
[ &#39;Application started!&#39; ]
*/
</code></pre>
<h3>Effect.Tag</h3>
<p>When working with runtimes that you pass around, <code>Effect.Tag</code> can help simplify the access to services. It lets you define a new tag and embed the service shape directly into the static properties of the tag class.</p>
<p><strong>Example</strong> (Defining a Tag for Notifications)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

class Notifications extends Effect.Tag(&quot;Notifications&quot;)&lt;
  Notifications,
  { readonly notify: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}
</code></pre>
<p>In this setup, the fields of the service (in this case, the <code>notify</code> method) are turned into static properties of the <code>Notifications</code> class, making it easier to access them.</p>
<p>This allows you to interact with the service directly:</p>
<p><strong>Example</strong> (Using the Notifications Tag)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

class Notifications extends Effect.Tag(&quot;Notifications&quot;)&lt;
  Notifications,
  { readonly notify: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {}

// Create an effect that depends on the Notifications service
const action = Notifications.notify(&quot;Hello, world!&quot;)
//    ^? const action: Effect&lt;void, never, Notifications&gt;
</code></pre>
<p>In this example, the <code>action</code> effect depends on the <code>Notifications</code> service. This approach allows you to reference services without manually passing them around. Later, you can create a <code>Layer</code> that provides the <code>Notifications</code> service and build a <code>ManagedRuntime</code> with that layer to ensure the service is available where needed.</p>
<h3>Integrations</h3>
<p>The <code>ManagedRuntime</code> simplifies the integration of services and layers with other frameworks or tools, particularly in environments where Effect is not the primary framework and access to the main entry point is restricted.</p>
<p>For example, in environments like React or other frameworks where you have limited control over the main application entry point, <code>ManagedRuntime</code> helps manage the lifecycle of services.</p>
<p>Here&#39;s how to manage a service&#39;s lifecycle within an external framework:</p>
<p><strong>Example</strong> (Using <code>ManagedRuntime</code> in an External Framework)</p>
<pre><code class="language-ts">import { Effect, ManagedRuntime, Layer, Console } from &quot;effect&quot;

// Define the Notifications service using Effect.Tag
class Notifications extends Effect.Tag(&quot;Notifications&quot;)&lt;
  Notifications,
  { readonly notify: (message: string) =&gt; Effect.Effect&lt;void&gt; }
&gt;() {
  // Provide a live implementation of the Notifications service
  static Live = Layer.succeed(this, {
    notify: (message) =&gt; Console.log(message)
  })
}

// Example entry point for an external framework
async function main() {
  // Create a custom runtime using the Notifications layer
  const runtime = ManagedRuntime.make(Notifications.Live)

  // Run the effect
  await runtime.runPromise(Notifications.notify(&quot;Hello, world!&quot;))

  // Dispose of the runtime, cleaning up resources
  await runtime.dispose()
}
</code></pre>
<hr>
<hr>
<h2>title: Built-In Schedules
description: Explore built-in scheduling patterns in Effect for efficient timed repetitions and delays.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>To demonstrate the functionality of different schedules, we will use the following helper function
that logs each repetition along with the corresponding delay in milliseconds, formatted as:</p>
<pre><code class="language-text">#&lt;repetition&gt;: &lt;delay in ms&gt;
</code></pre>
<p><strong>Helper</strong> (Logging Execution Delays)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10 // Limit the number of executions
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot; // Indicate truncation if there are more executions
        : i === delays.length - 1
        ? &quot;(end)&quot; // Mark the last execution
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}
</code></pre>
<h2>Infinite and Fixed Repeats</h2>
<h3>forever</h3>
<p>A schedule that repeats indefinitely, producing the number of recurrences each time it runs.</p>
<p><strong>Example</strong> (Indefinitely Recurring Schedule)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.forever

log(schedule)
/*
Output:
#1: 0ms &lt; forever
#2: 0ms
#3: 0ms
#4: 0ms
#5: 0ms
#6: 0ms
#7: 0ms
#8: 0ms
#9: 0ms
#10: 0ms
...
*/
</code></pre>
<h3>once</h3>
<p>A schedule that recurs only once.</p>
<p><strong>Example</strong> (Single Recurrence Schedule)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.once

log(schedule)
/*
Output:
#1: 0ms &lt; once
(end)
*/
</code></pre>
<h3>recurs</h3>
<p>A schedule that repeats a specified number of times, producing the number of recurrences each time it runs.</p>
<p><strong>Example</strong> (Fixed Number of Recurrences)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.recurs(5)

log(schedule)
/*
Output:
#1: 0ms &lt; recurs
#2: 0ms
#3: 0ms
#4: 0ms
#5: 0ms
(end)
*/
</code></pre>
<h2>Recurring at specific intervals</h2>
<p>You can define schedules that control the time between executions. The difference between <code>spaced</code> and <code>fixed</code> schedules lies in how the interval is measured:</p>
<ul>
<li><code>spaced</code> delays each repetition from the <strong>end</strong> of the previous one.</li>
<li><code>fixed</code> ensures repetitions occur at <strong>regular intervals</strong>, regardless of execution time.</li>
</ul>
<h3>spaced</h3>
<p>A schedule that repeats indefinitely, each repetition spaced the specified duration from the last run.
It returns the number of recurrences each time it runs.</p>
<p><strong>Example</strong> (Recurring with Delay Between Executions)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.spaced(&quot;200 millis&quot;)

//               ┌─── Simulating an effect that takes
//               │    100 milliseconds to complete
//               ▼
log(schedule, &quot;100 millis&quot;)
/*
Output:
#1: 300ms &lt; spaced
#2: 300ms
#3: 300ms
#4: 300ms
#5: 300ms
#6: 300ms
#7: 300ms
#8: 300ms
#9: 300ms
#10: 300ms
...
*/
</code></pre>
<p>The first delay is approximately 100 milliseconds, as the initial execution is not affected by the schedule. Subsequent delays are approximately 200 milliseconds apart, demonstrating the effect of the <code>spaced</code> schedule.</p>
<h3>fixed</h3>
<p>A schedule that recurs at fixed intervals. It returns the number of recurrences each time it runs.
If the action run between updates takes longer than the interval, then the action will be run immediately, but re-runs will not &quot;pile up&quot;.</p>
<pre><code class="language-text">|-----interval-----|-----interval-----|-----interval-----|
|---------action--------|action-------|action------------|
</code></pre>
<p><strong>Example</strong> (Fixed Interval Recurrence)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.fixed(&quot;200 millis&quot;)

//               ┌─── Simulating an effect that takes
//               │    100 milliseconds to complete
//               ▼
log(schedule, &quot;100 millis&quot;)
/*
Output:
#1: 300ms &lt; fixed
#2: 200ms
#3: 200ms
#4: 200ms
#5: 200ms
#6: 200ms
#7: 200ms
#8: 200ms
#9: 200ms
#10: 200ms
...
*/
</code></pre>
<h2>Increasing Delays Between Executions</h2>
<h3>exponential</h3>
<p>A schedule that recurs using exponential backoff, with each delay increasing exponentially.
Returns the current duration between recurrences.</p>
<p><strong>Example</strong> (Exponential Backoff Schedule)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.exponential(&quot;10 millis&quot;)

log(schedule)
/*
Output:
#1: 10ms &lt; exponential
#2: 20ms
#3: 40ms
#4: 80ms
#5: 160ms
#6: 320ms
#7: 640ms
#8: 1280ms
#9: 2560ms
#10: 5120ms
...
*/
</code></pre>
<h3>fibonacci</h3>
<p>A schedule that always recurs, increasing delays by summing the preceding two delays (similar to the fibonacci sequence). Returns the current duration between recurrences.</p>
<p><strong>Example</strong> (Fibonacci Delay Schedule)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.fibonacci(&quot;10 millis&quot;)

log(schedule)
/*
Output:
#1: 10ms &lt; fibonacci
#2: 10ms
#3: 20ms
#4: 30ms
#5: 50ms
#6: 80ms
#7: 130ms
#8: 210ms
#9: 340ms
#10: 550ms
...
*/
</code></pre>
<hr>
<hr>
<h2>title: Cron
description: Explore cron scheduling in Effect for executing actions at specific times and intervals.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The Cron module lets you define schedules in a style similar to <a href="https://en.wikipedia.org/wiki/Cron">UNIX cron expressions</a>.
It also supports partial constraints (e.g., certain months or weekdays), time zone awareness through the <a href="/docs/data-types/datetime/">DateTime</a> module, and robust error handling.</p>
<p>This module helps you:</p>
<ul>
<li><strong>Create</strong> a <code>Cron</code> instance from individual parts.</li>
<li><strong>Parse and validate</strong> cron expressions.</li>
<li><strong>Match</strong> existing dates to see if they satisfy a given cron schedule.</li>
<li><strong>Find</strong> the next occurrence of a schedule after a given date.</li>
<li><strong>Iterate</strong> over future dates that match a schedule.</li>
<li><strong>Convert</strong> a <code>Cron</code> instance to a <code>Schedule</code> for use in effectful programs.</li>
</ul>
<h2>Creating a Cron</h2>
<p>You can define a cron schedule by specifying numeric constraints for seconds, minutes, hours, days, months, and weekdays. The <code>make</code> function requires you to define all fields representing the schedule&#39;s constraints.</p>
<p><strong>Example</strong> (Creating a Cron)</p>
<pre><code class="language-ts">import { Cron, DateTime } from &quot;effect&quot;

// Build a cron that triggers at 4:00 AM
// on the 8th to the 14th of each month
const cron = Cron.make({
  seconds: [0], // Trigger at the start of a minute
  minutes: [0], // Trigger at the start of an hour
  hours: [4], // Trigger at 4:00 AM
  days: [8, 9, 10, 11, 12, 13, 14], // Specific days of the month
  months: [], // No restrictions on the month
  weekdays: [], // No restrictions on the weekday
  tz: DateTime.zoneUnsafeMakeNamed(&quot;Europe/Rome&quot;) // Optional time zone
})
</code></pre>
<ul>
<li><code>seconds</code>, <code>minutes</code>, and <code>hours</code>: Define the time of day.</li>
<li><code>days</code> and <code>months</code>: Specify which calendar days and months are valid.</li>
<li><code>weekdays</code>: Restrict the schedule to specific days of the week.</li>
<li><code>tz</code>: Optionally define the time zone for the schedule.</li>
</ul>
<p>If any field is left empty (e.g., <code>months</code>), it is treated as having &quot;no constraints,&quot; allowing any valid value for that part of the date.</p>
<h2>Parsing Cron Expressions</h2>
<p>Instead of manually constructing a <code>Cron</code>, you can use UNIX-like cron strings and parse them with <code>parse</code> or <code>unsafeParse</code>.</p>
<h3>parse</h3>
<p>The <code>parse(cronExpression, tz?)</code> function safely parses a cron string into a <code>Cron</code> instance. It returns an <a href="/docs/data-types/either/">Either</a>, which will contain either the parsed <code>Cron</code> or a parsing error.</p>
<p><strong>Example</strong> (Safely Parsing a Cron Expression)</p>
<pre><code class="language-ts">import { Either, Cron } from &quot;effect&quot;

// Define a cron expression for 4:00 AM
// on the 8th to the 14th of every month
const expression = &quot;0 0 4 8-14 * *&quot;

// Parse the cron expression
const eitherCron = Cron.parse(expression)

if (Either.isRight(eitherCron)) {
  // Successfully parsed
  console.log(&quot;Parsed cron:&quot;, eitherCron.right)
} else {
  // Parsing failed
  console.error(&quot;Failed to parse cron:&quot;, eitherCron.left.message)
}
</code></pre>
<h3>unsafeParse</h3>
<p>The <code>unsafeParse(cronExpression, tz?)</code> function works like <a href="#parse">parse</a>, but instead of returning an <a href="/docs/data-types/either/">Either</a>, it throws an exception if the input is invalid.</p>
<p><strong>Example</strong> (Parsing a Cron Expression)</p>
<pre><code class="language-ts">import { Cron } from &quot;effect&quot;

// Parse a cron expression for 4:00 AM
// on the 8th to the 14th of every month
// Throws if the expression is invalid
const cron = Cron.unsafeParse(&quot;0 0 4 8-14 * *&quot;)
</code></pre>
<h2>Checking Dates with match</h2>
<p>The <code>match</code> function allows you to determine if a given <code>Date</code> (or any <a href="/docs/data-types/datetime/#the-datetimeinput-type">DateTime.Input</a>) satisfies the constraints of a cron schedule.</p>
<p>If the date meets the schedule&#39;s conditions, <code>match</code> returns <code>true</code>. Otherwise, it returns <code>false</code>.</p>
<p><strong>Example</strong> (Checking if a Date Matches a Cron Schedule)</p>
<pre><code class="language-ts">import { Cron } from &quot;effect&quot;

// Suppose we have a cron that triggers at 4:00 AM
// on the 8th to the 14th of each month
const cron = Cron.unsafeParse(&quot;0 0 4 8-14 * *&quot;)

const checkDate = new Date(&quot;2025-01-08 04:00:00&quot;)

console.log(Cron.match(cron, checkDate))
// Output: true
</code></pre>
<h2>Finding the Next Run</h2>
<p>The <code>next</code> function determines the next date that satisfies a given cron schedule, starting from a specified date. If no starting date is provided, the current time is used as the starting point.</p>
<p>If <code>next</code> cannot find a matching date within a predefined number of iterations, it throws an error to prevent infinite loops.</p>
<p><strong>Example</strong> (Determining the Next Matching Date)</p>
<pre><code class="language-ts">import { Cron } from &quot;effect&quot;

// Define a cron expression for 4:00 AM
// on the 8th to the 14th of every month
const cron = Cron.unsafeParse(&quot;0 0 4 8-14 * *&quot;, &quot;UTC&quot;)

// Specify the starting point for the search
const after = new Date(&quot;2025-01-08&quot;)

// Find the next matching date
const nextDate = Cron.next(cron, after)

console.log(nextDate)
// Output: 2025-01-08T04:00:00.000Z
</code></pre>
<h2>Iterating Over Future Dates</h2>
<p>To generate multiple future dates that match a cron schedule, you can use the <code>sequence</code> function. This function provides an infinite iterator of matching dates, starting from a specified date.</p>
<p><strong>Example</strong> (Generating Future Dates with an Iterator)</p>
<pre><code class="language-ts">import { Cron } from &quot;effect&quot;

// Define a cron expression for 4:00 AM
// on the 8th to the 14th of every month
const cron = Cron.unsafeParse(&quot;0 0 4 8-14 * *&quot;, &quot;UTC&quot;)

// Specify the starting date
const start = new Date(&quot;2021-01-08&quot;)

// Create an iterator for the schedule
const iterator = Cron.sequence(cron, start)

// Get the first matching date after the start date
console.log(iterator.next().value)
// Output: 2021-01-08T04:00:00.000Z

// Get the second matching date after the start date
console.log(iterator.next().value)
// Output: 2021-01-09T04:00:00.000Z
</code></pre>
<h2>Converting to Schedule</h2>
<p>The Schedule module allows you to define recurring behaviors, such as retries or periodic events. The <code>cron</code> function bridges the <code>Cron</code> module with the Schedule module, enabling you to create schedules based on cron expressions or <code>Cron</code> instances.</p>
<h3>cron</h3>
<p>The <code>Schedule.cron</code> function generates a <a href="/docs/scheduling/introduction/">Schedule</a> that triggers at the start of each interval defined by the provided cron expression or <code>Cron</code> instance. When triggered, the schedule produces a tuple <code>[start, end]</code> representing the timestamps (in milliseconds) of the cron interval window.</p>
<p><strong>Example</strong> (Creating a Schedule from a Cron)</p>
<pre><code class="language-ts">import {
  Effect,
  Schedule,
  TestClock,
  Fiber,
  TestContext,
  Cron,
  Console
} from &quot;effect&quot;

// A helper function to log output at each interval of the schedule
const log = &lt;A&gt;(
  action: Effect.Effect&lt;A&gt;,
  schedule: Schedule.Schedule&lt;[number, number], void&gt;
): void =&gt; {
  let i = 0

  Effect.gen(function* () {
    const fiber: Fiber.RuntimeFiber&lt;[[number, number], number]&gt; =
      yield* Effect.gen(function* () {
        yield* action
        i++
      }).pipe(
        Effect.repeat(
          schedule.pipe(
            // Limit the number of iterations for the example
            Schedule.intersect(Schedule.recurs(10)),
            Schedule.tapOutput(([Out]) =&gt;
              Console.log(
                i === 11 ? &quot;...&quot; : [new Date(Out[0]), new Date(Out[1])]
              )
            )
          )
        ),
        Effect.fork
      )
    yield* TestClock.adjust(Infinity)
    yield* Fiber.join(fiber)
  }).pipe(Effect.provide(TestContext.TestContext), Effect.runPromise)
}

// Build a cron that triggers at 4:00 AM
// on the 8th to the 14th of each month
const cron = Cron.unsafeParse(&quot;0 0 4 8-14 * *&quot;, &quot;UTC&quot;)

// Convert the Cron into a Schedule
const schedule = Schedule.cron(cron)

// Define a dummy action to repeat
const action = Effect.void

// Log the schedule intervals
log(action, schedule)
/*
Output:
[ 1970-01-08T04:00:00.000Z, 1970-01-08T04:00:01.000Z ]
[ 1970-01-09T04:00:00.000Z, 1970-01-09T04:00:01.000Z ]
[ 1970-01-10T04:00:00.000Z, 1970-01-10T04:00:01.000Z ]
[ 1970-01-11T04:00:00.000Z, 1970-01-11T04:00:01.000Z ]
[ 1970-01-12T04:00:00.000Z, 1970-01-12T04:00:01.000Z ]
[ 1970-01-13T04:00:00.000Z, 1970-01-13T04:00:01.000Z ]
[ 1970-01-14T04:00:00.000Z, 1970-01-14T04:00:01.000Z ]
[ 1970-02-08T04:00:00.000Z, 1970-02-08T04:00:01.000Z ]
[ 1970-02-09T04:00:00.000Z, 1970-02-09T04:00:01.000Z ]
[ 1970-02-10T04:00:00.000Z, 1970-02-10T04:00:01.000Z ]
...
*/
</code></pre>
<Aside type="note" title="Using a Real Clock">
  In a real application, you do not need to use the `TestClock` or
  `TestContext`. These are only necessary for simulating time and
  controlling the execution in test environments.
</Aside>


<hr>
<hr>
<h2>title: Examples
description: Explore practical examples for scheduling, retries, timeouts, and periodic task execution in Effect.
sidebar:
  order: 5</h2>
<p>These examples demonstrate different approaches to handling timeouts, retries, and periodic execution using Effect. Each scenario ensures that the application remains responsive and resilient to failures while adapting dynamically to various conditions.</p>
<h2>Handling Timeouts and Retries for API Calls</h2>
<p>When calling third-party APIs, it is often necessary to enforce timeouts and implement retry mechanisms to handle transient failures. In this example, the API call retries up to two times in case of failure and will be interrupted if it takes longer than 4 seconds.</p>
<p><strong>Example</strong> (Retrying an API Call with a Timeout)</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

// Function to make the API call
const getJson = (url: string) =&gt;
  Effect.tryPromise(() =&gt;
    fetch(url).then((res) =&gt; {
      if (!res.ok) {
        console.log(&quot;error&quot;)
        throw new Error(res.statusText)
      }
      console.log(&quot;ok&quot;)
      return res.json() as unknown
    })
  )

// Program that retries the API call twice, times out after 4 seconds,
// and logs errors
const program = (url: string) =&gt;
  getJson(url).pipe(
    Effect.retry({ times: 2 }),
    Effect.timeout(&quot;4 seconds&quot;),
    Effect.catchAll(Console.error)
  )

// Test case: successful API response
Effect.runFork(program(&quot;https://dummyjson.com/products/1?delay=1000&quot;))
/*
Output:
ok
*/

// Test case: API call exceeding timeout limit
Effect.runFork(program(&quot;https://dummyjson.com/products/1?delay=5000&quot;))
/*
Output:
TimeoutException: Operation timed out before the specified duration of &#39;4s&#39; elapsed
*/

// Test case: API returning an error response
Effect.runFork(program(&quot;https://dummyjson.com/auth/products/1?delay=500&quot;))
/*
Output:
error
error
error
UnknownException: An unknown error occurred
*/
</code></pre>
<h2>Retrying API Calls Based on Specific Errors</h2>
<p>Sometimes, retries should only happen for certain error conditions. For example, if an API call fails with a <code>401 Unauthorized</code> response, retrying might make sense, while a <code>404 Not Found</code> error should not trigger a retry.</p>
<p><strong>Example</strong> (Retrying Only on Specific Error Codes)</p>
<pre><code class="language-ts">import { Console, Effect } from &quot;effect&quot;

// Custom error class for handling status codes
class Err extends Error {
  constructor(message: string, readonly status: number) {
    super(message)
  }
}

// Function to make the API call
const getJson = (url: string) =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(url).then((res) =&gt; {
        if (!res.ok) {
          console.log(res.status)
          throw new Err(res.statusText, res.status)
        }
        return res.json() as unknown
      }),
    catch: (e) =&gt; e as Err
  })

// Program that retries only when the error status is 401 (Unauthorized)
const program = (url: string) =&gt;
  getJson(url).pipe(
    Effect.retry({ while: (err) =&gt; err.status === 401 }),
    Effect.catchAll(Console.error)
  )

// Test case: API returns 401 (triggers multiple retries)
Effect.runFork(
  program(&quot;https://dummyjson.com/auth/products/1?delay=1000&quot;)
)
/*
Output:
401
401
401
401
...
*/

// Test case: API returns 404 (no retries)
Effect.runFork(program(&quot;https://dummyjson.com/-&quot;))
/*
Output:
404
Err [Error]: Not Found
*/
</code></pre>
<h2>Retrying with Dynamic Delays Based on Error Information</h2>
<p>Some API errors, such as <code>429 Too Many Requests</code>, include a <code>Retry-After</code> header that specifies how long to wait before retrying. Instead of using a fixed delay, we can dynamically adjust the retry interval based on this value.</p>
<p><strong>Example</strong> (Using the <code>Retry-After</code> Header for Retry Delays)</p>
<p>This approach ensures that the retry delay adapts dynamically to the server&#39;s response, preventing unnecessary retries while respecting the provided <code>Retry-After</code> value.</p>
<pre><code class="language-ts">import { Duration, Effect, Schedule } from &quot;effect&quot;

// Custom error class representing a &quot;Too Many Requests&quot; response
class TooManyRequestsError {
  readonly _tag = &quot;TooManyRequestsError&quot;
  constructor(readonly retryAfter: number) {}
}

let n = 1
const request = Effect.gen(function* () {
  // Simulate failing a particular number of times
  if (n &lt; 3) {
    const retryAfter = n * 500
    console.log(`Attempt #${n++}, retry after ${retryAfter} millis...`)
    // Simulate retrieving the retry-after header
    return yield* Effect.fail(new TooManyRequestsError(retryAfter))
  }
  console.log(&quot;Done&quot;)
  return &quot;some result&quot;
})

// Retry policy that extracts the retry delay from the error
const policy = Schedule.identity&lt;TooManyRequestsError&gt;().pipe(
  Schedule.addDelay((error) =&gt;
    error._tag === &quot;TooManyRequestsError&quot;
      ? // Wait for the specified retry-after duration
        Duration.millis(error.retryAfter)
      : Duration.zero
  ),
  // Limit retries to 5 attempts
  Schedule.intersect(Schedule.recurs(5))
)

const program = request.pipe(Effect.retry(policy))

Effect.runFork(program)
/*
Output:
Attempt #1, retry after 500 millis...
Attempt #2, retry after 1000 millis...
Done
*/
</code></pre>
<h2>Running Periodic Tasks Until Another Task Completes</h2>
<p>There are cases where we need to repeatedly perform an action at fixed intervals until another longer-running task finishes. This pattern is common in polling mechanisms or periodic logging.</p>
<p><strong>Example</strong> (Running a Scheduled Task Until Completion)</p>
<pre><code class="language-ts">import { Effect, Console, Schedule } from &quot;effect&quot;

// Define a long-running effect
// (e.g., a task that takes 5 seconds to complete)
const longRunningEffect = Console.log(&quot;done&quot;).pipe(
  Effect.delay(&quot;5 seconds&quot;)
)

// Define an action to run periodically
const action = Console.log(&quot;action...&quot;)

// Define a fixed interval schedule
const schedule = Schedule.fixed(&quot;1.5 seconds&quot;)

// Run the action repeatedly until the long-running task completes
const program = Effect.race(
  Effect.repeat(action, schedule),
  longRunningEffect
)

Effect.runPromise(program)
/*
Output:
action...
action...
action...
action...
done
*/
</code></pre>
<hr>
<hr>
<h2>title: Introduction
description: Learn the fundamentals of scheduling in Effect, including composable recurrence patterns and handling retries and repetitions.
sidebar:
  order: 0</h2>
<h1>Scheduling</h1>
<p>Scheduling is an important concept in Effect that allows you to define recurring effectful operations. It involves the use of the <code>Schedule</code> type, which is an immutable value that describes a scheduled pattern for executing effects.</p>
<p>The <code>Schedule</code> type is structured as follows:</p>
<pre><code class="language-text">          ┌─── The type of output produced by the schedule
          │   ┌─── The type of input consumed by the schedule
          │   │     ┌─── Additional requirements for the schedule
          ▼   ▼     ▼
Schedule&lt;Out, In, Requirements&gt;
</code></pre>
<p>A schedule operates by consuming values of type <code>In</code> (such as errors in the case of <code>retry</code>, or values in the case of <code>repeat</code>) and producing values of type <code>Out</code>. It determines when to halt or continue the execution based on input values and its internal state.</p>
<p>The inclusion of a <code>Requirements</code> parameter allows the schedule to leverage additional services or resources as needed.</p>
<p>Schedules are defined as a collection of intervals spread out over time. Each interval represents a window during which the recurrence of an effect is possible.</p>
<h2>Retrying and Repetition</h2>
<p>In the realm of scheduling, there are two related concepts: <a href="/docs/error-management/retrying/">Retrying</a> and <a href="/docs/scheduling/repetition/">Repetition</a>. While they share the same underlying idea, they differ in their focus. Retrying aims to handle failures by executing an effect again, while repetition focuses on executing an effect repeatedly to achieve a desired outcome.</p>
<p>When using schedules for retrying or repetition, each interval&#39;s starting boundary determines when the effect will be executed again. For example, in retrying, if an error occurs, the schedule defines when the effect should be retried.</p>
<h2>Composability of Schedules</h2>
<p>Schedules are composable, meaning you can combine simple schedules to create more complex recurrence patterns. Operators like <code>Schedule.union</code> or <code>Schedule.intersect</code> allow you to build sophisticated schedules by combining and modifying existing ones. This flexibility enables you to tailor the scheduling behavior to meet specific requirements.</p>
<hr>
<hr>
<h2>title: Repetition
description: Explore repetition in Effect for executing actions multiple times with control over retries, failures, and conditions.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Repetition is a common requirement when working with effects in software development. It allows us to perform an effect multiple times according to a specific repetition policy.</p>
<h2>repeat</h2>
<p>The <code>Effect.repeat</code> function returns a new effect that repeats the given effect according to a specified schedule or until the first failure.</p>
<Aside type="note" title="Initial Execution Included">
  The scheduled recurrences are in addition to the initial execution, so
  `Effect.repeat(action, Schedule.once)` executes `action` once initially,
  and if it succeeds, repeats it an additional time.
</Aside>

<p><strong>Example</strong> (Repeating a Successful Effect)</p>
<pre><code class="language-ts">import { Effect, Schedule, Console } from &quot;effect&quot;

// Define an effect that logs a message to the console
const action = Console.log(&quot;success&quot;)

// Define a schedule that repeats the action 2 more times with a delay
const policy = Schedule.addDelay(Schedule.recurs(2), () =&gt; &quot;100 millis&quot;)

// Repeat the action according to the schedule
const program = Effect.repeat(action, policy)

// Run the program and log the number of repetitions
Effect.runPromise(program).then((n) =&gt; console.log(`repetitions: ${n}`))
/*
Output:
success
success
success
repetitions: 2
*/
</code></pre>
<p><strong>Example</strong> (Handling Failures in Repetition)</p>
<pre><code class="language-ts">import { Effect, Schedule } from &quot;effect&quot;

let count = 0

// Define an async effect that simulates an action with potential failure
const action = Effect.async&lt;string, string&gt;((resume) =&gt; {
  if (count &gt; 1) {
    console.log(&quot;failure&quot;)
    resume(Effect.fail(&quot;Uh oh!&quot;))
  } else {
    count++
    console.log(&quot;success&quot;)
    resume(Effect.succeed(&quot;yay!&quot;))
  }
})

// Define a schedule that repeats the action 2 more times with a delay
const policy = Schedule.addDelay(Schedule.recurs(2), () =&gt; &quot;100 millis&quot;)

// Repeat the action according to the schedule
const program = Effect.repeat(action, policy)

// Run the program and observe the result on failure
Effect.runPromiseExit(program).then(console.log)
/*
Output:
success
success
failure
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;Uh oh!&#39; }
}
*/
</code></pre>
<h3>Skipping First Execution</h3>
<p>If you want to avoid the first execution and only run the action according to a schedule, you can use <code>Effect.schedule</code>. This allows the effect to skip the initial run and follow the defined repeat policy.</p>
<p><strong>Example</strong> (Skipping First Execution)</p>
<pre><code class="language-ts">import { Effect, Schedule, Console } from &quot;effect&quot;

const action = Console.log(&quot;success&quot;)

const policy = Schedule.addDelay(Schedule.recurs(2), () =&gt; &quot;100 millis&quot;)

const program = Effect.schedule(action, policy)

Effect.runPromise(program).then((n) =&gt; console.log(`repetitions: ${n}`))
/*
Output:
success
success
repetitions: 2
*/
</code></pre>
<h2>repeatN</h2>
<p>The <code>repeatN</code> function returns a new effect that repeats the specified effect a given number of times or until the first failure. The repeats are in addition to the initial execution, so <code>Effect.repeatN(action, 1)</code> executes <code>action</code> once initially and then repeats it one additional time if it succeeds.</p>
<p><strong>Example</strong> (Repeating an Action Multiple Times)</p>
<pre><code class="language-ts">import { Effect, Console } from &quot;effect&quot;

const action = Console.log(&quot;success&quot;)

// Repeat the action 2 additional times after the first execution
const program = Effect.repeatN(action, 2)

Effect.runPromise(program)
/*
Output:
success
success
success
*/
</code></pre>
<h2>repeatOrElse</h2>
<p>The <code>repeatOrElse</code> function returns a new effect that repeats the specified effect according to the given schedule or until the first failure.
When a failure occurs, the failure value and schedule output are passed to a specified handler.
Scheduled recurrences are in addition to the initial execution, so <code>Effect.repeat(action, Schedule.once)</code> executes <code>action</code> once initially and then repeats it an additional time if it succeeds.</p>
<p><strong>Example</strong> (Handling Failure During Repeats)</p>
<pre><code class="language-ts">import { Effect, Schedule } from &quot;effect&quot;

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async&lt;string, string&gt;((resume) =&gt; {
  if (count &gt; 1) {
    console.log(&quot;failure&quot;)
    resume(Effect.fail(&quot;Uh oh!&quot;))
  } else {
    count++
    console.log(&quot;success&quot;)
    resume(Effect.succeed(&quot;yay!&quot;))
  }
})

// Define a schedule that repeats up to 2 times
// with a 100ms delay between attempts
const policy = Schedule.addDelay(Schedule.recurs(2), () =&gt; &quot;100 millis&quot;)

// Provide a handler to run when failure occurs after the retries
const program = Effect.repeatOrElse(action, policy, () =&gt;
  Effect.sync(() =&gt; {
    console.log(&quot;orElse&quot;)
    return count - 1
  })
)

Effect.runPromise(program).then((n) =&gt; console.log(`repetitions: ${n}`))
/*
Output:
success
success
failure
orElse
repetitions: 1
*/
</code></pre>
<h2>Repeating Based on a Condition</h2>
<p>You can control the repetition of an effect by a condition using either a <code>while</code> or <code>until</code> option, allowing for dynamic control based on runtime outcomes.</p>
<p><strong>Example</strong> (Repeating Until a Condition is Met)</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;

let count = 0

// Define an effect that simulates varying outcomes on each invocation
const action = Effect.sync(() =&gt; {
  console.log(`Action called ${++count} time(s)`)
  return count
})

// Repeat the action until the count reaches 3
const program = Effect.repeat(action, { until: (n) =&gt; n === 3 })

Effect.runFork(program)
/*
Output:
Action called 1 time(s)
Action called 2 time(s)
Action called 3 time(s)
*/
</code></pre>
<Aside type="tip" title="Retrying on Errors">
  You can use
  [Effect.retry](/docs/error-management/retrying/#retrying-based-on-a-condition)
  if you need to set conditions based on error occurrences rather than
  success outcomes.
</Aside>


<hr>
<hr>
<h2>title: Schedule Combinators
description: Learn how to combine and customize schedules in Effect to create complex recurrence patterns, including union, intersection, sequencing, and more.
sidebar:
  order: 3</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Schedules define stateful, possibly effectful, recurring schedules of events, and compose in a variety of ways. Combinators allow us to take schedules and combine them together to get other schedules.</p>
<p>To demonstrate the functionality of different schedules, we will use the following helper function
that logs each repetition along with the corresponding delay in milliseconds, formatted as:</p>
<pre><code class="language-text">#&lt;repetition&gt;: &lt;delay in ms&gt;
</code></pre>
<p><strong>Helper</strong> (Logging Execution Delays)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10 // Limit the number of executions
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot; // Indicate truncation if there are more executions
        : i === delays.length - 1
        ? &quot;(end)&quot; // Mark the last execution
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}
</code></pre>
<h2>Composition</h2>
<p>Schedules can be composed in different ways:</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Union</strong></td>
<td>Combines two schedules and recurs if either schedule wants to continue, using the shorter delay.</td>
</tr>
<tr>
<td><strong>Intersection</strong></td>
<td>Combines two schedules and recurs only if both schedules want to continue, using the longer delay.</td>
</tr>
<tr>
<td><strong>Sequencing</strong></td>
<td>Combines two schedules by running the first one fully, then switching to the second.</td>
</tr>
</tbody></table>
<h3>Union</h3>
<p>Combines two schedules and recurs if either schedule wants to continue, using the shorter delay.</p>
<p><strong>Example</strong> (Combining Exponential and Spaced Intervals)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.union(
  Schedule.exponential(&quot;100 millis&quot;),
  Schedule.spaced(&quot;1 second&quot;)
)

log(schedule)
/*
Output:
#1: 100ms  &lt; exponential
#2: 200ms
#3: 400ms
#4: 800ms
#5: 1000ms &lt; spaced
#6: 1000ms
#7: 1000ms
#8: 1000ms
#9: 1000ms
#10: 1000ms
...
*/
</code></pre>
<p>The <code>Schedule.union</code> operator selects the shortest delay at each step, so when combining an exponential schedule with a spaced interval, the initial recurrences will follow the exponential backoff, then settle into the spaced interval once the delays exceed that value.</p>
<h3>Intersection</h3>
<p>Combines two schedules and recurs only if both schedules want to continue, using the longer delay.</p>
<p><strong>Example</strong> (Limiting Exponential Backoff with a Fixed Number of Retries)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.intersect(
  Schedule.exponential(&quot;10 millis&quot;),
  Schedule.recurs(5)
)

log(schedule)
/*
Output:
#1: 10ms  &lt; exponential
#2: 20ms
#3: 40ms
#4: 80ms
#5: 160ms
(end)     &lt; recurs
*/
</code></pre>
<p>The <code>Schedule.intersect</code> operator enforces both schedules&#39; constraints. In this example, the schedule follows an exponential backoff but stops after 5 recurrences due to the <code>Schedule.recurs(5)</code> limit.</p>
<h3>Sequencing</h3>
<p>Combines two schedules by running the first one fully, then switching to the second.</p>
<p><strong>Example</strong> (Switching from Fixed Retries to Periodic Execution)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.andThen(
  Schedule.recurs(5),
  Schedule.spaced(&quot;1 second&quot;)
)

log(schedule)
/*
Output:
#1: 0ms    &lt; recurs
#2: 0ms
#3: 0ms
#4: 0ms
#5: 0ms
#6: 1000ms &lt; spaced
#7: 1000ms
#8: 1000ms
#9: 1000ms
#10: 1000ms
...
*/
</code></pre>
<p>The first schedule runs until completion, after which the second schedule takes over. In this example, the effect initially executes 5 times with no delay, then continues every 1 second.</p>
<h2>Adding Randomness to Retry Delays</h2>
<p>The <code>Schedule.jittered</code> combinator modifies a schedule by applying a random delay within a specified range.</p>
<p>When a resource is out of service due to overload or contention, retrying and backing off doesn&#39;t help us. If all failed API calls are backed off to the same point of time, they cause another overload or contention. Jitter adds some amount of randomness to the delay of the schedule. This helps us to avoid ending up accidentally synchronizing and taking the service down by accident.</p>
<p><a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/">Research</a> suggests that <code>Schedule.jittered(0.0, 1.0)</code> is an effective way to introduce randomness in retries.</p>
<p><strong>Example</strong> (Jittered Exponential Backoff)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.jittered(Schedule.exponential(&quot;10 millis&quot;))

log(schedule)
/*
Output:
#1: 10.448486ms
#2: 21.134521ms
#3: 47.245117ms
#4: 88.263184ms
#5: 163.651367ms
#6: 335.818848ms
#7: 719.126709ms
#8: 1266.18457ms
#9: 2931.252441ms
#10: 6121.593018ms
...
*/
</code></pre>
<p>The <code>Schedule.jittered</code> combinator introduces randomness to delays within a range. For example, applying jitter to an exponential backoff ensures that each retry occurs at a slightly different time, reducing the risk of overwhelming the system.</p>
<h2>Controlling Repetitions with Filters</h2>
<p>You can use <code>Schedule.whileInput</code> or <code>Schedule.whileOutput</code> to limit how long a schedule continues based on conditions applied to its input or output.</p>
<p><strong>Example</strong> (Stopping Based on Output)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.whileOutput(Schedule.recurs(5), (n) =&gt; n &lt;= 2)

log(schedule)
/*
Output:
#1: 0ms &lt; recurs
#2: 0ms
#3: 0ms
(end)   &lt; whileOutput
*/
</code></pre>
<p><code>Schedule.whileOutput</code> filters repetitions based on the output of the schedule. In this example, the schedule stops once the output exceeds <code>2</code>, even though <code>Schedule.recurs(5)</code> allows up to 5 repetitions.</p>
<h2>Adjusting Delays Based on Output</h2>
<p>The <code>Schedule.modifyDelay</code> combinator allows you to dynamically change the delay of a schedule based on the number of repetitions or other output conditions.</p>
<p><strong>Example</strong> (Reducing Delay After a Certain Number of Repetitions)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.modifyDelay(
  Schedule.spaced(&quot;1 second&quot;),
  (out, duration) =&gt; (out &gt; 2 ? &quot;100 millis&quot; : duration)
)

log(schedule)
/*
Output:
#1: 1000ms
#2: 1000ms
#3: 1000ms
#4: 100ms  &lt; modifyDelay
#5: 100ms
#6: 100ms
#7: 100ms
#8: 100ms
#9: 100ms
#10: 100ms
...
*/
</code></pre>
<p>The delay modification applies dynamically during execution. In this example, the first three repetitions follow the original <code>1-second</code> spacing. After that, the delay drops to <code>100 milliseconds</code>, making subsequent repetitions occur more frequently.</p>
<h2>Tapping</h2>
<p><code>Schedule.tapInput</code> and <code>Schedule.tapOutput</code> allow you to perform additional effectful operations on a schedule&#39;s input or output without modifying its behavior.</p>
<p><strong>Example</strong> (Logging Schedule Outputs)</p>
<pre><code class="language-ts">import { Array, Chunk, Duration, Effect, Schedule, Console } from &quot;effect&quot;

const log = (
  schedule: Schedule.Schedule&lt;unknown&gt;,
  delay: Duration.DurationInput = 0
): void =&gt; {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () =&gt; delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) =&gt; {
    console.log(
      i === maxRecurs
        ? &quot;...&quot;
        : i === delays.length - 1
        ? &quot;(end)&quot;
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.tapOutput(Schedule.recurs(2), (n) =&gt;
  Console.log(`Schedule Output: ${n}`)
)

log(schedule)
/*
Output:
Schedule Output: 0
Schedule Output: 1
Schedule Output: 2
#1: 0ms
#2: 0ms
(end)
*/
</code></pre>
<p><code>Schedule.tapOutput</code> runs an effect before each recurrence, using the schedule&#39;s current output as input. This can be useful for logging, debugging, or triggering side effects.</p>
<hr>
<hr>
<h2>title: Advanced Usage
description: Learn advanced techniques for defining and extending data schemas, including recursive and mutually recursive types, optional fields, branded types, and schema transformations.
sidebar:
  order: 5</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<h2>Declaring New Data Types</h2>
<h3>Primitive Data Types</h3>
<p>To declare a schema for a primitive data type, such as <code>File</code>, you can use the <code>Schema.declare</code> function along with a type guard.</p>
<p><strong>Example</strong> (Declaring a Schema for <code>File</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Declare a schema for the File type using a type guard
const FileFromSelf = Schema.declare(
  (input: unknown): input is File =&gt; input instanceof File
)

const decode = Schema.decodeUnknownSync(FileFromSelf)

// Decoding a valid File object
console.log(decode(new File([], &quot;&quot;)))
/*
Output:
File { size: 0, type: &#39;&#39;, name: &#39;&#39;, lastModified: 1724774163056 }
*/

// Decoding an invalid input
decode(null)
/*
throws
ParseError: Expected &lt;declaration schema&gt;, actual null
*/
</code></pre>
<Aside type="tip" title="Adding Annotations">
  Annotations like `identifier` and `description` are useful for improving
  error messages and making schemas self-documenting.
</Aside>

<p>To enhance the default error message, you can add annotations, particularly the <code>identifier</code>, <code>title</code>, and <code>description</code> annotations (none of these annotations are required, but they are encouraged for good practice and can make your schema &quot;self-documenting&quot;). These annotations will be utilized by the messaging system to return more meaningful messages.</p>
<ul>
<li><strong>Identifier</strong>: a unique name for the schema</li>
<li><strong>Title</strong>: a brief, descriptive title</li>
<li><strong>Description</strong>: a detailed explanation of the schema&#39;s purpose</li>
</ul>
<p><strong>Example</strong> (Declaring a Schema with Annotations)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Declare a schema for the File type with additional annotations
const FileFromSelf = Schema.declare(
  (input: unknown): input is File =&gt; input instanceof File,
  {
    // A unique identifier for the schema
    identifier: &quot;FileFromSelf&quot;,
    // Detailed description of the schema
    description: &quot;The `File` type in JavaScript&quot;
  }
)

const decode = Schema.decodeUnknownSync(FileFromSelf)

// Decoding a valid File object
console.log(decode(new File([], &quot;&quot;)))
/*
Output:
File { size: 0, type: &#39;&#39;, name: &#39;&#39;, lastModified: 1724774163056 }
*/

// Decoding an invalid input
decode(null)
/*
throws
ParseError: Expected FileFromSelf, actual null
*/
</code></pre>
<h3>Type Constructors</h3>
<p>Type constructors are generic types that take one or more types as arguments and return a new type. To define a schema for a type constructor, you can use the <code>Schema.declare</code> function.</p>
<p><strong>Example</strong> (Declaring a Schema for <code>ReadonlySet&lt;A&gt;</code>)</p>
<pre><code class="language-ts">import { ParseResult, Schema } from &quot;effect&quot;

export const MyReadonlySet = &lt;A, I, R&gt;(
  // Schema for the elements of the Set
  item: Schema.Schema&lt;A, I, R&gt;
): Schema.Schema&lt;ReadonlySet&lt;A&gt;, ReadonlySet&lt;I&gt;, R&gt; =&gt;
  Schema.declare(
    // Store the schema for the Set&#39;s elements
    [item],
    {
      // Decoding function
      decode: (item) =&gt; (input, parseOptions, ast) =&gt; {
        if (input instanceof Set) {
          // Decode each element in the Set
          const elements = ParseResult.decodeUnknown(Schema.Array(item))(
            Array.from(input.values()),
            parseOptions
          )
          // Return a ReadonlySet containing the decoded elements
          return ParseResult.map(
            elements,
            (as): ReadonlySet&lt;A&gt; =&gt; new Set(as)
          )
        }
        // Handle invalid input
        return ParseResult.fail(new ParseResult.Type(ast, input))
      },
      // Encoding function
      encode: (item) =&gt; (input, parseOptions, ast) =&gt; {
        if (input instanceof Set) {
          // Encode each element in the Set
          const elements = ParseResult.encodeUnknown(Schema.Array(item))(
            Array.from(input.values()),
            parseOptions
          )
          // Return a ReadonlySet containing the encoded elements
          return ParseResult.map(
            elements,
            (is): ReadonlySet&lt;I&gt; =&gt; new Set(is)
          )
        }
        // Handle invalid input
        return ParseResult.fail(new ParseResult.Type(ast, input))
      }
    },
    {
      description: `ReadonlySet&lt;${Schema.format(item)}&gt;`
    }
  )

// Define a schema for a ReadonlySet of numbers
const setOfNumbers = MyReadonlySet(Schema.NumberFromString)

const decode = Schema.decodeUnknownSync(setOfNumbers)

console.log(decode(new Set([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]))) // Set(3) { 1, 2, 3 }

// Decode an invalid input
decode(null)
/*
throws
ParseError: Expected ReadonlySet&lt;NumberFromString&gt;, actual null
*/

// Decode a Set with an invalid element
decode(new Set([&quot;1&quot;, null, &quot;3&quot;]))
/*
throws
ParseError: ReadonlyArray&lt;NumberFromString&gt;
└─ [1]
   └─ NumberFromString
      └─ Encoded side transformation failure
         └─ Expected string, actual null
*/
</code></pre>
<Aside type="caution" title="Decoding/Encoding Limitations">
  The decoding and encoding functions cannot rely on context (the
  `Requirements` type parameter) and cannot handle asynchronous effects.
  This means that only synchronous operations are supported within these
  functions.
</Aside>

<h3>Adding Compilers Annotations</h3>
<p>When defining a new data type, some compilers like <a href="/docs/schema/arbitrary/">Arbitrary</a> or <a href="/docs/schema/pretty/">Pretty</a> may not know how to handle the new type.
This can result in an error, as the compiler may lack the necessary information for generating instances or producing readable output:</p>
<p><strong>Example</strong> (Attempting to Generate Arbitrary Values Without Required Annotations)</p>
<pre><code class="language-ts">import { Arbitrary, Schema } from &quot;effect&quot;

// Define a schema for the File type
const FileFromSelf = Schema.declare(
  (input: unknown): input is File =&gt; input instanceof File,
  {
    identifier: &quot;FileFromSelf&quot;
  }
)

// Try creating an Arbitrary instance for the schema
const arb = Arbitrary.make(FileFromSelf)
/*
throws:
Error: Missing annotation
details: Generating an Arbitrary for this schema requires an &quot;arbitrary&quot; annotation
schema (Declaration): FileFromSelf
*/
</code></pre>
<p>In the above example, attempting to generate arbitrary values for the <code>FileFromSelf</code> schema fails because the compiler lacks necessary annotations. To resolve this, you need to provide annotations for generating arbitrary data:</p>
<p><strong>Example</strong> (Adding Arbitrary Annotation for Custom <code>File</code> Schema)</p>
<pre><code class="language-ts">import { Arbitrary, FastCheck, Pretty, Schema } from &quot;effect&quot;

const FileFromSelf = Schema.declare(
  (input: unknown): input is File =&gt; input instanceof File,
  {
    identifier: &quot;FileFromSelf&quot;,
    // Provide a function to generate random File instances
    arbitrary: () =&gt; (fc) =&gt;
      fc
        .tuple(fc.string(), fc.string())
        .map(([content, path]) =&gt; new File([content], path))
  }
)

// Create an Arbitrary instance for the schema
const arb = Arbitrary.make(FileFromSelf)

// Generate sample files using the Arbitrary instance
const files = FastCheck.sample(arb, 2)
console.log(files)
/*
Example Output:
[
  File { size: 5, type: &#39;&#39;, name: &#39;C&#39;, lastModified: 1706435571176 },
  File { size: 1, type: &#39;&#39;, name: &#39;98Ggmc&#39;, lastModified: 1706435571176 }
]
*/
</code></pre>
<p>For more details on how to add annotations for the Arbitrary compiler, refer to the <a href="/docs/schema/arbitrary/">Arbitrary</a> documentation.</p>
<h2>Branded types</h2>
<p>TypeScript&#39;s type system is structural, which means that any two types that are structurally equivalent are considered the same.
This can cause issues when types that are semantically different are treated as if they were the same.</p>
<p><strong>Example</strong> (Structural Typing Issue)</p>
<pre><code class="language-ts">type UserId = string
type Username = string

declare const getUser: (id: UserId) =&gt; object

const myUsername: Username = &quot;gcanti&quot;

getUser(myUsername) // This erroneously works
</code></pre>
<p>In the above example, <code>UserId</code> and <code>Username</code> are both aliases for the same type, <code>string</code>. This means that the <code>getUser</code> function can mistakenly accept a <code>Username</code> as a valid <code>UserId</code>, causing bugs and errors.</p>
<p>To prevent this, Effect introduces <strong>branded types</strong>. These types attach a unique identifier (or &quot;brand&quot;) to a type, allowing you to differentiate between structurally similar but semantically distinct types.</p>
<p><strong>Example</strong> (Defining Branded Types)</p>
<pre><code class="language-ts">import { Brand } from &quot;effect&quot;

type UserId = string &amp; Brand.Brand&lt;&quot;UserId&quot;&gt;
type Username = string

declare const getUser: (id: UserId) =&gt; object

const myUsername: Username = &quot;gcanti&quot;

// @ts-expect-error
getUser(myUsername)
/*
Argument of type &#39;string&#39; is not assignable to parameter of type &#39;UserId&#39;.
  Type &#39;string&#39; is not assignable to type &#39;Brand&lt;&quot;UserId&quot;&gt;&#39;.ts(2345)
*/
</code></pre>
<p>By defining <code>UserId</code> as a branded type, the <code>getUser</code> function can accept only values of type <code>UserId</code>, and not plain strings or other types that are compatible with strings. This helps to prevent bugs caused by accidentally passing the wrong type of value to the function.</p>
<p>There are two ways to define a schema for a branded type, depending on whether you:</p>
<ul>
<li>want to define the schema from scratch</li>
<li>have already defined a branded type via <a href="/docs/code-style/branded-types/"><code>effect/Brand</code></a> and want to reuse it to define a schema</li>
</ul>
<h3>Defining a brand schema from scratch</h3>
<p>To define a schema for a branded type from scratch, use the <code>Schema.brand</code> function.</p>
<p><strong>Example</strong> (Creating a schema for a Branded Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const UserId = Schema.String.pipe(Schema.brand(&quot;UserId&quot;))

// string &amp; Brand&lt;&quot;UserId&quot;&gt;
type UserId = typeof UserId.Type
</code></pre>
<p>Note that you can use <code>unique symbol</code>s as brands to ensure uniqueness across modules / packages.</p>
<p><strong>Example</strong> (Using a unique symbol as a Brand)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const UserIdBrand: unique symbol = Symbol.for(&quot;UserId&quot;)

const UserId = Schema.String.pipe(Schema.brand(UserIdBrand))

// string &amp; Brand&lt;typeof UserIdBrand&gt;
type UserId = typeof UserId.Type
</code></pre>
<h3>Reusing an existing branded constructor</h3>
<p>If you have already defined a branded type using the <a href="/docs/code-style/branded-types/"><code>effect/Brand</code></a> module, you can reuse it to define a schema using the <code>Schema.fromBrand</code> function.</p>
<p><strong>Example</strong> (Reusing an Existing Branded Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Brand } from &quot;effect&quot;

// the existing branded type
type UserId = string &amp; Brand.Brand&lt;&quot;UserId&quot;&gt;

const UserId = Brand.nominal&lt;UserId&gt;()

// Define a schema for the branded type
const UserIdSchema = Schema.String.pipe(Schema.fromBrand(UserId))
</code></pre>
<h3>Utilizing Default Constructors</h3>
<p>The <code>Schema.brand</code> function includes a default constructor to facilitate the creation of branded values.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const UserId = Schema.String.pipe(Schema.brand(&quot;UserId&quot;))

const userId = UserId.make(&quot;123&quot;) // Creates a branded UserId
</code></pre>
<h2>Property Signatures</h2>
<p>A <code>PropertySignature</code> represents a transformation from a &quot;From&quot; field to a &quot;To&quot; field. This allows you to define mappings between incoming data fields and your internal model.</p>
<h3>Basic Usage</h3>
<p>A property signature can be defined with annotations to provide additional context about a field.</p>
<p><strong>Example</strong> (Adding Annotations to a Property Signature)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).annotations({
    title: &quot;Age&quot; // Annotation to label the age field
  })
})
</code></pre>
<p>A <code>PropertySignature</code> type contains several parameters, each providing details about the transformation between the source field (From) and the target field (To). Let&#39;s take a look at what each of these parameters represents:</p>
<pre><code class="language-ts">age: PropertySignature&lt;
  ToToken,
  ToType,
  FromKey,
  FromToken,
  FromType,
  HasDefault,
  Context
&gt;
</code></pre>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>age</code></td>
<td>Key of the &quot;To&quot; field</td>
</tr>
<tr>
<td><code>ToToken</code></td>
<td>Indicates field requirement: <code>&quot;?:&quot;</code> for optional, <code>&quot;:&quot;</code> for required</td>
</tr>
<tr>
<td><code>ToType</code></td>
<td>Type of the &quot;To&quot; field</td>
</tr>
<tr>
<td><code>FromKey</code></td>
<td>(Optional, default = <code>never</code>) Indicates the source field key, typically the same as &quot;To&quot; field key unless specified</td>
</tr>
<tr>
<td><code>FormToken</code></td>
<td>Indicates source field requirement: <code>&quot;?:&quot;</code> for optional, <code>&quot;:&quot;</code> for required</td>
</tr>
<tr>
<td><code>FromType</code></td>
<td>Type of the &quot;From&quot; field</td>
</tr>
<tr>
<td><code>HasDefault</code></td>
<td>Indicates if there is a constructor default value (Boolean)</td>
</tr>
</tbody></table>
<p>In the example above, the <code>PropertySignature</code> type for <code>age</code> is:</p>
<pre><code class="language-ts">PropertySignature&lt;&quot;:&quot;, number, never, &quot;:&quot;, string, false, never&gt;
</code></pre>
<p>This means:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>age</code></td>
<td>Key of the &quot;To&quot; field</td>
</tr>
<tr>
<td><code>ToToken</code></td>
<td><code>&quot;:&quot;</code> indicates that the <code>age</code> field is required</td>
</tr>
<tr>
<td><code>ToType</code></td>
<td>Type of the <code>age</code> field is <code>number</code></td>
</tr>
<tr>
<td><code>FromKey</code></td>
<td><code>never</code> indicates that the decoding occurs from the same field named <code>age</code></td>
</tr>
<tr>
<td><code>FormToken</code></td>
<td><code>&quot;:&quot;</code> indicates that the decoding occurs from a required <code>age</code> field</td>
</tr>
<tr>
<td><code>FromType</code></td>
<td>Type of the &quot;From&quot; field is <code>string</code></td>
</tr>
<tr>
<td><code>HasDefault</code></td>
<td><code>false</code>: indicates there is no default value</td>
</tr>
</tbody></table>
<p>Sometimes, the source field (the &quot;From&quot; field) may have a different name from the field in your internal model. You can map between these fields using the <code>Schema.fromKey</code> function.</p>
<p><strong>Example</strong> (Mapping from a Different Key)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey(&quot;AGE&quot;) // Maps from &quot;AGE&quot; to &quot;age&quot;
  )
})

console.log(Schema.decodeUnknownSync(Person)({ name: &quot;name&quot;, AGE: &quot;18&quot; }))
// Output: { name: &#39;name&#39;, age: 18 }
</code></pre>
<p>When you map from <code>&quot;AGE&quot;</code> to <code>&quot;age&quot;</code>, the <code>PropertySignature</code> type changes to:</p>
<pre><code class="language-ts">PropertySignature&lt;&quot;:&quot;, number, never, &quot;:&quot;, string, false, never&gt;
PropertySignature&lt;&quot;:&quot;, number, &quot;AGE&quot;, &quot;:&quot;, string, false, never&gt;
</code></pre>
<h3>Optional Fields</h3>
<h4>Basic Optional Property</h4>
<p>The syntax:</p>
<pre><code class="language-ts">Schema.optional(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<p>creates an optional property within a schema, allowing fields to be omitted or set to <code>undefined</code>.</p>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>remains <code>undefined</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>a: A</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>remains <code>undefined</code></td>
</tr>
<tr>
<td><code>a: A</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Defining an Optional Number Field)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optional(Schema.NumberFromString)
})

//     ┌─── { readonly quantity?: string | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: number | undefined; }
//     ▼
type Type = typeof Product.Type

// Decoding examples

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;1&quot; }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }

// Encoding examples

console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: &quot;1&quot; }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
console.log(Schema.encodeSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optional(Schema.NumberFromString)
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Optional with Nullability</h4>
<p>The syntax:</p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, { nullable: true })
</code></pre>
<p>creates an optional property within a schema, treating <code>null</code> values the same as missing values.</p>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>remains <code>undefined</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>a: A</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>remains <code>undefined</code></td>
</tr>
<tr>
<td><code>a: A</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Handling Null as Missing Value)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    nullable: true
  })
})

//     ┌─── { readonly quantity?: string | null | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: number | undefined; }
//     ▼
type Type = typeof Product.Type

// Decoding examples

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;1&quot; }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }
console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: {}

// Encoding examples

console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: &quot;1&quot; }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
console.log(Schema.encodeSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    nullable: true
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Optional with Exactness</h4>
<p>The syntax:</p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, { exact: true })
</code></pre>
<p>creates an optional property while enforcing strict typing. This means that only the specified type (excluding <code>undefined</code>) is accepted. Any attempt to decode <code>undefined</code> results in an error.</p>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>ParseError</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>a: A</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>a: A</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Exactness with Optional Field)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, { exact: true })
})

//     ┌─── { readonly quantity?: string; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: number; }
//     ▼
type Type = typeof Product.Type

// Decoding examples

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;1&quot; }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: { readonly quantity?: NumberFromString }
└─ [&quot;quantity&quot;]
   └─ NumberFromString
      └─ Encoded side transformation failure
         └─ Expected string, actual undefined
*/

// Encoding examples

console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: &quot;1&quot; }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, { exact: true })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Combining Nullability and Exactness</h4>
<p>The syntax:</p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, { exact: true, nullable: true })
</code></pre>
<p>allows you to define an optional property that enforces strict typing (exact type only) while also treating <code>null</code> as equivalent to a missing value.</p>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>ParseError</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>a: A</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>remains <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>a: A</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Exactness and Handling Null as Missing Value with Optional Field)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    exact: true,
    nullable: true
  })
})

//     ┌─── { readonly quantity?: string | null; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: number; }
//     ▼
type Type = typeof Product.Type

// Decoding examples

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;1&quot; }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) &lt;-&gt; Struct (Type side))
└─ Encoded side transformation failure
   └─ Struct (Encoded side)
      └─ [&quot;quantity&quot;]
         └─ NumberFromString | null
            ├─ NumberFromString
            │  └─ Encoded side transformation failure
            │     └─ Expected string, actual undefined
            └─ Expected null, actual undefined
*/
console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: {}

// Encoding examples

console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: &quot;1&quot; }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    exact: true,
    nullable: true
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h3>Representing Optional Fields with never Type</h3>
<p>When creating a schema to replicate a TypeScript type that includes optional fields with the <code>never</code> type, like:</p>
<pre><code class="language-ts">type MyType = {
  readonly quantity?: never
}
</code></pre>
<p>the handling of these fields depends on the <code>exactOptionalPropertyTypes</code> setting in your <code>tsconfig.json</code>.
This setting affects whether the schema should treat optional <code>never</code>-typed fields as simply absent or allow <code>undefined</code> as a value.</p>
<p><strong>Example</strong> (<code>exactOptionalPropertyTypes: false</code>)</p>
<p>When this feature is turned off, you can employ the <code>Schema.optional</code> function. This approach allows the field to implicitly accept <code>undefined</code> as a value.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optional(Schema.Never)
})

//     ┌─── { readonly quantity?: undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: undefined; }
//     ▼
type Type = typeof Product.Type
</code></pre>
<p><strong>Example</strong> (<code>exactOptionalPropertyTypes: true</code>)</p>
<p>When this feature is turned on, the <code>Schema.optionalWith</code> function is recommended.
It ensures stricter enforcement of the field&#39;s absence.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.Never, { exact: true })
})

//     ┌─── { readonly quantity?: never; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity?: never; }
//     ▼
type Type = typeof Product.Type
</code></pre>
<h3>Default Values</h3>
<p>The <code>default</code> option in <code>Schema.optionalWith</code> allows you to set default values that are applied during both decoding and object construction phases.
This feature ensures that even if certain properties are not provided by the user, the system will automatically use the specified default values.</p>
<p>The <code>Schema.optionalWith</code> function offers several ways to control how defaults are applied during decoding and encoding. You can fine-tune whether defaults are applied only when the input is completely missing, or even when <code>null</code> or <code>undefined</code> values are provided.</p>
<h4>Basic Default</h4>
<p>This is the simplest use case. If the input is missing or <code>undefined</code>, the default value will be applied.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, { default: () =&gt; A })
</code></pre>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Decoding</strong></td>
<td>Applies the default value if the input is missing or <code>undefined</code></td>
</tr>
<tr>
<td><strong>Encoding</strong></td>
<td>Transforms the input <code>a: A</code> back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Applying Default When Field Is Missing or <code>undefined</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () =&gt; 1 // Default value for quantity
  })
})

//     ┌─── { readonly quantity?: string | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: number; }
//     ▼
type Type = typeof Product.Type

// Decoding examples with default applied

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: 2 }

// Object construction examples with default applied

console.log(Product.make({}))
// Output: { quantity: 1 }

console.log(Product.make({ quantity: 2 }))
// Output: { quantity: 2 }
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () =&gt; 1 // Default value for quantity
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Default with Exactness</h4>
<p>When you want the default value to be applied only if the field is completely missing (not when it&#39;s <code>undefined</code>), you can use the <code>exact</code> option.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, {
  default: () =&gt; A,
  exact: true
})
</code></pre>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Decoding</strong></td>
<td>Applies the default value only if the input is missing</td>
</tr>
<tr>
<td><strong>Encoding</strong></td>
<td>Transforms the input <code>a: A</code> back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Applying Default Only When Field Is Missing)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () =&gt; 1, // Default value for quantity
    exact: true // Only apply default if quantity is not provided
  })
})

//     ┌─── { readonly quantity?: string; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: number; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: 2 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) &lt;-&gt; Struct (Type side))
└─ Encoded side transformation failure
   └─ Struct (Encoded side)
      └─ [&quot;quantity&quot;]
         └─ NumberFromString
            └─ Encoded side transformation failure
               └─ Expected string, actual undefined
*/
</code></pre>
<h4>Default with Nullability</h4>
<p>In cases where you want <code>null</code> values to trigger the default behavior, you can use the <code>nullable</code> option. This ensures that if a field is set to <code>null</code>, it will be replaced by the default value.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, {
  default: () =&gt; A,
  nullable: true
})
</code></pre>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Decoding</strong></td>
<td>Applies the default value if the input is missing or <code>undefined</code> or <code>null</code></td>
</tr>
<tr>
<td><strong>Encoding</strong></td>
<td>Transforms the input <code>a: A</code> back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Applying Default When Field Is Missing or <code>undefined</code> or <code>null</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () =&gt; 1, // Default value for quantity
    nullable: true // Apply default if quantity is null
  })
})

//     ┌─── { readonly quantity?: string | null | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: number; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: 2 }
</code></pre>
<h4>Combining Exactness and Nullability</h4>
<p>For a more strict approach, you can combine both <code>exact</code> and <code>nullable</code> options. This way, the default value is applied only when the field is <code>null</code> or missing, and not when it&#39;s explicitly set to <code>undefined</code>.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.optionalWith(schema: Schema&lt;A, I, R&gt;, {
  default: () =&gt; A,
  exact: true,
  nullable: true
})
</code></pre>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Decoding</strong></td>
<td>Applies the default value if the input is missing or <code>null</code></td>
</tr>
<tr>
<td><strong>Encoding</strong></td>
<td>Transforms the input <code>a: A</code> back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Applying Default Only When Field Is Missing or <code>null</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () =&gt; 1, // Default value for quantity
    exact: true, // Only apply default if quantity is not provided
    nullable: true // Apply default if quantity is null
  })
})

//     ┌─── { readonly quantity?: string | null; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: number; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: 2 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) &lt;-&gt; Struct (Type side))
└─ Encoded side transformation failure
   └─ Struct (Encoded side)
      └─ [&quot;quantity&quot;]
         └─ NumberFromString
            └─ Encoded side transformation failure
               └─ Expected string, actual undefined
*/
</code></pre>
<h3>Optional Fields as Options</h3>
<p>When working with optional fields, you may want to handle them as <a href="/docs/data-types/option/">Option</a> types. This approach allows you to explicitly manage the presence or absence of a field rather than relying on <code>undefined</code> or <code>null</code>.</p>
<h4>Basic Optional with Option Type</h4>
<p>You can configure a schema to treat optional fields as <code>Option</code> types, where missing or <code>undefined</code> values are converted to <code>Option.none()</code> and existing values are wrapped in <code>Option.some()</code>.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">optionalWith(schema: Schema&lt;A, I, R&gt;, { as: &quot;Option&quot; })
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>Option.some(a: A)</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>Option.some(a: A)</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Handling Optional Field as Option)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, { as: &quot;Option&quot; })
})

//     ┌─── { readonly quantity?: string | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: Option&lt;number&gt;; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 } }
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, { as: &quot;Option&quot; })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Optional with Exactness</h4>
<p>The <code>exact</code> option ensures that the default behavior of the optional field applies only when the field is entirely missing, not when it is <code>undefined</code>.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">optionalWith(schema: Schema&lt;A, I, R&gt;, {
  as: &quot;Option&quot;,
  exact: true
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>ParseError</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>Option.some(a: A)</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>Option.some(a: A)</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Exactness with Optional Field as Option)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    exact: true
  })
})

//     ┌─── { readonly quantity?: string; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: Option&lt;number&gt;; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) &lt;-&gt; Struct (Type side))
└─ Encoded side transformation failure
   └─ Struct (Encoded side)
      └─ [&quot;quantity&quot;]
         └─ NumberFromString
            └─ Encoded side transformation failure
               └─ Expected string, actual undefined
*/
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    exact: true
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Optional with Nullability</h4>
<p>The <code>nullable</code> option extends the default behavior to treat <code>null</code> as equivalent to <code>Option.none()</code>, alongside missing or <code>undefined</code> values.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">optionalWith(schema: Schema&lt;A, I, R&gt;, {
  as: &quot;Option&quot;,
  nullable: true
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>Option.some(a: A)</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>Option.some(a: A)</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Handling Null as Missing Value with Optional Field as Option)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    nullable: true
  })
})

//     ┌─── { readonly quantity?: string | null | undefined; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: Option&lt;number&gt;; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 } }
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    nullable: true
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h4>Combining Exactness and Nullability</h4>
<p>When both <code>exact</code> and <code>nullable</code> options are used together, only <code>null</code> and missing fields are treated as <code>Option.none()</code>, while <code>undefined</code> is considered an invalid value.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">optionalWith(schema: Schema&lt;A, I, R&gt;, {
  as: &quot;Option&quot;,
  exact: true,
  nullable: true
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;missing value&gt;</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>ParseError</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td>transforms to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>i: I</code></td>
<td>transforms to <code>Option.some(a: A)</code></td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>transforms to <code>&lt;missing value&gt;</code></td>
</tr>
<tr>
<td><code>Option.some(a: A)</code></td>
<td>transforms back to <code>i: I</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using Exactness and Handling Null as Missing Value with Optional Field as Option)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    exact: true,
    nullable: true
  })
})

//     ┌─── { readonly quantity?: string | null; }
//     ▼
type Encoded = typeof Product.Encoded

//     ┌─── { readonly quantity: Option&lt;number&gt;; }
//     ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;None&#39; } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: &quot;2&quot; }))
// Output: { quantity: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) &lt;-&gt; Struct (Type side))
└─ Encoded side transformation failure
   └─ Struct (Encoded side)
      └─ [&quot;quantity&quot;]
         └─ NumberFromString
            └─ Encoded side transformation failure
               └─ Expected string, actual undefined
*/
</code></pre>
<h5>Exposed Values</h5>
<p>You can access the original schema type (before it was marked as optional) using the <code>from</code> property.</p>
<p><strong>Example</strong> (Accessing the Original Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: &quot;Option&quot;,
    exact: true,
    nullable: true
  })
})

//      ┌─── typeof Schema.NumberFromString
//      ▼
const from = Product.fields.quantity.from
</code></pre>
<h2>Optional Fields Primitives</h2>
<h3>optionalToOptional</h3>
<p>The <code>Schema.optionalToOptional</code> API allows you to manage transformations from an optional field in the input to an optional field in the output. This can be useful for controlling both the output type and whether a field is present or absent based on specific criteria.</p>
<p>One common use case for <code>optionalToOptional</code> is handling fields where a specific input value, such as an empty string, should be treated as an absent field in the output.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const optionalToOptional = &lt;FA, FI, FR, TA, TI, TR&gt;(
  from: Schema&lt;FA, FI, FR&gt;,
  to: Schema&lt;TA, TI, TR&gt;,
  options: {
    readonly decode: (o: Option.Option&lt;FA&gt;) =&gt; Option.Option&lt;TI&gt;,
    readonly encode: (o: Option.Option&lt;TI&gt;) =&gt; Option.Option&lt;FA&gt;
  }
): PropertySignature&lt;&quot;?:&quot;, TA, never, &quot;?:&quot;, FI, false, FR | TR&gt;
</code></pre>
<p>In this function:</p>
<ul>
<li>The <code>from</code> parameter specifies the input schema, and <code>to</code> specifies the output schema.</li>
<li>The <code>decode</code> and <code>encode</code> functions define how the field should be interpreted on both sides:<ul>
<li><code>Option.none()</code> as an input argument indicates a missing field in the input.</li>
<li>Returning <code>Option.none()</code> from either function will omit the field in the output.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong> (Omitting Empty Strings from the Output)</p>
<p>Consider an optional field of type <code>string</code> where empty strings in the input should be removed from the output.</p>
<pre><code class="language-ts">import { Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  nonEmpty: Schema.optionalToOptional(Schema.String, Schema.String, {
    //         ┌─── Option&lt;string&gt;
    //         ▼
    decode: (maybeString) =&gt; {
      if (Option.isNone(maybeString)) {
        // If `maybeString` is `None`, the field is absent in the input.
        // Return Option.none() to omit it in the output.
        return Option.none()
      }
      // Extract the value from the `Some` instance
      const value = maybeString.value
      if (value === &quot;&quot;) {
        // Treat empty strings as missing in the output
        // by returning Option.none().
        return Option.none()
      }
      // Include non-empty strings in the output.
      return Option.some(value)
    },
    // In the encoding phase, you can decide to process the field
    // similarly to the decoding phase or use a different logic.
    // Here, the logic is left unchanged.
    //
    //         ┌─── Option&lt;string&gt;
    //         ▼
    encode: (maybeString) =&gt; maybeString
  })
})

// Decoding examples

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({}))
// Output: {}
console.log(decode({ nonEmpty: &quot;&quot; }))
// Output: {}
console.log(decode({ nonEmpty: &quot;a non-empty string&quot; }))
// Output: { nonEmpty: &#39;a non-empty string&#39; }

// Encoding examples

const encode = Schema.encodeSync(schema)

console.log(encode({}))
// Output: {}
console.log(encode({ nonEmpty: &quot;&quot; }))
// Output: { nonEmpty: &#39;&#39; }
console.log(encode({ nonEmpty: &quot;a non-empty string&quot; }))
// Output: { nonEmpty: &#39;a non-empty string&#39; }
</code></pre>
<p>You can simplify the decoding logic with <code>Option.filter</code>, which filters out unwanted values in a concise way.</p>
<p><strong>Example</strong> (Using <code>Option.filter</code> for Decoding)</p>
<pre><code class="language-ts">import { identity, Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  nonEmpty: Schema.optionalToOptional(Schema.String, Schema.String, {
    decode: Option.filter((s) =&gt; s !== &quot;&quot;),
    encode: identity
  })
})
</code></pre>
<h3>optionalToRequired</h3>
<p>The <code>Schema.optionalToRequired</code> API lets you transform an optional field into a required one, with custom logic to handle cases when the field is missing in the input.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const optionalToRequired = &lt;FA, FI, FR, TA, TI, TR&gt;(
  from: Schema&lt;FA, FI, FR&gt;,
  to: Schema&lt;TA, TI, TR&gt;,
  options: {
    readonly decode: (o: Option.Option&lt;FA&gt;) =&gt; TI,
    readonly encode: (ti: TI) =&gt; Option.Option&lt;FA&gt;
  }
): PropertySignature&lt;&quot;:&quot;, TA, never, &quot;?:&quot;, FI, false, FR | TR&gt;
</code></pre>
<p>In this function:</p>
<ul>
<li><code>from</code> specifies the input schema, while <code>to</code> specifies the output schema.</li>
<li>The <code>decode</code> and <code>encode</code> functions define the transformation behavior:<ul>
<li>Passing <code>Option.none()</code> to <code>decode</code> means the field is absent in the input. The function can then return a default value for the output.</li>
<li>Returning <code>Option.none()</code> in <code>encode</code> will omit the field in the output.</li>
</ul>
</li>
</ul>
<p><strong>Example</strong> (Setting <code>null</code> as Default for Missing Field)</p>
<p>This example demonstrates how to use <code>optionalToRequired</code> to provide a <code>null</code> default value when the <code>nullable</code> field is missing in the input. During encoding, fields with a value of <code>null</code> are omitted from the output.</p>
<pre><code class="language-ts">import { Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  nullable: Schema.optionalToRequired(
    // Input schema for an optional string
    Schema.String,
    // Output schema allowing null or string
    Schema.NullOr(Schema.String),
    {
      //         ┌─── Option&lt;string&gt;
      //         ▼
      decode: (maybeString) =&gt; {
        if (Option.isNone(maybeString)) {
          // If `maybeString` is `None`, the field is absent in the input.
          // Return `null` as the default value for the output.
          return null
        }
        // Extract the value from the `Some` instance
        // and use it as the output.
        return maybeString.value
      },
      // During encoding, treat `null` as an absent field
      //
      //         ┌─── string | null
      //         ▼
      encode: (stringOrNull) =&gt;
        stringOrNull === null
          ? // Omit the field by returning `None`
            Option.none()
          : // Include the field by returning `Some`
            Option.some(stringOrNull)
    }
  )
})

// Decoding examples

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({}))
// Output: { nullable: null }
console.log(decode({ nullable: &quot;a value&quot; }))
// Output: { nullable: &#39;a value&#39; }

// Encoding examples

const encode = Schema.encodeSync(schema)

console.log(encode({ nullable: &quot;a value&quot; }))
// Output: { nullable: &#39;a value&#39; }
console.log(encode({ nullable: null }))
// Output: {}
</code></pre>
<p>You can streamline the decoding and encoding logic using <code>Option.getOrElse</code> and <code>Option.liftPredicate</code> for concise and readable transformations.</p>
<p><strong>Example</strong> (Using <code>Option.getOrElse</code> and <code>Option.liftPredicate</code>)</p>
<pre><code class="language-ts">import { Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  nullable: Schema.optionalToRequired(
    Schema.String,
    Schema.NullOr(Schema.String),
    {
      decode: Option.getOrElse(() =&gt; null),
      encode: Option.liftPredicate((value) =&gt; value !== null)
    }
  )
})
</code></pre>
<h3>requiredToOptional</h3>
<p>The <code>requiredToOptional</code> API allows you to transform a required field into an optional one, applying custom logic to determine when the field can be omitted.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">const requiredToOptional = &lt;FA, FI, FR, TA, TI, TR&gt;(
  from: Schema&lt;FA, FI, FR&gt;,
  to: Schema&lt;TA, TI, TR&gt;,
  options: {
    readonly decode: (fa: FA) =&gt; Option.Option&lt;TI&gt;
    readonly encode: (o: Option.Option&lt;TI&gt;) =&gt; FA
  }
): PropertySignature&lt;&quot;?:&quot;, TA, never, &quot;:&quot;, FI, false, FR | TR&gt;
</code></pre>
<p>With <code>decode</code> and <code>encode</code> functions, you control the presence or absence of the field:</p>
<ul>
<li><code>Option.none()</code> as an argument in <code>decode</code> means the field is missing in the input.</li>
<li><code>Option.none()</code> as a return value from <code>encode</code> means the field will be omitted in the output.</li>
</ul>
<p><strong>Example</strong> (Handling Empty String as Missing Value)</p>
<p>In this example, the <code>name</code> field is required but treated as optional if it is an empty string. During decoding, an empty string in <code>name</code> is considered absent, while encoding ensures a value (using an empty string as a default if <code>name</code> is absent).</p>
<pre><code class="language-ts">import { Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  name: Schema.requiredToOptional(Schema.String, Schema.String, {
    //         ┌─── string
    //         ▼
    decode: (string) =&gt; {
      // Treat empty string as a missing value
      if (string === &quot;&quot;) {
        // Omit the field by returning `None`
        return Option.none()
      }
      // Otherwise, return the string as is
      return Option.some(string)
    },
    //         ┌─── Option&lt;string&gt;
    //         ▼
    encode: (maybeString) =&gt; {
      // Check if the field is missing
      if (Option.isNone(maybeString)) {
        // Provide an empty string as default
        return &quot;&quot;
      }
      // Otherwise, return the string as is
      return maybeString.value
    }
  })
})

// Decoding examples

const decode = Schema.decodeUnknownSync(schema)

console.log(decode({ name: &quot;John&quot; }))
// Output: { name: &#39;John&#39; }
console.log(decode({ name: &quot;&quot; }))
// Output: {}

// Encoding examples

const encode = Schema.encodeSync(schema)

console.log(encode({ name: &quot;John&quot; }))
// Output: { name: &#39;John&#39; }
console.log(encode({}))
// Output: { name: &#39;&#39; }
</code></pre>
<p>You can streamline the decoding and encoding logic using <code>Option.liftPredicate</code> and <code>Option.getOrElse</code> for concise and readable transformations.</p>
<p><strong>Example</strong> (Using <code>Option.liftPredicate</code> and <code>Option.getOrElse</code>)</p>
<pre><code class="language-ts">import { Option, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  name: Schema.requiredToOptional(Schema.String, Schema.String, {
    decode: Option.liftPredicate((s) =&gt; s !== &quot;&quot;),
    encode: Option.getOrElse(() =&gt; &quot;&quot;)
  })
})
</code></pre>
<h2>Extending Schemas</h2>
<p>Schemas in <code>effect</code> can be extended in multiple ways, allowing you to combine or enhance existing types with additional fields or functionality. One common method is to use the <code>fields</code> property available in <code>Struct</code> schemas. This property provides a convenient way to add fields or merge fields from different structs while retaining the original <code>Struct</code> type. This approach also makes it easier to access and modify fields.</p>
<p>For more complex cases, such as extending a struct with a union, you may want to use the <code>Schema.extend</code> function, which offers flexibility in scenarios where direct field spreading may not be sufficient.</p>
<Aside type="tip" title="Retaining Struct Type with Field Spreading">
  By using field spreading with `...Struct.fields`, you maintain the
  schema's `Struct` type, which allows continued access to the `fields`
  property for further modifications.
</Aside>

<h3>Spreading Struct fields</h3>
<p>Structs provide access to their fields through the <code>fields</code> property, which allows you to extend an existing struct by adding additional fields or combining fields from multiple structs.</p>
<p><strong>Example</strong> (Adding New Fields)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Orginal = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Extended = Schema.Struct({
  ...Orginal.fields,
  // Adding new fields
  c: Schema.String,
  d: Schema.String
})

//     ┌─── {
//     |      readonly a: string;
//     |      readonly b: string;
//     |      readonly c: string;
//     |      readonly d: string;
//     |    }
//     ▼
type Type = typeof Extended.Type
</code></pre>
<p><strong>Example</strong> (Adding Additional Index Signatures)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Extended = Schema.Struct(
  Original.fields,
  // Adding an index signature
  Schema.Record({ key: Schema.String, value: Schema.String })
)

//     ┌─── {
//     │      readonly [x: string]: string;
//     |      readonly a: string;
//     |      readonly b: string;
//     |    }
//     ▼
type Type = typeof Extended.Type
</code></pre>
<p><strong>Example</strong> (Combining Fields from Multiple Structs)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Struct1 = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

const Struct2 = Schema.Struct({
  c: Schema.String,
  d: Schema.String
})

const Extended = Schema.Struct({
  ...Struct1.fields,
  ...Struct2.fields
})

//     ┌─── {
//     |      readonly a: string;
//     |      readonly b: string;
//     |      readonly c: string;
//     |      readonly d: string;
//     |    }
//     ▼
type Type = typeof Extended.Type
</code></pre>
<h3>The extend function</h3>
<p>The <code>Schema.extend</code> function provides a structured method to expand schemas, especially useful when direct <a href="#spreading-struct-fields">field spreading</a> isn&#39;t sufficient—such as when you need to extend a struct with a union of other structs.</p>
<Aside type="caution" title="Extension Support Limitations">
  Not all extensions are supported, and compatibility depends on the type
  of schemas involved in the extension.
</Aside>

<p>Supported extensions include:</p>
<ul>
<li><code>Schema.String</code> with another <code>Schema.String</code> refinement or a string literal</li>
<li><code>Schema.Number</code> with another <code>Schema.Number</code> refinement or a number literal</li>
<li><code>Schema.Boolean</code> with another <code>Schema.Boolean</code> refinement or a boolean literal</li>
<li>A struct with another struct where overlapping fields support extension</li>
<li>A struct with in index signature</li>
<li>A struct with a union of supported schemas</li>
<li>A refinement of a struct with a supported schema</li>
<li>A <code>suspend</code> of a struct with a supported schema</li>
</ul>
<p><strong>Example</strong> (Extending a Struct with a Union of Structs)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Struct = Schema.Struct({
  a: Schema.String
})

const UnionOfStructs = Schema.Union(
  Schema.Struct({ b: Schema.String }),
  Schema.Struct({ c: Schema.String })
)

const Extended = Schema.extend(Struct, UnionOfStructs)

//     ┌─── {
//     |        readonly a: string;
//     |    } &amp; ({
//     |        readonly b: string;
//     |    } | {
//     |        readonly c: string;
//     |    })
//     ▼
type Type = typeof Extended.Type
</code></pre>
<p><strong>Example</strong> (Attempting to Extend Structs with Conflicting Fields)</p>
<p>This example demonstrates an attempt to extend a struct with another struct that contains overlapping field names, resulting in an error due to conflicting types.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Struct = Schema.Struct({
  a: Schema.String
})

const OverlappingUnion = Schema.Union(
  Schema.Struct({ a: Schema.Number }), // conflicting type for key &quot;a&quot;
  Schema.Struct({ d: Schema.String })
)

const Extended = Schema.extend(Struct, OverlappingUnion)
/*
throws:
Error: Unsupported schema or overlapping types
at path: [&quot;a&quot;]
details: cannot extend string with number
*/
</code></pre>
<p><strong>Example</strong> (Extending a Refinement with Another Refinement)</p>
<p>In this example, we extend two refinements, <code>Integer</code> and <code>Positive</code>, creating a schema that enforces both integer and positivity constraints.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Integer = Schema.Int.pipe(Schema.brand(&quot;Int&quot;))
const Positive = Schema.Positive.pipe(Schema.brand(&quot;Positive&quot;))

//      ┌─── Schema&lt;number &amp; Brand&lt;&quot;Positive&quot;&gt; &amp; Brand&lt;&quot;Int&quot;&gt;, number, never&gt;
//      ▼
const PositiveInteger = Schema.asSchema(Schema.extend(Positive, Integer))

Schema.decodeUnknownSync(PositiveInteger)(-1)
/*
throws
ParseError: positive &amp; Brand&lt;&quot;Positive&quot;&gt; &amp; int &amp; Brand&lt;&quot;Int&quot;&gt;
└─ From side refinement failure
   └─ positive &amp; Brand&lt;&quot;Positive&quot;&gt;
      └─ Predicate refinement failure
         └─ Expected a positive number, actual -1
*/

Schema.decodeUnknownSync(PositiveInteger)(1.1)
/*
throws
ParseError: positive &amp; Brand&lt;&quot;Positive&quot;&gt; &amp; int &amp; Brand&lt;&quot;Int&quot;&gt;
└─ Predicate refinement failure
   └─ Expected an integer, actual 1.1
*/
</code></pre>
<h2>Renaming Properties</h2>
<h3>Renaming a Property During Definition</h3>
<p>To rename a property directly during schema creation, you can utilize the <code>Schema.fromKey</code> function.</p>
<p><strong>Example</strong> (Renaming a Required Property)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  a: Schema.propertySignature(Schema.String).pipe(Schema.fromKey(&quot;c&quot;)),
  b: Schema.Number
})

//     ┌─── { readonly c: string; readonly b: number; }
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── { readonly a: string; readonly b: number; }
//     ▼
type Type = typeof schema.Type

console.log(Schema.decodeUnknownSync(schema)({ c: &quot;c&quot;, b: 1 }))
// Output: { a: &quot;c&quot;, b: 1 }
</code></pre>
<p><strong>Example</strong> (Renaming an Optional Property)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  a: Schema.optional(Schema.String).pipe(Schema.fromKey(&quot;c&quot;)),
  b: Schema.Number
})

//     ┌─── { readonly b: number; readonly c?: string | undefined; }
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── { readonly a?: string | undefined; readonly b: number; }
//     ▼
type Type = typeof schema.Type

console.log(Schema.decodeUnknownSync(schema)({ c: &quot;c&quot;, b: 1 }))
// Output: { a: &#39;c&#39;, b: 1 }

console.log(Schema.decodeUnknownSync(schema)({ b: 1 }))
// Output: { b: 1 }
</code></pre>
<p>Using <code>Schema.optional</code> automatically returns a <code>PropertySignature</code>, making it unnecessary to explicitly use <code>Schema.propertySignature</code> as required for renaming required fields in the previous example.</p>
<h3>Renaming Properties of an Existing Schema</h3>
<p>For existing schemas, the <code>Schema.rename</code> API offers a way to systematically change property names across a schema, even within complex structures like unions, though in case of structs you lose the original field types.</p>
<p><strong>Example</strong> (Renaming Properties in a Struct Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Struct({
  c: Schema.String,
  b: Schema.Number
})

// Renaming the &quot;c&quot; property to &quot;a&quot;
//
//
//      ┌─── SchemaClass&lt;{
//      |      readonly a: string;
//      |      readonly b: number;
//      |    }&gt;
//      ▼
const Renamed = Schema.rename(Original, { c: &quot;a&quot; })

console.log(Schema.decodeUnknownSync(Renamed)({ c: &quot;c&quot;, b: 1 }))
// Output: { a: &quot;c&quot;, b: 1 }
</code></pre>
<p><strong>Example</strong> (Renaming Properties in Union Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Union(
  Schema.Struct({
    c: Schema.String,
    b: Schema.Number
  }),
  Schema.Struct({
    c: Schema.String,
    d: Schema.Boolean
  })
)

// Renaming the &quot;c&quot; property to &quot;a&quot; for all members
//
//      ┌─── SchemaClass&lt;{
//      |      readonly a: string;
//      |      readonly b: number;
//      |    } | {
//      |      readonly a: string;
//      |      readonly d: number;
//      |    }&gt;
//      ▼
const Renamed = Schema.rename(Original, { c: &quot;a&quot; })

console.log(Schema.decodeUnknownSync(Renamed)({ c: &quot;c&quot;, b: 1 }))
// Output: { a: &quot;c&quot;, b: 1 }

console.log(Schema.decodeUnknownSync(Renamed)({ c: &quot;c&quot;, d: false }))
// Output: { a: &#39;c&#39;, d: false }
</code></pre>
<h2>Recursive Schemas</h2>
<p>The <code>Schema.suspend</code> function is designed for defining schemas that reference themselves, such as in recursive data structures.</p>
<p><strong>Example</strong> (Self-Referencing Schema)</p>
<p>In this example, the <code>Category</code> schema references itself through the <code>subcategories</code> field, which is an array of <code>Category</code> objects.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

interface Category {
  readonly name: string
  readonly subcategories: ReadonlyArray&lt;Category&gt;
}

const Category = Schema.Struct({
  name: Schema.String,
  subcategories: Schema.Array(
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
})
</code></pre>
<Aside type="note" title="Correct Inference">
  It is necessary to define the `Category` type and add an explicit type
  annotation because otherwise TypeScript would struggle to infer types
  correctly. Without this annotation, you might encounter the error
  message:
</Aside>

<p><strong>Example</strong> (Type Inference Error)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// @ts-expect-error
const Category = Schema.Struct({
  name: Schema.String,
  // @ts-expect-error
  subcategories: Schema.Array(Schema.suspend(() =&gt; Category))
})
/*
&#39;Category&#39; implicitly has type &#39;any&#39; because it does not have a type annotation and is
referenced directly or indirectly in its own initializer.ts(7022)
*/
</code></pre>
<h3>A Helpful Pattern to Simplify Schema Definition</h3>
<p>As we&#39;ve observed, it&#39;s necessary to define an interface for the <code>Type</code> of the schema to enable recursive schema definition, which can complicate things and be quite tedious.
One pattern to mitigate this is to <strong>separate the field responsible for recursion</strong> from all other fields.</p>
<p><strong>Example</strong> (Separating Recursive Fields)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const fields = {
  name: Schema.String
  // ...other fields as needed
}

// Define an interface for the Category schema,
// extending the Type of the defined fields
interface Category extends Schema.Struct.Type&lt;typeof fields&gt; {
  // Define `subcategories` using recursion
  readonly subcategories: ReadonlyArray&lt;Category&gt;
}

const Category = Schema.Struct({
  ...fields, // Spread in the base fields
  subcategories: Schema.Array(
    // Define `subcategories` using recursion
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
})
</code></pre>
<h3>Mutually Recursive Schemas</h3>
<p>You can also use <code>Schema.suspend</code> to create mutually recursive schemas, where two schemas reference each other. In the following example, <code>Expression</code> and <code>Operation</code> form a simple arithmetic expression tree by referencing each other.</p>
<p><strong>Example</strong> (Defining Mutually Recursive Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

interface Expression {
  readonly type: &quot;expression&quot;
  readonly value: number | Operation
}

interface Operation {
  readonly type: &quot;operation&quot;
  readonly operator: &quot;+&quot; | &quot;-&quot;
  readonly left: Expression
  readonly right: Expression
}

const Expression = Schema.Struct({
  type: Schema.Literal(&quot;expression&quot;),
  value: Schema.Union(
    Schema.Number,
    Schema.suspend((): Schema.Schema&lt;Operation&gt; =&gt; Operation)
  )
})

const Operation = Schema.Struct({
  type: Schema.Literal(&quot;operation&quot;),
  operator: Schema.Literal(&quot;+&quot;, &quot;-&quot;),
  left: Expression,
  right: Expression
})
</code></pre>
<h3>Recursive Types with Different Encoded and Type</h3>
<p>Defining a recursive schema where the <code>Encoded</code> type differs from the <code>Type</code> type adds another layer of complexity. In such cases, we need to define two interfaces: one for the <code>Type</code> type, as seen previously, and another for the <code>Encoded</code> type.</p>
<p><strong>Example</strong> (Recursive Schema with Different Encoded and Type Definitions)</p>
<p>Let&#39;s consider an example: suppose we want to add an <code>id</code> field to the <code>Category</code> schema, where the schema for <code>id</code> is <code>NumberFromString</code>.
It&#39;s important to note that <code>NumberFromString</code> is a schema that transforms a string into a number, so the <code>Type</code> and <code>Encoded</code> types of <code>NumberFromString</code> differ, being <code>number</code> and <code>string</code> respectively.
When we add this field to the <code>Category</code> schema, TypeScript raises an error:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const fields = {
  id: Schema.NumberFromString,
  name: Schema.String
}

interface Category extends Schema.Struct.Type&lt;typeof fields&gt; {
  readonly subcategories: ReadonlyArray&lt;Category&gt;
}

const Category = Schema.Struct({
  ...fields,
  subcategories: Schema.Array(
    // @ts-expect-error
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
})
/*
Type &#39;Struct&lt;{ subcategories: Array$&lt;suspend&lt;Category, Category, never&gt;&gt;; id: typeof NumberFromString; name: typeof String$; }&gt;&#39; is not assignable to type &#39;Schema&lt;Category, Category, never&gt;&#39;.
  The types of &#39;Encoded.id&#39; are incompatible between these types.
    Type &#39;string&#39; is not assignable to type &#39;number&#39;.ts(2322)
*/
</code></pre>
<p>This error occurs because the explicit annotation <code>Schema.Schema&lt;Category&gt;</code> is no longer sufficient and needs to be adjusted by explicitly adding the <code>Encoded</code> type:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const fields = {
  id: Schema.NumberFromString,
  name: Schema.String
}

interface Category extends Schema.Struct.Type&lt;typeof fields&gt; {
  readonly subcategories: ReadonlyArray&lt;Category&gt;
}

interface CategoryEncoded extends Schema.Struct.Encoded&lt;typeof fields&gt; {
  readonly subcategories: ReadonlyArray&lt;CategoryEncoded&gt;
}

const Category = Schema.Struct({
  ...fields,
  subcategories: Schema.Array(
    Schema.suspend(
      (): Schema.Schema&lt;Category, CategoryEncoded&gt; =&gt; Category
    )
  )
})
</code></pre>
<hr>
<hr>
<h2>title: Schema Annotations
description: Learn how to enhance schemas with annotations for better customization, error handling, documentation, and concurrency control in your Effect-based applications.
sidebar:
  label: Annotations
  order: 8</h2>
<p>One of the key features of the Schema design is its flexibility and ability to be customized.
This is achieved through &quot;annotations.&quot;
Each node in the <code>ast</code> field of a schema has an <code>annotations: Record&lt;string | symbol, unknown&gt;</code> field,
which allows you to attach additional information to the schema.
You can manage these annotations using the <code>annotations</code> method or the <code>Schema.annotations</code> API.</p>
<p><strong>Example</strong> (Using Annotations to Customize Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a Password schema, starting with a string type
const Password = Schema.String
  // Add a custom error message for non-string values
  .annotations({ message: () =&gt; &quot;not a string&quot; })
  .pipe(
    // Enforce non-empty strings and provide a custom error message
    Schema.nonEmptyString({ message: () =&gt; &quot;required&quot; }),
    // Restrict the string length to 10 characters or fewer
    // with a custom error message for exceeding length
    Schema.maxLength(10, {
      message: (issue) =&gt; `${issue.actual} is too long`
    })
  )
  .annotations({
    // Add a unique identifier for the schema
    identifier: &quot;Password&quot;,
    // Provide a title for the schema
    title: &quot;password&quot;,
    // Include a description explaining what this schema represents
    description:
      &quot;A password is a secret string used to authenticate a user&quot;,
    // Add examples for better clarity
    examples: [&quot;1Ki77y&quot;, &quot;jelly22fi$h&quot;],
    // Include any additional documentation
    documentation: `...technical information on Password schema...`
  })
</code></pre>
<h2>Built-in Annotations</h2>
<p>The following table provides an overview of common built-in annotations and their uses:</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>identifier</code></td>
<td>Assigns a unique identifier to the schema, ideal for TypeScript identifiers and code generation purposes. Commonly used in tools like <a href="/docs/schema/error-formatters/#customizing-the-output">TreeFormatter</a> to clarify output. Examples include <code>&quot;Person&quot;</code>, <code>&quot;Product&quot;</code>.</td>
</tr>
<tr>
<td><code>title</code></td>
<td>Sets a short, descriptive title for the schema, similar to a JSON Schema title. Useful for documentation or UI headings. It is also used by <a href="/docs/schema/error-formatters/#customizing-the-output">TreeFormatter</a> to enhance readability of error messages.</td>
</tr>
<tr>
<td><code>description</code></td>
<td>Provides a detailed explanation about the schema&#39;s purpose, akin to a JSON Schema description. Used by <a href="/docs/schema/error-formatters/#customizing-the-output">TreeFormatter</a> to provide more detailed error messages.</td>
</tr>
<tr>
<td><code>documentation</code></td>
<td>Extends detailed documentation for the schema, beneficial for developers or automated documentation generation.</td>
</tr>
<tr>
<td><code>examples</code></td>
<td>Lists examples of valid schema values, akin to the examples attribute in JSON Schema, useful for documentation and validation testing.</td>
</tr>
<tr>
<td><code>default</code></td>
<td>Defines a default value for the schema, similar to the default attribute in JSON Schema, to ensure schemas are pre-populated where applicable.</td>
</tr>
<tr>
<td><code>message</code></td>
<td>Customizes the error message for validation failures, improving clarity in outputs from tools like <a href="/docs/schema/error-formatters/#customizing-the-output">TreeFormatter</a> and <a href="/docs/schema/error-formatters/#arrayformatter">ArrayFormatter</a> during decoding or validation errors.</td>
</tr>
<tr>
<td><code>jsonSchema</code></td>
<td>Specifies annotations that affect the generation of <a href="/docs/schema/json-schema/">JSON Schema</a> documents, customizing how schemas are represented.</td>
</tr>
<tr>
<td><code>arbitrary</code></td>
<td>Configures settings for generating <a href="/docs/schema/arbitrary/">Arbitrary</a> test data.</td>
</tr>
<tr>
<td><code>pretty</code></td>
<td>Configures settings for generating <a href="/docs/schema/pretty/">Pretty</a> output.</td>
</tr>
<tr>
<td><code>equivalence</code></td>
<td>Configures settings for evaluating data <a href="/docs/schema/equivalence/">Equivalence</a>.</td>
</tr>
<tr>
<td><code>concurrency</code></td>
<td>Controls concurrency behavior, ensuring schemas perform optimally under concurrent operations. Refer to <a href="#concurrency-annotation">Concurrency Annotation</a> for detailed usage.</td>
</tr>
<tr>
<td><code>batching</code></td>
<td>Manages settings for batching operations to enhance performance when operations can be grouped.</td>
</tr>
<tr>
<td><code>parseIssueTitle</code></td>
<td>Provides a custom title for parsing issues, enhancing error descriptions in outputs from <a href="/docs/schema/error-formatters/#treeformatter-default">TreeFormatter</a>. See <a href="/docs/schema/error-formatters/#parseissuetitle-annotation">ParseIssueTitle Annotation</a> for more information.</td>
</tr>
<tr>
<td><code>parseOptions</code></td>
<td>Allows overriding of parsing options at the schema level, offering granular control over parsing behaviors. See <a href="/docs/schema/getting-started/#customizing-parsing-behavior-at-the-schema-level">Customizing Parsing Behavior at the Schema Level</a> for application details.</td>
</tr>
<tr>
<td><code>decodingFallback</code></td>
<td>Provides a way to define custom fallback behaviors that trigger when decoding operations fail. Refer to <a href="#handling-decoding-errors-with-fallbacks">Handling Decoding Errors with Fallbacks</a> for detailed usage.</td>
</tr>
</tbody></table>
<h2>Concurrency Annotation</h2>
<p>For more complex schemas like <code>Struct</code>, <code>Array</code>, or <code>Union</code> that contain multiple nested schemas, the <code>concurrency</code> annotation provides a way to control how validations are executed concurrently.</p>
<pre><code class="language-ts">type ConcurrencyAnnotation = number | &quot;unbounded&quot; | &quot;inherit&quot; | undefined
</code></pre>
<p>Here&#39;s a shorter version presented in a table:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>number</code></td>
<td>Limits the maximum number of concurrent tasks.</td>
</tr>
<tr>
<td><code>&quot;unbounded&quot;</code></td>
<td>All tasks run concurrently with no limit.</td>
</tr>
<tr>
<td><code>&quot;inherit&quot;</code></td>
<td>Inherits concurrency settings from the parent context.</td>
</tr>
<tr>
<td><code>undefined</code></td>
<td>Tasks run sequentially, one after the other (default behavior).</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Sequential Execution)</p>
<p>In this example, we define three tasks that simulate asynchronous operations with different durations. Since no concurrency is specified, the tasks are executed sequentially, one after the other.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import type { Duration } from &quot;effect&quot;
import { Effect } from &quot;effect&quot;

// Simulates an async task
const item = (id: number, duration: Duration.DurationInput) =&gt;
  Schema.String.pipe(
    Schema.filterEffect(() =&gt;
      Effect.gen(function* () {
        yield* Effect.sleep(duration)
        console.log(`Task ${id} done`)
        return true
      })
    )
  )

const Sequential = Schema.Tuple(
  item(1, &quot;30 millis&quot;),
  item(2, &quot;10 millis&quot;),
  item(3, &quot;20 millis&quot;)
)

Effect.runPromise(Schema.decode(Sequential)([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
/*
Output:
Task 1 done
Task 2 done
Task 3 done
*/
</code></pre>
<p><strong>Example</strong> (Concurrent Execution)</p>
<p>By adding a <code>concurrency</code> annotation set to <code>&quot;unbounded&quot;</code>, the tasks can now run concurrently, meaning they don&#39;t wait for one another to finish before starting. This allows faster execution when multiple tasks are involved.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import type { Duration } from &quot;effect&quot;
import { Effect } from &quot;effect&quot;

// Simulates an async task
const item = (id: number, duration: Duration.DurationInput) =&gt;
  Schema.String.pipe(
    Schema.filterEffect(() =&gt;
      Effect.gen(function* () {
        yield* Effect.sleep(duration)
        console.log(`Task ${id} done`)
        return true
      })
    )
  )

const Concurrent = Schema.Tuple(
  item(1, &quot;30 millis&quot;),
  item(2, &quot;10 millis&quot;),
  item(3, &quot;20 millis&quot;)
).annotations({ concurrency: &quot;unbounded&quot; })

Effect.runPromise(Schema.decode(Concurrent)([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
/*
Output:
Task 2 done
Task 3 done
Task 1 done
*/
</code></pre>
<h2>Handling Decoding Errors with Fallbacks</h2>
<p>The <code>DecodingFallbackAnnotation</code> allows you to handle decoding errors by providing a custom fallback logic.</p>
<pre><code class="language-ts">type DecodingFallbackAnnotation&lt;A&gt; = (
  issue: ParseIssue
) =&gt; Effect&lt;A, ParseIssue&gt;
</code></pre>
<p>This annotation enables you to specify fallback behavior when decoding fails, making it possible to recover gracefully from errors.</p>
<p><strong>Example</strong> (Basic Fallback)</p>
<p>In this basic example, when decoding fails (e.g., the input is <code>null</code>), the fallback value is returned instead of an error.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Either } from &quot;effect&quot;

// Schema with a fallback value
const schema = Schema.String.annotations({
  decodingFallback: () =&gt; Either.right(&quot;&lt;fallback&gt;&quot;)
})

console.log(Schema.decodeUnknownSync(schema)(&quot;valid input&quot;))
// Output: valid input

console.log(Schema.decodeUnknownSync(schema)(null))
// Output: &lt;fallback&gt;
</code></pre>
<p><strong>Example</strong> (Advanced Fallback with Logging)</p>
<p>In this advanced example, when a decoding error occurs, the schema logs the issue and then returns a fallback value.
This demonstrates how you can incorporate logging and other side effects during error handling.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Effect } from &quot;effect&quot;

// Schema with logging and fallback
const schemaWithLog = Schema.String.annotations({
  decodingFallback: (issue) =&gt;
    Effect.gen(function* () {
      // Log the error issue
      yield* Effect.log(issue._tag)
      // Simulate a delay
      yield* Effect.sleep(10)
      // Return a fallback value
      return yield* Effect.succeed(&quot;&lt;fallback&gt;&quot;)
    })
})

// Run the effectful fallback logic
Effect.runPromise(Schema.decodeUnknown(schemaWithLog)(null)).then(
  console.log
)
/*
Output:
timestamp=2024-07-25T13:22:37.706Z level=INFO fiber=#0 message=Type
&lt;fallback&gt;
*/
</code></pre>
<h2>Custom Annotations</h2>
<p>In addition to built-in annotations, you can define custom annotations to meet specific requirements. For instance, here&#39;s how to create a <code>deprecated</code> annotation:</p>
<p><strong>Example</strong> (Defining a Custom Annotation)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a unique identifier for your custom annotation
const DeprecatedId = Symbol.for(
  &quot;some/unique/identifier/for/your/custom/annotation&quot;
)

// Apply the custom annotation to the schema
const MyString = Schema.String.annotations({ [DeprecatedId]: true })

console.log(MyString)
/*
Output:
[class SchemaClass] {
  ast: StringKeyword {
    annotations: {
      [Symbol(@effect/docs/schema/annotation/Title)]: &#39;string&#39;,
      [Symbol(@effect/docs/schema/annotation/Description)]: &#39;a string&#39;,
      [Symbol(some/unique/identifier/for/your/custom/annotation)]: true
    },
    _tag: &#39;StringKeyword&#39;
  },
  ...
}
*/
</code></pre>
<p>To make your new custom annotation type-safe, you can use a module augmentation. In the next example, we want our custom annotation to be a boolean.</p>
<p><strong>Example</strong> (Adding Type Safety to Custom Annotations)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const DeprecatedId = Symbol.for(
  &quot;some/unique/identifier/for/your/custom/annotation&quot;
)

// Module augmentation
declare module &quot;effect/Schema&quot; {
  namespace Annotations {
    interface GenericSchema&lt;A&gt; extends Schema&lt;A&gt; {
      [DeprecatedId]?: boolean
    }
  }
}

const MyString = Schema.String.annotations({
  // @ts-expect-error
  [DeprecatedId]: &quot;bad value&quot;
  // Type of computed property&#39;s value is &#39;string&#39;,
  // which is not assignable to type &#39;boolean&#39;.ts(2418)
})
</code></pre>
<p>You can retrieve custom annotations using the <code>SchemaAST.getAnnotation</code> helper function.</p>
<p><strong>Example</strong> (Retrieving a Custom Annotation)</p>
<pre><code class="language-ts">import { SchemaAST, Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const DeprecatedId = Symbol.for(
  &quot;some/unique/identifier/for/your/custom/annotation&quot;
)

declare module &quot;effect/Schema&quot; {
  namespace Annotations {
    interface GenericSchema&lt;A&gt; extends Schema&lt;A&gt; {
      [DeprecatedId]?: boolean
    }
  }
}

const MyString = Schema.String.annotations({ [DeprecatedId]: true })

// Helper function to check if a schema is marked as deprecated
const isDeprecated = &lt;A, I, R&gt;(schema: Schema.Schema&lt;A, I, R&gt;): boolean =&gt;
  SchemaAST.getAnnotation&lt;boolean&gt;(DeprecatedId)(schema.ast).pipe(
    Option.getOrElse(() =&gt; false)
  )

console.log(isDeprecated(Schema.String))
// Output: false

console.log(isDeprecated(MyString))
// Output: true
</code></pre>
<hr>
<hr>
<h2>title: Schema to Arbitrary
description: Generate random test data that adheres to schema constraints using Arbitrary, with options for transformations, filters, and custom generation.
sidebar:
  label: Arbitrary
  order: 15</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>Arbitrary.make</code> function allows for the creation of random values that align with a specific <code>Schema&lt;A, I, R&gt;</code>.
This function returns an <code>Arbitrary&lt;A&gt;</code> from the <a href="https://github.com/dubzzz/fast-check">fast-check</a> library,
which is particularly useful for generating random test data that adheres to the defined schema constraints.</p>
<p><strong>Example</strong> (Generating Arbitrary Data for a Schema)</p>
<pre><code class="language-ts">import { Arbitrary, FastCheck, Schema } from &quot;effect&quot;

// Define a Person schema with constraints
const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Int.pipe(Schema.between(1, 80))
})

// Create an Arbitrary based on the schema
const arb = Arbitrary.make(Person)

// Generate random samples from the Arbitrary
console.log(FastCheck.sample(arb, 2))
/*
Example Output:
[ { name: &#39;q r&#39;, age: 3 }, { name: &#39;&amp;|&#39;, age: 6 } ]
*/
</code></pre>
<p>To make the output more realistic, see the <a href="#customizing-arbitrary-data-generation">Customizing Arbitrary Data Generation</a> section.</p>
<Aside type="tip" title="Access FastCheck API">
  The entirety of `fast-check`'s API is accessible via the `FastCheck`
  export, allowing direct use of all its functionalities within your
  projects.
</Aside>

<h2>Filters</h2>
<p>When generating random values, <code>Arbitrary</code> tries to follow the schema&#39;s constraints. It uses the most appropriate <code>fast-check</code> primitives and applies constraints if the primitive supports them.</p>
<p>For instance, if you define an <code>age</code> property as:</p>
<pre><code class="language-ts">Schema.Int.pipe(Schema.between(1, 80))
</code></pre>
<p>the arbitrary generation will use:</p>
<pre><code class="language-ts">FastCheck.integer({ min: 1, max: 80 })
</code></pre>
<p>to produce values within that range.</p>
<Aside type="note" title="Avoiding Conflicts in Filters">
When using multiple filters, be aware that conflicting filters might lead to hangs during arbitrary data generation. This can occur when the constraints make it difficult or impossible to produce valid values.

<p>For guidance on mitigating these issues, refer to <a href="https://github.com/dubzzz/fast-check/discussions/4659">this discussion</a>.</p>
</Aside>

<h3>Patterns</h3>
<p>To generate efficient arbitraries for strings that must match a certain pattern, use the <code>Schema.pattern</code> filter instead of writing a custom filter:</p>
<p><strong>Example</strong> (Using <code>Schema.pattern</code> for Pattern Constraints)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// ❌ Without using Schema.pattern (less efficient)
const Bad = Schema.String.pipe(Schema.filter((s) =&gt; /^[a-z]+$/.test(s)))

// ✅ Using Schema.pattern (more efficient)
const Good = Schema.String.pipe(Schema.pattern(/^[a-z]+$/))
</code></pre>
<p>By using <code>Schema.pattern</code>, arbitrary generation will rely on <code>FastCheck.stringMatching(regexp)</code>, which is more efficient and directly aligned with the defined pattern.</p>
<p>When multiple patterns are used, they are combined into a union. For example:</p>
<pre><code class="language-ts">(?:${pattern1})|(?:${pattern2})
</code></pre>
<p>This approach ensures all patterns have an equal chance of generating values when using <code>FastCheck.stringMatching</code>.</p>
<h2>Transformations and Arbitrary Generation</h2>
<p>When generating arbitrary data, it is important to understand how transformations and filters are handled within a schema:</p>
<Aside type="caution" title="Filters Ignored">
  Filters applied before the last transformation in the transformation
  chain are not considered during the generation of arbitrary data.
</Aside>

<p><strong>Example</strong> (Filters and Transformations)</p>
<pre><code class="language-ts">import { Arbitrary, FastCheck, Schema } from &quot;effect&quot;

// Schema with filters before the transformation
const schema1 = Schema.compose(Schema.NonEmptyString, Schema.Trim).pipe(
  Schema.maxLength(500)
)

// May produce empty strings due to ignored NonEmpty filter
console.log(FastCheck.sample(Arbitrary.make(schema1), 2))
/*
Example Output:
[ &#39;&#39;, &#39;&quot;Ry&#39; ]
*/

// Schema with filters applied after transformations
const schema2 = Schema.Trim.pipe(
  Schema.nonEmptyString(),
  Schema.maxLength(500)
)

// Adheres to all filters, avoiding empty strings
console.log(FastCheck.sample(Arbitrary.make(schema2), 2))
/*
Example Output:
[ &#39;]H+MPXgZKz&#39;, &#39;SNS|waP~\\&#39; ]
*/
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>schema1</code>: Takes into account <code>Schema.maxLength(500)</code> since it is applied after the <code>Schema.Trim</code> transformation, but ignores the <code>Schema.NonEmptyString</code> as it precedes the transformations.</li>
<li><code>schema2</code>: Adheres fully to all filters because they are correctly sequenced after transformations, preventing the generation of undesired data.</li>
</ul>
<h3>Best Practices</h3>
<p>To ensure consistent and valid arbitrary data generation, follow these guidelines:</p>
<ol>
<li><strong>Apply Filters First</strong>: Define filters for the initial type (<code>I</code>).</li>
<li><strong>Apply Transformations</strong>: Add transformations to convert the data.</li>
<li><strong>Apply Final Filters</strong>: Use filters for the transformed type (<code>A</code>).</li>
</ol>
<p>This setup ensures that each stage of data processing is precise and well-defined.</p>
<p><strong>Example</strong> (Avoid Mixed Filters and Transformations)</p>
<p>Avoid haphazard combinations of transformations and filters:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Less optimal approach: Mixing transformations and filters
const problematic = Schema.compose(Schema.Lowercase, Schema.Trim)
</code></pre>
<p>Prefer a structured approach by separating transformation steps from filter applications:</p>
<p><strong>Example</strong> (Preferred Structured Approach)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Recommended: Separate transformations and filters
const improved = Schema.transform(
  Schema.String,
  Schema.String.pipe(Schema.trimmed(), Schema.lowercased()),
  {
    strict: true,
    decode: (s) =&gt; s.trim().toLowerCase(),
    encode: (s) =&gt; s
  }
)
</code></pre>
<h2>Customizing Arbitrary Data Generation</h2>
<p>You can customize how arbitrary data is generated using the <code>arbitrary</code> annotation in schema definitions.</p>
<p><strong>Example</strong> (Custom Arbitrary Generator)</p>
<pre><code class="language-ts">import { Arbitrary, FastCheck, Schema } from &quot;effect&quot;

const Name = Schema.NonEmptyString.annotations({
  arbitrary: () =&gt; (fc) =&gt;
    fc.constantFrom(&quot;Alice Johnson&quot;, &quot;Dante Howell&quot;, &quot;Marta Reyes&quot;)
})

const Age = Schema.Int.pipe(Schema.between(1, 80))

const Person = Schema.Struct({
  name: Name,
  age: Age
})

const arb = Arbitrary.make(Person)

console.log(FastCheck.sample(arb, 2))
/*
Example Output:
[ { name: &#39;Dante Howell&#39;, age: 6 }, { name: &#39;Marta Reyes&#39;, age: 53 } ]
*/
</code></pre>
<p>The annotation allows access the complete export of the fast-check library (<code>fc</code>).
This setup enables you to return an <code>Arbitrary</code> that precisely generates the type of data desired.</p>
<h3>Integration with Fake Data Generators</h3>
<p>When using mocking libraries like <a href="https://www.npmjs.com/package/@faker-js/faker">@faker-js/faker</a>,
you can combine them with <code>fast-check</code> to generate realistic data for testing purposes.</p>
<p><strong>Example</strong> (Integrating with Faker)</p>
<pre><code class="language-ts">import { Arbitrary, FastCheck, Schema } from &quot;effect&quot;
import { faker } from &quot;@faker-js/faker&quot;

const Name = Schema.NonEmptyString.annotations({
  arbitrary: () =&gt; (fc) =&gt;
    fc.constant(null).map(() =&gt; {
      // Each time the arbitrary is sampled, faker generates a new name
      return faker.person.fullName()
    })
})

const Age = Schema.Int.pipe(Schema.between(1, 80))

const Person = Schema.Struct({
  name: Name,
  age: Age
})

const arb = Arbitrary.make(Person)

console.log(FastCheck.sample(arb, 2))
/*
Example Output:
[
  { name: &#39;Henry Dietrich&#39;, age: 68 },
  { name: &#39;Lucas Haag&#39;, age: 52 }
]
*/
</code></pre>
<hr>
<hr>
<h2>title: Basic Usage
description: Learn to define and work with basic schemas, including primitives, literals, unions, and structs, for effective data validation and transformation.
sidebar:
  order: 3</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<h2>Primitives</h2>
<p>The Schema module provides built-in schemas for common primitive types.</p>
<table>
<thead>
<tr>
<th>Schema</th>
<th>Equivalent TypeScript Type</th>
</tr>
</thead>
<tbody><tr>
<td><code>Schema.String</code></td>
<td><code>string</code></td>
</tr>
<tr>
<td><code>Schema.Number</code></td>
<td><code>number</code></td>
</tr>
<tr>
<td><code>Schema.Boolean</code></td>
<td><code>boolean</code></td>
</tr>
<tr>
<td><code>Schema.BigIntFromSelf</code></td>
<td><code>BigInt</code></td>
</tr>
<tr>
<td><code>Schema.SymbolFromSelf</code></td>
<td><code>symbol</code></td>
</tr>
<tr>
<td><code>Schema.Object</code></td>
<td><code>object</code></td>
</tr>
<tr>
<td><code>Schema.Undefined</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>Schema.Void</code></td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>Schema.Any</code></td>
<td><code>any</code></td>
</tr>
<tr>
<td><code>Schema.Unknown</code></td>
<td><code>unknown</code></td>
</tr>
<tr>
<td><code>Schema.Never</code></td>
<td><code>never</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using a Primitive Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.String

// Infers the type as string
//
//     ┌─── string
//     ▼
type Type = typeof schema.Type

// Attempt to decode a null value, which will throw a parse error
Schema.decodeUnknownSync(schema)(null)
/*
throws:
ParseError: Expected string, actual null
*/
</code></pre>
<h2>asSchema</h2>
<p>To make it easier to work with schemas, built-in schemas are exposed with shorter, opaque types when possible.</p>
<p>The <code>Schema.asSchema</code> function allows you to view any schema as <code>Schema&lt;Type, Encoded, Context&gt;</code>.</p>
<p><strong>Example</strong> (Expanding a Schema with <code>asSchema</code>)</p>
<p>For example, while <code>Schema.String</code> is defined as a class with a type of <code>typeof Schema.String</code>, using <code>Schema.asSchema</code> provides the schema in its extended form as <code>Schema&lt;string, string, never&gt;</code>.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//     ┌─── typeof Schema.String
//     ▼
const schema = Schema.String

//     ┌─── Schema&lt;string, string, never&gt;
//     ▼
const nomalized = Schema.asSchema(schema)
</code></pre>
<h2>Unique Symbols</h2>
<p>You can create a schema for unique symbols using <code>Schema.UniqueSymbolFromSelf</code>.</p>
<p><strong>Example</strong> (Creating a Schema for a Unique Symbol)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const mySymbol = Symbol.for(&quot;mySymbol&quot;)

const schema = Schema.UniqueSymbolFromSelf(mySymbol)

//     ┌─── typeof mySymbol
//     ▼
type Type = typeof schema.Type

Schema.decodeUnknownSync(schema)(null)
/*
throws:
ParseError: Expected Symbol(mySymbol), actual null
*/
</code></pre>
<h2>Literals</h2>
<p>Literal schemas represent a <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">literal type</a>.
You can use them to specify exact values that a type must have.</p>
<p>Literals can be of the following types:</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>bigint</code></li>
</ul>
<p><strong>Example</strong> (Defining Literal Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define various literal schemas
Schema.Null // Same as S.Literal(null)
Schema.Literal(&quot;a&quot;) // string literal
Schema.Literal(1) // number literal
Schema.Literal(true) // boolean literal
Schema.Literal(2n) // BigInt literal
</code></pre>
<p><strong>Example</strong> (Defining a Literal Schema for <code>&quot;a&quot;</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//     ┌─── Literal&lt;[&quot;a&quot;]&gt;
//     ▼
const schema = Schema.Literal(&quot;a&quot;)

//     ┌─── &quot;a&quot;
//     ▼
type Type = typeof schema.Type

console.log(Schema.decodeUnknownSync(schema)(&quot;a&quot;))
// Output: &quot;a&quot;

console.log(Schema.decodeUnknownSync(schema)(&quot;b&quot;))
/*
throws:
ParseError: Expected &quot;a&quot;, actual &quot;b&quot;
*/
</code></pre>
<h3>Union of Literals</h3>
<p>You can create a union of multiple literals by passing them as arguments to the <code>Schema.Literal</code> constructor:</p>
<p><strong>Example</strong> (Defining a Union of Literals)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//     ┌─── Literal&lt;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&gt;
//     ▼
const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

//     ┌─── &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
//     ▼
type Type = typeof schema.Type

Schema.decodeUnknownSync(schema)(null)
/*
throws:
ParseError: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
├─ Expected &quot;a&quot;, actual null
├─ Expected &quot;b&quot;, actual null
└─ Expected &quot;c&quot;, actual null
*/
</code></pre>
<p>If you want to set a custom error message for the entire union of literals, you can use the <code>override: true</code> option (see <a href="/docs/schema/error-messages/#custom-error-messages">Custom Error Messages</a> for more details) to specify a unified message.</p>
<p><strong>Example</strong> (Adding a Custom Message to a Union of Literals)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Schema with individual messages for each literal
const individualMessages = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

console.log(Schema.decodeUnknownSync(individualMessages)(null))
/*
throws:
ParseError: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
├─ Expected &quot;a&quot;, actual null
├─ Expected &quot;b&quot;, actual null
└─ Expected &quot;c&quot;, actual null
*/

// Schema with a unified custom message for all literals
const unifiedMessage = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).annotations({
  message: () =&gt; ({ message: &quot;Not a valid code&quot;, override: true })
})

console.log(Schema.decodeUnknownSync(unifiedMessage)(null))
/*
throws:
ParseError: Not a valid code
*/
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the literals defined in a literal schema using the <code>literals</code> property:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

//      ┌─── readonly [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
//      ▼
const literals = schema.literals
</code></pre>
<h3>The pickLiteral Utility</h3>
<p>You can use <code>Schema.pickLiteral</code> with a literal schema to narrow down its possible values.</p>
<p><strong>Example</strong> (Using <code>pickLiteral</code> to Narrow Values)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a schema for a subset of literals (&quot;a&quot; and &quot;b&quot;) from a larger set
//
//      ┌─── Literal&lt;[&quot;a&quot;, &quot;b&quot;]&gt;
//      ▼
const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).pipe(
  Schema.pickLiteral(&quot;a&quot;, &quot;b&quot;)
)
</code></pre>
<p>Sometimes, you may need to reuse a literal schema in other parts of your code. Below is an example demonstrating how to do this:</p>
<p><strong>Example</strong> (Creating a Subtype from a Literal Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define the base set of fruit categories
const FruitCategory = Schema.Literal(&quot;sweet&quot;, &quot;citrus&quot;, &quot;tropical&quot;)

// Define a general Fruit schema with the base category set
const Fruit = Schema.Struct({
  id: Schema.Number,
  category: FruitCategory
})

// Define a specific Fruit schema for only &quot;sweet&quot; and &quot;citrus&quot; categories
const SweetAndCitrusFruit = Schema.Struct({
  id: Schema.Number,
  category: FruitCategory.pipe(Schema.pickLiteral(&quot;sweet&quot;, &quot;citrus&quot;))
})
</code></pre>
<p>In this example, <code>FruitCategory</code> serves as the source of truth for the different fruit categories.
We reuse it to create a subtype of <code>Fruit</code> called <code>SweetAndCitrusFruit</code>, ensuring that only the specified categories (<code>&quot;sweet&quot;</code> and <code>&quot;citrus&quot;</code>) are allowed.
This approach helps maintain consistency throughout your code and provides type safety if the category definition changes.</p>
<h2>Template literals</h2>
<p>In TypeScript, <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">template literals types</a> allow you to embed expressions within string literals.
The <code>Schema.TemplateLiteral</code> constructor allows you to create a schema for these template literal types.</p>
<p><strong>Example</strong> (Defining Template Literals)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// This creates a schema for: `a${string}`
//
//      ┌─── TemplateLiteral&lt;`a${string}`&gt;
//      ▼
const schema1 = Schema.TemplateLiteral(&quot;a&quot;, Schema.String)

// This creates a schema for:
// `https://${string}.com` | `https://${string}.net`
const schema2 = Schema.TemplateLiteral(
  &quot;https://&quot;,
  Schema.String,
  &quot;.&quot;,
  Schema.Literal(&quot;com&quot;, &quot;net&quot;)
)
</code></pre>
<p><strong>Example</strong> (From <a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">template literals types</a> Documentation)</p>
<p>Let&#39;s look at a more complex example. Suppose you have two sets of locale IDs for emails and footers.
You can use the <code>Schema.TemplateLiteral</code> constructor to create a schema that combines these IDs:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const EmailLocaleIDs = Schema.Literal(&quot;welcome_email&quot;, &quot;email_heading&quot;)
const FooterLocaleIDs = Schema.Literal(&quot;footer_title&quot;, &quot;footer_sendoff&quot;)

// This creates a schema for:
// &quot;welcome_email_id&quot; | &quot;email_heading_id&quot; |
// &quot;footer_title_id&quot; | &quot;footer_sendoff_id&quot;
const schema = Schema.TemplateLiteral(
  Schema.Union(EmailLocaleIDs, FooterLocaleIDs),
  &quot;_id&quot;
)
</code></pre>
<h3>Supported Span Types</h3>
<p>The <code>Schema.TemplateLiteral</code> constructor supports the following types of spans:</p>
<ul>
<li><code>Schema.String</code></li>
<li><code>Schema.Number</code></li>
<li>Literals: <code>string | number | boolean | null | bigint</code>. These can be either wrapped by <code>Schema.Literal</code> or used directly</li>
<li>Unions of the above types</li>
<li>Brands of the above types</li>
</ul>
<p><strong>Example</strong> (Using a Branded String in a Template Literal)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a branded string schema for an authorization token
const AuthorizationToken = Schema.String.pipe(
  Schema.brand(&quot;AuthorizationToken&quot;)
)

// This creates a schema for:
// `Bearer ${string &amp; Brand&lt;&quot;AuthorizationToken&quot;&gt;}`
const schema = Schema.TemplateLiteral(&quot;Bearer &quot;, AuthorizationToken)
</code></pre>
<h3>TemplateLiteralParser</h3>
<p>The <code>Schema.TemplateLiteral</code> constructor, while useful as a simple validator, only verifies that an input conforms to a specific string pattern by converting template literal definitions into regular expressions. Similarly, <a href="/docs/schema/filters/#string-filters"><code>Schema.pattern</code></a> employs regular expressions directly for the same purpose. Post-validation, both methods require additional manual parsing to convert the validated string into a usable data format.</p>
<p>To address these limitations and eliminate the need for manual post-validation parsing, the <code>Schema.TemplateLiteralParser</code> API has been developed. It not only validates the input format but also automatically parses it into a more structured and type-safe output, specifically into a <strong>tuple</strong> format.</p>
<p>The <code>Schema.TemplateLiteralParser</code> constructor supports the same types of <a href="#supported-span-types">spans</a> as <code>Schema.TemplateLiteral</code>.</p>
<p><strong>Example</strong> (Using TemplateLiteralParser for Parsing and Encoding)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//      ┌─── Schema&lt;readonly [number, &quot;a&quot;, string], `${string}a${string}`&gt;
//      ▼
const schema = Schema.TemplateLiteralParser(
  Schema.NumberFromString,
  &quot;a&quot;,
  Schema.NonEmptyString
)

console.log(Schema.decodeSync(schema)(&quot;100afoo&quot;))
// Output: [ 100, &#39;a&#39;, &#39;foo&#39; ]

console.log(Schema.encodeSync(schema)([100, &quot;a&quot;, &quot;foo&quot;]))
// Output: &#39;100afoo&#39;
</code></pre>
<h2>Native enums</h2>
<p>The Schema module provides support for native TypeScript enums. You can define a schema for an enum using <code>Schema.Enums</code>, allowing you to validate values that belong to the enum.</p>
<p><strong>Example</strong> (Defining a Schema for an Enum)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

enum Fruits {
  Apple,
  Banana
}

//      ┌─── Enums&lt;typeof Fruits&gt;
//      ▼
const schema = Schema.Enums(Fruits)

//
//     ┌─── Fruits
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Exposed Values</h3>
<p>Enums are accessible through the <code>enums</code> property of the schema. You can use this property to retrieve individual members or the entire set of enum values.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

enum Fruits {
  Apple,
  Banana
}

const schema = Schema.Enums(Fruits)

schema.enums // Returns all enum members
schema.enums.Apple // Access the Apple member
schema.enums.Banana // Access the Banana member
</code></pre>
<h2>Unions</h2>
<p>The Schema module includes a built-in <code>Schema.Union</code> constructor for creating &quot;OR&quot; types, allowing you to define schemas that can represent multiple types.</p>
<p><strong>Example</strong> (Defining a Union Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//      ┌─── Union&lt;[typeof Schema.String, typeof Schema.Number]&gt;
//      ▼
const schema = Schema.Union(Schema.String, Schema.Number)

//     ┌─── string | number
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Union Member Evaluation Order</h3>
<p>When decoding, union members are evaluated in the order they are defined. If a value matches the first member, it will be decoded using that schema. If not, the decoding process moves on to the next member.</p>
<p>If multiple schemas could decode the same value, the order matters. Placing a more general schema before a more specific one may result in missing properties, as the first matching schema will be used.</p>
<p><strong>Example</strong> (Handling Overlapping Schemas in a Union)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define two overlapping schemas

const Member1 = Schema.Struct({
  a: Schema.String
})

const Member2 = Schema.Struct({
  a: Schema.String,
  b: Schema.Number
})

// ❌ Define a union where Member1 appears first
const Bad = Schema.Union(Member1, Member2)

console.log(Schema.decodeUnknownSync(Bad)({ a: &quot;a&quot;, b: 12 }))
// Output: { a: &#39;a&#39; }  (Member1 matched first, so `b` was ignored)

// ✅ Define a union where Member2 appears first
const Good = Schema.Union(Member2, Member1)

console.log(Schema.decodeUnknownSync(Good)({ a: &quot;a&quot;, b: 12 }))
// Output: { a: &#39;a&#39;, b: 12 } (Member2 matched first, so `b` was included)
</code></pre>
<h3>Union of Literals</h3>
<p>While you can create a union of literals by combining individual literal schemas:</p>
<p><strong>Example</strong> (Using Individual Literal Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//      ┌─── Union&lt;[Schema.Literal&lt;[&quot;a&quot;]&gt;, Schema.Literal&lt;[&quot;b&quot;]&gt;, Schema.Literal&lt;[&quot;c&quot;]&gt;]&gt;
//      ▼
const schema = Schema.Union(
  Schema.Literal(&quot;a&quot;),
  Schema.Literal(&quot;b&quot;),
  Schema.Literal(&quot;c&quot;)
)
</code></pre>
<p>You can simplify the process by passing multiple literals directly to the <code>Schema.Literal</code> constructor:</p>
<p><strong>Example</strong> (Defining a Union of Literals)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//     ┌─── Literal&lt;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&gt;
//     ▼
const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

//     ┌─── &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
//     ▼
type Type = typeof schema.Type
</code></pre>
<p>If you want to set a custom error message for the entire union of literals, you can use the <code>override: true</code> option (see <a href="/docs/schema/error-messages/#custom-error-messages">Custom Error Messages</a> for more details) to specify a unified message.</p>
<p><strong>Example</strong> (Adding a Custom Message to a Union of Literals)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Schema with individual messages for each literal
const individualMessages = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

console.log(Schema.decodeUnknownSync(individualMessages)(null))
/*
throws:
ParseError: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;
├─ Expected &quot;a&quot;, actual null
├─ Expected &quot;b&quot;, actual null
└─ Expected &quot;c&quot;, actual null
*/

// Schema with a unified custom message for all literals
const unifiedMessage = Schema.Literal(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).annotations({
  message: () =&gt; ({ message: &quot;Not a valid code&quot;, override: true })
})

console.log(Schema.decodeUnknownSync(unifiedMessage)(null))
/*
throws:
ParseError: Not a valid code
*/
</code></pre>
<h3>Nullables</h3>
<p>The Schema module includes utility functions for defining schemas that allow nullable types, helping to handle values that may be <code>null</code>, <code>undefined</code>, or both.</p>
<p><strong>Example</strong> (Creating Nullable Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Represents a schema for a string or null value
Schema.NullOr(Schema.String)

// Represents a schema for a string, null, or undefined value
Schema.NullishOr(Schema.String)

// Represents a schema for a string or undefined value
Schema.UndefinedOr(Schema.String)
</code></pre>
<h3>Discriminated unions</h3>
<p><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions">Discriminated unions</a> in TypeScript are a way of modeling complex data structures that may take on different forms based on a specific set of conditions or properties. They allow you to define a type that represents multiple related shapes, where each shape is uniquely identified by a shared discriminant property.</p>
<p>In a discriminated union, each variant of the union has a common property, called the discriminant. The discriminant is a literal type, which means it can only have a finite set of possible values. Based on the value of the discriminant property, TypeScript can infer which variant of the union is currently in use.</p>
<p><strong>Example</strong> (Defining a Discriminated Union in TypeScript)</p>
<pre><code class="language-ts">type Circle = {
  readonly kind: &quot;circle&quot;
  readonly radius: number
}

type Square = {
  readonly kind: &quot;square&quot;
  readonly sideLength: number
}

type Shape = Circle | Square
</code></pre>
<p>In the <code>Schema</code> module, you can define a discriminated union similarly by specifying a literal field as the discriminant for each type.</p>
<p><strong>Example</strong> (Defining a Discriminated Union Using Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Circle = Schema.Struct({
  kind: Schema.Literal(&quot;circle&quot;),
  radius: Schema.Number
})

const Square = Schema.Struct({
  kind: Schema.Literal(&quot;square&quot;),
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
</code></pre>
<p>In this example, the <code>Schema.Literal</code> constructor sets up the <code>kind</code> property as the discriminant for both <code>Circle</code> and <code>Square</code> schemas. The <code>Shape</code> schema then represents a union of these two types, allowing TypeScript to infer the specific shape based on the <code>kind</code> value.</p>
<h3>Transforming a Simple Union into a Discriminated Union</h3>
<p>If you start with a simple union and want to transform it into a discriminated union, you can add a special property to each member. This allows TypeScript to automatically infer the correct type based on the value of the discriminant property.</p>
<p><strong>Example</strong> (Initial Simple Union)</p>
<p>For example, let&#39;s say you&#39;ve defined a <code>Shape</code> union as a combination of <code>Circle</code> and <code>Square</code> without any special property:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const Shape = Schema.Union(Circle, Square)
</code></pre>
<p>To make your code more manageable, you may want to transform the simple union into a discriminated union. This way, TypeScript will be able to automatically determine which member of the union you&#39;re working with based on the value of a specific property.</p>
<p>To achieve this, you can add a special property to each member of the union, which will allow TypeScript to know which type it&#39;s dealing with at runtime.
Here&#39;s how you can <a href="/docs/schema/transformations/#transform">transform</a> the <code>Shape</code> schema into another schema that represents a discriminated union:</p>
<p><strong>Example</strong> (Adding Discriminant Property)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const DiscriminatedShape = Schema.Union(
  Schema.transform(
    Circle,
    // Add a &quot;kind&quot; property with the literal value &quot;circle&quot; to Circle
    Schema.Struct({ ...Circle.fields, kind: Schema.Literal(&quot;circle&quot;) }),
    {
      strict: true,
      // Add the discriminant property to Circle
      decode: (circle) =&gt; ({ ...circle, kind: &quot;circle&quot; as const }),
      // Remove the discriminant property
      encode: ({ kind: _kind, ...rest }) =&gt; rest
    }
  ),

  Schema.transform(
    Square,
    // Add a &quot;kind&quot; property with the literal value &quot;square&quot; to Square
    Schema.Struct({ ...Square.fields, kind: Schema.Literal(&quot;square&quot;) }),
    {
      strict: true,
      // Add the discriminant property to Square
      decode: (square) =&gt; ({ ...square, kind: &quot;square&quot; as const }),
      // Remove the discriminant property
      encode: ({ kind: _kind, ...rest }) =&gt; rest
    }
  )
)

console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { radius: 10, kind: &#39;circle&#39; }

console.log(
  Schema.decodeUnknownSync(DiscriminatedShape)({ sideLength: 10 })
)
// Output: { sideLength: 10, kind: &#39;square&#39; }
</code></pre>
<p>The previous solution works perfectly and shows how we can add properties to our schema at will, making it easier to consume the result within our domain model.
However, it requires a lot of boilerplate. Fortunately, there is an API called <code>Schema.attachPropertySignature</code> designed specifically for this use case, which allows us to achieve the same result with much less effort:</p>
<p><strong>Example</strong> (Using <code>Schema.attachPropertySignature</code> for Less Code)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Circle = Schema.Struct({
  radius: Schema.Number
})

const Square = Schema.Struct({
  sideLength: Schema.Number
})

const DiscriminatedShape = Schema.Union(
  Circle.pipe(Schema.attachPropertySignature(&quot;kind&quot;, &quot;circle&quot;)),
  Square.pipe(Schema.attachPropertySignature(&quot;kind&quot;, &quot;square&quot;))
)

// decoding
console.log(Schema.decodeUnknownSync(DiscriminatedShape)({ radius: 10 }))
// Output: { radius: 10, kind: &#39;circle&#39; }

// encoding
console.log(
  Schema.encodeSync(DiscriminatedShape)({
    kind: &quot;circle&quot;,
    radius: 10
  })
)
// Output: { radius: 10 }
</code></pre>
<Aside type="caution" title="Property Addition Only">
  Please note that with `Schema.attachPropertySignature`, you can only add
  a property, it cannot replace or override an existing one.
</Aside>

<h3>Exposed Values</h3>
<p>You can access the individual members of a union schema represented as a tuple:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Union(Schema.String, Schema.Number)

// Accesses the members of the union
const members = schema.members

//      ┌─── typeof Schema.String
//      ▼
const firstMember = members[0]

//      ┌─── typeof Schema.Number
//      ▼
const secondMember = members[1]
</code></pre>
<h2>Tuples</h2>
<p>The Schema module allows you to define tuples, which are ordered collections of elements that may have different types.
You can define tuples with required, optional, or rest elements.</p>
<h3>Required Elements</h3>
<p>To define a tuple with required elements, you can use the <code>Schema.Tuple</code> constructor and simply list the element schemas in order:</p>
<p><strong>Example</strong> (Defining a Tuple with Required Elements)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tuple with a string and a number as required elements
//
//      ┌─── Tuple&lt;[typeof Schema.String, typeof Schema.Number]&gt;
//      ▼
const schema = Schema.Tuple(Schema.String, Schema.Number)

//     ┌─── readonly [string, number]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Append a Required Element</h3>
<p>You can append additional required elements to an existing tuple by using the spread operator:</p>
<p><strong>Example</strong> (Adding an Element to an Existing Tuple)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const tuple1 = Schema.Tuple(Schema.String, Schema.Number)

// Append a boolean to the existing tuple
const tuple2 = Schema.Tuple(...tuple1.elements, Schema.Boolean)

//     ┌─── readonly [string, number, boolean]
//     ▼
type Type = typeof tuple2.Type
</code></pre>
<h3>Optional Elements</h3>
<p>To define an optional element, use the <code>Schema.optionalElement</code> constructor.</p>
<p><strong>Example</strong> (Defining a Tuple with Optional Elements)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tuple with a required string and an optional number
const schema = Schema.Tuple(
  Schema.String, // required element
  Schema.optionalElement(Schema.Number) // optional element
)

//     ┌─── readonly [string, number?]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Rest Element</h3>
<p>To define a rest element, add it after the list of required or optional elements.
The rest element allows the tuple to accept additional elements of a specific type.</p>
<p><strong>Example</strong> (Using a Rest Element)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tuple with required elements and a rest element of type boolean
const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean // rest element
)

//     ┌─── readonly [string, number?, ...boolean[]]
//     ▼
type Type = typeof schema.Type
</code></pre>
<p>You can also include other elements after the rest:</p>
<p><strong>Example</strong> (Including Additional Elements After a Rest Element)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tuple with required elements, a rest element,
// and an additional element
const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest element
  Schema.String // additional element
)

//     ┌─── readonly [string, number | undefined, ...boolean[], string]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Annotations</h3>
<p>Annotations are useful for adding metadata to tuple elements, making it easier to describe their purpose or requirements.
This is especially helpful for generating documentation or JSON schemas.</p>
<p><strong>Example</strong> (Adding Annotations to Tuple Elements)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

// Define a tuple representing a point with annotations for each coordinate
const Point = Schema.Tuple(
  Schema.element(Schema.Number).annotations({
    title: &quot;X&quot;,
    description: &quot;X coordinate&quot;
  }),
  Schema.optionalElement(Schema.Number).annotations({
    title: &quot;Y&quot;,
    description: &quot;optional Y coordinate&quot;
  })
)

// Generate a JSON Schema from the tuple
console.log(JSONSchema.make(Point))
/*
Output:
{
  &#39;$schema&#39;: &#39;http://json-schema.org/draft-07/schema#&#39;,
  type: &#39;array&#39;,
  minItems: 1,
  items: [
    { type: &#39;number&#39;, description: &#39;X coordinate&#39;, title: &#39;X&#39; },
    {
      type: &#39;number&#39;,
      description: &#39;optional Y coordinate&#39;,
      title: &#39;Y&#39;
    }
  ],
  additionalItems: false
}
*/
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the elements and rest elements of a tuple schema using the <code>elements</code> and <code>rest</code> properties:</p>
<p><strong>Example</strong> (Accessing Elements and Rest Element in a Tuple Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tuple with required, optional, and rest elements
const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean, // rest element
  Schema.String // additional element
)

// Access the required and optional elements of the tuple
//
//      ┌─── readonly [typeof Schema.String, Schema.Element&lt;typeof Schema.Number, &quot;?&quot;&gt;]
//      ▼
const tupleElements = schema.elements

// Access the rest element of the tuple
//
//      ┌─── readonly [typeof Schema.Boolean, typeof Schema.String]
//      ▼
const restElement = schema.rest
</code></pre>
<h2>Arrays</h2>
<p>The Schema module allows you to define schemas for arrays, making it easy to validate collections of elements of a specific type.</p>
<p><strong>Example</strong> (Defining an Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for an array of numbers
//
//      ┌─── Array$&lt;typeof Schema.Number&gt;
//      ▼
const schema = Schema.Array(Schema.Number)

//     ┌─── readonly number[]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Mutable Arrays</h3>
<p>By default, <code>Schema.Array</code> generates a type marked as <code>readonly</code>.
To create a schema for a mutable array, you can use the <code>Schema.mutable</code> function, which makes the array type mutable in a <strong>shallow</strong> manner.</p>
<p><strong>Example</strong> (Creating a Mutable Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for a mutable array of numbers
//
//      ┌─── mutable&lt;Schema.Array$&lt;typeof Schema.Number&gt;&gt;
//      ▼
const schema = Schema.mutable(Schema.Array(Schema.Number))

//     ┌─── number[]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the value type of an array schema using the <code>value</code> property:</p>
<p><strong>Example</strong> (Accessing the Value Type of an Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Array(Schema.Number)

// Access the value type of the array schema
//
//      ┌─── typeof Schema.Number
//      ▼
const value = schema.value
</code></pre>
<h2>Non Empty Arrays</h2>
<p>The Schema module also provides a way to define schemas for non-empty arrays, ensuring that the array always contains at least one element.</p>
<p><strong>Example</strong> (Defining a Non-Empty Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for a non-empty array of numbers
//
//      ┌─── NonEmptyArray&lt;typeof Schema.Number&gt;
//      ▼
const schema = Schema.NonEmptyArray(Schema.Number)

//     ┌─── readonly [number, ...number[]]
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the value type of a non-empty array schema using the <code>value</code> property:</p>
<p><strong>Example</strong> (Accessing the Value Type of a Non-Empty Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for a non-empty array of numbers
const schema = Schema.NonEmptyArray(Schema.Number)

// Access the value type of the non-empty array schema
//
//      ┌─── typeof Schema.Number
//      ▼
const value = schema.value
</code></pre>
<h2>Records</h2>
<p>The Schema module provides support for defining record types, which are collections of key-value pairs where the key can be a string, symbol, or other types, and the value has a defined schema.</p>
<h3>String Keys</h3>
<p>You can define a record with string keys and a specified type for the values.</p>
<p><strong>Example</strong> (String Keys with Number Values)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a record schema with string keys and number values
//
//      ┌─── Record$&lt;typeof Schema.String, typeof Schema.Number&gt;
//      ▼
const schema = Schema.Record({ key: Schema.String, value: Schema.Number })

//     ┌─── { readonly [x: string]: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Symbol Keys</h3>
<p>Records can also use symbols as keys.</p>
<p><strong>Example</strong> (Symbol Keys with Number Values)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a record schema with symbol keys and number values
const schema = Schema.Record({
  key: Schema.SymbolFromSelf,
  value: Schema.Number
})

//     ┌─── { readonly [x: symbol]: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Union of Literal Keys</h3>
<p>Use a union of literals to restrict keys to a specific set of values.</p>
<p><strong>Example</strong> (Union of String Literals as Keys)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a record schema where keys are limited
// to specific string literals (&quot;a&quot; or &quot;b&quot;)
const schema = Schema.Record({
  key: Schema.Union(Schema.Literal(&quot;a&quot;), Schema.Literal(&quot;b&quot;)),
  value: Schema.Number
})

//     ┌─── { readonly a: number; readonly b: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Template Literal Keys</h3>
<p>Records can use template literals as keys, allowing for more complex key patterns.</p>
<p><strong>Example</strong> (Template Literal Keys with Number Values)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a record schema with keys that match
// the template literal pattern &quot;a${string}&quot;
const schema = Schema.Record({
  key: Schema.TemplateLiteral(Schema.Literal(&quot;a&quot;), Schema.String),
  value: Schema.Number
})

//     ┌─── { readonly [x: `a${string}`]: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Refined Keys</h3>
<p>You can refine the key type with additional constraints.</p>
<p><strong>Example</strong> (Refined Keys with Minimum Length Constraint)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a record schema where keys are strings with a minimum length of 2
const schema = Schema.Record({
  key: Schema.String.pipe(Schema.minLength(2)),
  value: Schema.Number
})

//     ┌─── { readonly [x: string]: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Mutable Records</h3>
<p>By default, <code>Schema.Record</code> generates a type marked as <code>readonly</code>.
To create a schema for a mutable record, you can use the <code>Schema.mutable</code> function, which makes the record type mutable in a <strong>shallow</strong> manner.</p>
<p><strong>Example</strong> (Creating a Mutable Record Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a schema for a mutable record with string keys and number values
const schema = Schema.mutable(
  Schema.Record({ key: Schema.String, value: Schema.Number })
)

//     ┌─── { [x: string]: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the <code>key</code> and <code>value</code> types of a record schema using the <code>key</code> and <code>value</code> properties:</p>
<p><strong>Example</strong> (Accessing Key and Value Types)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Record({ key: Schema.String, value: Schema.Number })

// Accesses the key
//
//     ┌─── typeof Schema.String
//     ▼
const key = schema.key

// Accesses the value
//
//      ┌─── typeof Schema.Number
//      ▼
const value = schema.value
</code></pre>
<h2>Structs</h2>
<p>The <code>Schema.Struct</code> constructor allows you to define a schema for an object with specific properties.</p>
<p><strong>Example</strong> (Defining a Struct Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a struct schema for an object with properties:
// - &quot;name&quot; (string)
// - &quot;age&quot; (number)
//
//      ┌─── Schema.Struct&lt;{
//      │      name: typeof Schema.String;
//      │      age: typeof Schema.Number;
//      │    }&gt;
//      ▼
const schema = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

//     ┌─── { readonly name: string; readonly age: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<Aside type="caution" title="Allows Any Data">
  Note that `Schema.Struct({})` models the TypeScript type `{}`, which is
  similar to `unknown`. This means that the schema will allow any type of
  data to pass through without validation.
</Aside>

<h3>Index Signatures</h3>
<p>The <code>Schema.Struct</code> constructor can optionally accept a list of key/value pairs representing index signatures, allowing you to define additional dynamic properties.</p>
<pre><code class="language-ts">declare const Struct: (props, ...indexSignatures) =&gt; Struct&lt;...&gt;
</code></pre>
<p><strong>Example</strong> (Adding an Index Signature)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a struct with a specific property &quot;a&quot;
// and an index signature for other properties
const schema = Schema.Struct(
  {
    a: Schema.Number
  },
  { key: Schema.String, value: Schema.Number }
)

//     ┌─── { readonly [x: string]: number; readonly a: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<p>Since the <code>Schema.Record</code> constructor returns a schema that exposes both the <code>key</code> and <code>value</code>, you can simplify the above code by using the <code>Schema.Record</code> constructor:</p>
<p><strong>Example</strong> (Simplifying with <code>Schema.Record</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct(
  { a: Schema.Number },
  Schema.Record({ key: Schema.String, value: Schema.Number })
)

//     ┌─── { readonly [x: string]: number; readonly a: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Mutable Structs</h3>
<p>By default, <code>Schema.Struct</code> generates a type with properties marked as <code>readonly</code>.
To create a mutable version of the struct, use the <code>Schema.mutable</code> function, which makes the properties mutable in a <strong>shallow</strong> manner.</p>
<p><strong>Example</strong> (Creating a Mutable Struct Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.mutable(
  Schema.Struct({ a: Schema.String, b: Schema.Number })
)

//     ┌─── { a: string; b: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h3>Exposed Values</h3>
<p>You can access the fields and records of a struct schema using the <code>fields</code> and <code>records</code> properties:</p>
<p><strong>Example</strong> (Accessing Fields and Records)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct(
  { a: Schema.Number },
  Schema.Record({ key: Schema.String, value: Schema.Number })
)

// Accesses the fields
//
//      ┌─── { readonly a: typeof Schema.Number; }
//      ▼
const fields = schema.fields

// Accesses the records
//
//      ┌─── readonly [Schema.Record$&lt;typeof Schema.String, typeof Schema.Number&gt;]
//      ▼
const records = schema.records
</code></pre>
<h2>Tagged Structs</h2>
<p>In TypeScript tags help to enhance type discrimination and pattern matching by providing a simple yet powerful way to define and recognize different data types.</p>
<h3>What is a Tag?</h3>
<p>A tag is a literal value added to data structures, commonly used in structs, to distinguish between various object types or variants within tagged unions. This literal acts as a discriminator, making it easier to handle and process different types of data correctly and efficiently.</p>
<h3>Using the tag Constructor</h3>
<p>The <code>Schema.tag</code> constructor is specifically designed to create a property signature that holds a specific literal value, serving as the discriminator for object types.</p>
<p><strong>Example</strong> (Defining a Tagged Struct)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const User = Schema.Struct({
  _tag: Schema.tag(&quot;User&quot;),
  name: Schema.String,
  age: Schema.Number
})

//     ┌─── { readonly _tag: &quot;User&quot;; readonly name: string; readonly age: number; }
//     ▼
type Type = typeof User.Type

console.log(User.make({ name: &quot;John&quot;, age: 44 }))
/*
Output:
{ _tag: &#39;User&#39;, name: &#39;John&#39;, age: 44 }
*/
</code></pre>
<p>In the example above, <code>Schema.tag(&quot;User&quot;)</code> attaches a <code>_tag</code> property to the <code>User</code> struct schema, effectively labeling objects of this struct type as &quot;User&quot;.
This label is automatically applied when using the <code>make</code> method to create new instances, simplifying object creation and ensuring consistent tagging.</p>
<h3>Simplifying Tagged Structs with TaggedStruct</h3>
<p>The <code>Schema.TaggedStruct</code> constructor streamlines the process of creating tagged structs by directly integrating the tag into the struct definition. This method provides a clearer and more declarative approach to building data structures with embedded discriminators.</p>
<p><strong>Example</strong> (Using <code>TaggedStruct</code> for a Simplified Tagged Struct)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const User = Schema.TaggedStruct(&quot;User&quot;, {
  name: Schema.String,
  age: Schema.Number
})

// `_tag` is automatically applied when constructing an instance
console.log(User.make({ name: &quot;John&quot;, age: 44 }))
// Output: { _tag: &#39;User&#39;, name: &#39;John&#39;, age: 44 }

// `_tag` is required when decoding from an unknown source
console.log(Schema.decodeUnknownSync(User)({ name: &quot;John&quot;, age: 44 }))
/*
throws:
ParseError: { readonly _tag: &quot;User&quot;; readonly name: string; readonly age: number }
└─ [&quot;_tag&quot;]
   └─ is missing
*/
</code></pre>
<p>In this example:</p>
<ul>
<li>The <code>_tag</code> property is optional when constructing an instance with <code>make</code>, allowing the schema to automatically apply it.</li>
<li>When decoding unknown data, <code>_tag</code> is required to ensure correct type identification. This distinction between instance construction and decoding is useful for preserving the tag’s role as a type discriminator while simplifying instance creation.</li>
</ul>
<p>If you need <code>_tag</code> to be applied automatically during decoding as well, you can create a customized version of <code>Schema.TaggedStruct</code>:</p>
<p><strong>Example</strong> (Custom <code>TaggedStruct</code> with <code>_tag</code> Applied during Decoding)</p>
<pre><code class="language-ts">import type { SchemaAST } from &quot;effect&quot;
import { Schema } from &quot;effect&quot;

const TaggedStruct = &lt;
  Tag extends SchemaAST.LiteralValue,
  Fields extends Schema.Struct.Fields
&gt;(
  tag: Tag,
  fields: Fields
) =&gt;
  Schema.Struct({
    _tag: Schema.Literal(tag).pipe(
      Schema.optional,
      Schema.withDefaults({
        constructor: () =&gt; tag, // Apply _tag during instance construction
        decoding: () =&gt; tag // Apply _tag during decoding
      })
    ),
    ...fields
  })

const User = TaggedStruct(&quot;User&quot;, {
  name: Schema.String,
  age: Schema.Number
})

console.log(User.make({ name: &quot;John&quot;, age: 44 }))
// Output: { _tag: &#39;User&#39;, name: &#39;John&#39;, age: 44 }

console.log(Schema.decodeUnknownSync(User)({ name: &quot;John&quot;, age: 44 }))
// Output: { _tag: &#39;User&#39;, name: &#39;John&#39;, age: 44 }
</code></pre>
<h3>Multiple Tags</h3>
<p>While a primary tag is often sufficient, TypeScript allows you to define multiple tags for more complex data structuring needs. Here&#39;s an example demonstrating the use of multiple tags within a single struct:</p>
<p><strong>Example</strong> (Adding Multiple Tags to a Struct)</p>
<p>This example defines a product schema with a primary tag (<code>&quot;Product&quot;</code>) and an additional category tag (<code>&quot;Electronics&quot;</code>), adding further specificity to the data structure.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Product = Schema.TaggedStruct(&quot;Product&quot;, {
  category: Schema.tag(&quot;Electronics&quot;),
  name: Schema.String,
  price: Schema.Number
})

// `_tag` and `category` are optional when creating an instance
console.log(Product.make({ name: &quot;Smartphone&quot;, price: 999 }))
/*
Output:
{
  _tag: &#39;Product&#39;,
  category: &#39;Electronics&#39;,
  name: &#39;Smartphone&#39;,
  price: 999
}
*/
</code></pre>
<h2>instanceOf</h2>
<p>When you need to define a schema for your custom data type defined through a <code>class</code>, the most convenient and fast way is to use the <code>Schema.instanceOf</code> constructor.</p>
<p><strong>Example</strong> (Defining a Schema with <code>instanceOf</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a custom class
class MyData {
  constructor(readonly name: string) {}
}

// Create a schema for the class
const MyDataSchema = Schema.instanceOf(MyData)

//     ┌─── MyData
//     ▼
type Type = typeof MyDataSchema.Type

console.log(Schema.decodeUnknownSync(MyDataSchema)(new MyData(&quot;name&quot;)))
// Output: MyData { name: &#39;name&#39; }

console.log(Schema.decodeUnknownSync(MyDataSchema)({ name: &quot;name&quot; }))
/*
throws
ParseError: Expected MyData, actual {&quot;name&quot;:&quot;name&quot;}
*/
</code></pre>
<p>The <code>Schema.instanceOf</code> constructor is just a lightweight wrapper of the <a href="/docs/schema/advanced-usage/#declaring-new-data-types">Schema.declare</a> API, which is the primitive in <code>effect/Schema</code> for declaring new custom data types.</p>
<h3>Private Constructors</h3>
<p>Note that <code>Schema.instanceOf</code> can only be used for classes that expose a <strong>public constructor</strong>.
If you try to use it with classes that, for some reason, have marked the constructor as <code>private</code>, you&#39;ll receive a TypeScript error:</p>
<p><strong>Example</strong> (Error With Private Constructors)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class MyData {
  static make = (name: string) =&gt; new MyData(name)
  private constructor(readonly name: string) {}
}

// @ts-expect-error
const MyDataSchema = Schema.instanceOf(MyData)
/*
Argument of type &#39;typeof MyData&#39; is not assignable to parameter of type &#39;abstract new (...args: any) =&gt; any&#39;.
  Cannot assign a &#39;private&#39; constructor type to a &#39;public&#39; constructor type.ts(2345)
*/
</code></pre>
<p>In such cases, you cannot use <code>Schema.instanceOf</code>, and you must rely on <a href="/docs/schema/advanced-usage/#declaring-new-data-types">Schema.declare</a> like this:</p>
<p><strong>Example</strong> (Using <code>Schema.declare</code> With Private Constructors)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class MyData {
  static make = (name: string) =&gt; new MyData(name)
  private constructor(readonly name: string) {}
}

const MyDataSchema = Schema.declare(
  (input: unknown): input is MyData =&gt; input instanceof MyData
).annotations({ identifier: &quot;MyData&quot; })

console.log(Schema.decodeUnknownSync(MyDataSchema)(MyData.make(&quot;name&quot;)))
// Output: MyData { name: &#39;name&#39; }

console.log(Schema.decodeUnknownSync(MyDataSchema)({ name: &quot;name&quot; }))
/*
throws
ParseError: Expected MyData, actual {&quot;name&quot;:&quot;name&quot;}
*/
</code></pre>
<h3>Validating Fields of the Instance</h3>
<p>To validate the fields of a class instance, you can use a <a href="/docs/schema/filters/">filter</a>. This approach combines instance validation with additional checks on the instance&#39;s fields.</p>
<p><strong>Example</strong> (Adding Field Validation to an Instance Schema)</p>
<pre><code class="language-ts">import { Either, ParseResult, Schema } from &quot;effect&quot;

class MyData {
  constructor(readonly name: string) {}
}

const MyDataFields = Schema.Struct({
  name: Schema.NonEmptyString
})

// Define a schema for the class instance with additional field validation
const MyDataSchema = Schema.instanceOf(MyData).pipe(
  Schema.filter((a, options) =&gt;
    // Validate the fields of the instance
    ParseResult.validateEither(MyDataFields)(a, options).pipe(
      // Invert success and failure for filtering
      Either.flip,
      // Return undefined if validation succeeds, or an error if it fails
      Either.getOrUndefined
    )
  )
)

// Example: Valid instance
console.log(Schema.validateSync(MyDataSchema)(new MyData(&quot;John&quot;)))
// Output: MyData { name: &#39;John&#39; }

// Example: Invalid instance (empty name)
console.log(Schema.validateSync(MyDataSchema)(new MyData(&quot;&quot;)))
/*
throws:
ParseError: { MyData | filter }
└─ Predicate refinement failure
   └─ { readonly name: NonEmptyString }
      └─ [&quot;name&quot;]
         └─ NonEmptyString
            └─ Predicate refinement failure
               └─ Expected a non empty string, actual &quot;&quot;
*/
</code></pre>
<h2>Picking</h2>
<p>The <code>pick</code> static function available on each struct schema can be used to create a new <code>Struct</code> by selecting specific properties from an existing <code>Struct</code>.</p>
<p><strong>Example</strong> (Picking Properties from a Struct)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a struct schema with properties &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;
const MyStruct = Schema.Struct({
  a: Schema.String,
  b: Schema.Number,
  c: Schema.Boolean
})

// Create a new schema that picks properties &quot;a&quot; and &quot;c&quot;
//
//      ┌─── Struct&lt;{
//      |      a: typeof Schema.String;
//      |      c: typeof Schema.Boolean;
//      |    }&gt;
//      ▼
const PickedSchema = MyStruct.pick(&quot;a&quot;, &quot;c&quot;)
</code></pre>
<p>The <code>Schema.pick</code> function can be applied more broadly beyond just <code>Struct</code> types, such as with unions of schemas.
However it returns a generic <code>SchemaClass</code>.</p>
<p><strong>Example</strong> (Picking Properties from a Union)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a union of two struct schemas
const MyUnion = Schema.Union(
  Schema.Struct({ a: Schema.String, b: Schema.String, c: Schema.String }),
  Schema.Struct({ a: Schema.Number, b: Schema.Number, d: Schema.Number })
)

// Create a new schema that picks properties &quot;a&quot; and &quot;b&quot;
//
//      ┌─── SchemaClass&lt;{
//      |      readonly a: string | number;
//      |      readonly b: string | number;
//      |    }&gt;
//      ▼
const PickedSchema = MyUnion.pipe(Schema.pick(&quot;a&quot;, &quot;b&quot;))
</code></pre>
<h2>Omitting</h2>
<p>The <code>omit</code> static function available in each struct schema can be used to create a new <code>Struct</code> by excluding particular properties from an existing <code>Struct</code>.</p>
<p><strong>Example</strong> (Omitting Properties from a Struct)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a struct schema with properties &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;
const MyStruct = Schema.Struct({
  a: Schema.String,
  b: Schema.Number,
  c: Schema.Boolean
})

// Create a new schema that omits property &quot;b&quot;
//
//      ┌─── Schema.Struct&lt;{
//      |      a: typeof Schema.String;
//      |      c: typeof Schema.Boolean;
//      |    }&gt;
//      ▼
const PickedSchema = MyStruct.omit(&quot;b&quot;)
</code></pre>
<p>The <code>Schema.omit</code> function can be applied more broadly beyond just <code>Struct</code> types, such as with unions of schemas.
However it returns a generic <code>Schema</code>.</p>
<p><strong>Example</strong> (Omitting Properties from a Union)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a union of two struct schemas
const MyUnion = Schema.Union(
  Schema.Struct({ a: Schema.String, b: Schema.String, c: Schema.String }),
  Schema.Struct({ a: Schema.Number, b: Schema.Number, d: Schema.Number })
)

// Create a new schema that omits property &quot;b&quot;
//
//      ┌─── SchemaClass&lt;{
//      |      readonly a: string | number;
//      |    }&gt;
//      ▼
const PickedSchema = MyUnion.pipe(Schema.omit(&quot;b&quot;))
</code></pre>
<h2>partial</h2>
<p>The <code>Schema.partial</code> function makes all properties within a schema optional.</p>
<p><strong>Example</strong> (Making All Properties Optional)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a schema with an optional property &quot;a&quot;
const schema = Schema.partial(Schema.Struct({ a: Schema.String }))

//     ┌─── { readonly a?: string | undefined; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<p>By default, the <code>Schema.partial</code> operation adds <code>undefined</code> to the type of each property. If you want to avoid this, you can use <code>Schema.partialWith</code> and pass <code>{ exact: true }</code> as an argument.</p>
<p><strong>Example</strong> (Defining an Exact Partial Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a schema with an optional property &quot;a&quot; without allowing undefined
const schema = Schema.partialWith(
  Schema.Struct({
    a: Schema.String
  }),
  { exact: true }
)

//     ┌─── { readonly a?: string; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<h2>required</h2>
<p>The <code>Schema.required</code> function ensures that all properties in a schema are mandatory.</p>
<p><strong>Example</strong> (Making All Properties Required)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Create a schema and make all properties required
const schema = Schema.required(
  Schema.Struct({
    a: Schema.optionalWith(Schema.String, { exact: true }),
    b: Schema.optionalWith(Schema.Number, { exact: true })
  })
)

//     ┌─── { readonly a: string; readonly b: number; }
//     ▼
type Type = typeof schema.Type
</code></pre>
<p>In this example, both <code>a</code> and <code>b</code> are made required, even though they were initially defined as optional.</p>
<h2>keyof</h2>
<p>The <code>Schema.keyof</code> operation creates a schema that represents the keys of a given object schema.</p>
<p><strong>Example</strong> (Extracting Keys from an Object Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.Number
})

const keys = Schema.keyof(schema)

//     ┌─── &quot;a&quot; | &quot;b&quot;
//     ▼
type Type = typeof keys.Type
</code></pre>
<hr>
<hr>
<h2>title: Class APIs
description: Learn to define and extend schemas using classes, incorporating validation, custom logic, and advanced features like equality checks and transformations.
sidebar:
  order: 11</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>When working with schemas, you have a choice beyond the <a href="/docs/schema/basic-usage/#structs">Schema.Struct</a> constructor.
You can leverage the power of classes through the <code>Schema.Class</code> utility, which comes with its own set of advantages tailored to common use cases:</p>
<p>Classes offer several features that simplify the schema creation process:</p>
<ul>
<li><strong>All-in-One Definition</strong>: With classes, you can define both a schema and an opaque type simultaneously.</li>
<li><strong>Shared Functionality</strong>: You can incorporate shared functionality using class methods or getters.</li>
<li><strong>Value Hashing and Equality</strong>: Utilize the built-in capability for checking value equality and applying hashing (thanks to <code>Class</code> implementing <a href="/docs/data-types/data/#class">Data.Class</a>).</li>
</ul>
<h2>Definition</h2>
<p>To define a class using <code>Schema.Class</code>, you need to specify:</p>
<ul>
<li>The <strong>type</strong> of the class being created.</li>
<li>A unique <strong>identifier</strong> for the class.</li>
<li>The desired <strong>fields</strong>.</li>
</ul>
<p><strong>Example</strong> (Defining a Schema Class)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}
</code></pre>
<p>In this example, <code>Person</code> is both a schema and a TypeScript class. Instances of <code>Person</code> are created using the defined schema, ensuring compliance with the specified fields.</p>
<p><strong>Example</strong> (Creating Instances)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

console.log(new Person({ id: 1, name: &quot;John&quot; }))
/*
Output:
Person { id: 1, name: &#39;John&#39; }
*/

// Using the factory function
console.log(Person.make({ id: 1, name: &quot;John&quot; }))
/*
Output:
Person { id: 1, name: &#39;John&#39; }
*/
</code></pre>
<Aside type="note" title="Why Use Identifiers?">
  You need to specify an identifier to make the class global. This ensures that two classes with the same identifier refer to the same instance, avoiding reliance on `instanceof` checks.

<p>This behavior is similar to how we handle other class-based APIs like <a href="/docs/requirements-management/services/#creating-a-service">Context.Tag</a>.</p>
<p>Using a unique identifier is particularly useful in scenarios where live reloads can occur, as it helps preserve the instance across reloads. It ensures there is no duplication of instances (although it shouldn&#39;t happen, some bundlers and frameworks can behave unpredictably).</p>
</Aside>

<h3>Defining Classes Without Fields</h3>
<p>When your schema does not require any fields, you can define a class with an empty object.</p>
<p><strong>Example</strong> (Defining and Using a Class Without Arguments)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a class with no fields
class NoArgs extends Schema.Class&lt;NoArgs&gt;(&quot;NoArgs&quot;)({}) {}

// Create an instance using the default constructor
const noargs1 = new NoArgs()

// Alternatively, create an instance by explicitly passing an empty object
const noargs2 = new NoArgs({})
</code></pre>
<h3>Defining Classes With Filters</h3>
<p>Filters allow you to validate input when decoding, encoding, or creating an instance. Instead of specifying raw fields, you can pass a <code>Schema.Struct</code> with a filter applied.</p>
<p><strong>Example</strong> (Applying a Filter to a Schema Class)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class WithFilter extends Schema.Class&lt;WithFilter&gt;(&quot;WithFilter&quot;)(
  Schema.Struct({
    a: Schema.NumberFromString,
    b: Schema.NumberFromString
  }).pipe(
    Schema.filter(({ a, b }) =&gt; a &gt;= b || &quot;a must be greater than b&quot;)
  )
) {}

// Constructor
console.log(new WithFilter({ a: 1, b: 2 }))
/*
throws:
ParseError: WithFilter (Constructor)
└─ Predicate refinement failure
   └─ a must be greater than b
*/

// Decoding
console.log(Schema.decodeUnknownSync(WithFilter)({ a: &quot;1&quot;, b: &quot;2&quot; }))
/*
throws:
ParseError: (WithFilter (Encoded side) &lt;-&gt; WithFilter)
└─ Encoded side transformation failure
   └─ WithFilter (Encoded side)
      └─ Predicate refinement failure
         └─ a must be greater than b
*/
</code></pre>
<h2>Validating Properties via Class Constructors</h2>
<p>When you define a class using <code>Schema.Class</code>, the constructor automatically checks that the provided properties adhere to the schema&#39;s rules.</p>
<h3>Defining and Instantiating a Valid Class Instance</h3>
<p>The constructor ensures that each property, like <code>id</code> and <code>name</code>, adheres to the schema. For instance, <code>id</code> must be a number, and <code>name</code> must be a non-empty string.</p>
<p><strong>Example</strong> (Creating a Valid Instance)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Create an instance with valid properties
const john = new Person({ id: 1, name: &quot;John&quot; })
</code></pre>
<h3>Handling Invalid Properties</h3>
<p>If invalid properties are provided during instantiation, the constructor throws an error, explaining why the validation failed.</p>
<p><strong>Example</strong> (Creating an Instance with Invalid Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Attempt to create an instance with an invalid `name`
new Person({ id: 1, name: &quot;&quot; })
/*
throws:
ParseError: Person (Constructor)
└─ [&quot;name&quot;]
   └─ NonEmptyString
      └─ Predicate refinement failure
         └─ Expected NonEmptyString, actual &quot;&quot;
*/
</code></pre>
<p>The error clearly specifies that the <code>name</code> field failed to meet the <code>NonEmptyString</code> requirement.</p>
<h3>Bypassing Validation</h3>
<p>In some scenarios, you might want to bypass the validation logic. While not generally recommended, the library provides an option to do so.</p>
<p><strong>Example</strong> (Bypassing Validation)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Bypass validation during instantiation
const john = new Person({ id: 1, name: &quot;&quot; }, true)

// Or use the `disableValidation` option explicitly
new Person({ id: 1, name: &quot;&quot; }, { disableValidation: true })
</code></pre>
<h2>Automatic Hashing and Equality in Classes</h2>
<p>Instances of classes created with <code>Schema.Class</code> support the <a href="/docs/trait/equal/">Equal</a> trait through their integration with <a href="/docs/data-types/data/#class">Data.Class</a>. This enables straightforward value comparisons, even across different instances.</p>
<h3>Basic Equality Check</h3>
<p>Two class instances are considered equal if their properties have identical values.</p>
<p><strong>Example</strong> (Comparing Instances with Equal Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Equal } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

const john1 = new Person({ id: 1, name: &quot;John&quot; })
const john2 = new Person({ id: 1, name: &quot;John&quot; })

// Compare instances
console.log(Equal.equals(john1, john2))
// Output: true
</code></pre>
<h3>Nested or Complex Properties</h3>
<p>The <code>Equal</code> trait performs comparisons at the first level. If a property is a more complex structure, such as an array, instances may not be considered equal, even if the arrays themselves have identical values.</p>
<p><strong>Example</strong> (Shallow Equality for Arrays)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Equal } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString,
  hobbies: Schema.Array(Schema.String) // Standard array schema
}) {}

const john1 = new Person({
  id: 1,
  name: &quot;John&quot;,
  hobbies: [&quot;reading&quot;, &quot;coding&quot;]
})
const john2 = new Person({
  id: 1,
  name: &quot;John&quot;,
  hobbies: [&quot;reading&quot;, &quot;coding&quot;]
})

// Equality fails because `hobbies` are not deeply compared
console.log(Equal.equals(john1, john2))
// Output: false
</code></pre>
<p>To achieve deep equality for nested structures like arrays, use <code>Schema.Data</code> in combination with <code>Data.array</code>. This enables the library to compare each element of the array rather than treating it as a single entity.</p>
<p><strong>Example</strong> (Using <code>Schema.Data</code> for Deep Equality)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Data, Equal } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString,
  hobbies: Schema.Data(Schema.Array(Schema.String)) // Enable deep equality
}) {}

const john1 = new Person({
  id: 1,
  name: &quot;John&quot;,
  hobbies: Data.array([&quot;reading&quot;, &quot;coding&quot;])
})
const john2 = new Person({
  id: 1,
  name: &quot;John&quot;,
  hobbies: Data.array([&quot;reading&quot;, &quot;coding&quot;])
})

// Equality succeeds because `hobbies` are deeply compared
console.log(Equal.equals(john1, john2))
// Output: true
</code></pre>
<h2>Extending Classes with Custom Logic</h2>
<p>Schema classes provide the flexibility to include custom getters and methods, allowing you to extend their functionality beyond the defined fields.</p>
<h3>Adding Custom Getters</h3>
<p>A getter can be used to derive computed values from the fields of the class. For example, a <code>Person</code> class can include a getter to return the <code>name</code> property in uppercase.</p>
<p><strong>Example</strong> (Adding a Getter for Uppercase Name)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {
  // Custom getter to return the name in uppercase
  get upperName() {
    return this.name.toUpperCase()
  }
}

const john = new Person({ id: 1, name: &quot;John&quot; })

// Use the custom getter
console.log(john.upperName)
// Output: &quot;JOHN&quot;
</code></pre>
<h3>Adding Custom Methods</h3>
<p>In addition to getters, you can define methods to encapsulate more complex logic or operations involving the class&#39;s fields.</p>
<p><strong>Example</strong> (Adding a Method)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {
  // Custom method to return a greeting
  greet() {
    return `Hello, my name is ${this.name}.`
  }
}

const john = new Person({ id: 1, name: &quot;John&quot; })

// Use the custom method
console.log(john.greet())
// Output: &quot;Hello, my name is John.&quot;
</code></pre>
<h2>Leveraging Classes as Schema Definitions</h2>
<p>When you define a class with <code>Schema.Class</code>, it serves both as a schema and as a class. This dual functionality allows the class to be used wherever a schema is required.</p>
<p><strong>Example</strong> (Using a Class in an Array Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Use the Person class in an array schema
const Persons = Schema.Array(Person)

//     ┌─── readonly Person[]
//     ▼
type Type = typeof Persons.Type
</code></pre>
<h3>Exposed Values</h3>
<p>The class also includes a <code>fields</code> static property, which outlines the fields defined during the class creation.</p>
<p><strong>Example</strong> (Accessing the <code>fields</code> Property)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

//       ┌─── {
//       |      readonly id: typeof Schema.Number;
//       |      readonly name: typeof Schema.NonEmptyString;
//       |    }
//       ▼
Person.fields
</code></pre>
<h2>Adding Annotations</h2>
<p>Defining a class with <code>Schema.Class</code> is similar to creating a <a href="/docs/schema/transformations/">transformation</a> schema that converts a struct schema into a <a href="/docs/schema/advanced-usage/#declaring-new-data-types">declaration</a> schema representing the class type.</p>
<p>For example, consider the following class definition:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}
</code></pre>
<p>Under the hood, this definition creates a transformation schema that maps:</p>
<pre><code class="language-ts">Schema.Struct({
  id: Schema.Number,
  name: Schema.NonEmptyString
})
</code></pre>
<p>to a schema representing the <code>Person</code> class:</p>
<pre><code class="language-ts">Schema.declare((input) =&gt; input instanceof Person)
</code></pre>
<p>So, defining a schema with <code>Schema.Class</code> involves three schemas:</p>
<ul>
<li>The &quot;from&quot; schema (the struct)</li>
<li>The &quot;to&quot; schema (the class)</li>
<li>The &quot;transformation&quot; schema (struct -&gt; class)</li>
</ul>
<p>You can annotate each of these schemas by passing a tuple as the second argument to the <code>Schema.Class</code> API.</p>
<p><strong>Example</strong> (Annotating Different Parts of the Class Schema)</p>
<pre><code class="language-ts">import { Schema, SchemaAST } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)(
  {
    id: Schema.Number,
    name: Schema.NonEmptyString
  },
  [
    // Annotations for the &quot;to&quot; schema
    { description: `&quot;to&quot; description` },

    // Annotations for the &quot;transformation schema
    { description: `&quot;transformation&quot; description` },

    // Annotations for the &quot;from&quot; schema
    { description: `&quot;from&quot; description` }
  ]
) {}

console.log(SchemaAST.getDescriptionAnnotation(Person.ast.to))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;&quot;to&quot; description&#39; }

console.log(SchemaAST.getDescriptionAnnotation(Person.ast))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;&quot;transformation&quot; description&#39; }

console.log(SchemaAST.getDescriptionAnnotation(Person.ast.from))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;&quot;from&quot; description&#39; }
</code></pre>
<p>If you do not want to annotate all three schemas, you can pass <code>undefined</code> for the ones you wish to skip.</p>
<p><strong>Example</strong> (Skipping Annotations)</p>
<pre><code class="language-ts">import { Schema, SchemaAST } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)(
  {
    id: Schema.Number,
    name: Schema.NonEmptyString
  },
  [
    // No annotations for the &quot;to&quot; schema
    undefined,

    // Annotations for the &quot;transformation schema
    { description: `&quot;transformation&quot; description` }
  ]
) {}

console.log(SchemaAST.getDescriptionAnnotation(Person.ast.to))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(SchemaAST.getDescriptionAnnotation(Person.ast))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;&quot;transformation&quot; description&#39; }

console.log(SchemaAST.getDescriptionAnnotation(Person.ast.from))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
</code></pre>
<p>By default, the unique identifier used to define the class is also applied as the default <code>identifier</code> annotation for the Class Schema.</p>
<p><strong>Example</strong> (Default Identifier Annotation)</p>
<pre><code class="language-ts">import { Schema, SchemaAST } from &quot;effect&quot;

// Used as default identifier annotation ────┐
//                                           |
//                                           ▼
class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

console.log(SchemaAST.getIdentifierAnnotation(Person.ast.to))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;Person&#39; }
</code></pre>
<h2>Recursive Schemas</h2>
<p>The <code>Schema.suspend</code> combinator is useful when you need to define a schema that depends on itself, like in the case of recursive data structures.
In this example, the <code>Category</code> schema depends on itself because it has a field <code>subcategories</code> that is an array of <code>Category</code> objects.</p>
<p><strong>Example</strong> (Self-Referencing Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a Category schema with a recursive subcategories field
class Category extends Schema.Class&lt;Category&gt;(&quot;Category&quot;)({
  name: Schema.String,
  subcategories: Schema.Array(
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
}) {}
</code></pre>
<Aside type="note" title="Correct Inference">
  It is necessary to add an explicit type annotation because otherwise
  TypeScript would struggle to infer types correctly. Without this
  annotation, you might encounter the error message:
</Aside>

<p><strong>Example</strong> (Missing Type Annotation Error)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// @ts-expect-error
class Category extends Schema.Class&lt;Category&gt;(&quot;Category&quot;)({
  name: Schema.String,
  // @ts-expect-error: TypeScript cannot infer the recursive type
  subcategories: Schema.Array(Schema.suspend(() =&gt; Category))
}) {}
/*
&#39;Category&#39; is referenced directly or indirectly in its own base expression.ts(2506)
*/
</code></pre>
<h3>Mutually Recursive Schemas</h3>
<p>Sometimes, schemas depend on each other in a mutually recursive way. For instance, an arithmetic expression tree might include <code>Expression</code> nodes that can either be numbers or <code>Operation</code> nodes, which in turn reference <code>Expression</code> nodes.</p>
<p><strong>Example</strong> (Arithmetic Expression Tree)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Expression extends Schema.Class&lt;Expression&gt;(&quot;Expression&quot;)({
  type: Schema.Literal(&quot;expression&quot;),
  value: Schema.Union(
    Schema.Number,
    Schema.suspend((): Schema.Schema&lt;Operation&gt; =&gt; Operation)
  )
}) {}

class Operation extends Schema.Class&lt;Operation&gt;(&quot;Operation&quot;)({
  type: Schema.Literal(&quot;operation&quot;),
  operator: Schema.Literal(&quot;+&quot;, &quot;-&quot;),
  left: Expression,
  right: Expression
}) {}
</code></pre>
<h3>Recursive Types with Different Encoded and Type</h3>
<p>Defining recursive schemas where the <code>Encoded</code> type differs from the <code>Type</code> type introduces additional complexity. For instance, if a schema includes fields that transform data (e.g., <code>NumberFromString</code>), the <code>Encoded</code> and <code>Type</code> types may not align.</p>
<p>In such cases, we need to define an interface for the <code>Encoded</code> type.</p>
<p>Let&#39;s consider an example: suppose we want to add an <code>id</code> field to the <code>Category</code> schema, where the schema for <code>id</code> is <code>NumberFromString</code>.
It&#39;s important to note that <code>NumberFromString</code> is a schema that transforms a string into a number, so the <code>Type</code> and <code>Encoded</code> types of <code>NumberFromString</code> differ, being <code>number</code> and <code>string</code> respectively.
When we add this field to the <code>Category</code> schema, TypeScript raises an error:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Category extends Schema.Class&lt;Category&gt;(&quot;Category&quot;)({
  id: Schema.NumberFromString,
  name: Schema.String,
  subcategories: Schema.Array(
    // @ts-expect-error
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
}) {}
/*
Type &#39;typeof Category&#39; is not assignable to type &#39;Schema&lt;Category, Category, never&gt;&#39;.
  The types of &#39;Encoded.id&#39; are incompatible between these types.
    Type &#39;string&#39; is not assignable to type &#39;number&#39;.ts(2322)
*/
</code></pre>
<p>This error occurs because the explicit annotation <code>S.suspend((): S.Schema&lt;Category&gt; =&gt; Category</code> is no longer sufficient and needs to be adjusted by explicitly adding the <code>Encoded</code> type:</p>
<p><strong>Example</strong> (Adjusting the Schema with Explicit <code>Encoded</code> Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

interface CategoryEncoded {
  readonly id: string
  readonly name: string
  readonly subcategories: ReadonlyArray&lt;CategoryEncoded&gt;
}

class Category extends Schema.Class&lt;Category&gt;(&quot;Category&quot;)({
  id: Schema.NumberFromString,
  name: Schema.String,
  subcategories: Schema.Array(
    Schema.suspend(
      (): Schema.Schema&lt;Category, CategoryEncoded&gt; =&gt; Category
    )
  )
}) {}
</code></pre>
<p>As we&#39;ve observed, it&#39;s necessary to define an interface for the <code>Encoded</code> of the schema to enable recursive schema definition, which can complicate things and be quite tedious.
One pattern to mitigate this is to <strong>separate the field responsible for recursion</strong> from all other fields.</p>
<p><strong>Example</strong> (Separating Recursive Field)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const fields = {
  id: Schema.NumberFromString,
  name: Schema.String
  // ...possibly other fields
}

interface CategoryEncoded extends Schema.Struct.Encoded&lt;typeof fields&gt; {
  // Define `subcategories` using recursion
  readonly subcategories: ReadonlyArray&lt;CategoryEncoded&gt;
}

class Category extends Schema.Class&lt;Category&gt;(&quot;Category&quot;)({
  ...fields, // Include the fields
  subcategories: Schema.Array(
    // Define `subcategories` using recursion
    Schema.suspend(
      (): Schema.Schema&lt;Category, CategoryEncoded&gt; =&gt; Category
    )
  )
}) {}
</code></pre>
<h2>Tagged Class variants</h2>
<p>You can also create classes that extend <a href="/docs/data-types/data/#taggedclass">TaggedClass</a> and <a href="/docs/data-types/data/#taggederror">TaggedError</a> from the <code>effect/Data</code> module.</p>
<p><strong>Example</strong> (Creating Tagged Classes and Errors)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a tagged class with a &quot;name&quot; field
class TaggedPerson extends Schema.TaggedClass&lt;TaggedPerson&gt;()(
  &quot;TaggedPerson&quot;,
  {
    name: Schema.String
  }
) {}

// Define a tagged error with a &quot;status&quot; field
class HttpError extends Schema.TaggedError&lt;HttpError&gt;()(&quot;HttpError&quot;, {
  status: Schema.Number
}) {}

const joe = new TaggedPerson({ name: &quot;Joe&quot; })
console.log(joe._tag)
// Output: &quot;TaggedPerson&quot;

const error = new HttpError({ status: 404 })
console.log(error._tag)
// Output: &quot;HttpError&quot;

console.log(error.stack) // access the stack trace
</code></pre>
<h2>Extending existing Classes</h2>
<p>The <code>extend</code> static utility allows you to enhance an existing schema class by adding <strong>additional</strong> fields and functionality. This approach helps in building on top of existing schemas without redefining them from scratch.</p>
<p><strong>Example</strong> (Extending a Schema Class)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define the base class
class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {
  // A custom getter that converts the name to uppercase
  get upperName() {
    return this.name.toUpperCase()
  }
}

// Extend the base class to include an &quot;age&quot; field
class PersonWithAge extends Person.extend&lt;PersonWithAge&gt;(&quot;PersonWithAge&quot;)(
  {
    age: Schema.Number
  }
) {
  // A custom getter to check if the person is an adult
  get isAdult() {
    return this.age &gt;= 18
  }
}

// Usage
const john = new PersonWithAge({ id: 1, name: &quot;John&quot;, age: 25 })
console.log(john.upperName) // Output: &quot;JOHN&quot;
console.log(john.isAdult) // Output: true
</code></pre>
<p>Note that you can only add additional fields when extending a class.</p>
<p><strong>Example</strong> (Attempting to Overwrite Existing Fields)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {
  get upperName() {
    return this.name.toUpperCase()
  }
}

class BadExtension extends Person.extend&lt;BadExtension&gt;(&quot;BadExtension&quot;)({
  name: Schema.Number
}) {}
/*
throws:
Error: Duplicate property signature
details: Duplicate key &quot;name&quot;
*/
</code></pre>
<p>This error occurs because allowing fields to be overwritten is not safe. It could interfere with any getters or methods defined on the class that rely on the original definition. For example, in this case, the <code>upperName</code> getter would break if the <code>name</code> field was changed to a number.</p>
<h2>Transformations</h2>
<p>You can enhance schema classes with effectful transformations to enrich or validate entities, particularly when working with data sourced from external systems like databases or APIs.</p>
<p><strong>Example</strong> (Effectful Transformation)</p>
<p>The following example demonstrates adding an <code>age</code> field to a <code>Person</code> class. The <code>age</code> value is derived asynchronously based on the <code>id</code> field.</p>
<pre><code class="language-ts">import { Effect, Option, Schema, ParseResult } from &quot;effect&quot;

// Base class definition
class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  id: Schema.Number,
  name: Schema.String
}) {}

console.log(Schema.decodeUnknownSync(Person)({ id: 1, name: &quot;name&quot; }))
/*
Output:
Person { id: 1, name: &#39;name&#39; }
*/

// Simulate fetching age asynchronously based on id
function getAge(id: number): Effect.Effect&lt;number, Error&gt; {
  return Effect.succeed(id + 2)
}

// Extended class with a transformation
class PersonWithTransform extends Person.transformOrFail&lt;PersonWithTransform&gt;(
  &quot;PersonWithTransform&quot;
)(
  {
    age: Schema.optionalWith(Schema.Number, { exact: true, as: &quot;Option&quot; })
  },
  {
    // Decoding logic for the new field
    decode: (input) =&gt;
      Effect.mapBoth(getAge(input.id), {
        onFailure: (e) =&gt;
          new ParseResult.Type(Schema.String.ast, input.id, e.message),
        // Must return { age: Option&lt;number&gt; }
        onSuccess: (age) =&gt; ({ ...input, age: Option.some(age) })
      }),
    encode: ParseResult.succeed
  }
) {}

Schema.decodeUnknownPromise(PersonWithTransform)({
  id: 1,
  name: &quot;name&quot;
}).then(console.log)
/*
Output:
PersonWithTransform {
  id: 1,
  name: &#39;name&#39;,
  age: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 3 }
}
*/

// Extended class with a conditional Transformation
class PersonWithTransformFrom extends Person.transformOrFailFrom&lt;PersonWithTransformFrom&gt;(
  &quot;PersonWithTransformFrom&quot;
)(
  {
    age: Schema.optionalWith(Schema.Number, { exact: true, as: &quot;Option&quot; })
  },
  {
    decode: (input) =&gt;
      Effect.mapBoth(getAge(input.id), {
        onFailure: (e) =&gt;
          new ParseResult.Type(Schema.String.ast, input, e.message),
        // Must return { age?: number }
        onSuccess: (age) =&gt; (age &gt; 18 ? { ...input, age } : { ...input })
      }),
    encode: ParseResult.succeed
  }
) {}

Schema.decodeUnknownPromise(PersonWithTransformFrom)({
  id: 1,
  name: &quot;name&quot;
}).then(console.log)
/*
Output:
PersonWithTransformFrom {
  id: 1,
  name: &#39;name&#39;,
  age: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }
}
*/
</code></pre>
<p>The decision of which API to use, either <code>transformOrFail</code> or <code>transformOrFailFrom</code>, depends on when you wish to execute the transformation:</p>
<ol>
<li><p>Using <code>transformOrFail</code>:</p>
<ul>
<li>The transformation occurs at the end of the process.</li>
<li>It expects you to provide a value of type <code>{ age: Option&lt;number&gt; }</code>.</li>
<li>After processing the initial input, the new transformation comes into play, and you need to ensure the final output adheres to the specified structure.</li>
</ul>
</li>
<li><p>Using <code>transformOrFailFrom</code>:</p>
<ul>
<li>The new transformation starts as soon as the initial input is handled.</li>
<li>You should provide a value <code>{ age?: number }</code>.</li>
<li>Based on this fresh input, the subsequent transformation <code>Schema.optionalWith(Schema.Number, { exact: true, as: &quot;Option&quot; })</code> is executed.</li>
<li>This approach allows for immediate handling of the input, potentially influencing the subsequent transformations.</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h2>title: Default Constructors
description: Create values that conform to schemas effortlessly using default constructors for structs, records, filters, and branded types, with options for validation, default values, and lazy evaluation.
sidebar:
  order: 12</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>When working with data structures, it can be helpful to create values that conform to a schema with minimal effort.
For this purpose, the Schema module provides default constructors for various schema types, including <code>Structs</code>, <code>Records</code>, <code>filters</code>, and <code>brands</code>.</p>
<Aside type="note" title="Constructor Scope">
  Default constructors tied to a schema `Schema<A, I, R>` specifically operate on the `A` type, not the `I` type.
</Aside>

<h2>Structs</h2>
<p>Struct schemas allow you to define objects with specific fields and constraints. The <code>make</code> function can be used to create instances of a struct schema.</p>
<p><strong>Example</strong> (Creating Struct Instances)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Struct = Schema.Struct({
  name: Schema.NonEmptyString
})

// Successful creation
Struct.make({ name: &quot;a&quot; })

// This will throw an error because the name is empty
Struct.make({ name: &quot;&quot; })
/*
throws
ParseError: { readonly name: NonEmptyString }
└─ [&quot;name&quot;]
   └─ NonEmptyString
      └─ Predicate refinement failure
         └─ Expected NonEmptyString, actual &quot;&quot;
*/
</code></pre>
<p>In some cases, you might need to bypass validation. While not recommended in most scenarios, <code>make</code> provides an option to disable validation.</p>
<p><strong>Example</strong> (Bypassing Validation)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Struct = Schema.Struct({
  name: Schema.NonEmptyString
})

// Bypass validation during instantiation
Struct.make({ name: &quot;&quot; }, true)

// Or use the `disableValidation` option explicitly
Struct.make({ name: &quot;&quot; }, { disableValidation: true })
</code></pre>
<h2>Records</h2>
<p>Record schemas allow you to define key-value mappings where the keys and values must meet specific criteria.</p>
<p><strong>Example</strong> (Creating Record Instances)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Record = Schema.Record({
  key: Schema.String,
  value: Schema.NonEmptyString
})

// Successful creation
Record.make({ a: &quot;a&quot;, b: &quot;b&quot; })

// This will throw an error because &#39;b&#39; is empty
Record.make({ a: &quot;a&quot;, b: &quot;&quot; })
/*
throws
ParseError: { readonly [x: string]: NonEmptyString }
└─ [&quot;b&quot;]
   └─ NonEmptyString
      └─ Predicate refinement failure
         └─ Expected NonEmptyString, actual &quot;&quot;
*/

// Bypasses validation
Record.make({ a: &quot;a&quot;, b: &quot;&quot; }, { disableValidation: true })
</code></pre>
<h2>Filters</h2>
<p>Filters allow you to define constraints on individual values.</p>
<p><strong>Example</strong> (Using Filters to Enforce Ranges)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyNumber = Schema.Number.pipe(Schema.between(1, 10))

// Successful creation
const n = MyNumber.make(5)

// This will throw an error because the number is outside the valid range
MyNumber.make(20)
/*
throws
ParseError: a number between 1 and 10
└─ Predicate refinement failure
   └─ Expected a number between 1 and 10, actual 20
*/

// Bypasses validation
MyNumber.make(20, { disableValidation: true })
</code></pre>
<h2>Branded Types</h2>
<p>Branded schemas add metadata to a value to give it a more specific type, while still retaining its original type.</p>
<p><strong>Example</strong> (Creating Branded Values)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const BrandedNumberSchema = Schema.Number.pipe(
  Schema.between(1, 10),
  Schema.brand(&quot;MyNumber&quot;)
)

// Successful creation
const n = BrandedNumberSchema.make(5)

// This will throw an error because the number is outside the valid range
BrandedNumberSchema.make(20)
/*
throws
ParseError: a number between 1 and 10 &amp; Brand&lt;&quot;MyNumber&quot;&gt;
└─ Predicate refinement failure
   └─ Expected a number between 1 and 10 &amp; Brand&lt;&quot;MyNumber&quot;&gt;, actual 20
*/

// Bypasses validation
BrandedNumberSchema.make(20, { disableValidation: true })
</code></pre>
<p>When using default constructors, it is helpful to understand the type of value they produce.</p>
<p>For instance, in the <code>BrandedNumberSchema</code> example, the return type of the constructor is <code>number &amp; Brand&lt;&quot;MyNumber&quot;&gt;</code>. This indicates that the resulting value is a <code>number</code> with additional branding information, <code>&quot;MyNumber&quot;</code>.</p>
<p>This behavior contrasts with the filter example, where the return type is simply <code>number</code>. Branding adds an extra layer of type information, which can assist in identifying and working with your data more effectively.</p>
<h2>Error Handling in Constructors</h2>
<p>Default constructors are considered &quot;unsafe&quot; because they throw an error if the input does not conform to the schema. This error includes a detailed description of what went wrong. The intention behind default constructors is to provide a straightforward way to create valid values, such as for tests or configurations, where invalid inputs are expected to be exceptional cases.</p>
<p>If you need a &quot;safe&quot; constructor that does not throw errors but instead returns a result indicating success or failure, you can use <code>Schema.validateEither</code>.</p>
<p><strong>Example</strong> (Using <code>Schema.validateEither</code> for Safe Validation)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyNumber = Schema.Number.pipe(Schema.between(1, 10))

// Create a safe constructor that validates the input
const makeMyNumber = Schema.validateEither(MyNumber)

// Valid input returns a Right value
console.log(makeMyNumber(5))
/*
Output:
{ _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 5 }
*/

// Invalid input returns a Left value with detailed error information
console.log(makeMyNumber(20))
/*
Output:
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;a number between 1 and 10\n&#39; +
      &#39;└─ Predicate refinement failure\n&#39; +
      &#39;   └─ Expected a number between 1 and 10, actual 20&#39;
  }
}
*/
</code></pre>
<h2>Setting Default Values</h2>
<p>When creating objects, you might want to assign default values to certain fields to simplify object construction. The <code>Schema.withConstructorDefault</code> function lets you handle default values, making fields optional in the default constructor.</p>
<p><strong>Example</strong> (Struct with Required Fields)</p>
<p>In this example, all fields are required when creating a new instance.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Number
})

// Both name and age must be provided
console.log(Person.make({ name: &quot;John&quot;, age: 30 }))
/*
Output: { name: &#39;John&#39;, age: 30 }
*/
</code></pre>
<p><strong>Example</strong> (Struct with Default Value)</p>
<p>Here, the <code>age</code> field is optional because it has a default value of <code>0</code>.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; 0)
  )
})

// The age field is optional and defaults to 0
console.log(Person.make({ name: &quot;John&quot; }))
/*
Output:
{ name: &#39;John&#39;, age: 0 }
*/

console.log(Person.make({ name: &quot;John&quot;, age: 30 }))
/*
Output:
{ name: &#39;John&#39;, age: 30 }
*/
</code></pre>
<h3>Nested Structs and Shallow Defaults</h3>
<p>Default values in schemas are shallow, meaning that defaults defined in nested structs do not automatically propagate to the top-level constructor.</p>
<p><strong>Example</strong> (Shallow Defaults in Nested Structs)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Config = Schema.Struct({
  // Define a nested struct with a default value
  web: Schema.Struct({
    application_url: Schema.String.pipe(
      Schema.propertySignature,
      Schema.withConstructorDefault(() =&gt; &quot;http://localhost&quot;)
    ),
    application_port: Schema.Number
  })
})

// This will cause a type error because `application_url`
// is missing in the nested struct
// @ts-expect-error
Config.make({ web: { application_port: 3000 } })
</code></pre>
<p>This behavior occurs because the <code>Schema</code> interface does not include a type parameter to carry over default constructor types from nested structs.</p>
<p>To work around this limitation, extract the constructor for the nested struct and apply it to its fields directly. This ensures that the nested defaults are respected.</p>
<p><strong>Example</strong> (Using Nested Struct Constructors)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Config = Schema.Struct({
  web: Schema.Struct({
    application_url: Schema.String.pipe(
      Schema.propertySignature,
      Schema.withConstructorDefault(() =&gt; &quot;http://localhost&quot;)
    ),
    application_port: Schema.Number
  })
})

// Extract the nested struct constructor
const { web: Web } = Config.fields

// Use the constructor for the nested struct
console.log(Config.make({ web: Web.make({ application_port: 3000 }) }))
/*
Output:
{
  web: {
    application_url: &#39;http://localhost&#39;,
    application_port: 3000
  }
}
*/
</code></pre>
<h3>Lazy Evaluation of Defaults</h3>
<p>Defaults are lazily evaluated, meaning that a new instance of the default is generated every time the constructor is called:</p>
<p><strong>Example</strong> (Lazy Evaluation of Defaults)</p>
<p>In this example, the <code>timestamp</code> field generates a new value for each instance.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; 0)
  ),
  timestamp: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; new Date().getTime())
  )
})

console.log(Person.make({ name: &quot;name1&quot; }))
/*
Example Output:
{ age: 0, timestamp: 1714232909221, name: &#39;name1&#39; }
*/

console.log(Person.make({ name: &quot;name2&quot; }))
/*
Example Output:
{ age: 0, timestamp: 1714232909227, name: &#39;name2&#39; }
*/
</code></pre>
<h3>Reusing Defaults Across Schemas</h3>
<p>Default values are also &quot;portable&quot;, meaning that if you reuse the same property signature in another schema, the default is carried over:</p>
<p><strong>Example</strong> (Reusing Defaults in Another Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; 0)
  ),
  timestamp: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; new Date().getTime())
  )
})

const AnotherSchema = Schema.Struct({
  foo: Schema.String,
  age: Person.fields.age
})

console.log(AnotherSchema.make({ foo: &quot;bar&quot; }))
/*
Output:
{ foo: &#39;bar&#39;, age: 0 }
*/
</code></pre>
<h3>Using Defaults in Classes</h3>
<p>Default values can also be applied when working with the <code>Class</code> API, ensuring consistency across class-based schemas.</p>
<p><strong>Example</strong> (Defaults in a Class)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

class Person extends Schema.Class&lt;Person&gt;(&quot;Person&quot;)({
  name: Schema.NonEmptyString,
  age: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; 0)
  ),
  timestamp: Schema.Number.pipe(
    Schema.propertySignature,
    Schema.withConstructorDefault(() =&gt; new Date().getTime())
  )
}) {}

console.log(new Person({ name: &quot;name1&quot; }))
/*
Example Output:
Person { age: 0, timestamp: 1714400867208, name: &#39;name1&#39; }
*/

console.log(new Person({ name: &quot;name2&quot; }))
/*
Example Output:
Person { age: 0, timestamp: 1714400867215, name: &#39;name2&#39; }
*/
</code></pre>
<hr>
<hr>
<h2>title: Effect Data Types
description: Transform and manage various data types with schemas for enhanced JSON serialization, including support for options, eithers, sets, maps, durations, and sensitive redacted data.
sidebar:
  order: 13</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<h2>Interop With Data</h2>
<p>The <a href="/docs/data-types/data/">Data</a> module in the Effect ecosystem simplifies value comparison by automatically implementing the <a href="/docs/trait/equal/">Equal</a> and <a href="/docs/trait/hash/">Hash</a> traits. This eliminates the need for manual implementations, making equality checks straightforward.</p>
<p><strong>Example</strong> (Comparing Structs with Data)</p>
<pre><code class="language-ts">import { Data, Equal } from &quot;effect&quot;

const person1 = Data.struct({ name: &quot;Alice&quot;, age: 30 })
const person2 = Data.struct({ name: &quot;Alice&quot;, age: 30 })

console.log(Equal.equals(person1, person2))
// Output: true
</code></pre>
<p>By default, schemas like <code>Schema.Struct</code> do not implement the <code>Equal</code> and <code>Hash</code> traits. This means that two decoded objects with identical values will not be considered equal.</p>
<p><strong>Example</strong> (Default Behavior Without <code>Equal</code> and <code>Hash</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Equal } from &quot;effect&quot;

const schema = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decode(schema)

const person1 = decode({ name: &quot;Alice&quot;, age: 30 })
const person2 = decode({ name: &quot;Alice&quot;, age: 30 })

console.log(Equal.equals(person1, person2))
// Output: false
</code></pre>
<p>The <code>Schema.Data</code> function can be used to enhance a schema by including the <code>Equal</code> and <code>Hash</code> traits. This allows the resulting objects to support value-based equality.</p>
<p><strong>Example</strong> (Using <code>Schema.Data</code> to Add Equality)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Equal } from &quot;effect&quot;

const schema = Schema.Data(
  Schema.Struct({
    name: Schema.String,
    age: Schema.Number
  })
)

const decode = Schema.decode(schema)

const person1 = decode({ name: &quot;Alice&quot;, age: 30 })
const person2 = decode({ name: &quot;Alice&quot;, age: 30 })

console.log(Equal.equals(person1, person2))
// Output: true
</code></pre>
<h2>Config</h2>
<p>The <code>Schema.Config</code> function allows you to validate and manage application configuration settings using structured schemas. It ensures consistency in configuration data and provides detailed feedback for validation errors.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Config: &lt;A&gt;(name: string, schema: Schema&lt;A, string&gt;) =&gt; Config&lt;A&gt;
</code></pre>
<p>This function requires two parameters:</p>
<ul>
<li><code>name</code>: Identifier for the configuration setting.</li>
<li><code>schema</code>: Schema describing the expected data type and structure.</li>
</ul>
<p>The function returns a <a href="/docs/configuration/">Config</a> object that is directly integrated with your application&#39;s configuration management system.</p>
<p>The <code>Schema.Config</code> function operates through the following steps:</p>
<ol>
<li><strong>Fetching Configuration</strong>: The configuration value is retrieved based on its name.</li>
<li><strong>Validation</strong>: The value is then validated against the schema. If the value does not conform to the schema, the function formats and returns detailed validation errors.</li>
<li><strong>Error Formatting</strong>: Errors are formatted using <code>TreeFormatter.formatErrorSync</code> to provide clear, actionable error messages.</li>
</ol>
<p><strong>Example</strong> (Validating Configuration Settings)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Effect } from &quot;effect&quot;

const myconfig = Schema.Config(
  &quot;Foo&quot;,
  Schema.String.pipe(Schema.minLength(4))
)

const program = Effect.gen(function* () {
  const foo = yield* myconfig
  console.log(`ok: ${foo}`)
})

Effect.runSync(program)
</code></pre>
<p>To test the configuration, execute the following commands:</p>
<ul>
<li><strong>Test</strong> (with Missing Configuration Data)<pre><code class="language-sh">npx tsx config.ts
# Output:
# [(Missing data at Foo: &quot;Expected Foo to exist in the process context&quot;)]
</code></pre>
</li>
<li><strong>Test</strong> (with Invalid Data)<pre><code class="language-sh">Foo=bar npx tsx config.ts
# Output:
# [(Invalid data at Foo: &quot;a string at least 4 character(s) long
# └─ Predicate refinement failure
#    └─ Expected a string at least 4 character(s) long, actual &quot;bar&quot;&quot;)]
</code></pre>
</li>
<li><strong>Test</strong> (with Valid Data)<pre><code class="language-sh">Foo=foobar npx tsx config.ts
# Output:
# ok: foobar
</code></pre>
</li>
</ul>
<h2>Option</h2>
<h3>Option</h3>
<p>The <code>Schema.Option</code> function is useful for converting an <code>Option</code> into a JSON-serializable format.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.Option(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>{ _tag: &quot;None&quot; }</code></td>
<td>Converted to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>{ _tag: &quot;Some&quot;, value: I }</code></td>
<td>Converted to <code>Option.some(a)</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Converted to <code>{ _tag: &quot;None&quot; }</code></td>
</tr>
<tr>
<td><code>Option.some(A)</code></td>
<td>Converted to <code>{ _tag: &quot;Some&quot;, value: I }</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const schema = Schema.Option(Schema.NumberFromString)

//     ┌─── OptionEncoded&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Option&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode({ _tag: &quot;None&quot; }))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode({ _tag: &quot;Some&quot;, value: &quot;1&quot; }))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }

// Encoding examples

console.log(encode(Option.none()))
// Output: { _tag: &#39;None&#39; }

console.log(encode(Option.some(1)))
// Output: { _tag: &#39;Some&#39;, value: &#39;1&#39; }
</code></pre>
<h3>OptionFromSelf</h3>
<p>The <code>Schema.OptionFromSelf</code> function is designed for scenarios where <code>Option</code> values are already in the <code>Option</code> format and need to be decoded or encoded while transforming the inner value according to the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.OptionFromSelf(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Remains as <code>Option.none()</code></td>
</tr>
<tr>
<td><code>Option.some(I)</code></td>
<td>Converted to <code>Option.some(A)</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Remains as <code>Option.none()</code></td>
</tr>
<tr>
<td><code>Option.some(A)</code></td>
<td>Converted to <code>Option.some(I)</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const schema = Schema.OptionFromSelf(Schema.NumberFromString)

//     ┌─── Option&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Option&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(Option.none()))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(Option.some(&quot;1&quot;)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }

// Encoding examples

console.log(encode(Option.none()))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(encode(Option.some(1)))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;1&#39; }
</code></pre>
<h3>OptionFromUndefinedOr</h3>
<p>The <code>Schema.OptionFromUndefinedOr</code> function handles cases where <code>undefined</code> is treated as <code>Option.none()</code>, and all other values are interpreted as <code>Option.some()</code> based on the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.OptionFromUndefinedOr(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>undefined</code></td>
<td>Converted to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>I</code></td>
<td>Converted to <code>Option.some(A)</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Converted to <code>undefined</code></td>
</tr>
<tr>
<td><code>Option.some(A)</code></td>
<td>Converted to <code>I</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const schema = Schema.OptionFromUndefinedOr(Schema.NumberFromString)

//     ┌─── string | undefined
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Option&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(undefined))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(&quot;1&quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }

// Encoding examples

console.log(encode(Option.none()))
// Output: undefined

console.log(encode(Option.some(1)))
// Output: &quot;1&quot;
</code></pre>
<h3>OptionFromNullOr</h3>
<p>The <code>Schema.OptionFromUndefinedOr</code> function handles cases where <code>null</code> is treated as <code>Option.none()</code>, and all other values are interpreted as <code>Option.some()</code> based on the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.OptionFromNullOr(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>null</code></td>
<td>Converted to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>I</code></td>
<td>Converted to <code>Option.some(A)</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Converted to <code>null</code></td>
</tr>
<tr>
<td><code>Option.some(A)</code></td>
<td>Converted to <code>I</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const schema = Schema.OptionFromNullOr(Schema.NumberFromString)

//     ┌─── string | null
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Option&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(null))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(&quot;1&quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }

// Encoding examples

console.log(encode(Option.none()))
// Output: null
console.log(encode(Option.some(1)))
// Output: &quot;1&quot;
</code></pre>
<h3>OptionFromNullishOr</h3>
<p>The <code>Schema.OptionFromNullishOr</code> function handles cases where <code>null</code> or <code>undefined</code> are treated as <code>Option.none()</code>, and all other values are interpreted as <code>Option.some()</code> based on the provided schema. Additionally, it allows customization of how <code>Option.none()</code> is encoded (<code>null</code> or <code>undefined</code>).</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.OptionFromNullishOr(
  schema: Schema&lt;A, I, R&gt;,
  onNoneEncoding: null | undefined
)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>undefined</code></td>
<td>Converted to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td>Converted to <code>Option.none()</code></td>
</tr>
<tr>
<td><code>I</code></td>
<td>Converted to <code>Option.some(A)</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Converted to <code>undefined</code> or <code>null</code> based on user choice (<code>onNoneEncoding</code>)</td>
</tr>
<tr>
<td><code>Option.some(A)</code></td>
<td>Converted to <code>I</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Option } from &quot;effect&quot;

const schema = Schema.OptionFromNullishOr(
  Schema.NumberFromString,
  undefined // Encode Option.none() as undefined
)

//     ┌─── string | null | undefined
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Option&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(null))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(undefined))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(&quot;1&quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }

// Encoding examples

console.log(encode(Option.none()))
// Output: undefined

console.log(encode(Option.some(1)))
// Output: &quot;1&quot;
</code></pre>
<h3>OptionFromNonEmptyTrimmedString</h3>
<p>The <code>Schema.OptionFromNonEmptyTrimmedString</code> schema is designed for handling strings where trimmed empty strings are treated as <code>Option.none()</code>, and all other strings are converted to <code>Option.some()</code>.</p>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>s: string</code></td>
<td>Converted to <code>Option.some(s)</code>, if <code>s.trim().length &gt; 0</code></td>
</tr>
<tr>
<td></td>
<td>Converted to <code>Option.none()</code> otherwise</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Option.none()</code></td>
<td>Converted to <code>&quot;&quot;</code></td>
</tr>
<tr>
<td><code>Option.some(s: string)</code></td>
<td>Converted to <code>s</code></td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Option } from &quot;effect&quot;

//     ┌─── string
//     ▼
type Encoded = typeof Schema.OptionFromNonEmptyTrimmedString

//     ┌─── Option&lt;string&gt;
//     ▼
type Type = typeof Schema.OptionFromNonEmptyTrimmedString

const decode = Schema.decodeUnknownSync(
  Schema.OptionFromNonEmptyTrimmedString
)
const encode = Schema.encodeSync(Schema.OptionFromNonEmptyTrimmedString)

// Decoding examples

console.log(decode(&quot;&quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;None&#39; }

console.log(decode(&quot; a &quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;a&#39; }

console.log(decode(&quot;a&quot;))
// Output: { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: &#39;a&#39; }

// Encoding examples

console.log(encode(Option.none()))
// Output: &quot;&quot;

console.log(encode(Option.some(&quot;example&quot;)))
// Output: &quot;example&quot;
</code></pre>
<h2>Either</h2>
<h3>Either</h3>
<p>The <code>Schema.Either</code> function is useful for converting an <code>Either</code> into a JSON-serializable format.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.Either(options: {
  left: Schema&lt;LA, LI, LR&gt;,
  right: Schema&lt;RA, RI, RR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>{ _tag: &quot;Left&quot;, left: LI }</code></td>
<td>Converted to <code>Either.left(LA)</code>, where <code>LI</code> is decoded into <code>LA</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>{ _tag: &quot;Right&quot;, right: RI }</code></td>
<td>Converted to <code>Either.right(RA)</code>, where <code>RI</code> is decoded into <code>RA</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Either.left(LA)</code></td>
<td>Converted to <code>{ _tag: &quot;Left&quot;, left: LI }</code>, where <code>LA</code> is encoded into <code>LI</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>Either.right(RA)</code></td>
<td>Converted to <code>{ _tag: &quot;Right&quot;, right: RI }</code>, where <code>RA</code> is encoded into <code>RI</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Either } from &quot;effect&quot;

const schema = Schema.Either({
  left: Schema.Trim,
  right: Schema.NumberFromString
})

//     ┌─── EitherEncoded&lt;string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Either&lt;number, string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode({ _tag: &quot;Left&quot;, left: &quot; a &quot; }))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;a&#39; }

console.log(decode({ _tag: &quot;Right&quot;, right: &quot;1&quot; }))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 1 }

// Encoding examples

console.log(encode(Either.left(&quot;a&quot;)))
// Output: { _tag: &#39;Left&#39;, left: &#39;a&#39; }

console.log(encode(Either.right(1)))
// Output: { _tag: &#39;Right&#39;, right: &#39;1&#39; }
</code></pre>
<h3>EitherFromSelf</h3>
<p>The <code>Schema.EitherFromSelf</code> function is designed for scenarios where <code>Either</code> values are already in the <code>Either</code> format and need to be decoded or encoded while transforming the inner valued according to the provided schemas.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.EitherFromSelf(options: {
  left: Schema&lt;LA, LI, LR&gt;,
  right: Schema&lt;RA, RI, RR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Either.left(LI)</code></td>
<td>Converted to <code>Either.left(LA)</code>, where <code>LI</code> is decoded into <code>LA</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>Either.right(RI)</code></td>
<td>Converted to <code>Either.right(RA)</code>, where <code>RI</code> is decoded into <code>RA</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Either.left(LA)</code></td>
<td>Converted to <code>Either.left(LI)</code>, where <code>LA</code> is encoded into <code>LI</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>Either.right(RA)</code></td>
<td>Converted to <code>Either.right(RI)</code>, where <code>RA</code> is encoded into <code>RI</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Either } from &quot;effect&quot;

const schema = Schema.EitherFromSelf({
  left: Schema.Trim,
  right: Schema.NumberFromString
})

//     ┌─── Either&lt;string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Either&lt;number, string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(Either.left(&quot; a &quot;)))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;a&#39; }

console.log(decode(Either.right(&quot;1&quot;)))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 1 }

// Encoding examples

console.log(encode(Either.left(&quot;a&quot;)))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: &#39;a&#39; }

console.log(encode(Either.right(1)))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: &#39;1&#39; }
</code></pre>
<h3>EitherFromUnion</h3>
<p>The <code>Schema.EitherFromUnion</code> function is designed to decode and encode <code>Either</code> values where the <code>left</code> and <code>right</code> sides are represented as distinct types. This schema enables conversions between raw union types and structured <code>Either</code> types.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.EitherFromUnion(options: {
  left: Schema&lt;LA, LI, LR&gt;,
  right: Schema&lt;RA, RI, RR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>LI</code></td>
<td>Converted to <code>Either.left(LA)</code>, where <code>LI</code> is decoded into <code>LA</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>RI</code></td>
<td>Converted to <code>Either.right(RA)</code>, where <code>RI</code> is decoded into <code>RA</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Either.left(LA)</code></td>
<td>Converted to <code>LI</code>, where <code>LA</code> is encoded into <code>LI</code> using the inner <code>left</code> schema</td>
</tr>
<tr>
<td><code>Either.right(RA)</code></td>
<td>Converted to <code>RI</code>, where <code>RA</code> is encoded into <code>RI</code> using the inner <code>right</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Either } from &quot;effect&quot;

const schema = Schema.EitherFromUnion({
  left: Schema.Boolean,
  right: Schema.NumberFromString
})

//     ┌─── string | boolean
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Either&lt;number, boolean&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(true))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Left&#39;, left: true }

console.log(decode(&quot;1&quot;))
// Output: { _id: &#39;Either&#39;, _tag: &#39;Right&#39;, right: 1 }

// Encoding examples

console.log(encode(Either.left(true)))
// Output: true

console.log(encode(Either.right(1)))
// Output: &quot;1&quot;
</code></pre>
<h2>Exit</h2>
<h3>Exit</h3>
<p>The <code>Schema.Exit</code> function is useful for converting an <code>Exit</code> into a JSON-serializable format.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.Exit(options: {
  failure: Schema&lt;FA, FI, FR&gt;,
  success: Schema&lt;SA, SI, SR&gt;,
  defect: Schema&lt;DA, DI, DR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>{ _tag: &quot;Failure&quot;, cause: CauseEncoded&lt;FI, DI&gt; }</code></td>
<td>Converted to <code>Exit.failCause(Cause&lt;FA&gt;)</code>, where <code>CauseEncoded&lt;FI, DI&gt;</code> is decoded into <code>Cause&lt;FA&gt;</code> using the inner <code>failure</code> and <code>defect</code> schemas</td>
</tr>
<tr>
<td><code>{ _tag: &quot;Success&quot;, value: SI }</code></td>
<td>Converted to <code>Exit.succeed(SA)</code>, where <code>SI</code> is decoded into <code>SA</code> using the inner <code>success</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exit.failCause(Cause&lt;FA&gt;)</code></td>
<td>Converted to <code>{ _tag: &quot;Failure&quot;, cause: CauseEncoded&lt;FI, DI&gt; }</code>, where <code>Cause&lt;FA&gt;</code> is encoded into <code>CauseEncoded&lt;FI, DI&gt;</code> using the inner <code>failure</code> and <code>defect</code> schemas</td>
</tr>
<tr>
<td><code>Exit.succeed(SA)</code></td>
<td>Converted to <code>{ _tag: &quot;Success&quot;, value: SI }</code>, where <code>SA</code> is encoded into <code>SI</code> using the inner <code>success</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Exit } from &quot;effect&quot;

const schema = Schema.Exit({
  failure: Schema.String,
  success: Schema.NumberFromString,
  defect: Schema.String
})

//     ┌─── ExitEncoded&lt;string, string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Exit&lt;number, string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode({ _tag: &quot;Failure&quot;, cause: { _tag: &quot;Fail&quot;, error: &quot;a&quot; } })
)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;a&#39; }
}
*/

console.log(decode({ _tag: &quot;Success&quot;, value: &quot;1&quot; }))
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: 1 }
*/

// Encoding examples

console.log(encode(Exit.fail(&quot;a&quot;)))
/*
Output:
{ _tag: &#39;Failure&#39;, cause: { _tag: &#39;Fail&#39;, error: &#39;a&#39; } }
 */

console.log(encode(Exit.succeed(1)))
/*
Output:
{ _tag: &#39;Success&#39;, value: &#39;1&#39; }
*/
</code></pre>
<h3>ExitFromSelf</h3>
<p>The <code>Schema.ExitFromSelf</code> function is designed for scenarios where <code>Exit</code> values are already in the <code>Exit</code> format and need to be decoded or encoded while transforming the inner valued according to the provided schemas.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ExitFromSelf(options: {
  failure: Schema&lt;FA, FI, FR&gt;,
  success: Schema&lt;SA, SI, SR&gt;,
  defect: Schema&lt;DA, DI, DR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exit.failCause(Cause&lt;FI&gt;)</code></td>
<td>Converted to <code>Exit.failCause(Cause&lt;FA&gt;)</code>, where <code>Cause&lt;FI&gt;</code> is decoded into <code>Cause&lt;FA&gt;</code> using the inner <code>failure</code> and <code>defect</code> schemas</td>
</tr>
<tr>
<td><code>Exit.succeed(SI)</code></td>
<td>Converted to <code>Exit.succeed(SA)</code>, where <code>SI</code> is decoded into <code>SA</code> using the inner <code>success</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exit.failCause(Cause&lt;FA&gt;)</code></td>
<td>Converted to <code>Exit.failCause(Cause&lt;FI&gt;)</code>, where <code>Cause&lt;FA&gt;</code> is decoded into <code>Cause&lt;FI&gt;</code> using the inner <code>failure</code> and <code>defect</code> schemas</td>
</tr>
<tr>
<td><code>Exit.succeed(SA)</code></td>
<td>Converted to <code>Exit.succeed(SI)</code>, where <code>SA</code> is encoded into <code>SI</code> using the inner <code>success</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Exit } from &quot;effect&quot;

const schema = Schema.ExitFromSelf({
  failure: Schema.String,
  success: Schema.NumberFromString,
  defect: Schema.String
})

//     ┌─── Exit&lt;string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Exit&lt;number, string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(Exit.fail(&quot;a&quot;)))
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;a&#39; }
}
*/

console.log(decode(Exit.succeed(&quot;1&quot;)))
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: 1 }
*/

// Encoding examples

console.log(encode(Exit.fail(&quot;a&quot;)))
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;a&#39; }
}
*/

console.log(encode(Exit.succeed(1)))
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;1&#39; }
*/
</code></pre>
<h2>ReadonlySet</h2>
<h3>ReadonlySet</h3>
<p>The <code>Schema.ReadonlySet</code> function is useful for converting a <code>ReadonlySet</code> into a JSON-serializable format.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ReadonlySet(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyArray&lt;I&gt;</code></td>
<td>Converted to <code>ReadonlySet&lt;A&gt;</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlySet&lt;A&gt;</code></td>
<td><code>ReadonlyArray&lt;I&gt;</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.ReadonlySet(Schema.NumberFromString)

//     ┌─── readonly string[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlySet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]))
// Output: Set(3) { 1, 2, 3 }

// Encoding examples

console.log(encode(new Set([1, 2, 3])))
// Output: [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ]
</code></pre>
<h3>ReadonlySetFromSelf</h3>
<p>The <code>Schema.ReadonlySetFromSelf</code> function is designed for scenarios where <code>ReadonlySet</code> values are already in the <code>ReadonlySet</code> format and need to be decoded or encoded while transforming the inner values according to the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ReadonlySetFromSelf(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlySet&lt;I&gt;</code></td>
<td>Converted to <code>ReadonlySet&lt;A&gt;</code>, where <code>I</code> is decoded into <code>A</code> using the inner schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlySet&lt;A&gt;</code></td>
<td><code>ReadonlySet&lt;I&gt;</code>, where <code>A</code> is encoded into <code>I</code> using the inner schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.ReadonlySetFromSelf(Schema.NumberFromString)

//     ┌─── ReadonlySet&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlySet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(new Set([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])))
// Output: Set(3) { 1, 2, 3 }

// Encoding examples

console.log(encode(new Set([1, 2, 3])))
// Output: Set(3) { &#39;1&#39;, &#39;2&#39;, &#39;3&#39; }
</code></pre>
<h2>ReadonlyMap</h2>
<p>The <code>Schema.ReadonlyMap</code> function is useful for converting a <code>ReadonlyMap</code> into a JSON-serializable format.</p>
<h3>ReadonlyMap</h3>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ReadonlyMap(options: {
  key: Schema&lt;KA, KI, KR&gt;,
  value: Schema&lt;VA, VI, VR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyArray&lt;readonly [KI, VI]&gt;</code></td>
<td>Converted to <code>ReadonlyMap&lt;KA, VA&gt;</code>, where <code>KI</code> is decoded into <code>KA</code> using the inner <code>key</code> schema and <code>VI</code> is decoded into <code>VA</code> using the inner <code>value</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyMap&lt;KA, VA&gt;</code></td>
<td>Converted to <code>ReadonlyArray&lt;readonly [KI, VI]&gt;</code>, where <code>KA</code> is decoded into <code>KI</code> using the inner <code>key</code> schema and <code>VA</code> is decoded into <code>VI</code> using the inner <code>value</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.ReadonlyMap({
  key: Schema.String,
  value: Schema.NumberFromString
})

//     ┌─── readonly (readonly [string, string])[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlyMap&lt;string, number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode([
    [&quot;a&quot;, &quot;2&quot;],
    [&quot;b&quot;, &quot;2&quot;],
    [&quot;c&quot;, &quot;3&quot;]
  ])
)
// Output: Map(3) { &#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 3 }

// Encoding examples

console.log(
  encode(
    new Map([
      [&quot;a&quot;, 1],
      [&quot;b&quot;, 2],
      [&quot;c&quot;, 3]
    ])
  )
)
// Output: [ [ &#39;a&#39;, &#39;1&#39; ], [ &#39;b&#39;, &#39;2&#39; ], [ &#39;c&#39;, &#39;3&#39; ] ]
</code></pre>
<h3>ReadonlyMapFromSelf</h3>
<p>The <code>Schema.ReadonlyMapFromSelf</code> function is designed for scenarios where <code>ReadonlyMap</code> values are already in the <code>ReadonlyMap</code> format and need to be decoded or encoded while transforming the inner values according to the provided schemas.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ReadonlyMapFromSelf(options: {
  key: Schema&lt;KA, KI, KR&gt;,
  value: Schema&lt;VA, VI, VR&gt;
})
</code></pre>
<h5>Decoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyMap&lt;KI, VI&gt;</code></td>
<td>Converted to <code>ReadonlyMap&lt;KA, VA&gt;</code>, where <code>KI</code> is decoded into <code>KA</code> using the inner <code>key</code> schema and <code>VI</code> is decoded into <code>VA</code> using the inner <code>value</code> schema</td>
</tr>
</tbody></table>
<h5>Encoding</h5>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyMap&lt;KA, VA&gt;</code></td>
<td>Converted to <code>ReadonlyMap&lt;KI, VI&gt;</code>, where <code>KA</code> is decoded into <code>KI</code> using the inner <code>key</code> schema and <code>VA</code> is decoded into <code>VI</code> using the inner <code>value</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.ReadonlyMapFromSelf({
  key: Schema.String,
  value: Schema.NumberFromString
})

//     ┌─── ReadonlyMap&lt;string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlyMap&lt;string, number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode(
    new Map([
      [&quot;a&quot;, &quot;2&quot;],
      [&quot;b&quot;, &quot;2&quot;],
      [&quot;c&quot;, &quot;3&quot;]
    ])
  )
)
// Output: Map(3) { &#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 3 }

// Encoding examples

console.log(
  encode(
    new Map([
      [&quot;a&quot;, 1],
      [&quot;b&quot;, 2],
      [&quot;c&quot;, 3]
    ])
  )
)
// Output: Map(3) { &#39;a&#39; =&gt; &#39;1&#39;, &#39;b&#39; =&gt; &#39;2&#39;, &#39;c&#39; =&gt; &#39;3&#39; }
</code></pre>
<h3>ReadonlyMapFromRecord</h3>
<p>The <code>Schema.ReadonlyMapFromRecord</code> function is a utility to transform a <code>ReadonlyMap</code> into an object format, where keys are strings and values are serializable, and vice versa.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.ReadonlyMapFromRecord({
  key: Schema&lt;KA, KI, KR&gt;,
  value: Schema&lt;VA, VI, VR&gt;
})
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>{ readonly [x: string]: VI }</code></td>
<td>Converts to <code>ReadonlyMap&lt;KA, VA&gt;</code>, where <code>x</code> is decoded into <code>KA</code> using the <code>key</code> schema and <code>VI</code> into <code>VA</code> using the <code>value</code> schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyMap&lt;KA, VA&gt;</code></td>
<td>Converts to <code>{ readonly [x: string]: VI }</code>, where <code>KA</code> is encoded into <code>x</code> using the <code>key</code> schema and <code>VA</code> into <code>VI</code> using the <code>value</code> schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.ReadonlyMapFromRecord({
  key: Schema.NumberFromString,
  value: Schema.NumberFromString
})

//     ┌─── { readonly [x: string]: string; }
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlyMap&lt;number, number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode({
    &quot;1&quot;: &quot;4&quot;,
    &quot;2&quot;: &quot;5&quot;,
    &quot;3&quot;: &quot;6&quot;
  })
)
// Output: Map(3) { 1 =&gt; 4, 2 =&gt; 5, 3 =&gt; 6 }

// Encoding examples

console.log(
  encode(
    new Map([
      [1, 4],
      [2, 5],
      [3, 6]
    ])
  )
)
// Output: { &#39;1&#39;: &#39;4&#39;, &#39;2&#39;: &#39;5&#39;, &#39;3&#39;: &#39;6&#39; }
</code></pre>
<h2>HashSet</h2>
<h3>HashSet</h3>
<p>The <code>Schema.HashSet</code> function provides a way to map between <code>HashSet</code> and an array representation, allowing for JSON serialization and deserialization.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.HashSet(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyArray&lt;I&gt;</code></td>
<td>Converts to <code>HashSet&lt;A&gt;</code>, where each element in the array is decoded into type <code>A</code> using the schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashSet&lt;A&gt;</code></td>
<td>Converts to <code>ReadonlyArray&lt;I&gt;</code>, where each element in the <code>HashSet</code> is encoded into type <code>I</code> using the schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { HashSet } from &quot;effect&quot;

const schema = Schema.HashSet(Schema.NumberFromString)

//     ┌─── readonly string[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── HashSet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]))
// Output: { _id: &#39;HashSet&#39;, values: [ 1, 2, 3 ] }

// Encoding examples

console.log(encode(HashSet.fromIterable([1, 2, 3])))
// Output: [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ]
</code></pre>
<h3>HashSetFromSelf</h3>
<p>The <code>Schema.HashSetFromSelf</code> function is designed for scenarios where <code>HashSet</code> values are already in the <code>HashSet</code> format and need to be decoded or encoded while transforming the inner values according to the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.HashSetFromSelf(schema: Schema&lt;A, I, R&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashSet&lt;I&gt;</code></td>
<td>Converts to <code>HashSet&lt;A&gt;</code>, decoding each element from type <code>I</code> to type <code>A</code> using the schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashSet&lt;A&gt;</code></td>
<td>Converts to <code>HashSet&lt;I&gt;</code>, encoding each element from type <code>A</code> to type <code>I</code> using the schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { HashSet } from &quot;effect&quot;

const schema = Schema.HashSetFromSelf(Schema.NumberFromString)

//     ┌─── HashSet&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── HashSet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(HashSet.fromIterable([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])))
// Output: { _id: &#39;HashSet&#39;, values: [ 1, 2, 3 ] }

// Encoding examples

console.log(encode(HashSet.fromIterable([1, 2, 3])))
// Output: { _id: &#39;HashSet&#39;, values: [ &#39;1&#39;, &#39;3&#39;, &#39;2&#39; ] }
</code></pre>
<h2>HashMap</h2>
<h3>HashMap</h3>
<p>The <code>Schema.HashMap</code> function is useful for converting a <code>HashMap</code> into a JSON-serializable format.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.HashMap(options: {
  key: Schema&lt;KA, KI, KR&gt;,
  value: Schema&lt;VA, VI, VR&gt;
})
</code></pre>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyArray&lt;readonly [KI, VI]&gt;</code></td>
<td>Converts to <code>HashMap&lt;KA, VA&gt;</code>, where <code>KI</code> is decoded into <code>KA</code> and <code>VI</code> is decoded into <code>VA</code> using the specified schemas</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap&lt;KA, VA&gt;</code></td>
<td>Converts to <code>ReadonlyArray&lt;readonly [KI, VI]&gt;</code>, where <code>KA</code> is encoded into <code>KI</code> and <code>VA</code> is encoded into <code>VI</code> using the specified schemas</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { HashMap } from &quot;effect&quot;

const schema = Schema.HashMap({
  key: Schema.String,
  value: Schema.NumberFromString
})

//     ┌─── readonly (readonly [string, string])[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── HashMap&lt;string, number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode([
    [&quot;a&quot;, &quot;2&quot;],
    [&quot;b&quot;, &quot;2&quot;],
    [&quot;c&quot;, &quot;3&quot;]
  ])
)
// Output: { _id: &#39;HashMap&#39;, values: [ [ &#39;a&#39;, 2 ], [ &#39;c&#39;, 3 ], [ &#39;b&#39;, 2 ] ] }

// Encoding examples

console.log(
  encode(
    HashMap.fromIterable([
      [&quot;a&quot;, 1],
      [&quot;b&quot;, 2],
      [&quot;c&quot;, 3]
    ])
  )
)
// Output: [ [ &#39;a&#39;, &#39;1&#39; ], [ &#39;c&#39;, &#39;3&#39; ], [ &#39;b&#39;, &#39;2&#39; ] ]
</code></pre>
<h3>HashMapFromSelf</h3>
<p>The <code>Schema.HashMapFromSelf</code> function is designed for scenarios where <code>HashMap</code> values are already in the <code>HashMap</code> format and need to be decoded or encoded while transforming the inner values according to the provided schemas.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.HashMapFromSelf(options: {
  key: Schema&lt;KA, KI, KR&gt;,
  value: Schema&lt;VA, VI, VR&gt;
})
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap&lt;KI, VI&gt;</code></td>
<td>Converts to <code>HashMap&lt;KA, VA&gt;</code>, where <code>KI</code> is decoded into <code>KA</code> and <code>VI</code> is decoded into <code>VA</code> using the specified schemas</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>HashMap&lt;KA, VA&gt;</code></td>
<td>Converts to <code>HashMap&lt;KI, VI&gt;</code>, where <code>KA</code> is encoded into <code>KI</code> and <code>VA</code> is encoded into <code>VI</code> using the specified schemas</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { HashMap } from &quot;effect&quot;

const schema = Schema.HashMapFromSelf({
  key: Schema.String,
  value: Schema.NumberFromString
})

//     ┌─── HashMap&lt;string, string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── HashMap&lt;string, number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode(
    HashMap.fromIterable([
      [&quot;a&quot;, &quot;2&quot;],
      [&quot;b&quot;, &quot;2&quot;],
      [&quot;c&quot;, &quot;3&quot;]
    ])
  )
)
// Output: { _id: &#39;HashMap&#39;, values: [ [ &#39;a&#39;, 2 ], [ &#39;c&#39;, 3 ], [ &#39;b&#39;, 2 ] ] }

// Encoding examples

console.log(
  encode(
    HashMap.fromIterable([
      [&quot;a&quot;, 1],
      [&quot;b&quot;, 2],
      [&quot;c&quot;, 3]
    ])
  )
)
// Output: { _id: &#39;HashMap&#39;, values: [ [ &#39;a&#39;, &#39;1&#39; ], [ &#39;c&#39;, &#39;3&#39; ], [ &#39;b&#39;, &#39;2&#39; ] ] }
</code></pre>
<h2>SortedSet</h2>
<h3>SortedSet</h3>
<p>The <code>Schema.SortedSet</code> function provides a way to map between <code>SortedSet</code> and an array representation, allowing for JSON serialization and deserialization.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.SortedSet(schema: Schema&lt;A, I, R&gt;, order: Order&lt;A&gt;)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>ReadonlyArray&lt;I&gt;</code></td>
<td>Converts to <code>SortedSet&lt;A&gt;</code>, where each element in the array is decoded into type <code>A</code> using the schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>SortedSet&lt;A&gt;</code></td>
<td>Converts to <code>ReadonlyArray&lt;I&gt;</code>, where each element in the <code>SortedSet</code> is encoded into type <code>I</code> using the schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Number, SortedSet } from &quot;effect&quot;

const schema = Schema.SortedSet(Schema.NumberFromString, Number.Order)

//     ┌─── readonly string[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── SortedSet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]))
// Output: { _id: &#39;SortedSet&#39;, values: [ 1, 2, 3 ] }

// Encoding examples

console.log(encode(SortedSet.fromIterable(Number.Order)([1, 2, 3])))
// Output: [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ]
</code></pre>
<h3>SortedSetFromSelf</h3>
<p>The <code>Schema.SortedSetFromSelf</code> function is designed for scenarios where <code>SortedSet</code> values are already in the <code>SortedSet</code> format and need to be decoded or encoded while transforming the inner values according to the provided schema.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-ts">Schema.SortedSetFromSelf(
  schema: Schema&lt;A, I, R&gt;,
  decodeOrder: Order&lt;A&gt;,
  encodeOrder: Order&lt;I&gt;
)
</code></pre>
<h4>Decoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>SortedSet&lt;I&gt;</code></td>
<td>Converts to <code>SortedSet&lt;A&gt;</code>, decoding each element from type <code>I</code> to type <code>A</code> using the schema</td>
</tr>
</tbody></table>
<h4>Encoding</h4>
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td><code>SortedSet&lt;A&gt;</code></td>
<td>Converts to <code>SortedSet&lt;I&gt;</code>, encoding each element from type <code>A</code> to type <code>I</code> using the schema</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Number, SortedSet, String } from &quot;effect&quot;

const schema = Schema.SortedSetFromSelf(
  Schema.NumberFromString,
  Number.Order,
  String.Order
)

//     ┌─── SortedSet&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── SortedSet&lt;number&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(SortedSet.fromIterable(String.Order)([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])))
// Output: { _id: &#39;SortedSet&#39;, values: [ 1, 2, 3 ] }

// Encoding examples

console.log(encode(SortedSet.fromIterable(Number.Order)([1, 2, 3])))
// Output: { _id: &#39;SortedSet&#39;, values: [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39; ] }
</code></pre>
<h2>Duration</h2>
<p>The <code>Duration</code> schema family enables the transformation and validation of duration values across various formats, including <code>hrtime</code>, milliseconds, and nanoseconds.</p>
<h3>Duration</h3>
<p>Converts an hrtime(i.e. <code>[seconds: number, nanos: number]</code>) into a <code>Duration</code>.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Duration

//     ┌─── readonly [seconds: number, nanos: number]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Duration
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode([0, 0]))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 0 }

console.log(decode([5000, 0]))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Nanos&#39;, hrtime: [ 5000, 0 ] }
</code></pre>
<h3>DurationFromSelf</h3>
<p>The <code>DurationFromSelf</code> schema is designed to validate that a given value conforms to the <code>Duration</code> type.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Duration } from &quot;effect&quot;

const schema = Schema.DurationFromSelf

//     ┌─── Duration
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Duration
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(Duration.seconds(2)))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 2000 }

console.log(decode(null))
/*
throws:
ParseError: Expected DurationFromSelf, actual null
*/
</code></pre>
<h3>DurationFromMillis</h3>
<p>Converts a <code>number</code> into a <code>Duration</code> where the number represents the number of milliseconds.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.DurationFromMillis

//     ┌─── number
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Duration
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(0))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 0 }

console.log(decode(5000))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 5000 }
</code></pre>
<h3>DurationFromNanos</h3>
<p>Converts a <code>BigInt</code> into a <code>Duration</code> where the number represents the number of nanoseconds.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.DurationFromNanos

//     ┌─── bigint
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Duration
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(0n))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 0 }

console.log(decode(5000000000n))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Nanos&#39;, hrtime: [ 5, 0 ] }
</code></pre>
<h3>clampDuration</h3>
<p>Clamps a <code>Duration</code> between a minimum and a maximum value.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema, Duration } from &quot;effect&quot;

const schema = Schema.DurationFromSelf.pipe(
  Schema.clampDuration(&quot;5 seconds&quot;, &quot;10 seconds&quot;)
)

//     ┌─── Duration
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Duration
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(Duration.decode(&quot;2 seconds&quot;)))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 5000 }

console.log(decode(Duration.decode(&quot;6 seconds&quot;)))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 6000 }

console.log(decode(Duration.decode(&quot;11 seconds&quot;)))
// Output: { _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 10000 }
</code></pre>
<h2>Redacted</h2>
<h3>Redacted</h3>
<p>The <code>Schema.Redacted</code> function is specifically designed to handle sensitive information by converting a <code>string</code> into a <a href="/docs/data-types/redacted/">Redacted</a> object.
This transformation ensures that the sensitive data is not exposed in the application&#39;s output.</p>
<p><strong>Example</strong> (Basic Redacted Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Redacted(Schema.String)

//     ┌─── string
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Redacted&lt;string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(&quot;keep it secret, keep it safe&quot;))
// Output: &lt;redacted&gt;
</code></pre>
<p>It&#39;s important to note that when successfully decoding a <code>Redacted</code>, the output is intentionally obscured (<code>&lt;redacted&gt;</code>) to prevent the actual secret from being revealed in logs or console outputs.</p>
<Aside type="caution" title="Potential Risks">
  When composing the `Redacted` schema with other schemas, care must be
  taken as decoding or encoding errors could potentially expose sensitive
  information.
</Aside>

<p><strong>Example</strong> (Exposure Risks During Errors)</p>
<p>In the example below, if the input string does not meet the criteria (e.g., contains spaces), the error message generated might inadvertently expose sensitive information included in the input.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Redacted } from &quot;effect&quot;

const schema = Schema.Trimmed.pipe(
  Schema.compose(Schema.Redacted(Schema.String))
)

console.log(Schema.decodeUnknownEither(schema)(&quot; SECRET&quot;))
/*
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;(Trimmed &lt;-&gt; (string &lt;-&gt; Redacted(&lt;redacted&gt;)))\n&#39; +
      &#39;└─ Encoded side transformation failure\n&#39; +
      &#39;   └─ Trimmed\n&#39; +
      &#39;      └─ Predicate refinement failure\n&#39; +
      &#39;         └─ Expected Trimmed (a string with no leading or trailing whitespace), actual &quot; SECRET&quot;&#39;
  }
}
*/

console.log(Schema.encodeEither(schema)(Redacted.make(&quot; SECRET&quot;)))
/*
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;(Trimmed &lt;-&gt; (string &lt;-&gt; Redacted(&lt;redacted&gt;)))\n&#39; +
      &#39;└─ Encoded side transformation failure\n&#39; +
      &#39;   └─ Trimmed\n&#39; +
      &#39;      └─ Predicate refinement failure\n&#39; +
      &#39;         └─ Expected Trimmed (a string with no leading or trailing whitespace), actual &quot; SECRET&quot;&#39;
  }
}
*/
</code></pre>
<h4>Mitigating Exposure Risks</h4>
<p>To reduce the risk of sensitive information leakage in error messages, you can customize the error messages to obscure sensitive details:</p>
<p><strong>Example</strong> (Customizing Error Messages)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Redacted } from &quot;effect&quot;

const schema = Schema.Trimmed.annotations({
  message: () =&gt; &quot;Expected Trimmed, actual &lt;redacted&gt;&quot;
}).pipe(Schema.compose(Schema.Redacted(Schema.String)))

console.log(Schema.decodeUnknownEither(schema)(&quot; SECRET&quot;))
/*
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;(Trimmed &lt;-&gt; (string &lt;-&gt; Redacted(&lt;redacted&gt;)))\n&#39; +
      &#39;└─ Encoded side transformation failure\n&#39; +
      &#39;   └─ Expected Trimmed, actual &lt;redacted&gt;&#39;
  }
}
*/

console.log(Schema.encodeEither(schema)(Redacted.make(&quot; SECRET&quot;)))
/*
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;(Trimmed &lt;-&gt; (string &lt;-&gt; Redacted(&lt;redacted&gt;)))\n&#39; +
      &#39;└─ Encoded side transformation failure\n&#39; +
      &#39;   └─ Expected Trimmed, actual &lt;redacted&gt;&#39;
  }
}
*/
</code></pre>
<h3>RedactedFromSelf</h3>
<p>The <code>Schema.RedactedFromSelf</code> schema is designed to validate that a given value conforms to the <code>Redacted</code> type from the <code>effect</code> library.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Redacted } from &quot;effect&quot;

const schema = Schema.RedactedFromSelf(Schema.String)

//     ┌─── Redacted&lt;string&gt;
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── Redacted&lt;string&gt;
//     ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)

// Decoding examples

console.log(decode(Redacted.make(&quot;mysecret&quot;)))
// Output: &lt;redacted&gt;

console.log(decode(null))
/*
throws:
ParseError: Expected Redacted(&lt;redacted&gt;), actual null
*/
</code></pre>
<p>It&#39;s important to note that when successfully decoding a <code>Redacted</code>, the output is intentionally obscured (<code>&lt;redacted&gt;</code>) to prevent the actual secret from being revealed in logs or console outputs.</p>
<hr>
<hr>
<h2>title: Schema to Equivalence
description: Generate and customize equivalence checks for data structures based on schema definitions.
sidebar:
  label: Equivalence
  order: 17</h2>
<p>The <code>Schema.equivalence</code> function allows you to generate an <a href="/docs/schema/equivalence/">Equivalence</a> based on a schema definition.
This function is designed to compare data structures for equivalence according to the rules defined in the schema.</p>
<p><strong>Example</strong> (Comparing Structs for Equivalence)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Generate an equivalence function based on the schema
const PersonEquivalence = Schema.equivalence(Person)

const john = { name: &quot;John&quot;, age: 23 }
const alice = { name: &quot;Alice&quot;, age: 30 }

// Use the equivalence function to compare objects

console.log(PersonEquivalence(john, { name: &quot;John&quot;, age: 23 }))
// Output: true

console.log(PersonEquivalence(john, alice))
// Output: false
</code></pre>
<h2>Equivalence for Any, Unknown, and Object</h2>
<p>When working with the following schemas:</p>
<ul>
<li><code>Schema.Any</code></li>
<li><code>Schema.Unknown</code></li>
<li><code>Schema.Object</code></li>
<li><code>Schema.Struct({})</code> (representing the broad <code>{}</code> TypeScript type)</li>
</ul>
<p>the most sensible form of equivalence is to use <code>Equal.equals</code> from the <a href="/docs/trait/equal/">Equal</a> module, which defaults to reference equality (<code>===</code>).
This is because these types can hold almost any kind of value.</p>
<p><strong>Example</strong> (Comparing Empty Objects Using Reference Equality)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({})

const input1 = {}
const input2 = {}

console.log(Schema.equivalence(schema)(input1, input2))
// Output: false (because they are different references)
</code></pre>
<h2>Customizing Equivalence Generation</h2>
<p>You can customize the equivalence logic by providing an <code>equivalence</code> annotation in the schema definition.</p>
<p>The <code>equivalence</code> annotation takes any type parameters provided (<code>typeParameters</code>) and two values for comparison, returning a boolean based on the desired condition of equivalence.</p>
<p><strong>Example</strong> (Custom Equivalence for Strings)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema with a custom equivalence annotation
const schema = Schema.String.annotations({
  equivalence: (/**typeParameters**/) =&gt; (s1, s2) =&gt;
    // Custom rule: Compare only the first character of the strings
    s1.charAt(0) === s2.charAt(0)
})

// Generate the equivalence function
const customEquivalence = Schema.equivalence(schema)

// Use the custom equivalence function
console.log(customEquivalence(&quot;aaa&quot;, &quot;abb&quot;))
// Output: true (both start with &#39;a&#39;)

console.log(customEquivalence(&quot;aaa&quot;, &quot;bba&quot;))
// Output: false (strings start with different characters)
</code></pre>
<hr>
<hr>
<h2>title: Error Formatters
description: Format and customize error messages during schema decoding and encoding using TreeFormatter or ArrayFormatter.
sidebar:
  order: 10</h2>
<p>When working with Effect Schema, errors encountered during decoding or encoding operations can be formatted using two built-in methods: <code>TreeFormatter</code> and <code>ArrayFormatter</code>. These formatters help structure and present errors in a readable and actionable manner.</p>
<h2>TreeFormatter (default)</h2>
<p>The <code>TreeFormatter</code> is the default method for formatting errors. It organizes errors in a tree structure, providing a clear hierarchy of issues.</p>
<p><strong>Example</strong> (Decoding with Missing Properties)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decodeUnknownEither(Person)

const result = decode({})
if (Either.isLeft(result)) {
  console.error(&quot;Decoding failed:&quot;)
  console.error(ParseResult.TreeFormatter.formatErrorSync(result.left))
}
/*
Decoding failed:
{ readonly name: string; readonly age: number }
└─ [&quot;name&quot;]
   └─ is missing
*/
</code></pre>
<p>In this example:</p>
<ul>
<li><code>{ readonly name: string; readonly age: number }</code> describes the schema&#39;s expected structure.</li>
<li><code>[&quot;name&quot;]</code> identifies the specific field causing the error.</li>
<li><code>is missing</code> explains the issue for the <code>&quot;name&quot;</code> field.</li>
</ul>
<h3>Customizing the Output</h3>
<p>You can make the error output more concise and meaningful by annotating the schema with annotations like <code>identifier</code>, <code>title</code>, or <code>description</code>. These annotations replace the default TypeScript-like representation in the error messages.</p>
<p><strong>Example</strong> (Using <code>title</code> Annotation for Clarity)</p>
<p>Adding a <code>title</code> annotation replaces the schema structure in the error message with the more human-readable &quot;Person&quot; making it easier to understand.</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
}).annotations({ title: &quot;Person&quot; }) // Add a title annotation

const result = Schema.decodeUnknownEither(Person)({})
if (Either.isLeft(result)) {
  console.error(ParseResult.TreeFormatter.formatErrorSync(result.left))
}
/*
Person
└─ [&quot;name&quot;]
   └─ is missing
*/
</code></pre>
<h3>Handling Multiple Errors</h3>
<p>By default, decoding functions like <code>Schema.decodeUnknownEither</code> report only the first error. To list all errors, use the <code>{ errors: &quot;all&quot; }</code> option.</p>
<p><strong>Example</strong> (Listing All Errors)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decodeUnknownEither(Person, { errors: &quot;all&quot; })

const result = decode({})
if (Either.isLeft(result)) {
  console.error(&quot;Decoding failed:&quot;)
  console.error(ParseResult.TreeFormatter.formatErrorSync(result.left))
}
/*
Decoding failed:
{ readonly name: string; readonly age: number }
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;age&quot;]
   └─ is missing
*/
</code></pre>
<h3>ParseIssueTitle Annotation</h3>
<p>The <code>parseIssueTitle</code> annotation allows you to add dynamic context to error messages by generating titles based on the value being validated. For instance, it can include an ID from the validated object, making it easier to identify specific issues in complex or nested data structures.</p>
<p><strong>Annotation Type</strong></p>
<pre><code class="language-ts">export type ParseIssueTitleAnnotation = (
  issue: ParseIssue
) =&gt; string | undefined
</code></pre>
<p><strong>Return Value</strong>:</p>
<ul>
<li>If the function returns a <code>string</code>, the <code>TreeFormatter</code> uses it as the title unless a <code>message</code> annotation is present (which takes precedence).</li>
<li>If the function returns <code>undefined</code>, the <code>TreeFormatter</code> determines the title based on the following priority:<ol>
<li><code>identifier</code> annotation</li>
<li><code>title</code> annotation</li>
<li><code>description</code> annotation</li>
<li>Default TypeScript-like schema representation</li>
</ol>
</li>
</ul>
<p><strong>Example</strong> (Dynamic Titles Using <code>parseIssueTitle</code>)</p>
<pre><code class="language-ts">import type { ParseResult } from &quot;effect&quot;
import { Schema } from &quot;effect&quot;

// Function to generate titles for OrderItem issues
const getOrderItemId = ({ actual }: ParseResult.ParseIssue) =&gt; {
  if (Schema.is(Schema.Struct({ id: Schema.String }))(actual)) {
    return `OrderItem with id: ${actual.id}`
  }
}

const OrderItem = Schema.Struct({
  id: Schema.String,
  name: Schema.String,
  price: Schema.Number
}).annotations({
  identifier: &quot;OrderItem&quot;,
  parseIssueTitle: getOrderItemId
})

// Function to generate titles for Order issues
const getOrderId = ({ actual }: ParseResult.ParseIssue) =&gt; {
  if (Schema.is(Schema.Struct({ id: Schema.Number }))(actual)) {
    return `Order with id: ${actual.id}`
  }
}

const Order = Schema.Struct({
  id: Schema.Number,
  name: Schema.String,
  items: Schema.Array(OrderItem)
}).annotations({
  identifier: &quot;Order&quot;,
  parseIssueTitle: getOrderId
})

const decode = Schema.decodeUnknownSync(Order, { errors: &quot;all&quot; })

// Case 1: No id available, uses the `identifier` annotation
decode({})
/*
throws
ParseError: Order
├─ [&quot;id&quot;]
│  └─ is missing
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;items&quot;]
   └─ is missing
*/

// Case 2: ID present, uses the dynamic `parseIssueTitle` annotation
decode({ id: 1 })
/*
throws
ParseError: Order with id: 1
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;items&quot;]
   └─ is missing
*/

// Case 3: Nested issues with IDs for both Order and OrderItem
decode({ id: 1, items: [{ id: &quot;22b&quot;, price: &quot;100&quot; }] })
/*
throws
ParseError: Order with id: 1
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;items&quot;]
   └─ ReadonlyArray&lt;OrderItem&gt;
      └─ [0]
         └─ OrderItem with id: 22b
            ├─ [&quot;name&quot;]
            │  └─ is missing
            └─ [&quot;price&quot;]
               └─ Expected a number, actual &quot;100&quot;
*/
</code></pre>
<h2>ArrayFormatter</h2>
<p>The <code>ArrayFormatter</code> provides a structured, array-based approach to formatting errors. It represents each error as an object, making it easier to analyze and address multiple issues during data decoding or encoding. Each error object includes properties like <code>_tag</code>, <code>path</code>, and <code>message</code> for clarity.</p>
<p><strong>Example</strong> (Single Error in Array Format)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decodeUnknownEither(Person)

const result = decode({})
if (Either.isLeft(result)) {
  console.error(&quot;Decoding failed:&quot;)
  console.error(ParseResult.ArrayFormatter.formatErrorSync(result.left))
}
/*
Decoding failed:
[ { _tag: &#39;Missing&#39;, path: [ &#39;name&#39; ], message: &#39;is missing&#39; } ]
*/
</code></pre>
<p>In this example:</p>
<ul>
<li><code>_tag</code>: Indicates the type of error (<code>Missing</code>).</li>
<li><code>path</code>: Specifies the location of the error in the data (<code>[&#39;name&#39;]</code>).</li>
<li><code>message</code>: Describes the issue (<code>&#39;is missing&#39;</code>).</li>
</ul>
<h3>Handling Multiple Errors</h3>
<p>By default, decoding functions like <code>Schema.decodeUnknownEither</code> report only the first error. To list all errors, use the <code>{ errors: &quot;all&quot; }</code> option.</p>
<p><strong>Example</strong> (Listing All Errors)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decodeUnknownEither(Person, { errors: &quot;all&quot; })

const result = decode({})
if (Either.isLeft(result)) {
  console.error(&quot;Decoding failed:&quot;)
  console.error(ParseResult.ArrayFormatter.formatErrorSync(result.left))
}
/*
Decoding failed:
[
  { _tag: &#39;Missing&#39;, path: [ &#39;name&#39; ], message: &#39;is missing&#39; },
  { _tag: &#39;Missing&#39;, path: [ &#39;age&#39; ], message: &#39;is missing&#39; }
]
*/
</code></pre>
<h2>React Hook Form</h2>
<p>If you are working with React and need form validation, <code>@hookform/resolvers</code> offers an adapter for <code>effect/Schema</code>, which can be integrated with React Hook Form for enhanced form validation processes. This integration allows you to leverage the powerful features of <code>effect/Schema</code> within your React applications.</p>
<p>For more detailed instructions and examples on how to integrate <code>effect/Schema</code> with React Hook Form using <code>@hookform/resolvers</code>, you can visit the official npm package page:
<a href="https://www.npmjs.com/package/@hookform/resolvers#effect-ts">React Hook Form Resolvers</a></p>
<hr>
<hr>
<h2>title: Error Messages
description: Customize and enhance error messages for schema decoding with default, refined, and custom messages.
sidebar:
  order: 9</h2>
<h2>Default Error Messages</h2>
<p>By default, when a parsing error occurs, the system automatically generates an informative message based on the schema&#39;s structure and the nature of the error (see <a href="/docs/schema/error-formatters/#treeformatter-default">TreeFormatter</a> for more informations).
For example, if a required property is missing or a data type does not match, the error message will clearly state the expectation versus the actual input.</p>
<p><strong>Example</strong> (Type Mismatch)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)(null)
// Output: ParseError: Expected { readonly name: string; readonly age: number }, actual null
</code></pre>
<p><strong>Example</strong> (Missing Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)({}, { errors: &quot;all&quot; })
/*
throws:
ParseError: { readonly name: string; readonly age: number }
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;age&quot;]
   └─ is missing
*/
</code></pre>
<p><strong>Example</strong> (Incorrect Property Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)(
  { name: null, age: &quot;age&quot; },
  { errors: &quot;all&quot; }
)
/*
throws:
ParseError: { readonly name: string; readonly age: number }
├─ [&quot;name&quot;]
│  └─ Expected string, actual null
└─ [&quot;age&quot;]
   └─ Expected number, actual &quot;age&quot;
*/
</code></pre>
<h3>Enhancing Clarity in Error Messages with Identifiers</h3>
<p>In scenarios where a schema has multiple fields or nested structures, the default error messages can become overly complex and verbose.
To address this, you can enhance the clarity and brevity of these messages by utilizing annotations such as <code>identifier</code>, <code>title</code>, and <code>description</code>.</p>
<p><strong>Example</strong> (Using Identifiers for Clarity)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Name = Schema.String.annotations({ identifier: &quot;Name&quot; })

const Age = Schema.Number.annotations({ identifier: &quot;Age&quot; })

const Person = Schema.Struct({
  name: Name,
  age: Age
}).annotations({ identifier: &quot;Person&quot; })

Schema.decodeUnknownSync(Person)(null)
/*
throws:
ParseError: Expected Person, actual null
*/

Schema.decodeUnknownSync(Person)({}, { errors: &quot;all&quot; })
/*
throws:
ParseError: Person
├─ [&quot;name&quot;]
│  └─ is missing
└─ [&quot;age&quot;]
   └─ is missing
*/

Schema.decodeUnknownSync(Person)(
  { name: null, age: null },
  { errors: &quot;all&quot; }
)
/*
throws:
ParseError: Person
├─ [&quot;name&quot;]
│  └─ Expected Name, actual null
└─ [&quot;age&quot;]
   └─ Expected Age, actual null
*/
</code></pre>
<h3>Refinements</h3>
<p>When a refinement fails, the default error message indicates whether the failure occurred in the &quot;from&quot; part or within the predicate defining the refinement:</p>
<p><strong>Example</strong> (Refinement Errors)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Name = Schema.NonEmptyString.annotations({ identifier: &quot;Name&quot; })

const Age = Schema.Positive.pipe(Schema.int({ identifier: &quot;Age&quot; }))

const Person = Schema.Struct({
  name: Name,
  age: Age
}).annotations({ identifier: &quot;Person&quot; })

// From side failure
Schema.decodeUnknownSync(Person)({ name: null, age: 18 })
/*
throws:
ParseError: Person
└─ [&quot;name&quot;]
   └─ Name
      └─ From side refinement failure
         └─ Expected string, actual null
*/

// Predicate refinement failure
Schema.decodeUnknownSync(Person)({ name: &quot;&quot;, age: 18 })
/*
throws:
ParseError: Person
└─ [&quot;name&quot;]
   └─ Name
      └─ Predicate refinement failure
         └─ Expected a non empty string, actual &quot;&quot;
*/
</code></pre>
<p>In the first example, the error message indicates a &quot;from side&quot; refinement failure in the <code>name</code> property, specifying that a string was expected but received <code>null</code>.
In the second example, a &quot;predicate&quot; refinement failure is reported, indicating that a non-empty string was expected for <code>name</code> but an empty string was provided.</p>
<h3>Transformations</h3>
<p>Transformations between different types or formats can occasionally result in errors.
The system provides a structured error message to specify where the error occurred:</p>
<ul>
<li><strong>Encoded Side Failure:</strong> Errors on this side typically indicate that the input to the transformation does not match the expected initial type or format. For example, receiving a <code>null</code> when a <code>string</code> is expected.</li>
<li><strong>Transformation Process Failure:</strong> This type of error arises when the transformation logic itself fails, such as when the input does not meet the criteria specified within the transformation functions.</li>
<li><strong>Type Side Failure:</strong> Occurs when the output of a transformation does not meet the schema requirements on the decoded side. This can happen if the transformed value fails subsequent validations or conditions.</li>
</ul>
<p><strong>Example</strong> (Transformation Errors)</p>
<pre><code class="language-ts">import { ParseResult, Schema } from &quot;effect&quot;

const schema = Schema.transformOrFail(
  Schema.String,
  Schema.String.pipe(Schema.minLength(2)),
  {
    strict: true,
    decode: (s, _, ast) =&gt;
      s.length &gt; 0
        ? ParseResult.succeed(s)
        : ParseResult.fail(new ParseResult.Type(ast, s)),
    encode: ParseResult.succeed
  }
)

// Encoded side failure
Schema.decodeUnknownSync(schema)(null)
/*
throws:
ParseError: (string &lt;-&gt; minLength(2))
└─ Encoded side transformation failure
   └─ Expected string, actual null
*/

// transformation failure
Schema.decodeUnknownSync(schema)(&quot;&quot;)
/*
throws:
ParseError: (string &lt;-&gt; minLength(2))
└─ Transformation process failure
   └─ Expected (string &lt;-&gt; minLength(2)), actual &quot;&quot;
*/

// Type side failure
Schema.decodeUnknownSync(schema)(&quot;a&quot;)
/*
throws:
ParseError: (string &lt;-&gt; minLength(2))
└─ Type side transformation failure
   └─ minLength(2)
      └─ Predicate refinement failure
         └─ Expected a string at least 2 character(s) long, actual &quot;a&quot;
*/
</code></pre>
<h2>Custom Error Messages</h2>
<p>You have the capability to define custom error messages specifically tailored for different parts of your schema using the <code>message</code> annotation.
This allows developers to provide more context-specific feedback which can improve the debugging and validation processes.</p>
<p>Here&#39;s an overview of the <code>MessageAnnotation</code> type, which you can use to craft these messages:</p>
<pre><code class="language-ts">type MessageAnnotation = (issue: ParseIssue) =&gt;
  | string
  | Effect&lt;string&gt;
  | {
      readonly message: string | Effect&lt;string&gt;
      readonly override: boolean
    }
</code></pre>
<table>
<thead>
<tr>
<th>Return Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>string</code></td>
<td>Provides a static message that directly describes the error.</td>
</tr>
<tr>
<td><code>Effect&lt;string&gt;</code></td>
<td>Utilizes dynamic messages that can incorporate results from <strong>synchronous</strong> processes or rely on <strong>optional</strong> dependencies.</td>
</tr>
<tr>
<td>Object (with <code>message</code> and <code>override</code>)</td>
<td>Allows you to define a specific error message along with a boolean flag (<code>override</code>). This flag determines if the custom message should supersede any default or nested custom messages, providing precise control over the error output displayed to users.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Adding a Custom Error Message to a String Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a string schema without a custom message
const MyString = Schema.String

// Attempt to decode `null`, resulting in a default error message
Schema.decodeUnknownSync(MyString)(null)
/*
throws:
ParseError: Expected string, actual null
*/

// Define a string schema with a custom error message
const MyStringWithMessage = Schema.String.annotations({
  message: () =&gt; &quot;not a string&quot;
})

// Decode with the custom schema, showing the new error message
Schema.decodeUnknownSync(MyStringWithMessage)(null)
/*
throws:
ParseError: not a string
*/
</code></pre>
<p><strong>Example</strong> (Custom Error Message for a Union Schema with Override Option)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a union schema without a custom message
const MyUnion = Schema.Union(Schema.String, Schema.Number)

// Decode `null`, resulting in default union error messages
Schema.decodeUnknownSync(MyUnion)(null)
/*
throws:
ParseError: string | number
├─ Expected string, actual null
└─ Expected number, actual null
*/

// Define a union schema with a custom message and override flag
const MyUnionWithMessage = Schema.Union(
  Schema.String,
  Schema.Number
).annotations({
  message: () =&gt; ({
    message: &quot;Please provide a string or a number&quot;,
    // Ensures this message replaces all nested messages
    override: true
  })
})

// Decode with the custom schema, showing the new error message
Schema.decodeUnknownSync(MyUnionWithMessage)(null)
/*
throws:
ParseError: Please provide a string or a number
*/
</code></pre>
<h3>General Guidelines for Messages</h3>
<p>The general logic followed to determine the messages is as follows:</p>
<ol>
<li><p>If no custom messages are set, the default message related to the innermost schema where the operation (i.e., decoding or encoding) failed is used.</p>
</li>
<li><p>If custom messages are set, then the message corresponding to the <strong>first</strong> failed schema is used, starting from the innermost schema to the outermost. However, if the failing schema does not have a custom message, then <strong>the default message is used</strong>.</p>
</li>
<li><p>As an opt-in feature, <strong>you can override guideline 2</strong> by setting the <code>overwrite</code> flag to <code>true</code>. This allows the custom message to take precedence over all other custom messages from inner schemas. This is to address the scenario where a user wants to define a single cumulative custom message describing the properties that a valid value must have and does not want to see default messages.</p>
</li>
</ol>
<p>Let&#39;s see some practical examples.</p>
<h3>Scalar Schemas</h3>
<p><strong>Example</strong> (Simple Custom Message for Scalar Schema)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyString = Schema.String.annotations({
  message: () =&gt; &quot;my custom message&quot;
})

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message) // &quot;my custom message&quot;
}
</code></pre>
<h3>Refinements</h3>
<p>This example demonstrates setting a custom message on the last refinement in a chain of refinements. As you can see, the custom message is only used if the refinement related to <code>maxLength</code> fails; otherwise, default messages are used.</p>
<p><strong>Example</strong> (Custom Message on Last Refinement in Chain)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyString = Schema.String.pipe(
  Schema.minLength(1),
  Schema.maxLength(2)
).annotations({
  // This message is displayed only if the last filter (`maxLength`) fails
  message: () =&gt; &quot;my custom message&quot;
})

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message)
  /*
   minLength(1) &amp; maxLength(2)
   └─ From side refinement failure
      └─ minLength(1)
         └─ From side refinement failure
            └─ Expected string, actual null
  */
}

try {
  decode(&quot;&quot;)
} catch (e: any) {
  console.log(e.message)
  /*
   minLength(1) &amp; maxLength(2)
   └─ From side refinement failure
      └─ minLength(1)
         └─ Predicate refinement failure
            └─ Expected a string at least 1 character(s) long, actual &quot;&quot;
  */
}

try {
  decode(&quot;abc&quot;)
} catch (e: any) {
  console.log(e.message)
  // &quot;my custom message&quot;
}
</code></pre>
<p>When setting multiple custom messages, the one corresponding to the <strong>first</strong> failed predicate is used, starting from the innermost refinement to the outermost:</p>
<p><strong>Example</strong> (Custom Messages for Multiple Refinements)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyString = Schema.String
  // This message is displayed only if a non-String is passed as input
  .annotations({ message: () =&gt; &quot;String custom message&quot; })
  .pipe(
    // This message is displayed only if the filter `minLength` fails
    Schema.minLength(1, { message: () =&gt; &quot;minLength custom message&quot; }),
    // This message is displayed only if the filter `maxLength` fails
    Schema.maxLength(2, { message: () =&gt; &quot;maxLength custom message&quot; })
  )

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message) // String custom message
}

try {
  decode(&quot;&quot;)
} catch (e: any) {
  console.log(e.message) // minLength custom message
}

try {
  decode(&quot;abc&quot;)
} catch (e: any) {
  console.log(e.message) // maxLength custom message
}
</code></pre>
<p>You have the option to change the default behavior by setting the <code>override</code> flag to <code>true</code>. This is useful when you want to create a single comprehensive custom message that describes the required properties of a valid value without displaying default messages.</p>
<p><strong>Example</strong> (Overriding Default Messages)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const MyString = Schema.String.pipe(
  Schema.minLength(1),
  Schema.maxLength(2)
).annotations({
  // By setting the `override` flag to `true`, this message will always be shown for any error
  message: () =&gt; ({ message: &quot;my custom message&quot;, override: true })
})

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message) // my custom message
}

try {
  decode(&quot;&quot;)
} catch (e: any) {
  console.log(e.message) // my custom message
}

try {
  decode(&quot;abc&quot;)
} catch (e: any) {
  console.log(e.message) // my custom message
}
</code></pre>
<h3>Transformations</h3>
<p>In this example, <code>IntFromString</code> is a transformation schema that converts strings to integers. It applies specific validation messages based on different scenarios.</p>
<p><strong>Example</strong> (Custom Error Messages for String-to-Integer Transformation)</p>
<pre><code class="language-ts">import { ParseResult, Schema } from &quot;effect&quot;

const IntFromString = Schema.transformOrFail(
  // This message is displayed only if the input is not a string
  Schema.String.annotations({ message: () =&gt; &quot;please enter a string&quot; }),
  // This message is displayed only if the input can be converted
  // to a number but it&#39;s not an integer
  Schema.Int.annotations({ message: () =&gt; &quot;please enter an integer&quot; }),
  {
    strict: true,
    decode: (s, _, ast) =&gt; {
      const n = Number(s)
      return Number.isNaN(n)
        ? ParseResult.fail(new ParseResult.Type(ast, s))
        : ParseResult.succeed(n)
    },
    encode: (n) =&gt; ParseResult.succeed(String(n))
  }
)
  // This message is displayed only if the input
  // cannot be converted to a number
  .annotations({ message: () =&gt; &quot;please enter a parseable string&quot; })

const decode = Schema.decodeUnknownSync(IntFromString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message) // please enter a string
}

try {
  decode(&quot;1.2&quot;)
} catch (e: any) {
  console.log(e.message) // please enter an integer
}

try {
  decode(&quot;not a number&quot;)
} catch (e: any) {
  console.log(e.message) // please enter a parseable string
}
</code></pre>
<h3>Compound Schemas</h3>
<p>The custom message system becomes especially handy when dealing with complex schemas, unlike simple scalar values like <code>string</code> or <code>number</code>. For instance, consider a schema comprising nested structures, such as a struct containing an array of other structs. Let&#39;s explore an example demonstrating the advantage of default messages in handling decoding errors within such nested structures:</p>
<p><strong>Example</strong> (Custom Error Messages in Nested Schemas)</p>
<pre><code class="language-ts">import { Schema, pipe } from &quot;effect&quot;

const schema = Schema.Struct({
  outcomes: pipe(
    Schema.Array(
      Schema.Struct({
        id: Schema.String,
        text: pipe(
          Schema.String.annotations({
            message: () =&gt; &quot;error_invalid_outcome_type&quot;
          }),
          Schema.minLength(1, { message: () =&gt; &quot;error_required_field&quot; }),
          Schema.maxLength(50, {
            message: () =&gt; &quot;error_max_length_field&quot;
          })
        )
      })
    ),
    Schema.minItems(1, { message: () =&gt; &quot;error_min_length_field&quot; })
  )
})

Schema.decodeUnknownSync(schema, { errors: &quot;all&quot; })({
  outcomes: []
})
/*
throws
ParseError: { readonly outcomes: minItems(1) }
└─ [&quot;outcomes&quot;]
   └─ error_min_length_field
*/

Schema.decodeUnknownSync(schema, { errors: &quot;all&quot; })({
  outcomes: [
    { id: &quot;1&quot;, text: &quot;&quot; },
    { id: &quot;2&quot;, text: &quot;this one is valid&quot; },
    { id: &quot;3&quot;, text: &quot;1234567890&quot;.repeat(6) }
  ]
})
/*
throws
ParseError: { readonly outcomes: minItems(1) }
└─ [&quot;outcomes&quot;]
   └─ minItems(1)
      └─ From side refinement failure
         └─ ReadonlyArray&lt;{ readonly id: string; readonly text: minLength(1) &amp; maxLength(50) }&gt;
            ├─ [0]
            │  └─ { readonly id: string; readonly text: minLength(1) &amp; maxLength(50) }
            │     └─ [&quot;text&quot;]
            │        └─ error_required_field
            └─ [2]
               └─ { readonly id: string; readonly text: minLength(1) &amp; maxLength(50) }
                  └─ [&quot;text&quot;]
                     └─ error_max_length_field
*/
</code></pre>
<h3>Effectful messages</h3>
<p>Error messages can go beyond simple strings by returning an <code>Effect</code>, allowing them to access dependencies, such as an internationalization service. This approach lets messages dynamically adjust based on external context or services. Below is an example illustrating how to create effect-based messages.</p>
<p><strong>Example</strong> (Effect-Based Message with Internationalization Service)</p>
<pre><code class="language-ts">import {
  Context,
  Effect,
  Either,
  Option,
  Schema,
  ParseResult
} from &quot;effect&quot;

// Define an internationalization service for custom messages
class Messages extends Context.Tag(&quot;Messages&quot;)&lt;
  Messages,
  {
    NonEmpty: string
  }
&gt;() {}

// Define a schema with an effect-based message
// that depends on the Messages service
const Name = Schema.NonEmptyString.annotations({
  message: () =&gt;
    Effect.gen(function* () {
      // Attempt to retrieve the Messages service
      const service = yield* Effect.serviceOption(Messages)
      // Use a fallback message if the service is not available
      return Option.match(service, {
        onNone: () =&gt; &quot;Invalid string&quot;,
        onSome: (messages) =&gt; messages.NonEmpty
      })
    })
})

// Attempt to decode an empty string without providing the Messages service
Schema.decodeUnknownEither(Name)(&quot;&quot;).pipe(
  Either.mapLeft((error) =&gt;
    ParseResult.TreeFormatter.formatError(error).pipe(
      Effect.runSync,
      console.log
    )
  )
)
// Output: Invalid string

// Provide the Messages service to customize the error message
Schema.decodeUnknownEither(Name)(&quot;&quot;).pipe(
  Either.mapLeft((error) =&gt;
    ParseResult.TreeFormatter.formatError(error).pipe(
      Effect.provideService(Messages, {
        NonEmpty: &quot;should be non empty&quot;
      }),
      Effect.runSync,
      console.log
    )
  )
)
// Output: should be non empty
</code></pre>
<h3>Missing messages</h3>
<p>You can provide custom messages for missing fields or tuple elements using the <code>missingMessage</code> annotation.</p>
<p><strong>Example</strong> (Custom Message for Missing Property)</p>
<p>In this example, a custom message is defined for a missing <code>name</code> property in the <code>Person</code> schema.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.propertySignature(Schema.String).annotations({
    // Custom message if &quot;name&quot; is missing
    missingMessage: () =&gt; &quot;Name is required&quot;
  })
})

Schema.decodeUnknownSync(Person)({})
/*
throws:
ParseError: { readonly name: string }
└─ [&quot;name&quot;]
   └─ Name is required
*/
</code></pre>
<p><strong>Example</strong> (Custom Message for Missing Tuple Elements)</p>
<p>Here, each element in the <code>Point</code> tuple schema has a specific custom message if the element is missing.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Point = Schema.Tuple(
  Schema.element(Schema.Number).annotations({
    // Message if X is missing
    missingMessage: () =&gt; &quot;X coordinate is required&quot;
  }),
  Schema.element(Schema.Number).annotations({
    // Message if Y is missing
    missingMessage: () =&gt; &quot;Y coordinate is required&quot;
  })
)

Schema.decodeUnknownSync(Point)([], { errors: &quot;all&quot; })
/*
throws:
ParseError: readonly [number, number]
├─ [0]
│  └─ X coordinate is required
└─ [1]
   └─ Y coordinate is required
*/
</code></pre>
<hr>
<hr>
<h2>title: Filters
description: Define custom validation logic with filters to enhance data validation beyond basic type checks.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Developers can define custom validation logic beyond basic type checks, giving more control over how data is validated.</p>
<h2>Declaring Filters</h2>
<p>Filters are declared using the <code>Schema.filter</code> function. This function requires two arguments: the schema to be validated and a predicate function. The predicate function is user-defined and determines whether the data satisfies the condition. If the data fails the validation, an error message can be provided.</p>
<p><strong>Example</strong> (Defining a Minimum String Length Filter)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a string schema with a filter to ensure the string
// is at least 10 characters long
const LongString = Schema.String.pipe(
  Schema.filter(
    // Custom error message for strings shorter than 10 characters
    (s) =&gt; s.length &gt;= 10 || &quot;a string at least 10 characters long&quot;
  )
)

//     ┌─── string
//     ▼
type Type = typeof LongString.Type

console.log(Schema.decodeUnknownSync(LongString)(&quot;a&quot;))
/*
throws:
ParseError: { string | filter }
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/
</code></pre>
<p>Note that the filter does not alter the schema&#39;s <code>Type</code>:</p>
<pre><code class="language-ts">//     ┌─── string
//     ▼
type Type = typeof LongString.Type
</code></pre>
<p>Filters add additional validation constraints without modifying the schema&#39;s underlying type.</p>
<Aside type="tip">
  If you need to modify the `Type`, consider using [Branded
  types](/docs/schema/advanced-usage/#branded-types).
</Aside>

<h2>The Predicate Function</h2>
<p>The predicate function in a filter follows this structure:</p>
<pre><code class="language-ts">type Predicate = (
  a: A,
  options: ParseOptions,
  self: AST.Refinement
) =&gt; FilterReturnType
</code></pre>
<p>where</p>
<pre><code class="language-ts">interface FilterIssue {
  readonly path: ReadonlyArray&lt;PropertyKey&gt;
  readonly issue: string | ParseResult.ParseIssue
}

type FilterOutput =
  | undefined
  | boolean
  | string
  | ParseResult.ParseIssue
  | FilterIssue

type FilterReturnType = FilterOutput | ReadonlyArray&lt;FilterOutput&gt;
</code></pre>
<p>The filter&#39;s predicate can return several types of values, each affecting validation in a different way:</p>
<table>
<thead>
<tr>
<th>Return Type</th>
<th>Behavior</th>
</tr>
</thead>
<tbody><tr>
<td><code>true</code></td>
<td>The data satisfies the filter&#39;s condition and passes validation.</td>
</tr>
<tr>
<td><code>false</code> or <code>undefined</code></td>
<td>The data does not meet the condition, and no specific error message is provided.</td>
</tr>
<tr>
<td><code>string</code></td>
<td>The validation fails, and the provided string is used as the error message.</td>
</tr>
<tr>
<td><code>ParseResult.ParseIssue</code></td>
<td>The validation fails with a detailed error structure, specifying where and why it failed.</td>
</tr>
<tr>
<td><code>FilterIssue</code></td>
<td>Allows for more detailed error messages with specific paths, providing enhanced error reporting.</td>
</tr>
<tr>
<td><code>ReadonlyArray&lt;FilterOutput&gt;</code></td>
<td>An array of issues can be returned if multiple validation errors need to be reported.</td>
</tr>
</tbody></table>
<Aside type="tip" title="Effectful Filters">
  Normal filters only handle synchronous, non-effectful validations. If
  you need filters that involve asynchronous logic or side effects,
  consider using
  [Schema.filterEffect](/docs/schema/transformations/#effectful-filters).
</Aside>

<h2>Adding Annotations</h2>
<p>Embedding metadata within the schema, such as identifiers, JSON schema specifications, and descriptions, enhances understanding and analysis of the schema&#39;s constraints and purpose.</p>
<p><strong>Example</strong> (Adding Metadata with Annotations)</p>
<pre><code class="language-ts">import { Schema, JSONSchema } from &quot;effect&quot;

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) =&gt;
      s.length &gt;= 10 ? undefined : &quot;a string at least 10 characters long&quot;,
    {
      identifier: &quot;LongString&quot;,
      jsonSchema: { minLength: 10 },
      description: &quot;Lorem ipsum dolor sit amet, ...&quot;
    }
  )
)

console.log(Schema.decodeUnknownSync(LongString)(&quot;a&quot;))
/*
throws:
ParseError: LongString
└─ Predicate refinement failure
   └─ a string at least 10 characters long
*/

console.log(JSON.stringify(JSONSchema.make(LongString), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$defs&quot;: {
    &quot;LongString&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, ...&quot;,
      &quot;minLength&quot;: 10
    }
  },
  &quot;$ref&quot;: &quot;#/$defs/LongString&quot;
}
*/
</code></pre>
<h2>Specifying Error Paths</h2>
<p>When validating forms or structured data, it&#39;s possible to associate specific error messages with particular fields or paths. This enhances error reporting and is especially useful when integrating with libraries like <a href="https://react-hook-form.com/">react-hook-form</a>.</p>
<p><strong>Example</strong> (Matching Passwords)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Password = Schema.Trim.pipe(Schema.minLength(2))

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password
}).pipe(
  // Add a filter to ensure that passwords match
  Schema.filter((input) =&gt; {
    if (input.password !== input.confirm_password) {
      // Return an error message associated
      // with the &quot;confirm_password&quot; field
      return {
        path: [&quot;confirm_password&quot;],
        message: &quot;Passwords do not match&quot;
      }
    }
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: &quot;abc&quot;,
      confirm_password: &quot;abd&quot; // Confirm password does not match
    }).pipe(
      Either.mapLeft((error) =&gt;
        ParseResult.ArrayFormatter.formatErrorSync(error)
      )
    ),
    null,
    2
  )
)
/*
  &quot;_id&quot;: &quot;Either&quot;,
  &quot;_tag&quot;: &quot;Left&quot;,
  &quot;left&quot;: [
    {
      &quot;_tag&quot;: &quot;Type&quot;,
      &quot;path&quot;: [
        &quot;confirm_password&quot;
      ],
      &quot;message&quot;: &quot;Passwords do not match&quot;
    }
  ]
}
*/
</code></pre>
<p>In this example, we define a <code>MyForm</code> schema with two password fields (<code>password</code> and <code>confirm_password</code>). We use <code>Schema.filter</code> to check that both passwords match. If they don&#39;t, an error message is returned, specifically associated with the <code>confirm_password</code> field. This makes it easier to pinpoint the exact location of the validation failure.</p>
<p>The error is formatted in a structured way using <code>ArrayFormatter</code>, allowing for easier post-processing and integration with form libraries.</p>
<Aside type="tip" title="Using ArrayFormatter for Structured Errors">
  The `ArrayFormatter` provides a detailed and structured error format
  rather than a simple error string. This is especially useful when
  handling complex forms or structured data. For more information, see
  [ArrayFormatter](/docs/schema/error-formatters/#arrayformatter).
</Aside>

<h2>Multiple Error Reporting</h2>
<p>The <code>Schema.filter</code> API supports reporting multiple validation issues at once, which is especially useful in scenarios like form validation where several checks might fail simultaneously.</p>
<p><strong>Example</strong> (Reporting Multiple Validation Errors)</p>
<pre><code class="language-ts">import { Either, Schema, ParseResult } from &quot;effect&quot;

const Password = Schema.Trim.pipe(Schema.minLength(2))
const OptionalString = Schema.optional(Schema.String)

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password,
  name: OptionalString,
  surname: OptionalString
}).pipe(
  Schema.filter((input) =&gt; {
    const issues: Array&lt;Schema.FilterIssue&gt; = []

    // Check if passwords match
    if (input.password !== input.confirm_password) {
      issues.push({
        path: [&quot;confirm_password&quot;],
        message: &quot;Passwords do not match&quot;
      })
    }

    // Ensure either name or surname is present
    if (!input.name &amp;&amp; !input.surname) {
      issues.push({
        path: [&quot;surname&quot;],
        message: &quot;Surname must be present if name is not present&quot;
      })
    }
    return issues
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: &quot;abc&quot;,
      confirm_password: &quot;abd&quot; // Confirm password does not match
    }).pipe(
      Either.mapLeft((error) =&gt;
        ParseResult.ArrayFormatter.formatErrorSync(error)
      )
    ),
    null,
    2
  )
)
/*
{
  &quot;_id&quot;: &quot;Either&quot;,
  &quot;_tag&quot;: &quot;Left&quot;,
  &quot;left&quot;: [
    {
      &quot;_tag&quot;: &quot;Type&quot;,
      &quot;path&quot;: [
        &quot;confirm_password&quot;
      ],
      &quot;message&quot;: &quot;Passwords do not match&quot;
    },
    {
      &quot;_tag&quot;: &quot;Type&quot;,
      &quot;path&quot;: [
        &quot;surname&quot;
      ],
      &quot;message&quot;: &quot;Surname must be present if name is not present&quot;
    }
  ]
}
*/
</code></pre>
<p>In this example, we define a <code>MyForm</code> schema with fields for password validation and optional name/surname fields. The <code>Schema.filter</code> function checks if the passwords match and ensures that either a name or surname is provided. If either validation fails, the corresponding error message is associated with the relevant field and both errors are returned in a structured format.</p>
<Aside type="tip" title="Using ArrayFormatter for Structured Errors">
  The `ArrayFormatter` provides a detailed and structured error format
  rather than a simple error string. This is especially useful when
  handling complex forms or structured data. For more information, see
  [ArrayFormatter](/docs/schema/error-formatters/#arrayformatter).
</Aside>

<h2>Exposed Values</h2>
<p>For schemas with filters, you can access the base schema (the schema before the filter was applied) using the <code>from</code> property:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const LongString = Schema.String.pipe(
  Schema.filter((s) =&gt; s.length &gt;= 10)
)

// Access the base schema, which is the string schema
// before the filter was applied
//
//      ┌─── typeof Schema.String
//      ▼
const From = LongString.from
</code></pre>
<h2>Built-in Filters</h2>
<h3>String Filters</h3>
<p>Here is a list of useful string filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies maximum length of a string
Schema.String.pipe(Schema.maxLength(5))

// Specifies minimum length of a string
Schema.String.pipe(Schema.minLength(5))

// Equivalent to minLength(1)
Schema.String.pipe(Schema.nonEmptyString())
// or
Schema.NonEmptyString

// Specifies exact length of a string
Schema.String.pipe(Schema.length(5))

// Specifies a range for the length of a string
Schema.String.pipe(Schema.length({ min: 2, max: 4 }))

// Matches a string against a regular expression pattern
Schema.String.pipe(Schema.pattern(/^[a-z]+$/))

// Ensures a string starts with a specific substring
Schema.String.pipe(Schema.startsWith(&quot;prefix&quot;))

// Ensures a string ends with a specific substring
Schema.String.pipe(Schema.endsWith(&quot;suffix&quot;))

// Checks if a string includes a specific substring
Schema.String.pipe(Schema.includes(&quot;substring&quot;))

// Validates that a string has no leading or trailing whitespaces
Schema.String.pipe(Schema.trimmed())

// Validates that a string is entirely in lowercase
Schema.String.pipe(Schema.lowercased())

// Validates that a string is entirely in uppercase
Schema.String.pipe(Schema.uppercased())

// Validates that a string is capitalized
Schema.String.pipe(Schema.capitalized())

// Validates that a string is uncapitalized
Schema.String.pipe(Schema.uncapitalized())
</code></pre>
<Aside type="tip" title="Trim vs Trimmed">
  The `trimmed` combinator does not make any transformations, it only
  validates. If what you were looking for was a combinator to trim
  strings, then check out the `trim` combinator or the `Trim` schema.
</Aside>

<h3>Number Filters</h3>
<p>Here is a list of useful number filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies a number greater than 5
Schema.Number.pipe(Schema.greaterThan(5))

// Specifies a number greater than or equal to 5
Schema.Number.pipe(Schema.greaterThanOrEqualTo(5))

// Specifies a number less than 5
Schema.Number.pipe(Schema.lessThan(5))

// Specifies a number less than or equal to 5
Schema.Number.pipe(Schema.lessThanOrEqualTo(5))

// Specifies a number between -2 and 2, inclusive
Schema.Number.pipe(Schema.between(-2, 2))

// Specifies that the value must be an integer
Schema.Number.pipe(Schema.int())
// or
Schema.Int

// Ensures the value is not NaN
Schema.Number.pipe(Schema.nonNaN())
// or
Schema.NonNaN

// Ensures that the provided value is a finite number
// (excluding NaN, +Infinity, and -Infinity)
Schema.Number.pipe(Schema.finite())
// or
Schema.Finite

// Specifies a positive number (&gt; 0)
Schema.Number.pipe(Schema.positive())
// or
Schema.Positive

// Specifies a non-negative number (&gt;= 0)
Schema.Number.pipe(Schema.nonNegative())
// or
Schema.NonNegative

// A non-negative integer
Schema.NonNegativeInt

// Specifies a negative number (&lt; 0)
Schema.Number.pipe(Schema.negative())
// or
Schema.Negative

// Specifies a non-positive number (&lt;= 0)
Schema.Number.pipe(Schema.nonPositive())
// or
Schema.NonPositive

// Specifies a number that is evenly divisible by 5
Schema.Number.pipe(Schema.multipleOf(5))

// A 8-bit unsigned integer (0 to 255)
Schema.Uint8
</code></pre>
<h3>ReadonlyArray Filters</h3>
<p>Here is a list of useful array filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies the maximum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.maxItems(2))

// Specifies the minimum number of items in the array
Schema.Array(Schema.Number).pipe(Schema.minItems(2))

// Specifies the exact number of items in the array
Schema.Array(Schema.Number).pipe(Schema.itemsCount(2))
</code></pre>
<h3>Date Filters</h3>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies a valid date (rejects values like `new Date(&quot;Invalid Date&quot;)`)
Schema.DateFromSelf.pipe(Schema.validDate())
// or
Schema.ValidDateFromSelf

// Specifies a date greater than the current date
Schema.Date.pipe(Schema.greaterThanDate(new Date()))

// Specifies a date greater than or equal to the current date
Schema.Date.pipe(Schema.greaterThanOrEqualToDate(new Date()))

// Specifies a date less than the current date
Schema.Date.pipe(Schema.lessThanDate(new Date()))

// Specifies a date less than or equal to the current date
Schema.Date.pipe(Schema.lessThanOrEqualToDate(new Date()))

// Specifies a date between two dates
Schema.Date.pipe(Schema.betweenDate(new Date(0), new Date()))
</code></pre>
<h3>BigInt Filters</h3>
<p>Here is a list of useful <code>BigInt</code> filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies a BigInt greater than 5
Schema.BigInt.pipe(Schema.greaterThanBigInt(5n))

// Specifies a BigInt greater than or equal to 5
Schema.BigInt.pipe(Schema.greaterThanOrEqualToBigInt(5n))

// Specifies a BigInt less than 5
Schema.BigInt.pipe(Schema.lessThanBigInt(5n))

// Specifies a BigInt less than or equal to 5
Schema.BigInt.pipe(Schema.lessThanOrEqualToBigInt(5n))

// Specifies a BigInt between -2n and 2n, inclusive
Schema.BigInt.pipe(Schema.betweenBigInt(-2n, 2n))

// Specifies a positive BigInt (&gt; 0n)
Schema.BigInt.pipe(Schema.positiveBigInt())
// or
Schema.PositiveBigIntFromSelf

// Specifies a non-negative BigInt (&gt;= 0n)
Schema.BigInt.pipe(Schema.nonNegativeBigInt())
// or
Schema.NonNegativeBigIntFromSelf

// Specifies a negative BigInt (&lt; 0n)
Schema.BigInt.pipe(Schema.negativeBigInt())
// or
Schema.NegativeBigIntFromSelf

// Specifies a non-positive BigInt (&lt;= 0n)
Schema.BigInt.pipe(Schema.nonPositiveBigInt())
// or
Schema.NonPositiveBigIntFromSelf
</code></pre>
<h3>BigDecimal Filters</h3>
<p>Here is a list of useful <code>BigDecimal</code> filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema, BigDecimal } from &quot;effect&quot;

// Specifies a BigDecimal greater than 5
Schema.BigDecimal.pipe(
  Schema.greaterThanBigDecimal(BigDecimal.unsafeFromNumber(5))
)

// Specifies a BigDecimal greater than or equal to 5
Schema.BigDecimal.pipe(
  Schema.greaterThanOrEqualToBigDecimal(BigDecimal.unsafeFromNumber(5))
)
// Specifies a BigDecimal less than 5
Schema.BigDecimal.pipe(
  Schema.lessThanBigDecimal(BigDecimal.unsafeFromNumber(5))
)

// Specifies a BigDecimal less than or equal to 5
Schema.BigDecimal.pipe(
  Schema.lessThanOrEqualToBigDecimal(BigDecimal.unsafeFromNumber(5))
)

// Specifies a BigDecimal between -2 and 2, inclusive
Schema.BigDecimal.pipe(
  Schema.betweenBigDecimal(
    BigDecimal.unsafeFromNumber(-2),
    BigDecimal.unsafeFromNumber(2)
  )
)

// Specifies a positive BigDecimal (&gt; 0)
Schema.BigDecimal.pipe(Schema.positiveBigDecimal())

// Specifies a non-negative BigDecimal (&gt;= 0)
Schema.BigDecimal.pipe(Schema.nonNegativeBigDecimal())

// Specifies a negative BigDecimal (&lt; 0)
Schema.BigDecimal.pipe(Schema.negativeBigDecimal())

// Specifies a non-positive BigDecimal (&lt;= 0)
Schema.BigDecimal.pipe(Schema.nonPositiveBigDecimal())
</code></pre>
<h3>Duration Filters</h3>
<p>Here is a list of useful <a href="/docs/data-types/duration/">Duration</a> filters provided by the Schema module:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Specifies a duration greater than 5 seconds
Schema.Duration.pipe(Schema.greaterThanDuration(&quot;5 seconds&quot;))

// Specifies a duration greater than or equal to 5 seconds
Schema.Duration.pipe(Schema.greaterThanOrEqualToDuration(&quot;5 seconds&quot;))

// Specifies a duration less than 5 seconds
Schema.Duration.pipe(Schema.lessThanDuration(&quot;5 seconds&quot;))

// Specifies a duration less than or equal to 5 seconds
Schema.Duration.pipe(Schema.lessThanOrEqualToDuration(&quot;5 seconds&quot;))

// Specifies a duration between 5 seconds and 10 seconds, inclusive
Schema.Duration.pipe(Schema.betweenDuration(&quot;5 seconds&quot;, &quot;10 seconds&quot;))
</code></pre>
<hr>
<hr>
<h2>title: Getting Started
description: Learn how to define schemas, extract types, and handle decoding and encoding.
sidebar:
  order: 2</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>You can import the necessary types and functions from the <code>effect/Schema</code> module:</p>
<p><strong>Example</strong> (Namespace Import)</p>
<pre><code class="language-ts">import * as Schema from &quot;effect/Schema&quot;
</code></pre>
<p><strong>Example</strong> (Named Import)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
</code></pre>
<h2>Defining a schema</h2>
<p>One common way to define a <code>Schema</code> is by utilizing the <code>Struct</code> constructor.
This constructor allows you to create a new schema that outlines an object with specific properties.
Each property in the object is defined by its own schema, which specifies the data type and any validation rules.</p>
<p><strong>Example</strong> (Defining a Simple Object Schema)</p>
<p>This <code>Person</code> schema describes an object with a <code>name</code> (string) and <code>age</code> (number) property:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})
</code></pre>
<h2>Extracting Inferred Types</h2>
<h3>Type</h3>
<p>Once you&#39;ve defined a schema (<code>Schema&lt;Type, Encoded, Context&gt;</code>), you can extract the inferred type <code>Type</code> in two ways:</p>
<ol>
<li>Using the <code>Schema.Type</code> utility</li>
<li>Accessing the <code>Type</code> field directly on your schema</li>
</ol>
<p><strong>Example</strong> (Extracting Inferred Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// 1. Using the Schema.Type utility
type Person = Schema.Schema.Type&lt;typeof Person&gt;

// 2. Accessing the Type field directly
type Person2 = typeof Person.Type
</code></pre>
<p>The resulting type will look like this:</p>
<pre><code class="language-ts">type Person = {
  readonly name: string
  readonly age: number
}
</code></pre>
<p>Alternatively, you can extract the <code>Person</code> type using the <code>interface</code> keyword, which may improve readability and performance in some cases.</p>
<p><strong>Example</strong> (Extracting Type with an Interface)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

interface Person extends Schema.Schema.Type&lt;typeof Person&gt; {}
</code></pre>
<p>Both approaches yield the same result, but using an interface provides benefits such as performance advantages and improved readability.</p>
<h3>Encoded</h3>
<p>In a <code>Schema&lt;Type, Encoded, Context&gt;</code>, the <code>Encoded</code> type can differ from the <code>Type</code> type, representing the format in which data is encoded. You can extract the <code>Encoded</code> type in two ways:</p>
<ol>
<li>Using the <code>Schema.Encoded</code> utility</li>
<li>Accessing the <code>Encoded</code> field directly on the schema</li>
</ol>
<p><strong>Example</strong> (Extracting the Encoded Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  // a schema that decodes a string to a number
  age: Schema.NumberFromString
})

// 1. Using the Schema.Encoded utility
type PersonEncoded = Schema.Schema.Encoded&lt;typeof Person&gt;

// 2. Accessing the Encoded field directly
type PersonEncoded2 = typeof Person.Encoded
</code></pre>
<p>The resulting type is:</p>
<pre><code class="language-ts">type PersonEncoded = {
  readonly name: string
  readonly age: string
}
</code></pre>
<p>Note that <code>age</code> is of type <code>string</code> in the <code>Encoded</code> type of the schema and is of type <code>number</code> in the <code>Type</code> type of the schema.</p>
<p>Alternatively, you can define the <code>PersonEncoded</code> type using the <code>interface</code> keyword, which can enhance readability and performance.</p>
<p><strong>Example</strong> (Extracting Encoded Type with an Interface)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  // a schema that decodes a string to a number
  age: Schema.NumberFromString
})

interface PersonEncoded extends Schema.Schema.Encoded&lt;typeof Person&gt; {}
</code></pre>
<p>Both approaches yield the same result, but using an interface provides benefits such as performance advantages and improved readability.</p>
<h3>Context</h3>
<p>In a <code>Schema&lt;Type, Encoded, Context&gt;</code>, the <code>Context</code> type represents any external data or dependencies that the schema requires to perform encoding or decoding. You can extract the inferred <code>Context</code> type in two ways:</p>
<ol>
<li>Using the <code>Schema.Context</code> utility.</li>
<li>Accessing the <code>Context</code> field on the schema.</li>
</ol>
<p><strong>Example</strong> (Extracting the Context Type)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// 1. Using the Schema.Context utility
type PersonContext = Schema.Schema.Context&lt;typeof Person&gt;

// 2. Accessing the Context field directly
type PersonContext2 = typeof Person.Context
</code></pre>
<h3>Schemas with Opaque Types</h3>
<p>When defining a schema, you may want to create a schema with an opaque type. This is useful when you want to hide the internal structure of the schema and only expose the type of the schema.</p>
<p><strong>Example</strong> (Creating an Opaque Schema)</p>
<p>To create a schema with an opaque type, you can use the following technique that re-declares the schema:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define the schema structure
const _Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Declare the type interface to make it opaque
interface Person extends Schema.Schema.Type&lt;typeof _Person&gt; {}

// Re-declare the schema as opaque
const Person: Schema.Schema&lt;Person&gt; = _Person
</code></pre>
<p>Alternatively, you can use the Class APIs (see the <a href="/docs/schema/classes/">Class APIs</a> section for more details).</p>
<p>Note that the technique shown above becomes more complex when the schema is defined such that <code>Type</code> is different from <code>Encoded</code>.</p>
<p><strong>Example</strong> (Opaque Schema with Different Type and Encoded)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define the schema structure, with a field that
// decodes a string to a number
const _Person = Schema.Struct({
  name: Schema.String,
  age: Schema.NumberFromString
})

// Create the `Type` interface for an opaque schema
interface Person extends Schema.Schema.Type&lt;typeof _Person&gt; {}

// Create the `Encoded` interface for an opaque schema
interface PersonEncoded extends Schema.Schema.Encoded&lt;typeof _Person&gt; {}

// Re-declare the schema with opaque Type and Encoded
const Person: Schema.Schema&lt;Person, PersonEncoded&gt; = _Person
</code></pre>
<p>In this case, the field <code>&quot;age&quot;</code> is of type <code>string</code> in the <code>Encoded</code> type of the schema and is of type <code>number</code> in the <code>Type</code> type of the schema. Therefore, we need to define <strong>two</strong> interfaces (<code>PersonEncoded</code> and <code>Person</code>) and use both to redeclare our final schema <code>Person</code>.</p>
<h2>Readonly Types by Default</h2>
<p>It&#39;s important to note that by default, most constructors exported by
<code>effect/Schema</code> return <code>readonly</code> types.</p>
<p><strong>Example</strong> (Readonly Types in a Schema)</p>
<p>For instance, in the <code>Person</code> schema below:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})
</code></pre>
<p>the resulting inferred <code>Type</code> would be:</p>
<pre><code class="language-ts">{
  readonly name: string;
  readonly age: number;
}
</code></pre>
<h2>Decoding</h2>
<p>When working with unknown data types in TypeScript, decoding them into a known structure can be challenging. Luckily, <code>effect/Schema</code> provides several functions to help with this process. Let&#39;s explore how to decode unknown values using these functions.</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>decodeUnknownSync</code></td>
<td>Synchronously decodes a value and throws an error if parsing fails.</td>
</tr>
<tr>
<td><code>decodeUnknownOption</code></td>
<td>Decodes a value and returns an <a href="/docs/data-types/option/">Option</a> type.</td>
</tr>
<tr>
<td><code>decodeUnknownEither</code></td>
<td>Decodes a value and returns an <a href="/docs/data-types/either/">Either</a> type.</td>
</tr>
<tr>
<td><code>decodeUnknownPromise</code></td>
<td>Decodes a value and returns a <code>Promise</code>.</td>
</tr>
<tr>
<td><code>decodeUnknown</code></td>
<td>Decodes a value and returns an <a href="/docs/getting-started/the-effect-type/">Effect</a>.</td>
</tr>
</tbody></table>
<h3>decodeUnknownSync</h3>
<p>The <code>Schema.decodeUnknownSync</code> function is useful when you want to parse a value and immediately throw an error if the parsing fails.</p>
<p><strong>Example</strong> (Using <code>decodeUnknownSync</code> for Immediate Decoding)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Simulate an unknown input
const input: unknown = { name: &quot;Alice&quot;, age: 30 }

// Example of valid input matching the schema
console.log(Schema.decodeUnknownSync(Person)(input))
// Output: { name: &#39;Alice&#39;, age: 30 }

// Example of invalid input that does not match the schema
console.log(Schema.decodeUnknownSync(Person)(null))
/*
throws:
ParseError: Expected { readonly name: string; readonly age: number }, actual null
*/
</code></pre>
<h3>decodeUnknownEither</h3>
<p>The <code>Schema.decodeUnknownEither</code> function allows you to parse a value and receive the result as an <a href="/docs/data-types/either/">Either</a>, representing success (<code>Right</code>) or failure (<code>Left</code>). This approach lets you handle parsing errors more gracefully without throwing exceptions.</p>
<p><strong>Example</strong> (Using <code>Schema.decodeUnknownEither</code> for Error Handling)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Either } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const decode = Schema.decodeUnknownEither(Person)

// Simulate an unknown input
const input: unknown = { name: &quot;Alice&quot;, age: 30 }

// Attempt decoding a valid input
const result1 = decode(input)
if (Either.isRight(result1)) {
  console.log(result1.right)
  /*
  Output:
  { name: &quot;Alice&quot;, age: 30 }
  */
}

// Simulate decoding an invalid input
const result2 = decode(null)
if (Either.isLeft(result2)) {
  console.log(result2.left)
  /*
  Output:
  {
    _id: &#39;ParseError&#39;,
    message: &#39;Expected { readonly name: string; readonly age: number }, actual null&#39;
  }
  */
}
</code></pre>
<h3>decodeUnknown</h3>
<p>If your schema involves asynchronous transformations, the <code>Schema.decodeUnknownSync</code> and <code>Schema.decodeUnknownEither</code> functions will not be suitable.
In such cases, you should use the <code>Schema.decodeUnknown</code> function, which returns an <a href="/docs/getting-started/the-effect-type/">Effect</a>.</p>
<p><strong>Example</strong> (Handling Asynchronous Decoding)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Effect } from &quot;effect&quot;

const PersonId = Schema.Number

const Person = Schema.Struct({
  id: PersonId,
  name: Schema.String,
  age: Schema.Number
})

const asyncSchema = Schema.transformOrFail(PersonId, Person, {
  strict: true,
  // Decode with simulated async transformation
  decode: (id) =&gt;
    Effect.succeed({ id, name: &quot;name&quot;, age: 18 }).pipe(
      Effect.delay(&quot;10 millis&quot;)
    ),
  encode: (person) =&gt;
    Effect.succeed(person.id).pipe(Effect.delay(&quot;10 millis&quot;))
})

// Attempting to use a synchronous decoder on an async schema
console.log(Schema.decodeUnknownEither(asyncSchema)(1))
/*
Output:
{
  _id: &#39;Either&#39;,
  _tag: &#39;Left&#39;,
  left: {
    _id: &#39;ParseError&#39;,
    message: &#39;(number &lt;-&gt; { readonly id: number; readonly name: string; readonly age: number })\n&#39; +
      &#39;└─ cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work&#39;
  }
}
*/

// Decoding asynchronously with `Schema.decodeUnknown`
Effect.runPromise(Schema.decodeUnknown(asyncSchema)(1)).then(console.log)
/*
Output:
{ id: 1, name: &#39;name&#39;, age: 18 }
*/
</code></pre>
<p>In the code above, the first approach using <code>Schema.decodeUnknownEither</code> results in an error indicating that the transformation cannot be resolved synchronously.
This occurs because <code>Schema.decodeUnknownEither</code> is not designed for async operations.
The second approach, which uses <code>Schema.decodeUnknown</code>, works correctly, allowing you to handle asynchronous transformations and return the expected result.</p>
<h2>Encoding</h2>
<p>The <code>Schema</code> module provides several <code>encode*</code> functions to encode data according to a schema:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>encodeSync</code></td>
<td>Synchronously encodes data and throws an error if encoding fails.</td>
</tr>
<tr>
<td><code>encodeOption</code></td>
<td>Encodes data and returns an <a href="/docs/data-types/option/">Option</a> type.</td>
</tr>
<tr>
<td><code>encodeEither</code></td>
<td>Encodes data and returns an <a href="/docs/data-types/either/">Either</a> type representing success or failure.</td>
</tr>
<tr>
<td><code>encodePromise</code></td>
<td>Encodes data and returns a <code>Promise</code>.</td>
</tr>
<tr>
<td><code>encode</code></td>
<td>Encodes data and returns an <a href="/docs/getting-started/the-effect-type/">Effect</a>.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>Schema.encodeSync</code> for Immediate Encoding)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  // Ensure name is a non-empty string
  name: Schema.NonEmptyString,
  // Allow age to be decoded from a string and encoded to a string
  age: Schema.NumberFromString
})

// Valid input: encoding succeeds and returns expected types
console.log(Schema.encodeSync(Person)({ name: &quot;Alice&quot;, age: 30 }))
// Output: { name: &#39;Alice&#39;, age: &#39;30&#39; }

// Invalid input: encoding fails due to empty name string
console.log(Schema.encodeSync(Person)({ name: &quot;&quot;, age: 30 }))
/*
throws:
ParseError: { readonly name: NonEmptyString; readonly age: NumberFromString }
└─ [&quot;name&quot;]
   └─ NonEmptyString
      └─ Predicate refinement failure
         └─ Expected a non empty string, actual &quot;&quot;
*/
</code></pre>
<p>Note that during encoding, the number value <code>30</code> was converted to a string <code>&quot;30&quot;</code>.</p>
<h3>Handling Unsupported Encoding</h3>
<p>In certain cases, it may not be feasible to support encoding for a schema. While it is generally advised to define schemas that allow both decoding and encoding, there are situations where encoding a particular type is either unsupported or unnecessary. In these instances, the <code>Forbidden</code> issue can signal that encoding is not available for certain values.</p>
<p><strong>Example</strong> (Using <code>Forbidden</code> to Indicate Unsupported Encoding)</p>
<p>Here is an example of a transformation that never fails during decoding. It returns an <a href="/docs/data-types/either/">Either</a> containing either the decoded value or the original input. For encoding, it is reasonable to not support it and use <code>Forbidden</code> as the result.</p>
<pre><code class="language-ts">import { Either, ParseResult, Schema } from &quot;effect&quot;

// Define a schema that safely decodes to Either type
export const SafeDecode = &lt;A, I&gt;(self: Schema.Schema&lt;A, I, never&gt;) =&gt; {
  const decodeUnknownEither = Schema.decodeUnknownEither(self)
  return Schema.transformOrFail(
    Schema.Unknown,
    Schema.EitherFromSelf({
      left: Schema.Unknown,
      right: Schema.typeSchema(self)
    }),
    {
      strict: true,
      // Decode: map a failed result to the input as Left,
      // successful result as Right
      decode: (input) =&gt;
        ParseResult.succeed(
          Either.mapLeft(decodeUnknownEither(input), () =&gt; input)
        ),
      // Encode: only support encoding Right values,
      // Left values raise Forbidden error
      encode: (actual, _, ast) =&gt;
        Either.match(actual, {
          onLeft: () =&gt;
            ParseResult.fail(
              new ParseResult.Forbidden(
                ast,
                actual,
                &quot;cannot encode a Left&quot;
              )
            ),
          // Successfully encode a Right value
          onRight: ParseResult.succeed
        })
    }
  )
}
</code></pre>
<p><strong>Explanation</strong></p>
<ul>
<li><strong>Decoding</strong>: The <code>SafeDecode</code> function ensures that decoding never fails. It wraps the decoded value in an <a href="/docs/data-types/either/">Either</a>, where a successful decoding results in a <code>Right</code> and a failed decoding results in a <code>Left</code> containing the original input.</li>
<li><strong>Encoding</strong>: The encoding process uses the <code>Forbidden</code> error to indicate that encoding a <code>Left</code> value is not supported. Only <code>Right</code> values are successfully encoded.</li>
</ul>
<h2>ParseError</h2>
<p>The <code>Schema.decodeUnknownEither</code> and <code>Schema.encodeEither</code> functions returns a <a href="/docs/data-types/either/">Either</a>:</p>
<pre><code class="language-ts">Either&lt;Type, ParseError&gt;
</code></pre>
<p>where <code>ParseError</code> is defined as follows (simplified):</p>
<pre><code class="language-ts">interface ParseError {
  readonly _tag: &quot;ParseError&quot;
  readonly issue: ParseIssue
}
</code></pre>
<p>In this structure, <code>ParseIssue</code> represents an error that might occur during the parsing process.
It is wrapped in a tagged error to make it easier to catch errors using <a href="/docs/error-management/expected-errors/#catchtag">Effect.catchTag</a>.
The result <code>Either&lt;Type, ParseError&gt;</code> contains the inferred data type described by the schema (<code>Type</code>).
A successful parse yields a <code>Right</code> value with the parsed data <code>Type</code>, while a failed parse results in a <code>Left</code> value containing a <code>ParseError</code>.</p>
<Aside type="tip" title="Returning All Errors">
  By default only the first error is returned. You can use the
  [`errors`](#receive-all-errors) option to receive all errors.
</Aside>

<h2>Parse Options</h2>
<p>The options below provide control over both decoding and encoding behaviors.</p>
<h3>Managing Excess properties</h3>
<p>By default, any properties not defined in the schema are removed from the output when parsing a value. This ensures the parsed data conforms strictly to the expected structure.</p>
<p>If you want to detect and handle unexpected properties, use the <code>onExcessProperty</code> option (default value: <code>&quot;ignore&quot;</code>), which allows you to raise an error for excess properties. This can be helpful when you need to validate and catch unanticipated properties.</p>
<p><strong>Example</strong> (Setting <code>onExcessProperty</code> to <code>&quot;error&quot;</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Excess properties are ignored by default
console.log(
  Schema.decodeUnknownSync(Person)({
    name: &quot;Bob&quot;,
    age: 40,
    email: &quot;bob@example.com&quot; // Ignored
  })
)
/*
Output:
{ name: &#39;Bob&#39;, age: 40 }
*/

// With `onExcessProperty` set to &quot;error&quot;,
// an error is thrown for excess properties
Schema.decodeUnknownSync(Person)(
  {
    name: &quot;Bob&quot;,
    age: 40,
    email: &quot;bob@example.com&quot; // Will raise an error
  },
  { onExcessProperty: &quot;error&quot; }
)
/*
throws
ParseError: { readonly name: string; readonly age: number }
└─ [&quot;email&quot;]
   └─ is unexpected, expected: &quot;name&quot; | &quot;age&quot;
*/
</code></pre>
<p>To retain extra properties, set <code>onExcessProperty</code> to <code>&quot;preserve&quot;</code>.</p>
<p><strong>Example</strong> (Setting <code>onExcessProperty</code> to <code>&quot;preserve&quot;</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Excess properties are preserved in the output
console.log(
  Schema.decodeUnknownSync(Person)(
    {
      name: &quot;Bob&quot;,
      age: 40,
      email: &quot;bob@example.com&quot;
    },
    { onExcessProperty: &quot;preserve&quot; }
  )
)
/*
{ email: &#39;bob@example.com&#39;, name: &#39;Bob&#39;, age: 40 }
*/
</code></pre>
<h3>Receive all errors</h3>
<p>The <code>errors</code> option enables you to retrieve all errors encountered during parsing. By default, only the first error is returned. Setting <code>errors</code> to <code>&quot;all&quot;</code> provides comprehensive error feedback, which can be useful for debugging or offering detailed validation feedback.</p>
<p><strong>Example</strong> (Setting <code>errors</code> to <code>&quot;all&quot;</code>)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Attempt to parse with multiple issues in the input data
Schema.decodeUnknownSync(Person)(
  {
    name: &quot;Bob&quot;,
    age: &quot;abc&quot;,
    email: &quot;bob@example.com&quot;
  },
  { errors: &quot;all&quot;, onExcessProperty: &quot;error&quot; }
)
/*
throws
ParseError: { readonly name: string; readonly age: number }
├─ [&quot;email&quot;]
│  └─ is unexpected, expected: &quot;name&quot; | &quot;age&quot;
└─ [&quot;age&quot;]
   └─ Expected number, actual &quot;abc&quot;
*/
</code></pre>
<h3>Managing Property Order</h3>
<p>The <code>propertyOrder</code> option provides control over the order of object fields in the output. This feature is particularly useful when the sequence of keys is important for the consuming processes or when maintaining the input order enhances readability and usability.</p>
<p>By default, the <code>propertyOrder</code> option is set to <code>&quot;none&quot;</code>. This means that the internal system decides the order of keys to optimize parsing speed.
The order of keys in this mode should not be considered stable, and it&#39;s recommended not to rely on key ordering as it may change in future updates.</p>
<p>Setting <code>propertyOrder</code> to <code>&quot;original&quot;</code> ensures that the keys are ordered as they appear in the input during the decoding/encoding process.</p>
<p><strong>Example</strong> (Synchronous Decoding)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  a: Schema.Number,
  b: Schema.Literal(&quot;b&quot;),
  c: Schema.Number
})

// Default decoding, where property order is system-defined
console.log(Schema.decodeUnknownSync(schema)({ b: &quot;b&quot;, c: 2, a: 1 }))
// Output may vary: { a: 1, b: &#39;b&#39;, c: 2 }

// Decoding while preserving input order
console.log(
  Schema.decodeUnknownSync(schema)(
    { b: &quot;b&quot;, c: 2, a: 1 },
    { propertyOrder: &quot;original&quot; }
  )
)
// Output preserves input order: { b: &#39;b&#39;, c: 2, a: 1 }
</code></pre>
<p><strong>Example</strong> (Asynchronous Decoding)</p>
<pre><code class="language-ts">import type { Duration } from &quot;effect&quot;
import { Effect, ParseResult, Schema } from &quot;effect&quot;

// Helper function to simulate an async operation in schema
const effectify = (duration: Duration.DurationInput) =&gt;
  Schema.Number.pipe(
    Schema.transformOrFail(Schema.Number, {
      strict: true,
      decode: (x) =&gt;
        Effect.sleep(duration).pipe(
          Effect.andThen(ParseResult.succeed(x))
        ),
      encode: ParseResult.succeed
    })
  )

// Define a structure with asynchronous behavior in each field
const schema = Schema.Struct({
  a: effectify(&quot;200 millis&quot;),
  b: effectify(&quot;300 millis&quot;),
  c: effectify(&quot;100 millis&quot;)
}).annotations({ concurrency: 3 })

// Default decoding, where property order is system-defined
Schema.decode(schema)({ a: 1, b: 2, c: 3 })
  .pipe(Effect.runPromise)
  .then(console.log)
// Output decided internally: { c: 3, a: 1, b: 2 }

// Decoding while preserving input order
Schema.decode(schema)({ a: 1, b: 2, c: 3 }, { propertyOrder: &quot;original&quot; })
  .pipe(Effect.runPromise)
  .then(console.log)
// Output preserving input order: { a: 1, b: 2, c: 3 }
</code></pre>
<h3>Customizing Parsing Behavior at the Schema Level</h3>
<p>The <code>parseOptions</code> annotation allows you to customize parsing behavior at different schema levels, enabling you to apply unique parsing settings to nested schemas within a structure. Options defined within a schema override parent-level settings and apply to all nested schemas.</p>
<p><strong>Example</strong> (Using <code>parseOptions</code> to Customize Error Handling)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { Either } from &quot;effect&quot;

const schema = Schema.Struct({
  a: Schema.Struct({
    b: Schema.String,
    c: Schema.String
  }).annotations({
    title: &quot;first error only&quot;,
    // Limit errors to the first in this sub-schema
    parseOptions: { errors: &quot;first&quot; }
  }),
  d: Schema.String
}).annotations({
  title: &quot;all errors&quot;,
  // Capture all errors for the main schema
  parseOptions: { errors: &quot;all&quot; }
})

// Decode input with custom error-handling behavior
const result = Schema.decodeUnknownEither(schema)(
  { a: {} },
  { errors: &quot;first&quot; }
)
if (Either.isLeft(result)) {
  console.log(result.left.message)
}
/*
all errors
├─ [&quot;a&quot;]
│  └─ first error only
│     └─ [&quot;b&quot;]
│        └─ is missing
└─ [&quot;d&quot;]
   └─ is missing
*/
</code></pre>
<p><strong>Detailed Output Explanation:</strong></p>
<p>In this example:</p>
<ul>
<li>The main schema is configured to display all errors. Hence, you will see errors related to both the <code>d</code> field (since it&#39;s missing) and any errors from the <code>a</code> subschema.</li>
<li>The subschema (<code>a</code>) is set to display only the first error. Although both <code>b</code> and <code>c</code> fields are missing, only the first missing field (<code>b</code>) is reported.</li>
</ul>
<h2>Type Guards</h2>
<p>The <code>Schema.is</code> function provides a way to verify if a value conforms to a given schema. It acts as a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type guard</a>, taking a value of type <code>unknown</code> and determining if it matches the structure and type constraints defined in the schema.</p>
<p>Here&#39;s how the <code>Schema.is</code> function works:</p>
<ol>
<li><p><strong>Schema Definition</strong>: Define a schema to describe the structure and constraints of the data type you expect. For instance, <code>Schema&lt;Type, Encoded, Context&gt;</code>, where <code>Type</code> is the target type you want to validate against.</p>
</li>
<li><p><strong>Type Guard Creation</strong>: Use the schema to create a user-defined type guard, <code>(u: unknown) =&gt; u is Type</code>. This function can be used at runtime to check if a value meets the requirements of the schema.</p>
</li>
</ol>
<Aside type="note" title="Role of the Encoded Type in Type Guards">
  The type `Encoded`, which is often used in schema transformations, does
  not affect the creation of the type guard. The main purpose is to ensure
  that the input matches the desired type `Type`.
</Aside>

<p><strong>Example</strong> (Creating and Using a Type Guard)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for a Person object
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Generate a type guard from the schema
const isPerson = Schema.is(Person)

// Test the type guard with various inputs
console.log(isPerson({ name: &quot;Alice&quot;, age: 30 }))
// Output: true

console.log(isPerson(null))
// Output: false

console.log(isPerson({}))
// Output: false
</code></pre>
<p>The generated <code>isPerson</code> function has the following signature:</p>
<pre><code class="language-ts">const isPerson: (
  u: unknown,
  overrideOptions?: number | ParseOptions
) =&gt; u is {
  readonly name: string
  readonly age: number
}
</code></pre>
<h2>Assertions</h2>
<p>While type guards verify whether a value conforms to a specific type, the <code>Schema.asserts</code> function goes further by asserting that an input matches the schema type <code>Type</code> (from <code>Schema&lt;Type, Encoded, Context&gt;</code>).
If the input does not match the schema, it throws a detailed error, making it useful for runtime validation.</p>
<Aside type="note" title="Role of the Encoded Type in Assertions">
  The type `Encoded`, which is often used in schema transformations, does
  not affect the creation of the assertion. The main purpose is to ensure
  that the input matches the desired type `Type`.
</Aside>

<p><strong>Example</strong> (Creating and Using an Assertion)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Define a schema for a Person object
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Generate an assertion function from the schema
const assertsPerson: Schema.Schema.ToAsserts&lt;typeof Person&gt; =
  Schema.asserts(Person)

try {
  // Attempt to assert that the input matches the Person schema
  assertsPerson({ name: &quot;Alice&quot;, age: &quot;30&quot; })
} catch (e) {
  console.error(&quot;The input does not match the schema:&quot;)
  console.error(e)
}
/*
throws:
The input does not match the schema:
{
  _id: &#39;ParseError&#39;,
  message: &#39;{ readonly name: string; readonly age: number }\n&#39; +
    &#39;└─ [&quot;age&quot;]\n&#39; +
    &#39;   └─ Expected number, actual &quot;30&quot;&#39;
}
*/

// This input matches the schema and will not throw an error
assertsPerson({ name: &quot;Alice&quot;, age: 30 })
</code></pre>
<p>The <code>assertsPerson</code> function generated from the schema has the following signature:</p>
<pre><code class="language-ts">const assertsPerson: (
  input: unknown,
  overrideOptions?: number | ParseOptions
) =&gt; asserts input is {
  readonly name: string
  readonly age: number
}
</code></pre>
<h2>Managing Missing Properties</h2>
<p>When decoding, it&#39;s important to understand how missing properties are processed. By default, if a property is not present in the input, it is treated as if it were present with an <code>undefined</code> value.</p>
<p><strong>Example</strong> (Default Behavior of Missing Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({ a: Schema.Unknown })
const input = {}

console.log(Schema.decodeUnknownSync(schema)(input))
// Output: { a: undefined }
</code></pre>
<p>In this example, although the key <code>&quot;a&quot;</code> is not present in the input, it is treated as <code>{ a: undefined }</code> by default.</p>
<p>If you need your validation logic to differentiate between genuinely missing properties and those explicitly set to <code>undefined</code>, you can enable the <code>exact</code> option.</p>
<p><strong>Example</strong> (Setting <code>exact: true</code> to Distinguish Missing Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({ a: Schema.Unknown })
const input = {}

console.log(Schema.decodeUnknownSync(schema)(input, { exact: true }))
/*
throws
ParseError: { readonly a: unknown }
└─ [&quot;a&quot;]
   └─ is missing
*/
</code></pre>
<p>For the APIs <code>Schema.is</code> and <code>Schema.asserts</code>, however, the default behavior is to treat missing properties strictly, where the default for <code>exact</code> is <code>true</code>:</p>
<p><strong>Example</strong> (Strict Handling of Missing Properties with <code>Schema.is</code> and <code>Schema.asserts</code>)</p>
<pre><code class="language-ts">import type { SchemaAST } from &quot;effect&quot;
import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({ a: Schema.Unknown })
const input = {}

console.log(Schema.is(schema)(input))
// Output: false

console.log(Schema.is(schema)(input, { exact: false }))
// Output: true

const asserts: (
  u: unknown,
  overrideOptions?: SchemaAST.ParseOptions
) =&gt; asserts u is {
  readonly a: unknown
} = Schema.asserts(schema)

try {
  asserts(input)
  console.log(&quot;asserts passed&quot;)
} catch (e: any) {
  console.error(&quot;asserts failed&quot;)
  console.error(e.message)
}
/*
Output:
asserts failed
{ readonly a: unknown }
└─ [&quot;a&quot;]
  └─ is missing
*/

try {
  asserts(input, { exact: false })
  console.log(&quot;asserts passed&quot;)
} catch (e: any) {
  console.error(&quot;asserts failed&quot;)
  console.error(e.message)
}
// Output: asserts passed
</code></pre>
<h2>Naming Conventions</h2>
<p>The naming conventions in <code>effect/Schema</code> are designed to be straightforward and logical, <strong>focusing primarily on compatibility with JSON serialization</strong>. This approach simplifies the understanding and use of schemas, especially for developers who are integrating web technologies where JSON is a standard data interchange format.</p>
<h3>Overview of Naming Strategies</h3>
<p><strong>JSON-Compatible Types</strong></p>
<p>Schemas that naturally serialize to JSON-compatible formats are named directly after their data types.</p>
<p>For instance:</p>
<ul>
<li><code>Schema.Date</code>: serializes JavaScript Date objects to ISO-formatted strings, a typical method for representing dates in JSON.</li>
<li><code>Schema.Number</code>: used directly as it maps precisely to the JSON number type, requiring no special transformation to remain JSON-compatible.</li>
</ul>
<p><strong>Non-JSON-Compatible Types</strong></p>
<p>When dealing with types that do not have a direct representation in JSON, the naming strategy incorporates additional details to indicate the necessary transformation. This helps in setting clear expectations about the schema&#39;s behavior:</p>
<p>For instance:</p>
<ul>
<li><code>Schema.DateFromSelf</code>: indicates that the schema handles <code>Date</code> objects, which are not natively JSON-serializable.</li>
<li><code>Schema.NumberFromString</code>: this naming suggests that the schema processes numbers that are initially represented as strings, emphasizing the transformation from string to number when decoding.</li>
</ul>
<p>The primary goal of these schemas is to ensure that domain objects can be easily serialized (&quot;encoded&quot;) and deserialized (&quot;decoded&quot;) for transmission over network connections, thus facilitating their transfer between different parts of an application or across different applications.</p>
<h3>Rationale</h3>
<p>While JSON&#39;s ubiquity justifies its primary consideration in naming, the conventions also accommodate serialization for other types of transport. For instance, converting a <code>Date</code> to a string is a universally useful method for various communication protocols, not just JSON. Thus, the selected naming conventions serve as sensible defaults that prioritize clarity and ease of use, facilitating the serialization and deserialization processes across diverse technological environments.</p>
<hr>
<hr>
<h2>title: Introduction to Effect Schema
description: &quot;Introduction to <code>effect/Schema</code>, a module for defining, validating, and transforming data schemas.&quot;
sidebar:
  label: Introduction
  order: 0</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Welcome to the documentation for <code>effect/Schema</code>, a module for defining and using schemas to validate and transform data in TypeScript.</p>
<p>The <code>effect/Schema</code> module allows you to define a <code>Schema&lt;Type, Encoded, Requirements&gt;</code> that provides a blueprint for describing the structure and data types of your data. Once defined, you can leverage this schema to perform a range of operations, including:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Decoding</td>
<td>Transforming data from an input type <code>Encoded</code> to an output type <code>Type</code>.</td>
</tr>
<tr>
<td>Encoding</td>
<td>Converting data from an output type <code>Type</code> back to an input type <code>Encoded</code>.</td>
</tr>
<tr>
<td>Asserting</td>
<td>Verifying that a value adheres to the schema&#39;s output type <code>Type</code>.</td>
</tr>
<tr>
<td>Standard Schema</td>
<td>Generate a <a href="https://standardschema.dev/">Standard Schema V1</a>.</td>
</tr>
<tr>
<td>Arbitraries</td>
<td>Generate arbitraries for <a href="https://github.com/dubzzz/fast-check">fast-check</a> testing.</td>
</tr>
<tr>
<td>JSON Schemas</td>
<td>Create JSON Schemas based on defined schemas.</td>
</tr>
<tr>
<td>Equivalence</td>
<td>Create <a href="/docs/schema/equivalence/">Equivalence</a> based on defined schemas.</td>
</tr>
<tr>
<td>Pretty printing</td>
<td>Support pretty printing for data structures.</td>
</tr>
</tbody></table>
<h2>Requirements</h2>
<ul>
<li>TypeScript 5.4 or newer.</li>
<li>The <code>strict</code> flag enabled in your <code>tsconfig.json</code> file.</li>
<li>(Optional) The <code>exactOptionalPropertyTypes</code> flag enabled in your <code>tsconfig.json</code> file.</li>
</ul>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true,
    &quot;exactOptionalPropertyTypes&quot;: true // optional
  }
}
</code></pre>
<h3>The exactOptionalPropertyTypes Option</h3>
<p>The <code>effect/Schema</code> module takes advantage of the <code>exactOptionalPropertyTypes</code> option of <code>tsconfig.json</code>. This option affects how optional properties are typed (to learn more about this option, you can refer to the official <a href="https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes">TypeScript documentation</a>).</p>
<p><strong>Example</strong> (With <code>exactOptionalPropertyTypes</code> Enabled)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.optionalWith(Schema.NonEmptyString, { exact: true })
})

type Type = Schema.Schema.Type&lt;typeof Person&gt;
/*
type Type = {
    readonly name?: string;
}
*/

// @ts-expect-error
Schema.decodeSync(Person)({ name: undefined })
/*
Argument of type &#39;{ name: undefined; }&#39; is not assignable to parameter of type &#39;{ readonly name?: string; }&#39; with &#39;exactOptionalPropertyTypes: true&#39;. Consider adding &#39;undefined&#39; to the types of the target&#39;s properties.
  Types of property &#39;name&#39; are incompatible.
    Type &#39;undefined&#39; is not assignable to type &#39;string&#39;.ts(2379)
*/
</code></pre>
<p>Here, notice that the type of <code>name</code> is &quot;exact&quot; (<code>string</code>), which means the type checker will catch any attempt to assign an invalid value (like <code>undefined</code>).</p>
<p><strong>Example</strong> (With <code>exactOptionalPropertyTypes</code> Disabled)</p>
<p>If, for some reason, you can&#39;t enable the <code>exactOptionalPropertyTypes</code> option (perhaps due to conflicts with other third-party libraries), you can still use <code>effect/Schema</code>. However, there will be a mismatch between the types and the runtime behavior:</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.optionalWith(Schema.NonEmptyString, { exact: true })
})

type Type = Schema.Schema.Type&lt;typeof Person&gt;
/*
type Type = {
    readonly name?: string | undefined;
}
*/

// No type error, but a decoding failure occurs
Schema.decodeSync(Person)({ name: undefined })
/*
throws:
ParseError: { readonly name?: NonEmptyString }
└─ [&quot;name&quot;]
   └─ NonEmptyString
      └─ From side refinement failure
         └─ Expected string, actual undefined
*/
</code></pre>
<p>In this case, the type of <code>name</code> is widened to <code>string | undefined</code>, which means the type checker won&#39;t catch the invalid value (<code>undefined</code>). However, during decoding, you&#39;ll encounter an error, indicating that <code>undefined</code> is not allowed.</p>
<h2>The Schema Type</h2>
<p>The <code>Schema</code> type represents an <strong>immutable</strong> value that describes the structure of your data.</p>
<p>Here is the general form of a <code>Schema</code>:</p>
<pre><code class="language-text">         ┌─── Type of the decoded value
         │        ┌─── Encoded type (input/output)
         │        │      ┌─── Requirements (context)
         ▼        ▼      ▼
Schema&lt;Type, Encoded, Requirements&gt;
</code></pre>
<p>The <code>Schema</code> type has three type parameters with the following meanings:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Type</strong></td>
<td>Represents the type of value that a schema can succeed with during decoding.</td>
</tr>
<tr>
<td><strong>Encoded</strong></td>
<td>Represents the type of value that a schema can succeed with during encoding. By default, it&#39;s equal to <code>Type</code> if not explicitly provided.</td>
</tr>
<tr>
<td><strong>Requirements</strong></td>
<td>Similar to the <a href="https://effect.website/docs/docs/getting-started/the-effect-type"><code>Effect</code></a> type, it represents the contextual data required by the schema to execute both decoding and encoding. If this type parameter is <code>never</code> (default if not explicitly provided), it means the schema has no requirements.</td>
</tr>
</tbody></table>
<p><strong>Examples</strong></p>
<ul>
<li><code>Schema&lt;string&gt;</code> (defaulted to <code>Schema&lt;string, string, never&gt;</code>) represents a schema that decodes to <code>string</code>, encodes to <code>string</code>, and has no requirements.</li>
<li><code>Schema&lt;number, string&gt;</code> (defaulted to <code>Schema&lt;number, string, never&gt;</code>) represents a schema that decodes to <code>number</code> from <code>string</code>, encodes a <code>number</code> to a <code>string</code>, and has no requirements.</li>
</ul>
<Aside type="note" title="Type Parameter Abbreviations">
  In the Effect ecosystem, you may often encounter the type parameters of
  `Schema` abbreviated as `A`, `I`, and `R` respectively. This is just
  shorthand for the type value of type **A**, **I**nput, and
  **R**equirements.
</Aside>

<h2>Understanding Schema Values</h2>
<p><strong>Immutability</strong>. <code>Schema</code> values are immutable, and every function in the <code>effect/Schema</code> module produces a new <code>Schema</code> value.</p>
<p><strong>Modeling Data Structure</strong>. These values do not perform any actions themselves, they simply model or describe the structure of your data.</p>
<p><strong>Interpretation by Compilers</strong>. A <code>Schema</code> can be interpreted by various &quot;compilers&quot; into specific operations, depending on the compiler type (decoding, encoding, pretty printing, arbitraries, etc...).</p>
<h2>Understanding Decoding and Encoding</h2>
<p>When working with data in TypeScript, you often need to handle data coming from or being sent to external systems. This data may not always match the format or types you expect, especially when dealing with user input, data from APIs, or data stored in different formats. To handle these discrepancies, we use <strong>decoding</strong> and <strong>encoding</strong>.</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Decoding</strong></td>
<td>Used for parsing data from external sources where you have no control over the data format.</td>
</tr>
<tr>
<td><strong>Encoding</strong></td>
<td>Used when sending data out to external sources, converting it to a format that is expected by those sources.</td>
</tr>
</tbody></table>
<p>For instance, when working with forms in the frontend, you often receive untyped data in the form of strings. This data can be tampered with and does not natively support arrays or booleans. Decoding helps you validate and parse this data into more useful types like numbers, dates, and arrays. Encoding allows you to convert these types back into the string format expected by forms.</p>
<p>Below is a diagram that shows the relationship between encoding and decoding using a <code>Schema&lt;A, I, R&gt;</code>:</p>
<pre><code class="language-text">┌─────────┐       ┌───┐       ┌───┐       ┌─────────┐
| unknown |       | A |       | I |       | unknown |
└─────────┘       └───┘       └───┘       └─────────┘
     |              |           |              |
     | validate     |           |              |
     |─────────────►│           |              |
     |              |           |              |
     | is           |           |              |
     |─────────────►│           |              |
     |              |           |              |
     | asserts      |           |              |
     |─────────────►│           |              |
     |              |           |              |
     | encodeUnknown|           |              |
     |─────────────────────────►|              |
                    |           |              |
                    | encode    |              |
                    |──────────►│              |
                    |           |              |
                    |    decode |              |
                    | ◄─────────|              |
                    |           |              |
                    |           | decodeUnknown|
                    | ◄────────────────────────|
</code></pre>
<p>We&#39;ll break down these concepts using an example with a <code>Schema&lt;Date, string, never&gt;</code>. This schema serves as a tool to transform a <code>string</code> into a <code>Date</code> and vice versa.</p>
<h3>Encoding</h3>
<p>When we talk about &quot;encoding,&quot; we are referring to the process of changing a <code>Date</code> into a <code>string</code>. To put it simply, it&#39;s the act of converting data from one format to another.</p>
<h3>Decoding</h3>
<p>Conversely, &quot;decoding&quot; entails transforming a <code>string</code> back into a <code>Date</code>. It&#39;s essentially the reverse operation of encoding, where data is returned to its original form.</p>
<h3>Decoding From Unknown</h3>
<p>Decoding from <code>unknown</code> involves two key steps:</p>
<ol>
<li><p><strong>Checking:</strong> Initially, we verify that the input data (which is of the <code>unknown</code> type) matches the expected structure. In our specific case, this means ensuring that the input is indeed a <code>string</code>.</p>
</li>
<li><p><strong>Decoding:</strong> Following the successful check, we proceed to convert the <code>string</code> into a <code>Date</code>. This process completes the decoding operation, where the data is both validated and transformed.</p>
</li>
</ol>
<h3>Encoding From Unknown</h3>
<p>Encoding from <code>unknown</code> involves two key steps:</p>
<ol>
<li><p><strong>Checking:</strong> Initially, we verify that the input data (which is of the <code>unknown</code> type) matches the expected structure. In our specific case, this means ensuring that the input is indeed a <code>Date</code>.</p>
</li>
<li><p><strong>Encoding:</strong> Following the successful check, we proceed to convert the <code>Date</code> into a <code>string</code>. This process completes the encoding operation, where the data is both validated and transformed.</p>
</li>
</ol>
<h2>The Rule of Schemas</h2>
<p>When working with schemas, there&#39;s an important rule to keep in mind: your schemas should be crafted in a way that when you perform both encoding and decoding operations, you should end up with the original value.</p>
<p>In simpler terms, if you encode a value and then immediately decode it, the result should match the original value you started with. This rule ensures that your data remains consistent and reliable throughout the encoding and decoding process.</p>
<Aside type="tip" title="Ensure Consistency">
  As a general rule, schemas should be defined such that encode + decode
  return the original value.
</Aside>


<hr>
<hr>
<h2>title: Schema to JSON Schema
description: Convert schema definitions into JSON Schema for data validation and interoperability.
sidebar:
  label: JSON Schema
  order: 16</h2>
<p>The <code>JSONSchema.make</code> function allows you to generate a JSON Schema from a schema.</p>
<p><strong>Example</strong> (Creating a JSON Schema for a Struct)</p>
<p>The following example defines a <code>Person</code> schema with properties for <code>name</code> (a string) and <code>age</code> (a number). It then generates the corresponding JSON Schema.</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;name&quot;,
    &quot;age&quot;
  ],
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;age&quot;: {
      &quot;type&quot;: &quot;number&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<p>The <code>JSONSchema.make</code> function aims to produce an optimal JSON Schema representing the input part of the decoding phase.
It does this by traversing the schema from the most nested component, incorporating each refinement, and <strong>stops at the first transformation</strong> encountered.</p>
<p><strong>Example</strong> (Excluding Transformations in JSON Schema)</p>
<p>Consider modifying the <code>age</code> field to include both a refinement and a transformation. Only the refinement is reflected in the JSON Schema.</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number.pipe(
    // Refinement included in the JSON Schema
    Schema.int(),
    // Transformation excluded from the JSON Schema
    Schema.clamp(1, 10)
  )
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;name&quot;,
    &quot;age&quot;
  ],
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;age&quot;: {
      &quot;type&quot;: &quot;integer&quot;,
      &quot;description&quot;: &quot;an integer&quot;,
      &quot;title&quot;: &quot;integer&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<p>In this case, the JSON Schema reflects the integer refinement but does not include the transformation that clamps the value.</p>
<h2>Specific Outputs for Schema Types</h2>
<h3>Literals</h3>
<p>Literals are transformed into <code>enum</code> types within JSON Schema.</p>
<p><strong>Example</strong> (Single Literal)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Literal(&quot;a&quot;)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;enum&quot;: [
    &quot;a&quot;
  ]
}
*/
</code></pre>
<p><strong>Example</strong> (Union of literals)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;enum&quot;: [
    &quot;a&quot;,
    &quot;b&quot;
  ]
}
*/
</code></pre>
<h3>Void</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Void

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$id&quot;: &quot;/schemas/void&quot;,
  &quot;title&quot;: &quot;void&quot;
}
*/
</code></pre>
<h3>Any</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Any

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$id&quot;: &quot;/schemas/any&quot;,
  &quot;title&quot;: &quot;any&quot;
}
*/
</code></pre>
<h3>Unknown</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Unknown

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$id&quot;: &quot;/schemas/unknown&quot;,
  &quot;title&quot;: &quot;unknown&quot;
}
*/
</code></pre>
<h3>Object</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Object

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$id&quot;: &quot;/schemas/object&quot;,
  &quot;anyOf&quot;: [
    {
      &quot;type&quot;: &quot;object&quot;
    },
    {
      &quot;type&quot;: &quot;array&quot;
    }
  ],
  &quot;description&quot;: &quot;an object in the TypeScript meaning, i.e. the `object` type&quot;,
  &quot;title&quot;: &quot;object&quot;
}
*/
</code></pre>
<h3>String</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.String

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;
}
*/
</code></pre>
<h3>Number</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Number

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;number&quot;
}
*/
</code></pre>
<h3>Boolean</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Boolean

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;boolean&quot;
}
*/
</code></pre>
<h3>Tuples</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Tuple(Schema.String, Schema.Number)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;array&quot;,
  &quot;minItems&quot;: 2,
  &quot;items&quot;: [
    {
      &quot;type&quot;: &quot;string&quot;
    },
    {
      &quot;type&quot;: &quot;number&quot;
    }
  ],
  &quot;additionalItems&quot;: false
}
*/
</code></pre>
<h3>Arrays</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Array(Schema.String)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;array&quot;,
  &quot;items&quot;: {
    &quot;type&quot;: &quot;string&quot;
  }
}
*/
</code></pre>
<h3>Non Empty Arrays</h3>
<p>Represents an array with at least one element.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.NonEmptyArray(Schema.String)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;array&quot;,
  &quot;minItems&quot;: 1,
  &quot;items&quot;: {
    &quot;type&quot;: &quot;string&quot;
  }
}
*/
</code></pre>
<h3>Structs</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;name&quot;,
    &quot;age&quot;
  ],
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;age&quot;: {
      &quot;type&quot;: &quot;number&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<h3>Records</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Record({
  key: Schema.String,
  value: Schema.Number
})

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [],
  &quot;properties&quot;: {},
  &quot;patternProperties&quot;: {
    &quot;&quot;: {
      &quot;type&quot;: &quot;number&quot;
    }
  }
}
*/
</code></pre>
<h3>Mixed Structs with Records</h3>
<p>Combines fixed properties from a struct with dynamic properties from a record.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Struct(
  {
    name: Schema.String,
    age: Schema.Number
  },
  Schema.Record({
    key: Schema.String,
    value: Schema.Union(Schema.String, Schema.Number)
  })
)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;name&quot;,
    &quot;age&quot;
  ],
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;
    },
    &quot;age&quot;: {
      &quot;type&quot;: &quot;number&quot;
    }
  },
  &quot;patternProperties&quot;: {
    &quot;&quot;: {
      &quot;anyOf&quot;: [
        {
          &quot;type&quot;: &quot;string&quot;
        },
        {
          &quot;type&quot;: &quot;number&quot;
        }
      ]
    }
  }
}
*/
</code></pre>
<h3>Enums</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

enum Fruits {
  Apple,
  Banana
}

const schema = Schema.Enums(Fruits)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$comment&quot;: &quot;/schemas/enums&quot;,
  &quot;anyOf&quot;: [
    {
      &quot;type&quot;: &quot;number&quot;,
      &quot;title&quot;: &quot;Apple&quot;,
      &quot;enum&quot;: [
        0
      ]
    },
    {
      &quot;type&quot;: &quot;number&quot;,
      &quot;title&quot;: &quot;Banana&quot;,
      &quot;enum&quot;: [
        1
      ]
    }
  ]
}
*/
</code></pre>
<h3>Template Literals</h3>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.TemplateLiteral(Schema.Literal(&quot;a&quot;), Schema.Number)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;title&quot;: &quot;`a${number}`&quot;,
  &quot;description&quot;: &quot;a template literal&quot;,
  &quot;pattern&quot;: &quot;^a[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?$&quot;
}
*/
</code></pre>
<h3>Unions</h3>
<p>Unions are expressed using <code>anyOf</code> or <code>enum</code>, depending on the types involved:</p>
<p><strong>Example</strong> (Generic Union)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Union(Schema.String, Schema.Number)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;anyOf&quot;: [
    {
      &quot;type&quot;: &quot;string&quot;
    },
    {
      &quot;type&quot;: &quot;number&quot;
    }
  ]
}
*/
</code></pre>
<p><strong>Example</strong> (Union of literals)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Literal(&quot;a&quot;, &quot;b&quot;)

console.log(JSON.stringify(JSONSchema.make(schema), null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;enum&quot;: [
    &quot;a&quot;,
    &quot;b&quot;
  ]
}
*/
</code></pre>
<h2>Identifier Annotations</h2>
<p>You can add <code>identifier</code> annotations to schemas to improve structure and maintainability. Annotated schemas are included in a <code>$defs</code> object in the root of the JSON Schema and referenced from there.</p>
<p><strong>Example</strong> (Using Identifier Annotations)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const Name = Schema.String.annotations({ identifier: &quot;Name&quot; })

const Age = Schema.Number.annotations({ identifier: &quot;Age&quot; })

const Person = Schema.Struct({
  name: Name,
  age: Age
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$defs&quot;: {
    &quot;Name&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;description&quot;: &quot;a string&quot;,
      &quot;title&quot;: &quot;string&quot;
    },
    &quot;Age&quot;: {
      &quot;type&quot;: &quot;number&quot;,
      &quot;description&quot;: &quot;a number&quot;,
      &quot;title&quot;: &quot;number&quot;
    }
  },
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;name&quot;,
    &quot;age&quot;
  ],
  &quot;properties&quot;: {
    &quot;name&quot;: {
      &quot;$ref&quot;: &quot;#/$defs/Name&quot;
    },
    &quot;age&quot;: {
      &quot;$ref&quot;: &quot;#/$defs/Age&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<p>By using identifier annotations, schemas can be reused and referenced more easily, especially in complex JSON Schemas.</p>
<h2>Standard JSON Schema Annotations</h2>
<p>Standard JSON Schema annotations such as <code>title</code>, <code>description</code>, <code>default</code>, and <code>examples</code> are supported.
These annotations allow you to enrich your schemas with metadata that can enhance readability and provide additional information about the data structure.</p>
<p><strong>Example</strong> (Using Annotations for Metadata)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.String.annotations({
  description: &quot;my custom description&quot;,
  title: &quot;my custom title&quot;,
  default: &quot;&quot;,
  examples: [&quot;a&quot;, &quot;b&quot;]
})

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;string&quot;,
  &quot;description&quot;: &quot;my custom description&quot;,
  &quot;title&quot;: &quot;my custom title&quot;,
  &quot;examples&quot;: [
    &quot;a&quot;,
    &quot;b&quot;
  ],
  &quot;default&quot;: &quot;&quot;
}
*/
</code></pre>
<h3>Adding annotations to Struct properties</h3>
<p>To enhance the clarity of your JSON schemas, it&#39;s advisable to add annotations directly to the property signatures rather than to the type itself.
This method is more semantically appropriate as it links descriptive titles and other metadata specifically to the properties they describe, rather than to the generic type.</p>
<p><strong>Example</strong> (Annotated Struct Properties)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  firstName: Schema.propertySignature(Schema.String).annotations({
    title: &quot;First name&quot;
  }),
  lastName: Schema.propertySignature(Schema.String).annotations({
    title: &quot;Last Name&quot;
  })
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;firstName&quot;,
    &quot;lastName&quot;
  ],
  &quot;properties&quot;: {
    &quot;firstName&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;title&quot;: &quot;First name&quot;
    },
    &quot;lastName&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;title&quot;: &quot;Last Name&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<h2>Recursive and Mutually Recursive Schemas</h2>
<p>Recursive and mutually recursive schemas are supported, however it&#39;s <strong>mandatory</strong> to use <code>identifier</code> annotations for these types of schemas to ensure correct references and definitions within the generated JSON Schema.</p>
<p><strong>Example</strong> (Recursive Schema with Identifier Annotations)</p>
<p>In this example, the <code>Category</code> schema refers to itself, making it necessary to use an <code>identifier</code> annotation to facilitate the reference.</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

// Define the interface representing a category structure
interface Category {
  readonly name: string
  readonly categories: ReadonlyArray&lt;Category&gt;
}

// Define a recursive schema with a required identifier annotation
const Category = Schema.Struct({
  name: Schema.String,
  categories: Schema.Array(
    // Recursive reference to the Category schema
    Schema.suspend((): Schema.Schema&lt;Category&gt; =&gt; Category)
  )
}).annotations({ identifier: &quot;Category&quot; })

const jsonSchema = JSONSchema.make(Category)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;$defs&quot;: {
    &quot;Category&quot;: {
      &quot;type&quot;: &quot;object&quot;,
      &quot;required&quot;: [
        &quot;name&quot;,
        &quot;categories&quot;
      ],
      &quot;properties&quot;: {
        &quot;name&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;categories&quot;: {
          &quot;type&quot;: &quot;array&quot;,
          &quot;items&quot;: {
            &quot;$ref&quot;: &quot;#/$defs/Category&quot;
          }
        }
      },
      &quot;additionalProperties&quot;: false
    }
  },
  &quot;$ref&quot;: &quot;#/$defs/Category&quot;
}
*/
</code></pre>
<h2>Customizing JSON Schema Generation</h2>
<p>When working with JSON Schema certain data types, such as <code>bigint</code>, lack a direct representation because JSON Schema does not natively support them.
This absence typically leads to an error when the schema is generated.</p>
<p><strong>Example</strong> (Error Due to Missing Annotation)</p>
<p>Attempting to generate a JSON Schema for unsupported types like <code>bigint</code> will lead to a missing annotation error:</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  a_bigint_field: Schema.BigIntFromSelf
})

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
throws:
Error: Missing annotation
at path: [&quot;a_bigint_field&quot;]
details: Generating a JSON Schema for this schema requires a &quot;jsonSchema&quot; annotation
schema (BigIntKeyword): bigint
*/
</code></pre>
<p>To address this, you can enhance the schema with a custom <code>jsonSchema</code> annotation, defining how you intend to represent such types in JSON Schema:</p>
<p><strong>Example</strong> (Using Custom Annotation for Unsupported Type)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  // Adding a custom JSON Schema annotation for the `bigint` type
  a_bigint_field: Schema.BigIntFromSelf.annotations({
    jsonSchema: {
      type: &quot;some custom way to represent a bigint in JSON Schema&quot;
    }
  })
})

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;a_bigint_field&quot;
  ],
  &quot;properties&quot;: {
    &quot;a_bigint_field&quot;: {
      &quot;type&quot;: &quot;some custom way to represent a bigint in JSON Schema&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<h3>Refinements</h3>
<p>When defining a refinement (e.g., through the <code>Schema.filter</code> function), you can include a JSON Schema annotation to describe the refinement. This annotation is added as a &quot;fragment&quot; that becomes part of the generated JSON Schema. If a schema contains multiple refinements, their respective annotations are merged into the output.</p>
<p><strong>Example</strong> (Using Refinements with Merged Annotations)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

// Define a schema with a refinement for positive numbers
const Positive = Schema.Number.pipe(
  Schema.filter((n) =&gt; n &gt; 0, {
    jsonSchema: { minimum: 0 }
  })
)

// Add an upper bound refinement to the schema
const schema = Positive.pipe(
  Schema.filter((n) =&gt; n &lt;= 10, {
    jsonSchema: { maximum: 10 }
  })
)

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;number&quot;,
  &quot;minimum&quot;: 0,
  &quot;maximum&quot;: 10
}
*/
</code></pre>
<p>The <code>jsonSchema</code> annotation is defined as a generic object, allowing it to represent non-standard extensions. This flexibility leaves the responsibility of enforcing type constraints to the user.</p>
<p>If you prefer stricter type enforcement or need to support non-standard extensions, you can introduce a <code>satisfies</code> constraint on the object literal. This constraint should be used in conjunction with the typing library of your choice.</p>
<p><strong>Example</strong> (Ensuring Type Correctness)</p>
<p>In the following example, we&#39;ve used the <code>@types/json-schema</code> package to provide TypeScript definitions for JSON Schema. This approach not only ensures type correctness but also enables autocomplete suggestions in your IDE.</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;
import type { JSONSchema7 } from &quot;json-schema&quot;

const Positive = Schema.Number.pipe(
  Schema.filter((n) =&gt; n &gt; 0, {
    jsonSchema: { minimum: 0 } // Generic object, no type enforcement
  })
)

const schema = Positive.pipe(
  Schema.filter((n) =&gt; n &lt;= 10, {
    jsonSchema: { maximum: 10 } satisfies JSONSchema7 // Enforces type constraints
  })
)

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;number&quot;,
  &quot;minimum&quot;: 0,
  &quot;maximum&quot;: 10
}
*/
</code></pre>
<p>For schema types other than refinements, you can override the default generated JSON Schema by providing a custom <code>jsonSchema</code> annotation. The content of this annotation will replace the system-generated schema.</p>
<p><strong>Example</strong> (Custom Annotation for a Struct)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

// Define a struct with a custom JSON Schema annotation
const schema = Schema.Struct({ foo: Schema.String }).annotations({
  jsonSchema: { type: &quot;object&quot; }
})

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;
}
the default would be:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;foo&quot;
  ],
  &quot;properties&quot;: {
    &quot;foo&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<h2>Specialized JSON Schema Generation with Schema.parseJson</h2>
<p>The <code>Schema.parseJson</code> function provides a unique approach to JSON Schema generation. Instead of defaulting to a schema for a plain string, which represents the &quot;from&quot; side of the transformation, it generates a schema based on the structure provided within the argument.</p>
<p>This behavior ensures that the generated JSON Schema reflects the intended structure of the parsed data, rather than the raw JSON input.</p>
<p><strong>Example</strong> (Generating JSON Schema for a Parsed Object)</p>
<pre><code class="language-ts">import { JSONSchema, Schema } from &quot;effect&quot;

// Define a schema that parses a JSON string into a structured object
const schema = Schema.parseJson(
  Schema.Struct({
    // Nested parsing: JSON string to a number
    a: Schema.parseJson(Schema.NumberFromString)
  })
)

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
/*
Output:
{
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;required&quot;: [
    &quot;a&quot;
  ],
  &quot;properties&quot;: {
    &quot;a&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;contentMediaType&quot;: &quot;application/json&quot;
    }
  },
  &quot;additionalProperties&quot;: false
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Schema to Pretty Printer
description: Generate formatted string representations of values based on schemas.
sidebar:
  label: Pretty Printer
  order: 18</h2>
<p>The <code>Pretty.make</code> function is used to create pretty printers that generate a formatted string representation of values based on a schema.</p>
<p><strong>Example</strong> (Pretty Printer for a Struct Schema)</p>
<pre><code class="language-ts">import { Pretty, Schema } from &quot;effect&quot;

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Create a pretty printer for the schema
const PersonPretty = Pretty.make(Person)

// Format and print a Person object
console.log(PersonPretty({ name: &quot;Alice&quot;, age: 30 }))
/*
Output:
&#39;{ &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30 }&#39;
*/
</code></pre>
<h2>Customizing Pretty Printer Generation</h2>
<p>You can customize how the pretty printer formats output by using the <code>pretty</code> annotation within your schema definition.</p>
<p>The <code>pretty</code> annotation takes any type parameters provided (<code>typeParameters</code>) and formats the value into a string.</p>
<p><strong>Example</strong> (Custom Pretty Printer for Numbers)</p>
<pre><code class="language-ts">import { Pretty, Schema } from &quot;effect&quot;

// Define a schema with a custom pretty annotation
const schema = Schema.Number.annotations({
  pretty: (/**typeParameters**/) =&gt; (value) =&gt; `my format: ${value}`
})

// Create the pretty printer
const customPrettyPrinter = Pretty.make(schema)

// Format and print a value
console.log(customPrettyPrinter(1))
// Output: &quot;my format: 1&quot;
</code></pre>
<hr>
<hr>
<h2>title: Schema Projections
description: Create new schemas by extracting and customizing the Type or Encoded components of existing schemas.
sidebar:
  label: Projections
  order: 6</h2>
<p>Sometimes, you may want to create a new schema based on an existing one, focusing specifically on either its <code>Type</code> or <code>Encoded</code> aspect. The Schema module provides several functions to make this possible.</p>
<h2>typeSchema</h2>
<p>The <code>Schema.typeSchema</code> function is used to extract the <code>Type</code> portion of a schema, resulting in a new schema that retains only the type-specific properties from the original schema. This excludes any initial encoding or transformation logic applied to the original schema.</p>
<p><strong>Function Signature</strong></p>
<pre><code class="language-ts">declare const typeSchema: &lt;A, I, R&gt;(schema: Schema&lt;A, I, R&gt;) =&gt; Schema&lt;A&gt;
</code></pre>
<p><strong>Example</strong> (Extracting Only Type-Specific Properties)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Struct({
  quantity: Schema.NumberFromString.pipe(Schema.greaterThanOrEqualTo(2))
})

// This creates a schema where &#39;quantity&#39; is defined as a number
// that must be greater than or equal to 2.
const TypeSchema = Schema.typeSchema(Original)

// TypeSchema is equivalent to:
const TypeSchema2 = Schema.Struct({
  quantity: Schema.Number.pipe(Schema.greaterThanOrEqualTo(2))
})
</code></pre>
<h2>encodedSchema</h2>
<p>The <code>Schema.encodedSchema</code> function enables you to extract the <code>Encoded</code> portion of a schema, creating a new schema that matches the original properties but <strong>omits any refinements or transformations</strong> applied to the schema.</p>
<p><strong>Function Signature</strong></p>
<pre><code class="language-ts">declare const encodedSchema: &lt;A, I, R&gt;(
  schema: Schema&lt;A, I, R&gt;
) =&gt; Schema&lt;I&gt;
</code></pre>
<p><strong>Example</strong> (Extracting Encoded Properties Only)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Struct({
  quantity: Schema.String.pipe(Schema.minLength(3))
})

// This creates a schema where &#39;quantity&#39; is just a string,
// disregarding the minLength refinement.
const Encoded = Schema.encodedSchema(Original)

// Encoded is equivalent to:
const Encoded2 = Schema.Struct({
  quantity: Schema.String
})
</code></pre>
<h2>encodedBoundSchema</h2>
<p>The <code>Schema.encodedBoundSchema</code> function is similar to <code>Schema.encodedSchema</code> but preserves the refinements up to the first transformation point in the
original schema.</p>
<p><strong>Function Signature</strong></p>
<pre><code class="language-ts">declare const encodedBoundSchema: &lt;A, I, R&gt;(
  schema: Schema&lt;A, I, R&gt;
) =&gt; Schema&lt;I&gt;
</code></pre>
<p>The term &quot;bound&quot; in this context refers to the boundary up to which refinements are preserved when extracting the encoded form of a schema. It essentially marks the limit to which initial validations and structure are maintained before any transformations are applied.</p>
<p><strong>Example</strong> (Retaining Initial Refinements Only)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const Original = Schema.Struct({
  foo: Schema.String.pipe(
    Schema.minLength(3),
    Schema.compose(Schema.Trim)
  )
})

// The EncodedBoundSchema schema preserves the minLength(3) refinement,
// ensuring the string length condition is enforced
// but omits the Schema.Trim transformation.
const EncodedBoundSchema = Schema.encodedBoundSchema(Original)

// EncodedBoundSchema is equivalent to:
const EncodedBoundSchema2 = Schema.Struct({
  foo: Schema.String.pipe(Schema.minLength(3))
})
</code></pre>
<hr>
<hr>
<h2>title: Schema to Standard Schema
description: Generate Standard Schema V1.
sidebar:
  label: Standard Schema
  order: 14</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>The <code>Schema.standardSchemaV1</code> API allows you to generate a <a href="https://standardschema.dev/">Standard Schema v1</a> object from an Effect <code>Schema</code>.</p>
<p><strong>Example</strong> (Generating a Standard Schema V1)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.Struct({
  name: Schema.String
})

// Convert an Effect schema into a Standard Schema V1 object
//
//      ┌─── StandardSchemaV1&lt;{ readonly name: string; }&gt;
//      ▼
const standardSchema = Schema.standardSchemaV1(schema)
</code></pre>
<Aside type="note" title="Schema Restrictions">
  Only schemas that do not have dependencies (i.e., `R = never`) can be
  converted to a Standard Schema V1 object.
</Aside>

<h2>Sync vs Async Validation</h2>
<p>The <code>Schema.standardSchemaV1</code> API creates a schema whose <code>validate</code> method attempts to decode and validate the provided input synchronously. If the underlying <code>Schema</code> includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a <code>Promise</code> instead.</p>
<p><strong>Example</strong> (Handling Synchronous and Asynchronous Validation)</p>
<pre><code class="language-ts">import { Effect, Schema } from &quot;effect&quot;

// Utility function to display sync and async results
const print = &lt;T&gt;(t: T) =&gt;
  t instanceof Promise
    ? t.then((x) =&gt; console.log(&quot;Promise&quot;, JSON.stringify(x, null, 2)))
    : console.log(&quot;Value&quot;, JSON.stringify(t, null, 2))

// Define a synchronous schema
const sync = Schema.Struct({
  name: Schema.String
})

// Generate a Standard Schema V1 object
const syncStandardSchema = Schema.standardSchemaV1(sync)

// Validate synchronously
print(syncStandardSchema[&quot;~standard&quot;].validate({ name: null }))
/*
Output:
{
  &quot;issues&quot;: [
    {
      &quot;path&quot;: [
        &quot;name&quot;
      ],
      &quot;message&quot;: &quot;Expected string, actual null&quot;
    }
  ]
}
*/

// Define an asynchronous schema with a transformation
const async = Schema.transformOrFail(
  sync,
  Schema.Struct({
    name: Schema.NonEmptyString
  }),
  {
    // Simulate an asynchronous validation delay
    decode: (x) =&gt; Effect.sleep(&quot;100 millis&quot;).pipe(Effect.as(x)),
    encode: Effect.succeed
  }
)

// Generate a Standard Schema V1 object
const asyncStandardSchema = Schema.standardSchemaV1(async)

// Validate asynchronously
print(asyncStandardSchema[&quot;~standard&quot;].validate({ name: &quot;&quot; }))
/*
Output:
Promise {
  &quot;issues&quot;: [
    {
      &quot;path&quot;: [
        &quot;name&quot;
      ],
      &quot;message&quot;: &quot;Expected a non empty string, actual \&quot;\&quot;&quot;
    }
  ]
}
*/
</code></pre>
<h2>Defects</h2>
<p>If an unexpected defect occurs during validation, it is reported as a single issue without a <code>path</code>. This ensures that unexpected errors do not disrupt schema validation but are still captured and reported.</p>
<p><strong>Example</strong> (Handling Defects)</p>
<pre><code class="language-ts">import { Effect, Schema } from &quot;effect&quot;

// Define a schema with a defect in the decode function
const defect = Schema.transformOrFail(Schema.String, Schema.String, {
  // Simulate an internal failure
  decode: () =&gt; Effect.die(&quot;Boom!&quot;),
  encode: Effect.succeed
})

// Generate a Standard Schema V1 object
const defectStandardSchema = Schema.standardSchemaV1(defect)

// Validate input, triggering a defect
console.log(defectStandardSchema[&quot;~standard&quot;].validate(&quot;a&quot;))
/*
Output:
{ issues: [ { message: &#39;Error: Boom!&#39; } ] }
*/
</code></pre>
<hr>
<hr>
<h2>title: Schema Transformations
description: Transform and manipulate data with schema-based transformations, including type conversions, validations, and custom processing.
sidebar:
  label: Transformations
  order: 7</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>Transformations are important when working with schemas. They allow you to change data from one type to another. For example, you might parse a string into a number or convert a date string into a <code>Date</code> object.</p>
<p>The <a href="#transform">Schema.transform</a> and <a href="#transformorfail">Schema.transformOrFail</a> functions help you connect two schemas so you can convert data between them.</p>
<h2>transform</h2>
<p><code>Schema.transform</code> creates a new schema by taking the output of one schema (the &quot;source&quot;) and making it the input of another schema (the &quot;target&quot;). Use this when you know the transformation will always succeed. If it might fail, use <a href="#transformorfail">Schema.transformOrFail</a> instead.</p>
<h3>Understanding Input and Output</h3>
<p>&quot;Output&quot; and &quot;input&quot; depend on what you are doing (decoding or encoding):</p>
<p><strong>When decoding:</strong></p>
<ul>
<li>The source schema <code>Schema&lt;SourceType, SourceEncoded&gt;</code> produces a <code>SourceType</code>.</li>
<li>The target schema <code>Schema&lt;TargetType, TargetEncoded&gt;</code> expects a <code>TargetEncoded</code>.</li>
<li>The decoding path looks like this: <code>SourceEncoded</code> → <code>TargetType</code>.</li>
</ul>
<p>If <code>SourceType</code> and <code>TargetEncoded</code> differ, you can provide a <code>decode</code> function to convert the source schema&#39;s output into the target schema&#39;s input.</p>
<p><strong>When encoding:</strong></p>
<ul>
<li>The target schema <code>Schema&lt;TargetType, TargetEncoded&gt;</code> produces a <code>TargetEncoded</code>.</li>
<li>The source schema <code>Schema&lt;SourceType, SourceEncoded&gt;</code> expects a <code>SourceType</code>.</li>
<li>The encoding path looks like this: <code>TargetType</code> → <code>SourceEncoded</code>.</li>
</ul>
<p>If <code>TargetEncoded</code> and <code>SourceType</code> differ, you can provide an <code>encode</code> function to convert the target schema&#39;s output into the source schema&#39;s input.</p>
<h3>Combining Two Primitive Schemas</h3>
<p>In this example, we start with a schema that accepts <code>&quot;on&quot;</code> or <code>&quot;off&quot;</code> and transform it into a boolean schema. The <code>decode</code> function turns <code>&quot;on&quot;</code> into <code>true</code> and <code>&quot;off&quot;</code> into <code>false</code>. The <code>encode</code> function does the reverse. This gives us a <code>Schema&lt;boolean, &quot;on&quot; | &quot;off&quot;&gt;</code>.</p>
<p><strong>Example</strong> (Converting a String to a Boolean)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Convert &quot;on&quot;/&quot;off&quot; to boolean and back
const BooleanFromString = Schema.transform(
  // Source schema: &quot;on&quot; or &quot;off&quot;
  Schema.Literal(&quot;on&quot;, &quot;off&quot;),
  // Target schema: boolean
  Schema.Boolean,
  {
    // optional but you get better error messages from TypeScript
    strict: true,
    // Transformation to convert the output of the
    // source schema (&quot;on&quot; | &quot;off&quot;) into the input of the
    // target schema (boolean)
    decode: (literal) =&gt; literal === &quot;on&quot;, // Always succeeds here
    // Reverse transformation
    encode: (bool) =&gt; (bool ? &quot;on&quot; : &quot;off&quot;)
  }
)

//     ┌─── &quot;on&quot; | &quot;off&quot;
//     ▼
type Encoded = typeof BooleanFromString.Encoded

//     ┌─── boolean
//     ▼
type Type = typeof BooleanFromString.Type

console.log(Schema.decodeUnknownSync(BooleanFromString)(&quot;on&quot;))
// Output: true
</code></pre>
<p>The <code>decode</code> function above never fails by itself. However, the full decoding process can still fail if the input does not fit the source schema. For example, if you provide <code>&quot;wrong&quot;</code> instead of <code>&quot;on&quot;</code> or <code>&quot;off&quot;</code>, the source schema will fail before calling <code>decode</code>.</p>
<p><strong>Example</strong> (Handling Invalid Input)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Convert &quot;on&quot;/&quot;off&quot; to boolean and back
const BooleanFromString = Schema.transform(
  Schema.Literal(&quot;on&quot;, &quot;off&quot;),
  Schema.Boolean,
  {
    strict: true,
    decode: (s) =&gt; s === &quot;on&quot;,
    encode: (bool) =&gt; (bool ? &quot;on&quot; : &quot;off&quot;)
  }
)

// Providing input not allowed by the source schema
Schema.decodeUnknownSync(BooleanFromString)(&quot;wrong&quot;)
/*
throws:
ParseError: (&quot;on&quot; | &quot;off&quot; &lt;-&gt; boolean)
└─ Encoded side transformation failure
   └─ &quot;on&quot; | &quot;off&quot;
      ├─ Expected &quot;on&quot;, actual &quot;wrong&quot;
      └─ Expected &quot;off&quot;, actual &quot;wrong&quot;
*/
</code></pre>
<h3>Combining Two Transformation Schemas</h3>
<p>Below is an example where both the source and target schemas transform their data:</p>
<ul>
<li>The source schema is <code>Schema.NumberFromString</code>, which is <code>Schema&lt;number, string&gt;</code>.</li>
<li>The target schema is <code>BooleanFromString</code> (defined above), which is <code>Schema&lt;boolean, &quot;on&quot; | &quot;off&quot;&gt;</code>.</li>
</ul>
<p>This example involves four types and requires two conversions:</p>
<ul>
<li>When decoding, convert a <code>number</code> into <code>&quot;on&quot; | &quot;off&quot;</code>. For example, treat any positive number as <code>&quot;on&quot;</code>.</li>
<li>When encoding, convert <code>&quot;on&quot; | &quot;off&quot;</code> back into a <code>number</code>. For example, treat <code>&quot;on&quot;</code> as <code>1</code> and <code>&quot;off&quot;</code> as <code>-1</code>.</li>
</ul>
<p>By composing these transformations, we get a schema that decodes a string into a boolean and encodes a boolean back into a string. The resulting schema is <code>Schema&lt;boolean, string&gt;</code>.</p>
<p><strong>Example</strong> (Combining Two Transformation Schemas)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Convert &quot;on&quot;/&quot;off&quot; to boolean and back
const BooleanFromString = Schema.transform(
  Schema.Literal(&quot;on&quot;, &quot;off&quot;),
  Schema.Boolean,
  {
    strict: true,
    decode: (s) =&gt; s === &quot;on&quot;,
    encode: (bool) =&gt; (bool ? &quot;on&quot; : &quot;off&quot;)
  }
)

const BooleanFromNumericString = Schema.transform(
  // Source schema: Convert string -&gt; number
  Schema.NumberFromString,
  // Target schema: Convert &quot;on&quot;/&quot;off&quot; -&gt; boolean
  BooleanFromString,
  {
    strict: true,
    // If number is positive, use &quot;on&quot;, otherwise &quot;off&quot;
    decode: (n) =&gt; (n &gt; 0 ? &quot;on&quot; : &quot;off&quot;),
    // If boolean is true, use 1, otherwise -1
    encode: (bool) =&gt; (bool ? 1 : -1)
  }
)

//     ┌─── string
//     ▼
type Encoded = typeof BooleanFromNumericString.Encoded

//     ┌─── boolean
//     ▼
type Type = typeof BooleanFromNumericString.Type

console.log(Schema.decodeUnknownSync(BooleanFromNumericString)(&quot;100&quot;))
// Output: true
</code></pre>
<p><strong>Example</strong> (Converting an array to a ReadonlySet)</p>
<p>In this example, we convert an array into a <code>ReadonlySet</code>. The <code>decode</code> function takes an array and creates a new <code>ReadonlySet</code>. The <code>encode</code> function converts the set back into an array. We also provide the schema of the array items so they are properly validated.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// This function builds a schema that converts between a readonly array
// and a readonly set of items
const ReadonlySetFromArray = &lt;A, I, R&gt;(
  itemSchema: Schema.Schema&lt;A, I, R&gt;
): Schema.Schema&lt;ReadonlySet&lt;A&gt;, ReadonlyArray&lt;I&gt;, R&gt; =&gt;
  Schema.transform(
    // Source schema: array of items
    Schema.Array(itemSchema),
    // Target schema: readonly set of items
    // **IMPORTANT** We use `Schema.typeSchema` here to obtain the schema
    // of the items to avoid decoding the elements twice
    Schema.ReadonlySetFromSelf(Schema.typeSchema(itemSchema)),
    {
      strict: true,
      decode: (items) =&gt; new Set(items),
      encode: (set) =&gt; Array.from(set.values())
    }
  )

const schema = ReadonlySetFromArray(Schema.String)

//     ┌─── readonly string[]
//     ▼
type Encoded = typeof schema.Encoded

//     ┌─── ReadonlySet&lt;string&gt;
//     ▼
type Type = typeof schema.Type

console.log(Schema.decodeUnknownSync(schema)([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
// Output: Set(3) { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; }

console.log(Schema.encodeSync(schema)(new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])))
// Output: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</code></pre>
<Aside type="note" title="Why Schema.typeSchema is used">
  Please note that to define the target schema, we used
  [Schema.typeSchema](/docs/schema/projections/#typeschema). This is
  because the decoding/encoding of the elements is already handled by the
  `from` schema: `Schema.Array(itemSchema)`, avoiding double decoding.
</Aside>

<h3>Non-strict option</h3>
<p>In some cases, strict type checking can create issues during data transformations, especially when the types might slightly differ in specific transformations. To address these scenarios, <code>Schema.transform</code> offers the option <code>strict: false</code>, which relaxes type constraints and allows more flexible transformations.</p>
<p><strong>Example</strong> (Creating a Clamping Constructor)</p>
<p>Let&#39;s consider the scenario where you need to define a constructor <code>clamp</code> that ensures a number falls within a specific range. This function returns a schema that &quot;clamps&quot; a number to a specified minimum and maximum range:</p>
<pre><code class="language-ts">import { Schema, Number } from &quot;effect&quot;

const clamp =
  (minimum: number, maximum: number) =&gt;
  &lt;A extends number, I, R&gt;(self: Schema.Schema&lt;A, I, R&gt;) =&gt;
    Schema.transform(
      // Source schema
      self,
      // Target schema: filter based on min/max range
      self.pipe(
        Schema.typeSchema,
        Schema.filter((a) =&gt; a &lt;= minimum || a &gt;= maximum)
      ),
      // @ts-expect-error
      {
        strict: true,
        // Clamp the number within the specified range
        decode: (a) =&gt; Number.clamp(a, { minimum, maximum }),
        encode: (a) =&gt; a
      }
    )
</code></pre>
<p>In this example, <code>Number.clamp</code> returns a <code>number</code> that might not be recognized as the specific <code>A</code> type. This leads to a type mismatch under strict checking:</p>
<pre><code class="language-text">Argument of type &#39;{ strict: true; decode: (a: A) =&gt; number; encode: (a: A) =&gt; A; }&#39; is not assignable to parameter of type &#39;{ readonly decode: (fromA: A, fromI: I) =&gt; A; readonly encode: (toI: A, toA: A) =&gt; A; readonly strict?: true; } | { readonly decode: (fromA: A, fromI: I) =&gt; unknown; readonly encode: (toI: A, toA: A) =&gt; unknown; readonly strict: false; }&#39;.
  The types returned by &#39;decode(...)&#39; are incompatible between these types.
    Type &#39;number&#39; is not assignable to type &#39;A&#39;.
      &#39;number&#39; is assignable to the constraint of type &#39;A&#39;, but &#39;A&#39; could be instantiated with a different subtype of constraint &#39;number&#39;.ts(2345)
</code></pre>
<p>There are two ways to resolve this issue:</p>
<ol>
<li><p><strong>Using Type Assertion</strong>:
Adding a type cast can enforce the return type to be treated as type <code>A</code>:</p>
<pre><code class="language-ts">decode: (a) =&gt; Number.clamp(a, { minimum, maximum }) as A
</code></pre>
</li>
<li><p><strong>Using the Non-Strict Option</strong>:
Setting <code>strict: false</code> in the transformation options allows the schema to bypass some of TypeScript&#39;s type-checking rules, accommodating the type discrepancy:</p>
<pre><code class="language-ts">import { Schema, Number } from &quot;effect&quot;

const clamp =
  (minimum: number, maximum: number) =&gt;
  &lt;A extends number, I, R&gt;(self: Schema.Schema&lt;A, I, R&gt;) =&gt;
    Schema.transform(
      self,
      self.pipe(
        Schema.typeSchema,
        Schema.filter((a) =&gt; a &gt;= minimum &amp;&amp; a &lt;= maximum)
      ),
      {
        strict: false,
        decode: (a) =&gt; Number.clamp(a, { minimum, maximum }),
        encode: (a) =&gt; a
      }
    )
</code></pre>
</li>
</ol>
<h2>transformOrFail</h2>
<p>While the <a href="#transform">Schema.transform</a> function is suitable for error-free transformations,
the <code>Schema.transformOrFail</code> function is designed for more complex scenarios where <strong>transformations
can fail</strong> during the decoding or encoding stages.</p>
<p>This function enables decoding/encoding functions to return either a successful result or an error,
making it particularly useful for validating and processing data that might not always conform to expected formats.</p>
<h3>Error Handling</h3>
<p>The <code>Schema.transformOrFail</code> function utilizes the ParseResult module to manage potential errors:</p>
<table>
<thead>
<tr>
<th>Constructor</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>ParseResult.succeed</code></td>
<td>Indicates a successful transformation, where no errors occurred.</td>
</tr>
<tr>
<td><code>ParseResult.fail</code></td>
<td>Signals a failed transformation, creating a new <code>ParseError</code> based on the provided <code>ParseIssue</code>.</td>
</tr>
</tbody></table>
<p>Additionally, the ParseResult module provides constructors for dealing with various types of parse issues, such as:</p>
<table>
<thead>
<tr>
<th>Parse Issue Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Type</code></td>
<td>Indicates a type mismatch error.</td>
</tr>
<tr>
<td><code>Missing</code></td>
<td>Used when a required field is missing.</td>
</tr>
<tr>
<td><code>Unexpected</code></td>
<td>Used for unexpected fields that are not allowed in the schema.</td>
</tr>
<tr>
<td><code>Forbidden</code></td>
<td>Flags the decoding or encoding operation being forbidden by the schema.</td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td>Points to a specific location in the data where an issue occurred.</td>
</tr>
<tr>
<td><code>Refinement</code></td>
<td>Used when a value does not meet a specific refinement or constraint.</td>
</tr>
<tr>
<td><code>Transformation</code></td>
<td>Flags issues that occur during transformation from one type to another.</td>
</tr>
<tr>
<td><code>Composite</code></td>
<td>Represents a composite error, combining multiple issues into one, helpful for grouped errors.</td>
</tr>
</tbody></table>
<p>These tools allow for detailed and specific error handling, enhancing the reliability of data processing operations.</p>
<p><strong>Example</strong> (Converting a String to a Number)</p>
<p>A common use case for <code>Schema.transformOrFail</code> is converting string representations of numbers into actual numeric types. This scenario is typical when dealing with user inputs or data from external sources.</p>
<pre><code class="language-ts">import { ParseResult, Schema } from &quot;effect&quot;

export const NumberFromString = Schema.transformOrFail(
  // Source schema: accepts any string
  Schema.String,
  // Target schema: expects a number
  Schema.Number,
  {
    // optional but you get better error messages from TypeScript
    strict: true,
    decode: (input, options, ast) =&gt; {
      const parsed = parseFloat(input)
      // If parsing fails (NaN), return a ParseError with a custom error
      if (isNaN(parsed)) {
        return ParseResult.fail(
          // Create a Type Mismatch error
          new ParseResult.Type(
            // Provide the schema&#39;s abstract syntax tree for context
            ast,
            // Include the problematic input
            input,
            // Optional custom error message
            &quot;Failed to convert string to number&quot;
          )
        )
      }
      return ParseResult.succeed(parsed)
    },
    encode: (input, options, ast) =&gt; ParseResult.succeed(input.toString())
  }
)

//     ┌─── string
//     ▼
type Encoded = typeof NumberFromString.Encoded

//     ┌─── number
//     ▼
type Type = typeof NumberFromString.Type

console.log(Schema.decodeUnknownSync(NumberFromString)(&quot;123&quot;))
// Output: 123

console.log(Schema.decodeUnknownSync(NumberFromString)(&quot;-&quot;))
/*
throws:
ParseError: (string &lt;-&gt; number)
└─ Transformation process failure
   └─ Failed to convert string to number
*/
</code></pre>
<p>Both <code>decode</code> and <code>encode</code> functions not only receive the value to transform (<code>input</code>), but also the <a href="/docs/schema/getting-started/#parse-options">parse options</a> that the user sets when using the resulting schema, and the <code>ast</code>, which represents the low level definition of the schema you&#39;re transforming.</p>
<h3>Async Transformations</h3>
<p>In modern applications, especially those interacting with external APIs, you might need to transform data asynchronously. <code>Schema.transformOrFail</code> supports asynchronous transformations by allowing you to return an <code>Effect</code>.</p>
<p><strong>Example</strong> (Validating Data with an API Call)</p>
<p>Consider a scenario where you need to validate a person&#39;s ID by making an API call. Here&#39;s how you can implement it:</p>
<pre><code class="language-ts">import { Effect, Schema, ParseResult } from &quot;effect&quot;

// Define a function to make API requests
const get = (url: string): Effect.Effect&lt;unknown, Error&gt; =&gt;
  Effect.tryPromise({
    try: () =&gt;
      fetch(url).then((res) =&gt; {
        if (res.ok) {
          return res.json() as Promise&lt;unknown&gt;
        }
        throw new Error(String(res.status))
      }),
    catch: (e) =&gt; new Error(String(e))
  })

// Create a branded schema for a person&#39;s ID
const PeopleId = Schema.String.pipe(Schema.brand(&quot;PeopleId&quot;))

// Define a schema with async transformation
const PeopleIdFromString = Schema.transformOrFail(
  Schema.String,
  PeopleId,
  {
    strict: true,
    decode: (s, _, ast) =&gt;
      // Make an API call to validate the ID
      Effect.mapBoth(get(`https://swapi.dev/api/people/${s}`), {
        // Error handling for failed API call
        onFailure: (e) =&gt; new ParseResult.Type(ast, s, e.message),
        // Return the ID if the API call succeeds
        onSuccess: () =&gt; s
      }),
    encode: ParseResult.succeed
  }
)

//     ┌─── string
//     ▼
type Encoded = typeof PeopleIdFromString.Encoded

//     ┌─── string &amp; Brand&lt;&quot;PeopleId&quot;&gt;
//     ▼
type Type = typeof PeopleIdFromString.Type

//     ┌─── never
//     ▼
type Context = typeof PeopleIdFromString.Context

// Run a successful decode operation
Effect.runPromiseExit(Schema.decodeUnknown(PeopleIdFromString)(&quot;1&quot;)).then(
  console.log
)
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;1&#39; }
*/

// Run a decode operation that will fail
Effect.runPromiseExit(
  Schema.decodeUnknown(PeopleIdFromString)(&quot;fail&quot;)
).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: {
      _id: &#39;ParseError&#39;,
      message: &#39;(string &lt;-&gt; string &amp; Brand&lt;&quot;PeopleId&quot;&gt;)\n&#39; +
        &#39;└─ Transformation process failure\n&#39; +
        &#39;   └─ Error: 404&#39;
    }
  }
}
*/
</code></pre>
<h3>Declaring Dependencies</h3>
<p>In cases where your transformation depends on external services, you can inject these services in the <code>decode</code> or <code>encode</code> functions. These dependencies are then tracked in the <code>Requirements</code> channel of the schema:</p>
<pre><code class="language-text">Schema&lt;Type, Encoded, Requirements&gt;
</code></pre>
<p><strong>Example</strong> (Validating Data with a Service)</p>
<pre><code class="language-ts">import { Context, Effect, Schema, ParseResult, Layer } from &quot;effect&quot;

// Define a Validation service for dependency injection
class Validation extends Context.Tag(&quot;Validation&quot;)&lt;
  Validation,
  {
    readonly validatePeopleid: (s: string) =&gt; Effect.Effect&lt;void, Error&gt;
  }
&gt;() {}

// Create a branded schema for a person&#39;s ID
const PeopleId = Schema.String.pipe(Schema.brand(&quot;PeopleId&quot;))

// Transform a string into a validated PeopleId,
// using an external validation service
const PeopleIdFromString = Schema.transformOrFail(
  Schema.String,
  PeopleId,
  {
    strict: true,
    decode: (s, _, ast) =&gt;
      // Asynchronously validate the ID using the injected service
      Effect.gen(function* () {
        // Access the validation service
        const validator = yield* Validation
        // Use service to validate ID
        yield* validator.validatePeopleid(s)
        return s
      }).pipe(
        Effect.mapError((e) =&gt; new ParseResult.Type(ast, s, e.message))
      ),
    encode: ParseResult.succeed // Encode by simply returning the string
  }
)

//     ┌─── string
//     ▼
type Encoded = typeof PeopleIdFromString.Encoded

//     ┌─── string &amp; Brand&lt;&quot;PeopleId&quot;&gt;
//     ▼
type Type = typeof PeopleIdFromString.Type

//     ┌─── Validation
//     ▼
type Context = typeof PeopleIdFromString.Context

// Layer to provide a successful validation service
const SuccessTest = Layer.succeed(Validation, {
  validatePeopleid: (_) =&gt; Effect.void
})

// Run a successful decode operation
Effect.runPromiseExit(
  Schema.decodeUnknown(PeopleIdFromString)(&quot;1&quot;).pipe(
    Effect.provide(SuccessTest)
  )
).then(console.log)
/*
Output:
{ _id: &#39;Exit&#39;, _tag: &#39;Success&#39;, value: &#39;1&#39; }
*/

// Layer to provide a failing validation service
const FailureTest = Layer.succeed(Validation, {
  validatePeopleid: (_) =&gt; Effect.fail(new Error(&quot;404&quot;))
})

// Run a decode operation that will fail
Effect.runPromiseExit(
  Schema.decodeUnknown(PeopleIdFromString)(&quot;fail&quot;).pipe(
    Effect.provide(FailureTest)
  )
).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: {
    _id: &#39;Cause&#39;,
    _tag: &#39;Fail&#39;,
    failure: {
      _id: &#39;ParseError&#39;,
      message: &#39;(string &lt;-&gt; string &amp; Brand&lt;&quot;PeopleId&quot;&gt;)\n&#39; +
        &#39;└─ Transformation process failure\n&#39; +
        &#39;   └─ Error: 404&#39;
    }
  }
}
*/
</code></pre>
<h2>One-Way Transformations with Forbidden Encoding</h2>
<p>In some cases, encoding a value back to its original form may not make sense or may be undesirable. You can use <code>Schema.transformOrFail</code> to define a one-way transformation and explicitly return a <code>Forbidden</code> parse error during the encoding process. This ensures that once a value is transformed, it cannot be reverted to its original form.</p>
<p><strong>Example</strong> (Password Hashing with Forbidden Encoding)</p>
<p>Consider a scenario where you need to hash a user&#39;s plain text password for secure storage. It is important that the hashed password cannot be reversed back to plain text. By using <code>Schema.transformOrFail</code>, you can enforce this restriction, ensuring a one-way transformation from plain text to a hashed password.</p>
<pre><code class="language-ts">import { Schema, ParseResult, Redacted } from &quot;effect&quot;
import { createHash } from &quot;node:crypto&quot;

// Define a schema for plain text passwords
// with a minimum length requirement
const PlainPassword = Schema.String.pipe(
  Schema.minLength(6),
  Schema.brand(&quot;PlainPassword&quot;, { identifier: &quot;PlainPassword&quot; })
)

// Define a schema for hashed passwords as a separate branded type
const HashedPassword = Schema.String.pipe(
  Schema.brand(&quot;HashedPassword&quot;, { identifier: &quot;HashedPassword&quot; })
)

// Define a one-way transformation from plain passwords to hashed passwords
export const PasswordHashing = Schema.transformOrFail(
  PlainPassword,
  // Wrap the output in Redacted for added safety
  Schema.RedactedFromSelf(HashedPassword),
  {
    strict: true,
    // Decode: Transform a plain password into a hashed password
    decode: (plainPassword) =&gt; {
      const hash = createHash(&quot;sha256&quot;)
        .update(plainPassword)
        .digest(&quot;hex&quot;)
      // Wrap the hash in Redacted
      return ParseResult.succeed(Redacted.make(hash))
    },
    // Encode: Forbid reversing the hashed password back to plain text
    encode: (hashedPassword, _, ast) =&gt;
      ParseResult.fail(
        new ParseResult.Forbidden(
          ast,
          hashedPassword,
          &quot;Encoding hashed passwords back to plain text is forbidden.&quot;
        )
      )
  }
)

//     ┌─── string
//     ▼
type Encoded = typeof PasswordHashing.Encoded

//     ┌─── Redacted&lt;string &amp; Brand&lt;&quot;HashedPassword&quot;&gt;&gt;
//     ▼
type Type = typeof PasswordHashing.Type

// Example: Decoding a plain password into a hashed password
console.log(
  Schema.decodeUnknownSync(PasswordHashing)(&quot;myPlainPassword123&quot;)
)
// Output: &lt;redacted&gt;

// Example: Attempting to encode a hashed password back to plain text
console.log(
  Schema.encodeUnknownSync(PasswordHashing)(Redacted.make(&quot;2ef2b7...&quot;))
)
/*
throws:
ParseError: (PlainPassword &lt;-&gt; Redacted(&lt;redacted&gt;))
└─ Transformation process failure
   └─ (PlainPassword &lt;-&gt; Redacted(&lt;redacted&gt;))
      └─ Encoding hashed passwords back to plain text is forbidden.
*/
</code></pre>
<h2>Composition</h2>
<p>Combining and reusing schemas is often needed in complex applications, and the <code>Schema.compose</code> combinator provides an efficient way to do this. With <code>Schema.compose</code>, you can chain two schemas, <code>Schema&lt;B, A, R1&gt;</code> and <code>Schema&lt;C, B, R2&gt;</code>, into a single schema <code>Schema&lt;C, A, R1 | R2&gt;</code>:</p>
<p><strong>Example</strong> (Composing Schemas to Parse a Delimited String into Numbers)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Schema to split a string by commas into an array of strings
//
//     ┌─── Schema&lt;readonly string[], string, never&gt;
//     ▼
const schema1 = Schema.asSchema(Schema.split(&quot;,&quot;))

// Schema to convert an array of strings to an array of numbers
//
//     ┌─── Schema&lt;readonly number[], readonly string[], never&gt;
//     ▼
const schema2 = Schema.asSchema(Schema.Array(Schema.NumberFromString))

// Composed schema that takes a string, splits it by commas,
// and converts the result into an array of numbers
//
//     ┌─── Schema&lt;readonly number[], string, never&gt;
//     ▼
const ComposedSchema = Schema.asSchema(Schema.compose(schema1, schema2))
</code></pre>
<h3>Non-strict Option</h3>
<p>When composing schemas, you may encounter cases where the output of one schema does not perfectly match the input of the next, for example, if you have <code>Schema&lt;R1, A, B&gt;</code> and <code>Schema&lt;R2, C, D&gt;</code> where <code>C</code> differs from <code>B</code>. To handle these cases, you can use the <code>{ strict: false }</code> option to relax type constraints.</p>
<p><strong>Example</strong> (Using Non-strict Option in Composition)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// Without the `strict: false` option,
// this composition would raise a TypeScript error
Schema.compose(
  // @ts-expect-error: Type mismatch between schemas
  Schema.Union(Schema.Null, Schema.Literal(&quot;0&quot;)),
  Schema.NumberFromString
)

// Using `strict: false` to allow for type flexibility
Schema.compose(
  Schema.Union(Schema.Null, Schema.Literal(&quot;0&quot;)),
  Schema.NumberFromString,
  { strict: false }
)
</code></pre>
<h2>Effectful Filters</h2>
<p>The <code>Schema.filterEffect</code> function enables validations that require asynchronous or dynamic scenarios, making it suitable for cases where validations involve side effects like network requests or database queries. For simple synchronous validations, see <a href="/docs/schema/filters/#declaring-filters"><code>Schema.filter</code></a>.</p>
<p><strong>Example</strong> (Asynchronous Username Validation)</p>
<pre><code class="language-ts">import { Effect, Schema } from &quot;effect&quot;

// Mock async function to validate a username
async function validateUsername(username: string) {
  return Promise.resolve(username === &quot;gcanti&quot;)
}

// Define a schema with an effectful filter
const ValidUsername = Schema.String.pipe(
  Schema.filterEffect((username) =&gt;
    Effect.promise(() =&gt;
      // Validate the username asynchronously,
      // returning an error message if invalid
      validateUsername(username).then(
        (valid) =&gt; valid || &quot;Invalid username&quot;
      )
    )
  )
).annotations({ identifier: &quot;ValidUsername&quot; })

Effect.runPromise(Schema.decodeUnknown(ValidUsername)(&quot;xxx&quot;)).then(
  console.log
)
/*
ParseError: ValidUsername
└─ Transformation process failure
   └─ Invalid username
*/
</code></pre>
<h2>String Transformations</h2>
<h3>split</h3>
<p>Splits a string by a specified delimiter into an array of substrings.</p>
<p><strong>Example</strong> (Splitting a String by Comma)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.split(&quot;,&quot;)

const decode = Schema.decodeUnknownSync(schema)

console.log(decode(&quot;&quot;)) // [&quot;&quot;]
console.log(decode(&quot;,&quot;)) // [&quot;&quot;, &quot;&quot;]
console.log(decode(&quot;a,&quot;)) // [&quot;a&quot;, &quot;&quot;]
console.log(decode(&quot;a,b&quot;)) // [&quot;a&quot;, &quot;b&quot;]
</code></pre>
<h3>Trim</h3>
<p>Removes whitespace from the beginning and end of a string.</p>
<p><strong>Example</strong> (Trimming Whitespace)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Trim)

console.log(decode(&quot;a&quot;)) // &quot;a&quot;
console.log(decode(&quot; a&quot;)) // &quot;a&quot;
console.log(decode(&quot;a &quot;)) // &quot;a&quot;
console.log(decode(&quot; a &quot;)) // &quot;a&quot;
</code></pre>
<Aside type="tip" title="Trimmed Check">
  If you were looking for a combinator to check if a string is trimmed,
  check out the `Schema.trimmed` filter.
</Aside>

<h3>Lowercase</h3>
<p>Converts a string to lowercase.</p>
<p><strong>Example</strong> (Converting to Lowercase)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Lowercase)

console.log(decode(&quot;A&quot;)) // &quot;a&quot;
console.log(decode(&quot; AB&quot;)) // &quot; ab&quot;
console.log(decode(&quot;Ab &quot;)) // &quot;ab &quot;
console.log(decode(&quot; ABc &quot;)) // &quot; abc &quot;
</code></pre>
<Aside type="tip" title="Lowercase And Lowercased">
  If you were looking for a combinator to check if a string is lowercased,
  check out the `Schema.Lowercased` schema or the `Schema.lowercased`
  filter.
</Aside>

<h3>Uppercase</h3>
<p>Converts a string to uppercase.</p>
<p><strong>Example</strong> (Converting to Uppercase)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Uppercase)

console.log(decode(&quot;a&quot;)) // &quot;A&quot;
console.log(decode(&quot; ab&quot;)) // &quot; AB&quot;
console.log(decode(&quot;aB &quot;)) // &quot;AB &quot;
console.log(decode(&quot; abC &quot;)) // &quot; ABC &quot;
</code></pre>
<Aside type="tip" title="Uppercase And Uppercased">
  If you were looking for a combinator to check if a string is uppercased,
  check out the `Schema.Uppercased` schema or the `Schema.uppercased`
  filter.
</Aside>

<h3>Capitalize</h3>
<p>Converts the first character of a string to uppercase.</p>
<p><strong>Example</strong> (Capitalizing a String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Capitalize)

console.log(decode(&quot;aa&quot;)) // &quot;Aa&quot;
console.log(decode(&quot; ab&quot;)) // &quot; ab&quot;
console.log(decode(&quot;aB &quot;)) // &quot;AB &quot;
console.log(decode(&quot; abC &quot;)) // &quot; abC &quot;
</code></pre>
<Aside type="tip" title="Capitalize And Capitalized">
  If you were looking for a combinator to check if a string is
  capitalized, check out the `Schema.Capitalized` schema or the
  `Schema.capitalized` filter.
</Aside>

<h3>Uncapitalize</h3>
<p>Converts the first character of a string to lowercase.</p>
<p><strong>Example</strong> (Uncapitalizing a String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Uncapitalize)

console.log(decode(&quot;AA&quot;)) // &quot;aA&quot;
console.log(decode(&quot; AB&quot;)) // &quot; AB&quot;
console.log(decode(&quot;Ab &quot;)) // &quot;ab &quot;
console.log(decode(&quot; AbC &quot;)) // &quot; AbC &quot;
</code></pre>
<Aside type="tip" title="Uncapitalize And Uncapitalized">
  If you were looking for a combinator to check if a string is
  uncapitalized, check out the `Schema.Uncapitalized` schema or the
  `Schema.uncapitalized` filter.
</Aside>

<h3>parseJson</h3>
<p>The <code>Schema.parseJson</code> constructor offers a method to convert JSON strings into the <code>unknown</code> type using the underlying functionality of <code>JSON.parse</code>.
It also employs <code>JSON.stringify</code> for encoding.</p>
<p><strong>Example</strong> (Parsing JSON Strings)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.parseJson()
const decode = Schema.decodeUnknownSync(schema)

// Parse valid JSON strings
console.log(decode(&quot;{}&quot;)) // Output: {}
console.log(decode(`{&quot;a&quot;:&quot;b&quot;}`)) // Output: { a: &quot;b&quot; }

// Attempting to decode an empty string results in an error
decode(&quot;&quot;)
/*
throws:
ParseError: (JsonString &lt;-&gt; unknown)
└─ Transformation process failure
   └─ Unexpected end of JSON input
*/
</code></pre>
<p>To further refine the result of JSON parsing, you can provide a schema to the <code>Schema.parseJson</code> constructor. This schema will validate that the parsed JSON matches a specific structure.</p>
<p><strong>Example</strong> (Parsing JSON with Structured Validation)</p>
<p>In this example, <code>Schema.parseJson</code> uses a struct schema to ensure the parsed JSON is an object with a numeric property <code>a</code>. This adds validation to the parsed data, confirming that it follows the expected structure.</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

//     ┌─── SchemaClass&lt;{ readonly a: number; }, string, never&gt;
//     ▼
const schema = Schema.parseJson(Schema.Struct({ a: Schema.Number }))
</code></pre>
<h3>StringFromBase64</h3>
<p>Decodes a base64 (RFC4648) encoded string into a UTF-8 string.</p>
<p><strong>Example</strong> (Decoding Base64)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.StringFromBase64)

console.log(decode(&quot;Zm9vYmFy&quot;))
// Output: &quot;foobar&quot;
</code></pre>
<h3>StringFromBase64Url</h3>
<p>Decodes a base64 (URL) encoded string into a UTF-8 string.</p>
<p><strong>Example</strong> (Decoding Base64 URL)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.StringFromBase64Url)

console.log(decode(&quot;Zm9vYmFy&quot;))
// Output: &quot;foobar&quot;
</code></pre>
<h3>StringFromHex</h3>
<p>Decodes a hex encoded string into a UTF-8 string.</p>
<p><strong>Example</strong> (Decoding Hex String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.StringFromHex)

console.log(new TextEncoder().encode(decode(&quot;0001020304050607&quot;)))
/*
Output:
Uint8Array(8) [
  0, 1, 2, 3,
  4, 5, 6, 7
]
*/
</code></pre>
<h3>StringFromUriComponent</h3>
<p>Decodes a URI-encoded string into a UTF-8 string. It is useful for encoding and decoding data in URLs.</p>
<p><strong>Example</strong> (Decoding URI Component)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(
  Schema.StringFromUriComponent,
  Schema.parseJson(PaginationSchema)
)

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
</code></pre>
<h2>Number Transformations</h2>
<h3>NumberFromString</h3>
<p>Converts a string to a number using <code>parseFloat</code>, supporting special values &quot;NaN&quot;, &quot;Infinity&quot;, and &quot;-Infinity&quot;.</p>
<p><strong>Example</strong> (Parsing Number from String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.NumberFromString

const decode = Schema.decodeUnknownSync(schema)

// success cases
console.log(decode(&quot;1&quot;)) // 1
console.log(decode(&quot;-1&quot;)) // -1
console.log(decode(&quot;1.5&quot;)) // 1.5
console.log(decode(&quot;NaN&quot;)) // NaN
console.log(decode(&quot;Infinity&quot;)) // Infinity
console.log(decode(&quot;-Infinity&quot;)) // -Infinity

// failure cases
decode(&quot;a&quot;)
/*
throws:
ParseError: NumberFromString
└─ Transformation process failure
   └─ Expected NumberFromString, actual &quot;a&quot;
*/
</code></pre>
<h3>clamp</h3>
<p>Restricts a number within a specified range.</p>
<p><strong>Example</strong> (Clamping a Number)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// clamps the input to -1 &lt;= x &lt;= 1
const schema = Schema.Number.pipe(Schema.clamp(-1, 1))

const decode = Schema.decodeUnknownSync(schema)

console.log(decode(-3)) // -1
console.log(decode(0)) // 0
console.log(decode(3)) // 1
</code></pre>
<h3>parseNumber</h3>
<p>Transforms a string into a number by parsing the string using the <code>parse</code> function of the <code>effect/Number</code> module.</p>
<p>It returns an error if the value can&#39;t be converted (for example when non-numeric characters are provided).</p>
<p>The following special string values are supported: &quot;NaN&quot;, &quot;Infinity&quot;, &quot;-Infinity&quot;.</p>
<p><strong>Example</strong> (Parsing and Validating Numbers)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const schema = Schema.String.pipe(Schema.parseNumber)

const decode = Schema.decodeUnknownSync(schema)

console.log(decode(&quot;1&quot;)) // 1
console.log(decode(&quot;Infinity&quot;)) // Infinity
console.log(decode(&quot;NaN&quot;)) // NaN
console.log(decode(&quot;-&quot;))
/*
throws
ParseError: (string &lt;-&gt; number)
└─ Transformation process failure
   └─ Expected (string &lt;-&gt; number), actual &quot;-&quot;
*/
</code></pre>
<h2>Boolean Transformations</h2>
<h3>Not</h3>
<p>Negates a boolean value.</p>
<p><strong>Example</strong> (Negating Boolean)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Not)

console.log(decode(true)) // false
console.log(decode(false)) // true
</code></pre>
<h2>Symbol transformations</h2>
<h3>Symbol</h3>
<p>Converts a string to a symbol using <code>Symbol.for</code>.</p>
<p><strong>Example</strong> (Creating Symbols from Strings)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Symbol)

console.log(decode(&quot;a&quot;)) // Symbol(a)
</code></pre>
<h2>BigInt transformations</h2>
<h3>BigInt</h3>
<p>Converts a string to a <code>BigInt</code> using the <code>BigInt</code> constructor.</p>
<p><strong>Example</strong> (Parsing BigInt from String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.BigInt)

// success cases
console.log(decode(&quot;1&quot;)) // 1n
console.log(decode(&quot;-1&quot;)) // -1n

// failure cases
decode(&quot;a&quot;)
/*
throws:
ParseError: bigint
└─ Transformation process failure
   └─ Expected bigint, actual &quot;a&quot;
*/
decode(&quot;1.5&quot;) // throws
decode(&quot;NaN&quot;) // throws
decode(&quot;Infinity&quot;) // throws
decode(&quot;-Infinity&quot;) // throws
</code></pre>
<h3>BigIntFromNumber</h3>
<p>Converts a number to a <code>BigInt</code> using the <code>BigInt</code> constructor.</p>
<p><strong>Example</strong> (Parsing BigInt from Number)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.BigIntFromNumber)
const encode = Schema.encodeSync(Schema.BigIntFromNumber)

// success cases
console.log(decode(1)) // 1n
console.log(decode(-1)) // -1n
console.log(encode(1n)) // 1
console.log(encode(-1n)) // -1

// failure cases
decode(1.5)
/*
throws:
ParseError: BigintFromNumber
└─ Transformation process failure
   └─ Expected BigintFromNumber, actual 1.5
*/

decode(NaN) // throws
decode(Infinity) // throws
decode(-Infinity) // throws
encode(BigInt(Number.MAX_SAFE_INTEGER) + 1n) // throws
encode(BigInt(Number.MIN_SAFE_INTEGER) - 1n) // throws
</code></pre>
<h3>clampBigInt</h3>
<p>Restricts a <code>BigInt</code> within a specified range.</p>
<p><strong>Example</strong> (Clamping BigInt)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

// clamps the input to -1n &lt;= x &lt;= 1n
const schema = Schema.BigIntFromSelf.pipe(Schema.clampBigInt(-1n, 1n))

const decode = Schema.decodeUnknownSync(schema)

console.log(decode(-3n))
// Output: -1n

console.log(decode(0n))
// Output: 0n

console.log(decode(3n))
// Output: 1n
</code></pre>
<h2>Date transformations</h2>
<h3>Date</h3>
<p>Converts a string into a <strong>valid</strong> <code>Date</code>, ensuring that invalid dates, such as <code>new Date(&quot;Invalid Date&quot;)</code>, are rejected.</p>
<p><strong>Example</strong> (Parsing and Validating Date)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.Date)

console.log(decode(&quot;1970-01-01T00:00:00.000Z&quot;))
// Output: 1970-01-01T00:00:00.000Z

decode(&quot;a&quot;)
/*
throws:
ParseError: Date
└─ Predicate refinement failure
   └─ Expected Date, actual Invalid Date
*/

const validate = Schema.validateSync(Schema.Date)

console.log(validate(new Date(0)))
// Output: 1970-01-01T00:00:00.000Z

console.log(validate(new Date(&quot;Invalid Date&quot;)))
/*
throws:
ParseError: Date
└─ Predicate refinement failure
   └─ Expected Date, actual Invalid Date
*/
</code></pre>
<h2>BigDecimal Transformations</h2>
<h3>BigDecimal</h3>
<p>Converts a string to a <code>BigDecimal</code>.</p>
<p><strong>Example</strong> (Parsing BigDecimal from String)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.BigDecimal)

console.log(decode(&quot;.124&quot;))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;124&#39;, scale: 3 }
</code></pre>
<h3>BigDecimalFromNumber</h3>
<p>Converts a number to a <code>BigDecimal</code>.</p>
<Aside type="caution" title="Invalid Range">
  When encoding, this Schema will produce incorrect results if the
  BigDecimal exceeds the 64-bit range of a number.
</Aside>

<p><strong>Example</strong> (Parsing BigDecimal from Number)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;

const decode = Schema.decodeUnknownSync(Schema.BigDecimalFromNumber)

console.log(decode(0.111))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;111&#39;, scale: 3 }
</code></pre>
<h3>clampBigDecimal</h3>
<p>Clamps a <code>BigDecimal</code> within a specified range.</p>
<p><strong>Example</strong> (Clamping BigDecimal)</p>
<pre><code class="language-ts">import { Schema } from &quot;effect&quot;
import { BigDecimal } from &quot;effect&quot;

const schema = Schema.BigDecimal.pipe(
  Schema.clampBigDecimal(
    BigDecimal.fromNumber(-1),
    BigDecimal.fromNumber(1)
  )
)

const decode = Schema.decodeUnknownSync(schema)

console.log(decode(&quot;-2&quot;))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;-1&#39;, scale: 0 }

console.log(decode(&quot;0&quot;))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;0&#39;, scale: 0 }

console.log(decode(&quot;3&quot;))
// Output: { _id: &#39;BigDecimal&#39;, value: &#39;1&#39;, scale: 0 }
</code></pre>
<hr>
<hr>
<h2>title: Sink Concurrency
excerpt: Learn how to enhance performance with concurrent sink operations, such as combining results or racing to capture the first completion.
sidebar:
  label: Concurrency
  order: 3</h2>
<p>This section covers concurrent operations that allow multiple sinks to run simultaneously. These can be valuable for enhancing task performance when concurrent execution is desired.</p>
<h2>Combining Results with Concurrent Zipping</h2>
<p>To run two sinks concurrently and combine their results, use <code>Sink.zip</code>. This operation executes both sinks concurrently and combines their outcomes into a tuple.</p>
<p><strong>Example</strong> (Running Two Sinks Concurrently and Combining Results)</p>
<pre><code class="language-ts">import { Sink, Console, Stream, Schedule, Effect } from &quot;effect&quot;

const stream = Stream.make(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).pipe(
  Stream.schedule(Schedule.spaced(&quot;10 millis&quot;))
)

const sink1 = Sink.forEach((s: string) =&gt;
  Console.log(`sink 1: ${s}`)
).pipe(Sink.as(1))

const sink2 = Sink.forEach((s: string) =&gt;
  Console.log(`sink 2: ${s}`)
).pipe(Sink.as(2))

// Combine the two sinks to run concurrently and collect results in a tuple
const sink = Sink.zip(sink1, sink2, { concurrent: true })

Effect.runPromise(Stream.run(stream, sink)).then(console.log)
/*
Output:
sink 1: 1
sink 2: 1
sink 1: 2
sink 2: 2
sink 1: 3
sink 2: 3
sink 1: 4
sink 2: 4
sink 1: 5
sink 2: 5
[ 1, 2 ]
*/
</code></pre>
<h2>Racing Sinks: First Completion Wins</h2>
<p>The <code>Sink.race</code> operation allows multiple sinks to compete for completion. The first sink to finish provides the result.</p>
<p><strong>Example</strong> (Racing Two Sinks to Capture the First Result)</p>
<pre><code class="language-ts">import { Sink, Console, Stream, Schedule, Effect } from &quot;effect&quot;

const stream = Stream.make(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;).pipe(
  Stream.schedule(Schedule.spaced(&quot;10 millis&quot;))
)

const sink1 = Sink.forEach((s: string) =&gt;
  Console.log(`sink 1: ${s}`)
).pipe(Sink.as(1))

const sink2 = Sink.forEach((s: string) =&gt;
  Console.log(`sink 2: ${s}`)
).pipe(Sink.as(2))

// Race the two sinks, the result will be from the first to complete
const sink = Sink.race(sink1, sink2)

Effect.runPromise(Stream.run(stream, sink)).then(console.log)
/*
Output:
sink 1: 1
sink 2: 1
sink 1: 2
sink 2: 2
sink 1: 3
sink 2: 3
sink 1: 4
sink 2: 4
sink 1: 5
sink 2: 5
1
*/
</code></pre>
<hr>
<hr>
<h2>title: Creating Sinks
description: Discover how to create and use various sinks for processing streams, including counting, summing, collecting, folding, and handling success or failure.
sidebar:
  order: 1</h2>
<p>In stream processing, sinks are used to consume and handle elements from a stream. Here, we&#39;ll explore various sink constructors that allow you to create sinks for specific tasks.</p>
<h2>Common Constructors</h2>
<h3>head</h3>
<p>The <code>Sink.head</code> sink retrieves only the first element from a stream, wrapping it in <code>Some</code>. If the stream has no elements, it returns <code>None</code>.</p>
<p><strong>Example</strong> (Retrieving the First Element)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const nonEmptyStream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(nonEmptyStream, Sink.head())).then(
  console.log
)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 }
*/

const emptyStream = Stream.empty

Effect.runPromise(Stream.run(emptyStream, Sink.head())).then(console.log)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;None&#39; }
*/
</code></pre>
<h3>last</h3>
<p>The <code>Sink.last</code> sink retrieves only the last element from a stream, wrapping it in <code>Some</code>. If the stream has no elements, it returns <code>None</code>.</p>
<p><strong>Example</strong> (Retrieving the Last Element)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const nonEmptyStream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(nonEmptyStream, Sink.last())).then(
  console.log
)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 4 }
*/

const emptyStream = Stream.empty

Effect.runPromise(Stream.run(emptyStream, Sink.last())).then(console.log)
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;None&#39; }
*/
</code></pre>
<h3>count</h3>
<p>The <code>Sink.count</code> sink consumes all elements of the stream and counts the number of elements fed to it.</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.count)).then(console.log)
// Output: 4
</code></pre>
<h3>sum</h3>
<p>The <code>Sink.sum</code> sink consumes all elements of the stream and sums incoming numeric values.</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.sum)).then(console.log)
// Output: 10
</code></pre>
<h3>take</h3>
<p>The <code>Sink.take</code> sink takes the specified number of values from the stream and results in a <a href="/docs/data-types/chunk/">Chunk</a> data type.</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.take(3))).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }
*/
</code></pre>
<h3>drain</h3>
<p>The <code>Sink.drain</code> sink ignores its inputs, effectively discarding them.</p>
<pre><code class="language-ts">import { Stream, Console, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4).pipe(Stream.tap(Console.log))

Effect.runPromise(Stream.run(stream, Sink.drain)).then(console.log)
/*
Output:
1
2
3
4
undefined
*/
</code></pre>
<h3>timed</h3>
<p>The <code>Sink.timed</code> sink executes the stream and measures its execution time, providing the <a href="/docs/data-types/duration/">Duration</a>.</p>
<pre><code class="language-ts">import { Stream, Schedule, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4).pipe(
  Stream.schedule(Schedule.spaced(&quot;100 millis&quot;))
)

Effect.runPromise(Stream.run(stream, Sink.timed)).then(console.log)
/*
Output:
{ _id: &#39;Duration&#39;, _tag: &#39;Millis&#39;, millis: 408 }
*/
</code></pre>
<h3>forEach</h3>
<p>The <code>Sink.forEach</code> sink executes the provided effectful function for every element fed to it.</p>
<pre><code class="language-ts">import { Stream, Console, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.forEach(Console.log))).then(
  console.log
)
/*
Output:
1
2
3
4
undefined
*/
</code></pre>
<h2>Creating Sinks from Success and Failure</h2>
<p>Just as you can define streams to hold or manipulate data, you can also create sinks with specific success or failure outcomes using the <code>Sink.fail</code> and <code>Sink.succeed</code> functions.</p>
<h3>Succeeding Sink</h3>
<p>This example creates a sink that doesn’t consume any elements from its upstream source but instead immediately succeeds with a specified numeric value:</p>
<p><strong>Example</strong> (Sink that Always Succeeds with a Value)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.succeed(0))).then(console.log)
// Output: 0
</code></pre>
<h3>Failing Sink</h3>
<p>In this example, the sink also doesn’t consume any elements from its upstream source. Instead, it fails with a specified error message of type <code>string</code>:</p>
<p><strong>Example</strong> (Sink that Always Fails with an Error Message)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromiseExit(Stream.run(stream, Sink.fail(&quot;fail!&quot;))).then(
  console.log
)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;fail!&#39; }
}
*/
</code></pre>
<h2>Collecting</h2>
<h3>Collecting All Elements</h3>
<p>To gather all elements from a data stream into a <a href="/docs/data-types/chunk/">Chunk</a>, use the <code>Sink.collectAll</code> sink.</p>
<p>The final output is a chunk containing all elements from the stream, in the order they were emitted.</p>
<p><strong>Example</strong> (Collecting All Stream Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(Stream.run(stream, Sink.collectAll())).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4 ] }
*/
</code></pre>
<h3>Collecting a Specified Number</h3>
<p>To collect a fixed number of elements from a stream into a <a href="/docs/data-types/chunk/">Chunk</a>, use <code>Sink.collectAllN</code>. This sink stops collecting once it reaches the specified limit.</p>
<p><strong>Example</strong> (Collecting a Limited Number of Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4, 5)

Effect.runPromise(
  Stream.run(
    stream,
    // Collect the first 3 elements into a Chunk
    Sink.collectAllN(3)
  )
).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }
*/
</code></pre>
<h3>Collecting While Meeting a Condition</h3>
<p>To gather elements from a stream while they satisfy a specific condition, use <code>Sink.collectAllWhile</code>. This sink collects elements until the provided predicate returns <code>false</code>.</p>
<p><strong>Example</strong> (Collecting Elements Until a Condition Fails)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 0, 4, 0, 6, 7)

Effect.runPromise(
  Stream.run(
    stream,
    // Collect elements while they are not equal to 0
    Sink.collectAllWhile((n) =&gt; n !== 0)
  )
).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
*/
</code></pre>
<h3>Collecting into a HashSet</h3>
<p>To accumulate stream elements into a <code>HashSet</code>, use <code>Sink.collectAllToSet()</code>. This ensures that each element appears only once in the final set.</p>
<p><strong>Example</strong> (Collecting Unique Elements into a HashSet)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 2, 3, 4, 4)

Effect.runPromise(Stream.run(stream, Sink.collectAllToSet())).then(
  console.log
)
/*
Output:
{ _id: &#39;HashSet&#39;, values: [ 1, 2, 3, 4 ] }
*/
</code></pre>
<h3>Collecting into HashSets of a Specific Size</h3>
<p>For controlled collection into a <code>HashSet</code> with a specified maximum size, use <code>Sink.collectAllToSetN</code>. This sink gathers unique elements up to the given limit.</p>
<p><strong>Example</strong> (Collecting Unique Elements with a Set Size Limit)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 2, 3, 4, 4)

Effect.runPromise(
  Stream.run(
    stream,
    // Collect unique elements, limiting the set size to 3
    Sink.collectAllToSetN(3)
  )
).then(console.log)
/*
Output:
{ _id: &#39;HashSet&#39;, values: [ 1, 2, 3 ] }
*/
</code></pre>
<h3>Collecting into a HashMap</h3>
<p>For more complex collection scenarios, <code>Sink.collectAllToMap</code> lets you gather elements into a <code>HashMap&lt;K, A&gt;</code> with a specified keying and merging strategy.
This sink requires both a key function to define each element&#39;s grouping and a merge function to combine values sharing the same key.</p>
<p><strong>Example</strong> (Grouping and Merging Stream Elements in a HashMap)</p>
<p>In this example, we use <code>(n) =&gt; n % 3</code> to determine map keys and <code>(a, b) =&gt; a + b</code> to merge elements with the same key:</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 3, 2, 3, 1, 5, 1)

Effect.runPromise(
  Stream.run(
    stream,
    Sink.collectAllToMap(
      (n) =&gt; n % 3, // Key function to group by element value
      (a, b) =&gt; a + b // Merge function to sum values with the same key
    )
  )
).then(console.log)
/*
Output:
{ _id: &#39;HashMap&#39;, values: [ [ 0, 6 ], [ 1, 3 ], [ 2, 7 ] ] }
*/
</code></pre>
<h3>Collecting into a HashMap with Limited Keys</h3>
<p>To accumulate elements into a <code>HashMap</code> with a maximum number of keys, use <code>Sink.collectAllToMapN</code>. This sink collects elements until it reaches the specified key limit, requiring a key function to define the grouping of each element and a merge function to combine values with the same key.</p>
<p><strong>Example</strong> (Limiting Collected Keys in a HashMap)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 3, 2, 3, 1, 5, 1)

Effect.runPromise(
  Stream.run(
    stream,
    Sink.collectAllToMapN(
      3, // Maximum of 3 keys
      (n) =&gt; n, // Key function to group by element value
      (a, b) =&gt; a + b // Merge function to sum values with the same key
    )
  )
).then(console.log)
/*
Output:
{ _id: &#39;HashMap&#39;, values: [ [ 1, 2 ], [ 2, 2 ], [ 3, 6 ] ] }
*/
</code></pre>
<h2>Folding</h2>
<h3>Folding Left</h3>
<p>If you want to reduce a stream into a single cumulative value by applying an operation to each element in sequence, you can use the <code>Sink.foldLeft</code> function.</p>
<p><strong>Example</strong> (Summing Elements in a Stream Using Fold Left)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(
  Stream.run(
    stream,
    // Use foldLeft to sequentially add each element, starting with 0
    Sink.foldLeft(0, (a, b) =&gt; a + b)
  )
).then(console.log)
// Output: 10
</code></pre>
<h3>Folding with Termination</h3>
<p>Sometimes, you may want to fold elements in a stream but stop the process once a specific condition is met. This is known as &quot;short-circuiting.&quot; You can accomplish this with the <code>Sink.fold</code> function, which lets you define a termination condition.</p>
<p><strong>Example</strong> (Folding with a Condition to Stop Early)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.iterate(0, (n) =&gt; n + 1)

Effect.runPromise(
  Stream.run(
    stream,
    Sink.fold(
      0, // Initial value
      (sum) =&gt; sum &lt;= 10, // Termination condition
      (a, b) =&gt; a + b // Folding operation
    )
  )
).then(console.log)
// Output: 15
</code></pre>
<h3>Folding Until a Limit</h3>
<p>To accumulate elements until a specific count is reached, use <code>Sink.foldUntil</code>. This sink folds elements up to the specified limit and then stops.</p>
<p><strong>Example</strong> (Accumulating a Set Number of Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

Effect.runPromise(
  Stream.run(
    stream,
    // Fold elements, stopping after accumulating 3 values
    Sink.foldUntil(0, 3, (a, b) =&gt; a + b)
  )
).then(console.log)
// Output: 6
</code></pre>
<h3>Folding with Weighted Elements</h3>
<p>In some scenarios, you may want to fold elements based on a defined &quot;weight&quot; or &quot;cost,&quot; accumulating elements until a specified maximum cost is reached. You can accomplish this with <code>Sink.foldWeighted</code>.</p>
<p><strong>Example</strong> (Accumulating Elements Based on Weight)</p>
<p>In the example below, each element has a weight of <code>1</code>, and the folding resets when the accumulated weight hits <code>3</code>.</p>
<pre><code class="language-ts">import { Stream, Sink, Chunk, Effect } from &quot;effect&quot;

const stream = Stream.make(3, 2, 4, 1, 5, 6, 2, 1, 3, 5, 6).pipe(
  Stream.transduce(
    Sink.foldWeighted({
      initial: Chunk.empty&lt;number&gt;(), // Initial empty Chunk
      maxCost: 3, // Maximum accumulated cost
      cost: () =&gt; 1, // Each element has a weight of 1
      body: (acc, el) =&gt; Chunk.append(acc, el) // Append element to the Chunk
    })
  )
)

Effect.runPromise(Stream.runCollect(stream)).then((chunk) =&gt;
  console.log(&quot;%o&quot;, chunk)
)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    { _id: &#39;Chunk&#39;, values: [ 3, 2, 4, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 1, 5, 6, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 2, 1, 3, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 5, 6, [length]: 2 ] },
    [length]: 4
  ]
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Introduction
description: Learn the role of Sink in stream processing, handling element consumption, error management, result production, and leftover elements.
sidebar:
  order: 0</h2>
<p>In stream processing, a <code>Sink</code> is a construct designed to consume elements generated by a <code>Stream</code>.</p>
<pre><code class="language-text">     ┌─── Type of the result produced by the Sink
     |  ┌─── Type of elements consumed by the Sink
     |  |   ┌─── Type of any leftover elements
     │  |   |  ┌─── Type of possible errors
     │  │   |  |  ┌─── Type of required dependencies
     ▼  ▼   ▼  ▼  ▼
Sink&lt;A, In, L, E, R&gt;
</code></pre>
<p>Here&#39;s an overview of what a <code>Sink</code> does:</p>
<ul>
<li>It consumes a varying number of <code>In</code> elements, which may include zero, one, or multiple elements.</li>
<li>It can encounter errors of type <code>E</code> during processing.</li>
<li>It produces a result of type <code>A</code> once processing completes.</li>
<li>It can also return a remainder of type <code>L</code>, representing any leftover elements.</li>
</ul>
<p>To process a stream using a <code>Sink</code>, you can pass it directly to the <code>Stream.run</code> function:</p>
<p><strong>Example</strong> (Using a Sink to Collect Stream Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

//      ┌─── Stream&lt;number, never, never&gt;
//      ▼
const stream = Stream.make(1, 2, 3)

// Create a sink to take the first 2 elements of the stream
//
//      ┌─── Sink&lt;Chunk&lt;number&gt;, number, number, never, never&gt;
//      ▼
const sink = Sink.take&lt;number&gt;(2)

// Run the stream through the sink to collect the elements
//
//      ┌─── Effect&lt;number, never, never&gt;
//      ▼
const sum = Stream.run(stream, sink)

Effect.runPromise(sum).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
*/
</code></pre>
<p>The type of <code>sink</code> is as follows:</p>
<pre><code class="language-text">       ┌─── result
       |              ┌─── consumed elements
       |              |       ┌─── leftover elements
       │              |       |       ┌─── no errors
       │              │       |       |      ┌─── no dependencies
       ▼              ▼       ▼       ▼      ▼
Sink&lt;Chunk&lt;number&gt;, number, number, never, never&gt;
</code></pre>
<p>Here&#39;s the breakdown:</p>
<ul>
<li><code>Chunk&lt;number&gt;</code>: The final result produced by the sink after processing elements (in this case, a <a href="/docs/data-types/chunk/">Chunk</a> of numbers).</li>
<li><code>number</code> (first occurrence): The type of elements that the sink will consume from the stream.</li>
<li><code>number</code> (second occurrence): The type of leftover elements, if any, that are not consumed.</li>
<li><code>never</code> (first occurrence): Indicates that this sink does not produce any errors.</li>
<li><code>never</code> (second occurrence): Shows that no dependencies are required to operate this sink.</li>
</ul>
<hr>
<hr>
<h2>title: Leftovers
description: Learn how to handle unconsumed elements in streams, collecting or ignoring leftovers for efficient data processing.
sidebar:
  order: 4</h2>
<p>In this section, we&#39;ll look at handling elements left unconsumed by sinks. Sinks may process only a portion of the elements from an upstream source, leaving some elements as &quot;leftovers.&quot; Here&#39;s how to collect or ignore these remaining elements.</p>
<h2>Collecting Leftovers</h2>
<p>If a sink doesn&#39;t consume all elements from the upstream source, the remaining elements are called leftovers. To capture these leftovers, use <code>Sink.collectLeftover</code>, which returns a tuple containing the result of the sink operation and any unconsumed elements.</p>
<p><strong>Example</strong> (Collecting Leftover Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4, 5)

// Take the first 3 elements and collect any leftovers
const sink1 = Sink.take&lt;number&gt;(3).pipe(Sink.collectLeftover)

Effect.runPromise(Stream.run(stream, sink1)).then(console.log)
/*
Output:
[
  { _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] },
  { _id: &#39;Chunk&#39;, values: [ 4, 5 ] }
]
*/

// Take only the first element and collect the rest as leftovers
const sink2 = Sink.head&lt;number&gt;().pipe(Sink.collectLeftover)

Effect.runPromise(Stream.run(stream, sink2)).then(console.log)
/*
Output:
[
  { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 1 },
  { _id: &#39;Chunk&#39;, values: [ 2, 3, 4, 5 ] }
]
*/
</code></pre>
<h2>Ignoring Leftovers</h2>
<p>If leftover elements are not needed, you can ignore them using <code>Sink.ignoreLeftover</code>. This approach discards any unconsumed elements, so the sink operation focuses only on the elements it needs.</p>
<p><strong>Example</strong> (Ignoring Leftover Elements)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4, 5)

// Take the first 3 elements and ignore any remaining elements
const sink = Sink.take&lt;number&gt;(3).pipe(
  Sink.ignoreLeftover,
  Sink.collectLeftover
)

Effect.runPromise(Stream.run(stream, sink)).then(console.log)
/*
Output:
[ { _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }, { _id: &#39;Chunk&#39;, values: [] } ]
*/
</code></pre>
<hr>
<hr>
<h2>title: Sink Operations
description: Explore operations to transform, filter, and adapt sinks, enabling custom input-output handling and element filtering in stream processing.
sidebar:
  label: Operations
  order: 2</h2>
<p>In previous sections, we learned how to create and use sinks. Now, let&#39;s explore some operations that let you transform or filter sink behavior.</p>
<h2>Adapting Sink Input</h2>
<p>At times, you may have a sink that works with one type of input, but your current stream uses a different type. The <code>Sink.mapInput</code> function helps you adapt your sink to a new input type by transforming the input values. While <code>Sink.map</code> changes the sink&#39;s output, <code>Sink.mapInput</code> changes the input it accepts.</p>
<p><strong>Example</strong> (Converting String Input to Numeric for Summing)</p>
<p>Suppose you have a <code>Sink.sum</code> that calculates the sum of numbers. If your stream contains strings rather than numbers, <code>Sink.mapInput</code> can convert those strings into numbers, allowing <code>Sink.sum</code> to work with your stream:</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

// A stream of numeric strings
const stream = Stream.make(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)

// Define a sink for summing numeric values
const numericSum = Sink.sum

// Use mapInput to adapt the sink, converting strings to numbers
const stringSum = numericSum.pipe(
  Sink.mapInput((s: string) =&gt; Number.parseFloat(s))
)

Effect.runPromise(Stream.run(stream, stringSum)).then(console.log)
// Output: 15
</code></pre>
<h2>Transforming Both Input and Output</h2>
<p>When you need to transform both the input and output of a sink, <code>Sink.dimap</code> provides a flexible solution. It extends <code>mapInput</code> by allowing you to transform the input type, perform the operation, and then transform the output to a new type. This can be useful for complete conversions between input and output types.</p>
<p><strong>Example</strong> (Converting Input to Integer, Summing, and Converting Output to String)</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

// A stream of numeric strings
const stream = Stream.make(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)

// Convert string inputs to numbers, sum them,
// then convert the result to a string
const sumSink = Sink.dimap(Sink.sum, {
  // Transform input: string to number
  onInput: (s: string) =&gt; Number.parseFloat(s),
  // Transform output: number to string
  onDone: (n) =&gt; String(n)
})

Effect.runPromise(Stream.run(stream, sumSink)).then(console.log)
// Output: &quot;15&quot;
</code></pre>
<h2>Filtering Input</h2>
<p>Sinks can also filter incoming elements based on specific conditions with <code>Sink.filterInput</code>. This operation allows the sink to process only elements that meet certain criteria.</p>
<p><strong>Example</strong> (Filtering Negative Numbers in Chunks of Three)</p>
<p>In the example below, elements are collected in chunks of three, but only positive numbers are included:</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

// Define a stream with positive, negative, and zero values
const stream = Stream.fromIterable([
  1, -2, 0, 1, 3, -3, 4, 2, 0, 1, -3, 1, 1, 6
]).pipe(
  Stream.transduce(
    // Collect chunks of 3, filtering out non-positive numbers
    Sink.collectAllN&lt;number&gt;(3).pipe(Sink.filterInput((n) =&gt; n &gt; 0))
  )
)

Effect.runPromise(Stream.runCollect(stream)).then((chunk) =&gt;
  console.log(&quot;%o&quot;, chunk)
)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    { _id: &#39;Chunk&#39;, values: [ 1, 1, 3, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 4, 2, 1, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 1, 1, 6, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ [length]: 0 ] },
    [length]: 4
  ]
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Ref
description: Learn how to manage state in concurrent applications using Effect&#39;s Ref data type. Master mutable references for safe, controlled state updates across fibers.
sidebar:
  order: 0</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>When we write programs, it is common to need to keep track of some form of state during the execution of the program. State refers to any data that can change as the program runs. For example, in a counter application, the count value changes as the user increments or decrements it. Similarly, in a banking application, the account balance changes as deposits and withdrawals are made. State management is crucial to building interactive and dynamic applications.</p>
<p>In traditional imperative programming, one common way to store state is using variables. However, this approach can introduce bugs, especially when the state is shared between multiple components or functions. As the program becomes more complex, managing shared state can become challenging.</p>
<p>To overcome these issues, Effect introduces a powerful data type called <code>Ref</code>, which represents a mutable reference. With <code>Ref</code>, we can share state between different parts of our program without relying on mutable variables directly. Instead, <code>Ref</code> provides a controlled way to handle mutable state and safely update it in a concurrent environment.</p>
<p>Effect&#39;s <code>Ref</code> data type enables communication between different fibers in your program. This capability is crucial in concurrent programming, where multiple tasks may need to access and update shared state simultaneously.</p>
<p>In this guide, we will explore how to use the <code>Ref</code> data type to manage state in your programs effectively. We will cover simple examples like counting, as well as more complex scenarios where state is shared between different parts of the program. Additionally, we will show how to use <code>Ref</code> in a concurrent environment, allowing multiple tasks to interact with shared state safely.</p>
<p>Let&#39;s dive in and see how we can leverage <code>Ref</code> for effective state management in your Effect programs.</p>
<h2>Using Ref</h2>
<p>Here is a simple example using <code>Ref</code> to create a counter:</p>
<p><strong>Example</strong> (Basic Counter with <code>Ref</code>)</p>
<pre><code class="language-ts">import { Effect, Ref } from &quot;effect&quot;

class Counter {
  inc: Effect.Effect&lt;void&gt;
  dec: Effect.Effect&lt;void&gt;
  get: Effect.Effect&lt;number&gt;

  constructor(private value: Ref.Ref&lt;number&gt;) {
    this.inc = Ref.update(this.value, (n) =&gt; n + 1)
    this.dec = Ref.update(this.value, (n) =&gt; n - 1)
    this.get = Ref.get(this.value)
  }
}

const make = Effect.andThen(Ref.make(0), (value) =&gt; new Counter(value))
</code></pre>
<p><strong>Example</strong> (Using the Counter)</p>
<pre><code class="language-ts">import { Effect, Ref } from &quot;effect&quot;

class Counter {
  inc: Effect.Effect&lt;void&gt;
  dec: Effect.Effect&lt;void&gt;
  get: Effect.Effect&lt;number&gt;

  constructor(private value: Ref.Ref&lt;number&gt;) {
    this.inc = Ref.update(this.value, (n) =&gt; n + 1)
    this.dec = Ref.update(this.value, (n) =&gt; n - 1)
    this.get = Ref.get(this.value)
  }
}

const make = Effect.andThen(Ref.make(0), (value) =&gt; new Counter(value))

const program = Effect.gen(function* () {
  const counter = yield* make
  yield* counter.inc
  yield* counter.inc
  yield* counter.dec
  yield* counter.inc
  const value = yield* counter.get
  console.log(`This counter has a value of ${value}.`)
})

Effect.runPromise(program)
/*
Output:
This counter has a value of 2.
*/
</code></pre>
<Aside type="note" title="Ref Operations Are Effectful">
  All the operations on the `Ref` data type are effectful. So when we are
  reading from or writing to a `Ref`, we are performing an effectful
  operation.
</Aside>

<h2>Using Ref in a Concurrent Environment</h2>
<p>We can also use <code>Ref</code> in concurrent scenarios, where multiple tasks might be updating shared state at the same time.</p>
<p><strong>Example</strong> (Concurrent Updates to Shared Counter)</p>
<p>For this example, let&#39;s update the counter concurrently:</p>
<pre><code class="language-ts">import { Effect, Ref } from &quot;effect&quot;

class Counter {
  inc: Effect.Effect&lt;void&gt;
  dec: Effect.Effect&lt;void&gt;
  get: Effect.Effect&lt;number&gt;

  constructor(private value: Ref.Ref&lt;number&gt;) {
    this.inc = Ref.update(this.value, (n) =&gt; n + 1)
    this.dec = Ref.update(this.value, (n) =&gt; n - 1)
    this.get = Ref.get(this.value)
  }
}

const make = Effect.andThen(Ref.make(0), (value) =&gt; new Counter(value))

const program = Effect.gen(function* () {
  const counter = yield* make

  // Helper to log the counter&#39;s value before running an effect
  const logCounter = &lt;R, E, A&gt;(
    label: string,
    effect: Effect.Effect&lt;A, E, R&gt;
  ) =&gt;
    Effect.gen(function* () {
      const value = yield* counter.get
      yield* Effect.log(`${label} get: ${value}`)
      return yield* effect
    })

  yield* logCounter(&quot;task 1&quot;, counter.inc).pipe(
    Effect.zip(logCounter(&quot;task 2&quot;, counter.inc), { concurrent: true }),
    Effect.zip(logCounter(&quot;task 3&quot;, counter.dec), { concurrent: true }),
    Effect.zip(logCounter(&quot;task 4&quot;, counter.inc), { concurrent: true })
  )
  const value = yield* counter.get
  yield* Effect.log(`This counter has a value of ${value}.`)
})

Effect.runPromise(program)
/*
Output:
timestamp=... fiber=#3 message=&quot;task 4 get: 0&quot;
timestamp=... fiber=#6 message=&quot;task 3 get: 1&quot;
timestamp=... fiber=#8 message=&quot;task 1 get: 0&quot;
timestamp=... fiber=#9 message=&quot;task 2 get: 1&quot;
timestamp=... fiber=#0 message=&quot;This counter has a value of 2.&quot;
*/
</code></pre>
<h2>Using Ref as a Service</h2>
<p>You can pass a <code>Ref</code> as a <a href="/docs/requirements-management/services/">service</a> to share state across different parts of your program.</p>
<p><strong>Example</strong> (Using <code>Ref</code> as a Service)</p>
<pre><code class="language-ts">import { Effect, Context, Ref } from &quot;effect&quot;

// Create a Tag for our state
class MyState extends Context.Tag(&quot;MyState&quot;)&lt;
  MyState,
  Ref.Ref&lt;number&gt;
&gt;() {}

// Subprogram 1: Increment the state value twice
const subprogram1 = Effect.gen(function* () {
  const state = yield* MyState
  yield* Ref.update(state, (n) =&gt; n + 1)
  yield* Ref.update(state, (n) =&gt; n + 1)
})

// Subprogram 2: Decrement the state value and then increment it
const subprogram2 = Effect.gen(function* () {
  const state = yield* MyState
  yield* Ref.update(state, (n) =&gt; n - 1)
  yield* Ref.update(state, (n) =&gt; n + 1)
})

// Subprogram 3: Read and log the current value of the state
const subprogram3 = Effect.gen(function* () {
  const state = yield* MyState
  const value = yield* Ref.get(state)
  console.log(`MyState has a value of ${value}.`)
})

// Compose subprograms 1, 2, and 3 to create the main program
const program = Effect.gen(function* () {
  yield* subprogram1
  yield* subprogram2
  yield* subprogram3
})

// Create a Ref instance with an initial value of 0
const initialState = Ref.make(0)

// Provide the Ref as a service
const runnable = program.pipe(
  Effect.provideServiceEffect(MyState, initialState)
)

// Run the program and observe the output
Effect.runPromise(runnable)
/*
Output:
MyState has a value of 2.
*/
</code></pre>
<p>Note that we use <code>Effect.provideServiceEffect</code> instead of <code>Effect.provideService</code> to provide an actual implementation of the <code>MyState</code> service because all the operations on the <code>Ref</code> data type are effectful, including the creation <code>Ref.make(0)</code>.</p>
<h2>Sharing State Between Fibers</h2>
<p>You can use <code>Ref</code> to manage shared state between multiple fibers in a concurrent environment.</p>
<p><strong>Example</strong> (Managing Shared State Across Fibers)</p>
<p>Let&#39;s look at an example where we continuously read names from user input until the user enters <code>&quot;q&quot;</code> to exit.</p>
<p>First, let&#39;s introduce a <code>readLine</code> utility to read user input (ensure you have <code>@types/node</code> installed):</p>
<pre><code class="language-ts">import { Effect } from &quot;effect&quot;
import * as NodeReadLine from &quot;node:readline&quot;

// Utility to read user input
const readLine = (message: string): Effect.Effect&lt;string&gt; =&gt;
  Effect.promise(
    () =&gt;
      new Promise((resolve) =&gt; {
        const rl = NodeReadLine.createInterface({
          input: process.stdin,
          output: process.stdout
        })
        rl.question(message, (answer) =&gt; {
          rl.close()
          resolve(answer)
        })
      })
  )
</code></pre>
<p>Next, we implement the main program to collect names:</p>
<pre><code class="language-ts">import { Effect, Chunk, Ref } from &quot;effect&quot;
import * as NodeReadLine from &quot;node:readline&quot;

// Utility to read user input
const readLine = (message: string): Effect.Effect&lt;string&gt; =&gt;
  Effect.promise(
    () =&gt;
      new Promise((resolve) =&gt; {
        const rl = NodeReadLine.createInterface({
          input: process.stdin,
          output: process.stdout
        })
        rl.question(message, (answer) =&gt; {
          rl.close()
          resolve(answer)
        })
      })
  )

const getNames = Effect.gen(function* () {
  const ref = yield* Ref.make(Chunk.empty&lt;string&gt;())
  while (true) {
    const name = yield* readLine(&quot;Please enter a name or `q` to exit: &quot;)
    if (name === &quot;q&quot;) {
      break
    }
    yield* Ref.update(ref, (state) =&gt; Chunk.append(state, name))
  }
  return yield* Ref.get(ref)
})

Effect.runPromise(getNames).then(console.log)
/*
Output:
Please enter a name or `q` to exit: Alice
Please enter a name or `q` to exit: Bob
Please enter a name or `q` to exit: q
{
  _id: &quot;Chunk&quot;,
  values: [ &quot;Alice&quot;, &quot;Bob&quot; ]
}
*/
</code></pre>
<p>Now that we have learned how to use the <code>Ref</code> data type, we can use it to manage the state concurrently.</p>
<p>For example, assume while we are reading from the console, we have another fiber that is trying to update the state from a different source.</p>
<p>Here, one fiber reads names from user input, while another fiber concurrently adds preset names at regular intervals:</p>
<pre><code class="language-ts">import { Effect, Chunk, Ref, Fiber } from &quot;effect&quot;
import * as NodeReadLine from &quot;node:readline&quot;

// Utility to read user input
const readLine = (message: string): Effect.Effect&lt;string&gt; =&gt;
  Effect.promise(
    () =&gt;
      new Promise((resolve) =&gt; {
        const rl = NodeReadLine.createInterface({
          input: process.stdin,
          output: process.stdout
        })
        rl.question(message, (answer) =&gt; {
          rl.close()
          resolve(answer)
        })
      })
  )

const getNames = Effect.gen(function* () {
  const ref = yield* Ref.make(Chunk.empty&lt;string&gt;())

  // Fiber 1: Reading names from user input
  const fiber1 = yield* Effect.fork(
    Effect.gen(function* () {
      while (true) {
        const name = yield* readLine(
          &quot;Please enter a name or `q` to exit: &quot;
        )
        if (name === &quot;q&quot;) {
          break
        }
        yield* Ref.update(ref, (state) =&gt; Chunk.append(state, name))
      }
    })
  )

  // Fiber 2: Updating the state with predefined names
  const fiber2 = yield* Effect.fork(
    Effect.gen(function* () {
      for (const name of [&quot;John&quot;, &quot;Jane&quot;, &quot;Joe&quot;, &quot;Tom&quot;]) {
        yield* Ref.update(ref, (state) =&gt; Chunk.append(state, name))
        yield* Effect.sleep(&quot;1 second&quot;)
      }
    })
  )
  yield* Fiber.join(fiber1)
  yield* Fiber.join(fiber2)
  return yield* Ref.get(ref)
})

Effect.runPromise(getNames).then(console.log)
/*
Output:
Please enter a name or `q` to exit: Alice
Please enter a name or `q` to exit: Bob
Please enter a name or `q` to exit: q
{
  _id: &quot;Chunk&quot;,
  // Note: the following result may vary
  // depending on the speed of user input
  values: [ &#39;John&#39;, &#39;Jane&#39;, &#39;Joe&#39;, &#39;Tom&#39;, &#39;Alice&#39;, &#39;Bob&#39; ]
}
*/
</code></pre>
<hr>
<hr>
<h2>title: SubscriptionRef
description: Learn how to manage shared state with SubscriptionRef in Effect, enabling multiple observers to subscribe to and react to state changes efficiently in concurrent environments.
sidebar:
  order: 2</h2>
<p>A <code>SubscriptionRef&lt;A&gt;</code> is a specialized form of a <a href="/docs/state-management/synchronizedref/">SynchronizedRef</a>. It allows us to subscribe and receive updates on the current value and any changes made to that value.</p>
<pre><code class="language-ts">interface SubscriptionRef&lt;A&gt; extends SynchronizedRef&lt;A&gt; {
  /**
   * A stream containing the current value of the `Ref` as well as all changes
   * to that value.
   */
  readonly changes: Stream&lt;A&gt;
}
</code></pre>
<p>You can perform all standard operations on a <code>SubscriptionRef</code>, such as <code>get</code>, <code>set</code>, or <code>modify</code> to interact with the current value.</p>
<p>The key feature of <code>SubscriptionRef</code> is its <code>changes</code> stream. This stream allows you to observe the current value at the moment of subscription and receive all subsequent changes. Every time the stream is run, it emits the current value and tracks future updates.</p>
<p>To create a <code>SubscriptionRef</code>, you can use the <code>SubscriptionRef.make</code> constructor, specifying the initial value:</p>
<p><strong>Example</strong> (Creating a <code>SubscriptionRef</code>)</p>
<pre><code class="language-ts">import { SubscriptionRef } from &quot;effect&quot;

const ref = SubscriptionRef.make(0)
</code></pre>
<p><code>SubscriptionRef</code> is particularly useful for modeling shared state when multiple observers need to react to changes. For example, in functional reactive programming, the <code>SubscriptionRef</code> could represent a portion of the application state, and various observers (like UI components) would update in response to state changes.</p>
<p><strong>Example</strong> (Server-Client Model with <code>SubscriptionRef</code>)</p>
<p>In the following example, a &quot;server&quot; continually updates a shared value, while multiple &quot;clients&quot; observe the changes:</p>
<pre><code class="language-ts">import { Ref, Effect } from &quot;effect&quot;

// Server function that increments a shared value forever
const server = (ref: Ref.Ref&lt;number&gt;) =&gt;
  Ref.update(ref, (n) =&gt; n + 1).pipe(Effect.forever)
</code></pre>
<p>The <code>server</code> function operates on a regular <code>Ref</code> and continuously updates the value. It doesn&#39;t need to know about <code>SubscriptionRef</code> directly.</p>
<p>Next, let&#39;s define a <code>client</code> that subscribes to changes and collects a specified number of values:</p>
<pre><code class="language-ts">import { Ref, Effect, Stream, Random } from &quot;effect&quot;

// Server function that increments a shared value forever
const server = (ref: Ref.Ref&lt;number&gt;) =&gt;
  Ref.update(ref, (n) =&gt; n + 1).pipe(Effect.forever)

// Client function that observes the stream of changes
const client = (changes: Stream.Stream&lt;number&gt;) =&gt;
  Effect.gen(function* () {
    const n = yield* Random.nextIntBetween(1, 10)
    const chunk = yield* Stream.runCollect(Stream.take(changes, n))
    return chunk
  })
</code></pre>
<p>Similarly, the <code>client</code> function only works with a <code>Stream</code> of values and doesn&#39;t concern itself with the source of these values.</p>
<p>To tie everything together, we start the server, launch multiple client instances in parallel, and then shut down the server when we&#39;re finished. We also create the <code>SubscriptionRef</code> in this process.</p>
<pre><code class="language-ts">import {
  Ref,
  Effect,
  Stream,
  Random,
  SubscriptionRef,
  Fiber
} from &quot;effect&quot;

// Server function that increments a shared value forever
const server = (ref: Ref.Ref&lt;number&gt;) =&gt;
  Ref.update(ref, (n) =&gt; n + 1).pipe(Effect.forever)

// Client function that observes the stream of changes
const client = (changes: Stream.Stream&lt;number&gt;) =&gt;
  Effect.gen(function* () {
    const n = yield* Random.nextIntBetween(1, 10)
    const chunk = yield* Stream.runCollect(Stream.take(changes, n))
    return chunk
  })

const program = Effect.gen(function* () {
  // Create a SubscriptionRef with an initial value of 0
  const ref = yield* SubscriptionRef.make(0)

  // Fork the server to run concurrently
  const serverFiber = yield* Effect.fork(server(ref))

  // Create 5 clients that subscribe to the changes stream
  const clients = new Array(5).fill(null).map(() =&gt; client(ref.changes))

  // Run all clients in concurrently and collect their results
  const chunks = yield* Effect.all(clients, { concurrency: &quot;unbounded&quot; })

  // Interrupt the server when clients are done
  yield* Fiber.interrupt(serverFiber)

  // Output the results collected by each client
  for (const chunk of chunks) {
    console.log(chunk)
  }
})

Effect.runPromise(program)
/*
Example Output:
{ _id: &#39;Chunk&#39;, values: [ 4, 5, 6, 7, 8, 9 ] }
{ _id: &#39;Chunk&#39;, values: [ 4 ] }
{ _id: &#39;Chunk&#39;, values: [ 4, 5, 6, 7, 8, 9 ] }
{ _id: &#39;Chunk&#39;, values: [ 4, 5 ] }
{ _id: &#39;Chunk&#39;, values: [ 4, 5, 6, 7, 8, 9 ] }
*/
</code></pre>
<p>This setup ensures that each client observes the current value when it starts and receives all subsequent changes to the value.</p>
<p>Since the changes are represented as streams, you can easily build more complex programs using familiar stream operators. You can transform, filter, or merge these streams with other streams to achieve more sophisticated behavior.</p>
<hr>
<hr>
<h2>title: SynchronizedRef
description: Master concurrent state management with SynchronizedRef in Effect, a mutable reference that supports atomic, effectful updates to shared state in concurrent environments.
sidebar:
  order: 1</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p><code>SynchronizedRef&lt;A&gt;</code> serves as a mutable reference to a value of type <code>A</code>.
With it, we can store <strong>immutable</strong> data and perform updates <strong>atomically</strong> and effectfully.</p>
<Aside type="tip" title="Learn Ref First">
  Most of the operations for `SynchronizedRef` are similar to those of
  `Ref`. If you're not already familiar with `Ref`, it's recommended to
  read about [the Ref concept](/docs/state-management/ref/) first.
</Aside>

<p>The distinctive function in <code>SynchronizedRef</code> is <code>updateEffect</code>.
This function takes an effectful operation and executes it to modify the shared state.
This is the key feature setting <code>SynchronizedRef</code> apart from <code>Ref</code>.</p>
<p>In real-world applications, <code>SynchronizedRef</code> is useful when you need to execute effects, such as querying a database, and then update shared state based on the result. It ensures that updates happen sequentially, preserving consistency in concurrent environments.</p>
<p><strong>Example</strong> (Concurrent Updates with <code>SynchronizedRef</code>)</p>
<p>In this example, we simulate fetching user ages concurrently and updating a shared state that stores the ages:</p>
<pre><code class="language-ts">import { Effect, SynchronizedRef } from &quot;effect&quot;

// Simulated API to get user age
const getUserAge = (userId: number) =&gt;
  Effect.succeed(userId * 10).pipe(Effect.delay(10 - userId))

const meanAge = Effect.gen(function* () {
  // Initialize a SynchronizedRef to hold an array of ages
  const ref = yield* SynchronizedRef.make&lt;number[]&gt;([])

  // Helper function to log state before each effect
  const log = &lt;R, E, A&gt;(label: string, effect: Effect.Effect&lt;A, E, R&gt;) =&gt;
    Effect.gen(function* () {
      const value = yield* SynchronizedRef.get(ref)
      yield* Effect.log(label, value)
      return yield* effect
    })

  const task = (id: number) =&gt;
    log(
      `task ${id}`,
      SynchronizedRef.updateEffect(ref, (sumOfAges) =&gt;
        Effect.gen(function* () {
          const age = yield* getUserAge(id)
          return sumOfAges.concat(age)
        })
      )
    )

  // Run tasks concurrently with a limit of 2 concurrent tasks
  yield* Effect.all([task(1), task(2), task(3), task(4)], {
    concurrency: 2
  })

  // Retrieve the updated value
  const value = yield* SynchronizedRef.get(ref)
  return value
})

Effect.runPromise(meanAge).then(console.log)
/*
Output:
timestamp=... level=INFO fiber=#2 message=&quot;task 1&quot; message=[]
timestamp=... level=INFO fiber=#3 message=&quot;task 2&quot; message=[]
timestamp=... level=INFO fiber=#2 message=&quot;task 3&quot; message=&quot;[
  10
]&quot;
timestamp=... level=INFO fiber=#3 message=&quot;task 4&quot; message=&quot;[
  10,
  20
]&quot;
[ 10, 20, 30, 40 ]
*/
</code></pre>
<hr>
<hr>
<h2>title: Consuming Streams
description: Learn techniques for consuming streams, including collecting elements, processing with callbacks, and using folds and sinks.
sidebar:
  order: 2</h2>
<p>When working with streams, it&#39;s essential to understand how to consume the data they produce.
In this guide, we&#39;ll walk through several common methods for consuming streams.</p>
<h2>Using runCollect</h2>
<p>To gather all the elements from a stream into a single <code>Chunk</code>, you can use the <code>Stream.runCollect</code> function.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3, 4, 5)

const collectedData = Stream.runCollect(stream)

Effect.runPromise(collectedData).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, 4, 5 ]
}
*/
</code></pre>
<h2>Using runForEach</h2>
<p>Another way to consume elements of a stream is by using <code>Stream.runForEach</code>. It takes a callback function that receives each element of the stream. Here&#39;s an example:</p>
<pre><code class="language-ts">import { Stream, Effect, Console } from &quot;effect&quot;

const effect = Stream.make(1, 2, 3).pipe(
  Stream.runForEach((n) =&gt; Console.log(n))
)

Effect.runPromise(effect).then(console.log)
/*
Output:
1
2
3
undefined
*/
</code></pre>
<p>In this example, we use <code>Stream.runForEach</code> to log each element to the console.</p>
<h2>Using a Fold Operation</h2>
<p>The <code>Stream.fold</code> function is another way to consume a stream by performing a fold operation over the stream of values and returning an effect containing the result. Here are a couple of examples:</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const foldedStream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.runFold(0, (a, b) =&gt; a + b)
)

Effect.runPromise(foldedStream).then(console.log)
// Output: 15

const foldedWhileStream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.runFoldWhile(
    0,
    (n) =&gt; n &lt;= 3,
    (a, b) =&gt; a + b
  )
)

Effect.runPromise(foldedWhileStream).then(console.log)
// Output: 6
</code></pre>
<p>In the first example (<code>foldedStream</code>), we use <code>Stream.runFold</code> to calculate the sum of all elements. In the second example (<code>foldedWhileStream</code>), we use <code>Stream.runFoldWhile</code> to calculate the sum but only until a certain condition is met.</p>
<h2>Using a Sink</h2>
<p>To consume a stream using a Sink, you can pass the <code>Sink</code> to the <code>Stream.run</code> function. Here&#39;s an example:</p>
<pre><code class="language-ts">import { Stream, Sink, Effect } from &quot;effect&quot;

const effect = Stream.make(1, 2, 3).pipe(Stream.run(Sink.sum))

Effect.runPromise(effect).then(console.log)
// Output: 6
</code></pre>
<p>In this example, we use a <code>Sink</code> to calculate the sum of the elements in the stream.</p>
<hr>
<hr>
<h2>title: Creating Streams
description: Learn various methods for creating Effect streams, from basic constructors to handling asynchronous data sources, pagination, and schedules.
sidebar:
  order: 1</h2>
<p>In this section, we&#39;ll explore various methods for creating Effect <code>Stream</code>s. These methods will help you generate streams tailored to your needs.</p>
<h2>Common Constructors</h2>
<h3>make</h3>
<p>You can create a pure stream by using the <code>Stream.make</code> constructor. This constructor accepts a variable list of values as its arguments.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }
</code></pre>
<h3>empty</h3>
<p>Sometimes, you may require a stream that doesn&#39;t produce any values. In such cases, you can use <code>Stream.empty</code>. This constructor creates a stream that remains empty.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.empty

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [] }
</code></pre>
<h3>void</h3>
<p>If you need a stream that contains a single <code>void</code> value, you can use <code>Stream.void</code>. This constructor is handy when you want to represent a stream with a single event or signal.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.void

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ undefined ] }
</code></pre>
<h3>range</h3>
<p>To create a stream of integers within a specified range <code>[min, max]</code> (including both endpoints, <code>min</code> and <code>max</code>), you can use <code>Stream.range</code>. This is particularly useful for generating a stream of sequential numbers.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Creating a stream of numbers from 1 to 5
const stream = Stream.range(1, 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4, 5 ] }
</code></pre>
<h3>iterate</h3>
<p>With <code>Stream.iterate</code>, you can generate a stream by applying a function iteratively to an initial value. The initial value becomes the first element produced by the stream, followed by subsequent values produced by <code>f(init)</code>, <code>f(f(init))</code>, and so on.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Creating a stream of incrementing numbers
const stream = Stream.iterate(1, (n) =&gt; n + 1) // Produces 1, 2, 3, ...

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4, 5 ] }
</code></pre>
<h3>scoped</h3>
<p><code>Stream.scoped</code> is used to create a single-valued stream from a scoped resource. It can be handy when dealing with resources that require explicit acquisition, usage, and release.</p>
<pre><code class="language-ts">import { Stream, Effect, Console } from &quot;effect&quot;

// Creating a single-valued stream from a scoped resource
const stream = Stream.scoped(
  Effect.acquireUseRelease(
    Console.log(&quot;acquire&quot;),
    () =&gt; Console.log(&quot;use&quot;),
    () =&gt; Console.log(&quot;release&quot;)
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
acquire
use
release
{ _id: &#39;Chunk&#39;, values: [ undefined ] }
*/
</code></pre>
<h2>From Success and Failure</h2>
<p>Much like the <code>Effect</code> data type, you can generate a <code>Stream</code> using the <code>fail</code> and <code>succeed</code> functions:</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Creating a stream that can emit errors
const streamWithError: Stream.Stream&lt;never, string&gt; =
  Stream.fail(&quot;Uh oh!&quot;)

Effect.runPromise(Stream.runCollect(streamWithError))
// throws Error: Uh oh!

// Creating a stream that emits a numeric value
const streamWithNumber: Stream.Stream&lt;number&gt; = Stream.succeed(5)

Effect.runPromise(Stream.runCollect(streamWithNumber)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 5 ] }
</code></pre>
<h2>From Chunks</h2>
<p>You can construct a stream from a <code>Chunk</code> like this:</p>
<pre><code class="language-ts">import { Stream, Chunk, Effect } from &quot;effect&quot;

// Creating a stream with values from a single Chunk
const stream = Stream.fromChunk(Chunk.make(1, 2, 3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }
</code></pre>
<p>Moreover, you can create a stream from multiple <code>Chunk</code>s as well:</p>
<pre><code class="language-ts">import { Stream, Chunk, Effect } from &quot;effect&quot;

// Creating a stream with values from multiple Chunks
const stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4, 5, 6 ] }
</code></pre>
<h2>From Effect</h2>
<p>You can generate a stream from an Effect workflow by employing the <code>Stream.fromEffect</code> constructor. For instance, consider the following stream, which generates a single random number:</p>
<pre><code class="language-ts">import { Stream, Random, Effect } from &quot;effect&quot;

const stream = Stream.fromEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: &#39;Chunk&#39;, values: [ 1042302242 ] }
</code></pre>
<p>This method allows you to seamlessly transform the output of an Effect into a stream, providing a straightforward way to work with asynchronous operations within your streams.</p>
<h2>From Asynchronous Callback</h2>
<p>Imagine you have an asynchronous function that relies on callbacks. If you want to capture the results emitted by those callbacks as a stream, you can use the <code>Stream.async</code> function. This function is designed to adapt functions that invoke their callbacks multiple times and emit the results as a stream.</p>
<p>Let&#39;s break down how to use it in the following example:</p>
<pre><code class="language-ts">import { Stream, Effect, Chunk, Option, StreamEmit } from &quot;effect&quot;

const events = [1, 2, 3, 4]

const stream = Stream.async(
  (emit: StreamEmit.Emit&lt;never, never, number, void&gt;) =&gt; {
    events.forEach((n) =&gt; {
      setTimeout(() =&gt; {
        if (n === 3) {
          // Terminate the stream
          emit(Effect.fail(Option.none()))
        } else {
          // Add the current item to the stream
          emit(Effect.succeed(Chunk.of(n)))
        }
      }, 100 * n)
    })
  }
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
</code></pre>
<p>The <code>StreamEmit.Emit&lt;R, E, A, void&gt;</code> type represents an asynchronous callback that can be called multiple times. This callback takes a value of type <code>Effect&lt;Chunk&lt;A&gt;, Option&lt;E&gt;, R&gt;</code>. Here&#39;s what each of the possible outcomes means:</p>
<ul>
<li><p>When the value provided to the callback results in a <code>Chunk&lt;A&gt;</code> upon success, it signifies that the specified elements should be emitted as part of the stream.</p>
</li>
<li><p>If the value passed to the callback results in a failure with <code>Some&lt;E&gt;</code>, it indicates the termination of the stream with the specified error.</p>
</li>
<li><p>When the value passed to the callback results in a failure with <code>None</code>, it serves as a signal for the end of the stream, essentially terminating it.</p>
</li>
</ul>
<p>To put it simply, this type allows you to specify how your asynchronous callback interacts with the stream, determining when to emit elements, when to terminate with an error, or when to signal the end of the stream.</p>
<h2>From Iterables</h2>
<h3>fromIterable</h3>
<p>You can create a pure stream from an <code>Iterable</code> of values using the <code>Stream.fromIterable</code> constructor. It&#39;s a straightforward way to convert a collection of values into a stream.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const numbers = [1, 2, 3]

const stream = Stream.fromIterable(numbers)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3 ] }
</code></pre>
<h3>fromIterableEffect</h3>
<p>When you have an effect that produces a value of type <code>Iterable</code>, you can employ the <code>Stream.fromIterableEffect</code> constructor to generate a stream from that effect.</p>
<p>For instance, let&#39;s say you have a database operation that retrieves a list of users. Since this operation involves effects, you can utilize <code>Stream.fromIterableEffect</code> to convert the result into a <code>Stream</code>:</p>
<pre><code class="language-ts">import { Stream, Effect, Context } from &quot;effect&quot;

class Database extends Context.Tag(&quot;Database&quot;)&lt;
  Database,
  { readonly getUsers: Effect.Effect&lt;Array&lt;string&gt;&gt; }
&gt;() {}

const getUsers = Database.pipe(Effect.andThen((_) =&gt; _.getUsers))

const stream = Stream.fromIterableEffect(getUsers)

Effect.runPromise(
  Stream.runCollect(
    stream.pipe(
      Stream.provideService(Database, {
        getUsers: Effect.succeed([&quot;user1&quot;, &quot;user2&quot;])
      })
    )
  )
).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ &#39;user1&#39;, &#39;user2&#39; ] }
</code></pre>
<p>This enables you to work seamlessly with effects and convert their results into streams for further processing.</p>
<h3>fromAsyncIterable</h3>
<p>Async iterables are another type of data source that can be converted into a stream. With the <code>Stream.fromAsyncIterable</code> constructor, you can work with asynchronous data sources and handle potential errors gracefully.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const myAsyncIterable = async function* () {
  yield 1
  yield 2
}

const stream = Stream.fromAsyncIterable(
  myAsyncIterable(),
  (e) =&gt; new Error(String(e)) // Error Handling
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
</code></pre>
<p>In this code, we define an async iterable and then create a stream named <code>stream</code> from it. Additionally, we provide an error handler function to manage any potential errors that may occur during the conversion.</p>
<h2>From Repetition</h2>
<h3>Repeating a Single Value</h3>
<p>You can create a stream that endlessly repeats a specific value using the <code>Stream.repeatValue</code> constructor:</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.repeatValue(0)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: &#39;Chunk&#39;, values: [ 0, 0, 0, 0, 0 ] }
</code></pre>
<h3>Repeating a Stream&#39;s Content</h3>
<p><code>Stream.repeat</code> allows you to create a stream that repeats a specified stream&#39;s content according to a schedule. This can be useful for generating recurring events or values.</p>
<pre><code class="language-ts">import { Stream, Effect, Schedule } from &quot;effect&quot;

// Creating a stream that repeats a value indefinitely
const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: &#39;Chunk&#39;, values: [ 1, 1, 1, 1, 1 ] }
</code></pre>
<h3>Repeating an Effect&#39;s Result</h3>
<p>Imagine you have an effectful API call, and you want to use the result of that call to create a stream. You can achieve this by creating a stream from the effect and repeating it indefinitely.</p>
<p>Here&#39;s an example of generating a stream of random numbers:</p>
<pre><code class="language-ts">import { Stream, Effect, Random } from &quot;effect&quot;

const stream = Stream.repeatEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
/*
Example Output:
{
  _id: &#39;Chunk&#39;,
  values: [ 1666935266, 604851965, 2194299958, 3393707011, 4090317618 ]
}
*/
</code></pre>
<h3>Repeating an Effect with Termination</h3>
<p>You can repeatedly evaluate a given effect and terminate the stream based on specific conditions.</p>
<p>In this example, we&#39;re draining an <code>Iterator</code> to create a stream from it:</p>
<pre><code class="language-ts">import { Stream, Effect, Option } from &quot;effect&quot;

const drainIterator = &lt;A&gt;(it: Iterator&lt;A&gt;): Stream.Stream&lt;A&gt; =&gt;
  Stream.repeatEffectOption(
    Effect.sync(() =&gt; it.next()).pipe(
      Effect.andThen((res) =&gt; {
        if (res.done) {
          return Effect.fail(Option.none())
        }
        return Effect.succeed(res.value)
      })
    )
  )
</code></pre>
<h3>Generating Ticks</h3>
<p>You can create a stream that emits <code>void</code> values at specified intervals using the <code>Stream.tick</code> constructor. This is useful for creating periodic events.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.tick(&quot;100 millis&quot;)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [ undefined, undefined, undefined, undefined, undefined ]
}
*/
</code></pre>
<h2>From Unfolding/Pagination</h2>
<p>In functional programming, the concept of <code>unfold</code> can be thought of as the counterpart to <code>fold</code>.</p>
<p>With <code>fold</code>, we process a data structure and produce a return value. For example, we can take an <code>Array&lt;number&gt;</code> and calculate the sum of its elements.</p>
<p>On the other hand, <code>unfold</code> represents an operation where we start with an initial value and generate a recursive data structure, adding one element at a time using a specified state function. For example, we can create a sequence of natural numbers starting from <code>1</code> and using the <code>increment</code> function as the state function.</p>
<h3>Unfold</h3>
<h4>unfold</h4>
<p>The Stream module includes an <code>unfold</code> function defined as follows:</p>
<pre><code class="language-ts">declare const unfold: &lt;S, A&gt;(
  initialState: S,
  step: (s: S) =&gt; Option.Option&lt;readonly [A, S]&gt;
) =&gt; Stream&lt;A&gt;
</code></pre>
<p>Here&#39;s how it works:</p>
<ul>
<li><strong>initialState</strong>. This is the initial state value.</li>
<li><strong>step</strong>. The state function <code>step</code> takes the current state <code>s</code> as input. If the result of this function is <code>None</code>, the stream ends. If it&#39;s <code>Some&lt;[A, S]&gt;</code>, the next element in the stream is <code>A</code>, and the state <code>S</code> is updated for the next step process.</li>
</ul>
<p>For example, let&#39;s create a stream of natural numbers using <code>Stream.unfold</code>:</p>
<pre><code class="language-ts">import { Stream, Effect, Option } from &quot;effect&quot;

const stream = Stream.unfold(1, (n) =&gt; Option.some([n, n + 1]))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4, 5 ] }
</code></pre>
<h4>unfoldEffect</h4>
<p>Sometimes, we may need to perform effectful state transformations during the unfolding operation. This is where <code>Stream.unfoldEffect</code> comes in handy. It allows us to work with effects while generating streams.</p>
<p>Here&#39;s an example of creating an infinite stream of random <code>1</code> and <code>-1</code> values using <code>Stream.unfoldEffect</code>:</p>
<pre><code class="language-ts">import { Stream, Effect, Option, Random } from &quot;effect&quot;

const stream = Stream.unfoldEffect(1, (n) =&gt;
  Random.nextBoolean.pipe(
    Effect.map((b) =&gt; (b ? Option.some([n, -n]) : Option.some([n, n])))
  )
)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// Example Output: { _id: &#39;Chunk&#39;, values: [ 1, 1, 1, 1, -1 ] }
</code></pre>
<h4>Additional Variants</h4>
<p>There are also similar operations like <code>Stream.unfoldChunk</code> and <code>Stream.unfoldChunkEffect</code> tailored for working with <code>Chunk</code> data types.</p>
<h3>Pagination</h3>
<h4>paginate</h4>
<p><code>Stream.paginate</code> is similar to <code>Stream.unfold</code> but allows emitting values one step further.</p>
<p>For example, the following stream emits <code>0, 1, 2, 3</code> elements:</p>
<pre><code class="language-ts">import { Stream, Effect, Option } from &quot;effect&quot;

const stream = Stream.paginate(0, (n) =&gt; [
  n,
  n &lt; 3 ? Option.some(n + 1) : Option.none()
])

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: &#39;Chunk&#39;, values: [ 0, 1, 2, 3 ] }
</code></pre>
<p>Here&#39;s how it works:</p>
<ul>
<li>We start with an initial value of <code>0</code>.</li>
<li>The provided function takes the current value <code>n</code> and returns a tuple. The first element of the tuple is the value to emit (<code>n</code>), and the second element determines whether to continue (<code>Option.some(n + 1)</code>) or stop (<code>Option.none()</code>).</li>
</ul>
<h4>Additional Variants</h4>
<p>There are also similar operations like <code>Stream.paginateChunk</code> and <code>Stream.paginateChunkEffect</code> tailored for working with <code>Chunk</code> data types.</p>
<h3>Unfolding vs. Pagination</h3>
<p>You might wonder about the difference between the <code>unfold</code> and <code>paginate</code> combinators and when to use one over the other. Let&#39;s explore this by diving into an example.</p>
<p>Imagine we have a paginated API that provides a substantial amount of data in a paginated manner. When we make a request to this API, it returns a <code>ResultPage</code> object containing the results for the current page and a flag indicating whether it&#39;s the last page or if there&#39;s more data to retrieve on the next page. Here&#39;s a simplified representation of our API:</p>
<pre><code class="language-ts">import { Chunk, Effect } from &quot;effect&quot;

type RawData = string

class PageResult {
  constructor(
    readonly results: Chunk.Chunk&lt;RawData&gt;,
    readonly isLast: boolean
  ) {}
}

const pageSize = 2

const listPaginated = (
  pageNumber: number
): Effect.Effect&lt;PageResult, Error&gt; =&gt; {
  return Effect.succeed(
    new PageResult(
      Chunk.map(
        Chunk.range(1, pageSize),
        (index) =&gt; `Result ${pageNumber}-${index}`
      ),
      pageNumber === 2 // Return 3 pages
    )
  )
}
</code></pre>
<p>Our goal is to convert this paginated API into a stream of <code>RowData</code> events. For our initial attempt, we might think that using the <code>Stream.unfold</code> operation is the way to go:</p>
<pre><code class="language-ts">import { Chunk, Effect, Stream, Option } from &quot;effect&quot;

type RawData = string

class PageResult {
  constructor(
    readonly results: Chunk.Chunk&lt;RawData&gt;,
    readonly isLast: boolean
  ) {}
}

const pageSize = 2

const listPaginated = (
  pageNumber: number
): Effect.Effect&lt;PageResult, Error&gt; =&gt; {
  return Effect.succeed(
    new PageResult(
      Chunk.map(
        Chunk.range(1, pageSize),
        (index) =&gt; `Result ${pageNumber}-${index}`
      ),
      pageNumber === 2 // Return 3 pages
    )
  )
}

const firstAttempt = Stream.unfoldChunkEffect(0, (pageNumber) =&gt;
  listPaginated(pageNumber).pipe(
    Effect.map((page) =&gt; {
      if (page.isLast) {
        return Option.none()
      }
      return Option.some([page.results, pageNumber + 1] as const)
    })
  )
)

Effect.runPromise(Stream.runCollect(firstAttempt)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ &quot;Result 0-1&quot;, &quot;Result 0-2&quot;, &quot;Result 1-1&quot;, &quot;Result 1-2&quot; ]
}
*/
</code></pre>
<p>However, this approach has a drawback, it doesn&#39;t include the results from the last page. To work around this, we perform an extra API call to include those missing results:</p>
<pre><code class="language-ts">import { Chunk, Effect, Stream, Option } from &quot;effect&quot;

type RawData = string

class PageResult {
  constructor(
    readonly results: Chunk.Chunk&lt;RawData&gt;,
    readonly isLast: boolean
  ) {}
}

const pageSize = 2

const listPaginated = (
  pageNumber: number
): Effect.Effect&lt;PageResult, Error&gt; =&gt; {
  return Effect.succeed(
    new PageResult(
      Chunk.map(
        Chunk.range(1, pageSize),
        (index) =&gt; `Result ${pageNumber}-${index}`
      ),
      pageNumber === 2 // Return 3 pages
    )
  )
}

const secondAttempt = Stream.unfoldChunkEffect(
  Option.some(0),
  (pageNumber) =&gt;
    Option.match(pageNumber, {
      // We already hit the last page
      onNone: () =&gt; Effect.succeed(Option.none()),
      // We did not hit the last page yet
      onSome: (pageNumber) =&gt;
        listPaginated(pageNumber).pipe(
          Effect.map((page) =&gt;
            Option.some([
              page.results,
              page.isLast ? Option.none() : Option.some(pageNumber + 1)
            ])
          )
        )
    })
)

Effect.runPromise(Stream.runCollect(secondAttempt)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    &#39;Result 0-1&#39;,
    &#39;Result 0-2&#39;,
    &#39;Result 1-1&#39;,
    &#39;Result 1-2&#39;,
    &#39;Result 2-1&#39;,
    &#39;Result 2-2&#39;
  ]
}
*/
</code></pre>
<p>While this approach works, it&#39;s clear that <code>Stream.unfold</code> isn&#39;t the most friendly option for retrieving data from paginated APIs. It requires additional workarounds to include the results from the last page.</p>
<p>This is where <code>Stream.paginate</code> comes to the rescue. It provides a more ergonomic way to convert a paginated API into an Effect stream. Let&#39;s rewrite our solution using <code>Stream.paginate</code>:</p>
<pre><code class="language-ts">import { Chunk, Effect, Stream, Option } from &quot;effect&quot;

type RawData = string

class PageResult {
  constructor(
    readonly results: Chunk.Chunk&lt;RawData&gt;,
    readonly isLast: boolean
  ) {}
}

const pageSize = 2

const listPaginated = (
  pageNumber: number
): Effect.Effect&lt;PageResult, Error&gt; =&gt; {
  return Effect.succeed(
    new PageResult(
      Chunk.map(
        Chunk.range(1, pageSize),
        (index) =&gt; `Result ${pageNumber}-${index}`
      ),
      pageNumber === 2 // Return 3 pages
    )
  )
}

const finalAttempt = Stream.paginateChunkEffect(0, (pageNumber) =&gt;
  listPaginated(pageNumber).pipe(
    Effect.andThen((page) =&gt; {
      return [
        page.results,
        page.isLast ? Option.none&lt;number&gt;() : Option.some(pageNumber + 1)
      ]
    })
  )
)

Effect.runPromise(Stream.runCollect(finalAttempt)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    &#39;Result 0-1&#39;,
    &#39;Result 0-2&#39;,
    &#39;Result 1-1&#39;,
    &#39;Result 1-2&#39;,
    &#39;Result 2-1&#39;,
    &#39;Result 2-2&#39;
  ]
}
*/
</code></pre>
<h2>From Queue and PubSub</h2>
<p>In Effect, there are two essential asynchronous messaging data types: <a href="/docs/concurrency/queue/">Queue</a> and <a href="/docs/concurrency/pubsub/">PubSub</a>. You can easily transform these data types into <code>Stream</code>s by utilizing <code>Stream.fromQueue</code> and <code>Stream.fromPubSub</code>, respectively.</p>
<h2>From Schedule</h2>
<p>We can create a stream from a <code>Schedule</code> that does not require any further input. The stream will emit an element for each value output from the schedule, continuing for as long as the schedule continues:</p>
<pre><code class="language-ts">import { Effect, Stream, Schedule } from &quot;effect&quot;

// Emits values every 1 second for a total of 10 emissions
const schedule = Schedule.spaced(&quot;1 second&quot;).pipe(
  Schedule.compose(Schedule.recurs(10))
)

const stream = Stream.fromSchedule(schedule)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    0, 1, 2, 3, 4,
    5, 6, 7, 8, 9
  ]
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Error Handling in Streams
description: Learn how to handle errors in streams, ensuring robust recovery, retries, and graceful error management for reliable stream processing.
sidebar:
  label: Error Handling
  order: 3</h2>
<h2>Recovering from Failure</h2>
<p>When working with streams that may encounter errors, it&#39;s crucial to know how to handle these errors gracefully. The <code>Stream.orElse</code> function is a powerful tool for recovering from failures and switching to an alternative stream in case of an error.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.fail(&quot;Oh! Error!&quot;)),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const stream = Stream.orElse(s1, () =&gt; s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
}
*/
</code></pre>
<p>In this example, <code>s1</code> encounters an error, but instead of terminating the stream, we gracefully switch to <code>s2</code> using <code>Stream.orElse</code>. This ensures that we can continue processing data even if one stream fails.</p>
<p>There&#39;s also a variant called <code>Stream.orElseEither</code> that uses the <a href="/docs/data-types/either/">Either</a> data type to distinguish elements from the two streams based on success or failure:</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.fail(&quot;Oh! Error!&quot;)),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const stream = Stream.orElseEither(s1, () =&gt; s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [
    {
      _id: &quot;Either&quot;,
      _tag: &quot;Left&quot;,
      left: 1
    }, {
      _id: &quot;Either&quot;,
      _tag: &quot;Left&quot;,
      left: 2
    }, {
      _id: &quot;Either&quot;,
      _tag: &quot;Left&quot;,
      left: 3
    }, {
      _id: &quot;Either&quot;,
      _tag: &quot;Right&quot;,
      right: &quot;a&quot;
    }, {
      _id: &quot;Either&quot;,
      _tag: &quot;Right&quot;,
      right: &quot;b&quot;
    }, {
      _id: &quot;Either&quot;,
      _tag: &quot;Right&quot;,
      right: &quot;c&quot;
    }
  ]
}
*/
</code></pre>
<p>The <code>Stream.catchAll</code> function provides advanced error handling capabilities compared to <code>Stream.orElse</code>. With <code>Stream.catchAll</code>, you can make decisions based on both the type and value of the encountered failure.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.fail(&quot;Uh Oh!&quot; as const)),
  Stream.concat(Stream.make(4, 5)),
  Stream.concat(Stream.fail(&quot;Ouch&quot; as const))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const s3 = Stream.make(true, false, false)

const stream = Stream.catchAll(
  s1,
  (error): Stream.Stream&lt;string | boolean&gt; =&gt; {
    switch (error) {
      case &quot;Uh Oh!&quot;:
        return s2
      case &quot;Ouch&quot;:
        return s3
    }
  }
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
}
*/
</code></pre>
<p>In this example, we have a stream, <code>s1</code>, which may encounter two different types of errors. Instead of a straightforward switch to an alternative stream, as done with <code>Stream.orElse</code>, we employ <code>Stream.catchAll</code> to precisely determine how to handle each type of error. This level of control over error recovery enables you to choose different streams or actions based on the specific error conditions.</p>
<h2>Recovering from Defects</h2>
<p>When working with streams, it&#39;s essential to be prepared for various failure scenarios, including defects that might occur during stream processing. To address this, the <code>Stream.catchAllCause</code> function provides a robust solution. It enables you to gracefully handle and recover from any type of failure that may arise.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.dieMessage(&quot;Boom!&quot;)),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const stream = Stream.catchAllCause(s1, () =&gt; s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
}
*/
</code></pre>
<p>In this example, <code>s1</code> may encounter a defect, but instead of crashing the application, we use <code>Stream.catchAllCause</code> to gracefully switch to an alternative stream, <code>s2</code>. This ensures that your application remains robust and continues processing data even in the face of unexpected issues.</p>
<h2>Recovery from Some Errors</h2>
<p>In stream processing, there may be situations where you need to recover from specific types of failures. The <code>Stream.catchSome</code> and <code>Stream.catchSomeCause</code> functions come to the rescue, allowing you to handle and mitigate errors selectively.</p>
<p>If you want to recover from a particular error, you can use <code>Stream.catchSome</code>:</p>
<pre><code class="language-ts">import { Stream, Effect, Option } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.fail(&quot;Oh! Error!&quot;)),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const stream = Stream.catchSome(s1, (error) =&gt; {
  if (error === &quot;Oh! Error!&quot;) {
    return Option.some(s2)
  }
  return Option.none()
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
}
*/
</code></pre>
<p>To recover from a specific cause, you can use the <code>Stream.catchSomeCause</code> function:</p>
<pre><code class="language-ts">import { Stream, Effect, Option, Cause } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.dieMessage(&quot;Oh! Error!&quot;)),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

const stream = Stream.catchSomeCause(s1, (cause) =&gt; {
  if (Cause.isDie(cause)) {
    return Option.some(s2)
  }
  return Option.none()
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
}
*/
</code></pre>
<h2>Recovering to Effect</h2>
<p>In stream processing, it&#39;s crucial to handle errors gracefully and perform cleanup tasks when needed. The <code>Stream.onError</code> function allows us to do just that. If our stream encounters an error, we can specify a cleanup task to be executed.</p>
<pre><code class="language-ts">import { Stream, Console, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.dieMessage(&quot;Oh! Boom!&quot;)),
  Stream.concat(Stream.make(4, 5)),
  Stream.onError(() =&gt;
    Console.log(
      &quot;Stream application closed! We are doing some cleanup jobs.&quot;
    ).pipe(Effect.orDie)
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
Stream application closed! We are doing some cleanup jobs.
error: RuntimeException: Oh! Boom!
*/
</code></pre>
<h2>Retry a Failing Stream</h2>
<p>Sometimes, streams may encounter failures that are temporary or recoverable. In such cases, the <code>Stream.retry</code> operator comes in handy. It allows you to specify a retry schedule, and the stream will be retried according to that schedule.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Stream, Effect, Schedule } from &quot;effect&quot;
import * as NodeReadLine from &quot;node:readline&quot;

const stream = Stream.make(1, 2, 3).pipe(
  Stream.concat(
    Stream.fromEffect(
      Effect.gen(function* () {
        const s = yield* readLine(&quot;Enter a number: &quot;)
        const n = parseInt(s)
        if (Number.isNaN(n)) {
          return yield* Effect.fail(&quot;NaN&quot;)
        }
        return n
      })
    ).pipe(Stream.retry(Schedule.exponential(&quot;1 second&quot;)))
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
Enter a number: a
Enter a number: b
Enter a number: c
Enter a number: 4
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, 4 ]
}
*/

const readLine = (message: string): Effect.Effect&lt;string&gt; =&gt;
  Effect.promise(
    () =&gt;
      new Promise((resolve) =&gt; {
        const rl = NodeReadLine.createInterface({
          input: process.stdin,
          output: process.stdout
        })
        rl.question(message, (answer) =&gt; {
          rl.close()
          resolve(answer)
        })
      })
  )
</code></pre>
<p>In this example, the stream asks the user to input a number, but if an invalid value is entered (e.g., &quot;a,&quot; &quot;b,&quot; &quot;c&quot;), it fails with &quot;NaN.&quot; However, we use <code>Stream.retry</code> with an exponential backoff schedule, which means it will retry after a delay of increasing duration. This allows us to handle temporary errors and eventually collect valid input.</p>
<h2>Refining Errors</h2>
<p>When working with streams, there might be situations where you want to selectively keep certain errors and terminate the stream with the remaining errors. You can achieve this using the <code>Stream.refineOrDie</code> function.</p>
<p><strong>Example</strong></p>
<pre><code class="language-ts">import { Stream, Option } from &quot;effect&quot;

const stream = Stream.fail(new Error())

const res = Stream.refineOrDie(stream, (error) =&gt; {
  if (error instanceof SyntaxError) {
    return Option.some(error)
  }
  return Option.none()
})
</code></pre>
<p>In this example, <code>stream</code> initially fails with a generic <code>Error</code>. However, we use <code>Stream.refineOrDie</code> to filter and keep only errors of type <code>SyntaxError</code>. Any other errors will be terminated, while <code>SyntaxErrors</code> will be retained in <code>refinedStream</code>.</p>
<h2>Timing Out</h2>
<p>When working with streams, there are scenarios where you may want to handle timeouts, such as terminating a stream if it doesn&#39;t produce a value within a certain duration. In this section, we&#39;ll explore how to manage timeouts using various operators.</p>
<h3>timeout</h3>
<p>The <code>Stream.timeout</code> operator allows you to set a timeout on a stream. If the stream does not produce a value within the specified duration, it terminates.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeout(&quot;2 seconds&quot;)
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
{
  _id: &quot;Chunk&quot;,
  values: []
}
*/
</code></pre>
<h3>timeoutFail</h3>
<p>The <code>Stream.timeoutFail</code> operator combines a timeout with a custom failure message. If the stream times out, it fails with the specified error message.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeoutFail(() =&gt; &quot;timeout&quot;, &quot;2 seconds&quot;)
)

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Fail&#39;, failure: &#39;timeout&#39; }
}
*/
</code></pre>
<h3>timeoutFailCause</h3>
<p>Similar to <code>Stream.timeoutFail</code>, <code>Stream.timeoutFailCause</code> combines a timeout with a custom failure cause. If the stream times out, it fails with the specified cause.</p>
<pre><code class="language-ts">import { Stream, Effect, Cause } from &quot;effect&quot;

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeoutFailCause(() =&gt; Cause.die(&quot;timeout&quot;), &quot;2 seconds&quot;)
)

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Exit&#39;,
  _tag: &#39;Failure&#39;,
  cause: { _id: &#39;Cause&#39;, _tag: &#39;Die&#39;, defect: &#39;timeout&#39; }
}
*/
</code></pre>
<h3>timeoutTo</h3>
<p>The <code>Stream.timeoutTo</code> operator allows you to switch to another stream if the first stream does not produce a value within the specified duration.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeoutTo(&quot;2 seconds&quot;, Stream.make(1, 2, 3))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3 ]
}
*/
</code></pre>
<hr>
<hr>
<h2>title: Introduction to Streams
description: Learn the fundamentals of streams, a powerful tool for emitting multiple values, handling errors, and working with finite or infinite sequences in your applications.
sidebar:
  label: Introduction
  order: 0</h2>
<p>In this guide, we&#39;ll explore the concept of a <code>Stream&lt;A, E, R&gt;</code>. A <code>Stream</code> is a program description that, when executed, can emit <strong>zero or more values</strong> of type <code>A</code>, handle errors of type <code>E</code>, and operates within a context of type <code>R</code>.</p>
<h2>Use Cases</h2>
<p>Streams are particularly handy whenever you&#39;re dealing with sequences of values over time. They can serve as replacements for observables, node streams, and AsyncIterables.</p>
<h2>What is a Stream?</h2>
<p>Think of a <code>Stream</code> as an extension of an <code>Effect</code>. While an <code>Effect&lt;A, E, R&gt;</code> represents a program that requires a context of type <code>R</code>, may encounter an error of type <code>E</code>, and always produces a single result of type <code>A</code>, a <code>Stream&lt;A, E, R&gt;</code> takes this further by allowing the emission of zero or more values of type <code>A</code>.</p>
<p>To clarify, let&#39;s examine some examples using <code>Effect</code>:</p>
<pre><code class="language-ts">import { Effect, Chunk, Option } from &quot;effect&quot;

// An Effect that fails with a string error
const failedEffect = Effect.fail(&quot;fail!&quot;)

// An Effect that produces a single number
const oneNumberValue = Effect.succeed(3)

// An Effect that produces a chunk of numbers
const oneListValue = Effect.succeed(Chunk.make(1, 2, 3))

// An Effect that produces an optional number
const oneOption = Effect.succeed(Option.some(1))
</code></pre>
<p>In each case, the <code>Effect</code> always ends with <strong>exactly one value</strong>. There is no variability; you always get one result.</p>
<h2>Understanding Streams</h2>
<p>Now, let&#39;s shift our focus to <code>Stream</code>. A <code>Stream</code> represents a program description that shares similarities with <code>Effect</code>, it requires a context of type <code>R</code>, may signal errors of type <code>E</code>, and yields values of type <code>A</code>. However, the key distinction is that it can yield <strong>zero or more values</strong>.</p>
<p>Here are the possible scenarios for a <code>Stream</code>:</p>
<ul>
<li><strong>An Empty Stream</strong>: It can end up empty, representing a stream with no values.</li>
<li><strong>A Single-Element Stream</strong>: It can represent a stream with just one value.</li>
<li><strong>A Finite Stream of Elements</strong>: It can represent a stream with a finite number of values.</li>
<li><strong>An Infinite Stream of Elements</strong>: It can represent a stream that continues indefinitely, essentially an infinite stream.</li>
</ul>
<p>Let&#39;s see these scenarios in action:</p>
<pre><code class="language-ts">import { Stream } from &quot;effect&quot;

// An empty Stream
const emptyStream = Stream.empty

// A Stream with a single number
const oneNumberValueStream = Stream.succeed(3)

// A Stream with a range of numbers from 1 to 10
const finiteNumberStream = Stream.range(1, 10)

// An infinite Stream of numbers starting from 1 and incrementing
const infiniteNumberStream = Stream.iterate(1, (n) =&gt; n + 1)
</code></pre>
<p>In summary, a <code>Stream</code> is a versatile tool for representing programs that may yield multiple values, making it suitable for a wide range of tasks, from processing finite lists to handling infinite sequences.</p>
<hr>
<hr>
<h2>title: Operations
description: Explore essential operations for manipulating and managing data in streams, including tapping, mapping, filtering, merging, and more, to effectively process and transform streaming data.
sidebar:
  order: 4</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In this guide, we&#39;ll explore some essential operations you can perform on streams. These operations allow you to manipulate and interact with stream elements in various ways.</p>
<h2>Tapping</h2>
<p>The <code>Stream.tap</code> operation allows you to run an effect on each element emitted by the stream, observing or performing side effects without altering the elements or return type. This can be useful for logging, monitoring, or triggering additional actions with each emission.</p>
<p><strong>Example</strong> (Logging with <code>Stream.tap</code>)</p>
<p>For example, <code>Stream.tap</code> can be used to log each element before and after a mapping operation:</p>
<pre><code class="language-ts">import { Stream, Console, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3).pipe(
  Stream.tap((n) =&gt; Console.log(`before mapping: ${n}`)),
  Stream.map((n) =&gt; n * 2),
  Stream.tap((n) =&gt; Console.log(`after mapping: ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
before mapping: 1
after mapping: 2
before mapping: 2
after mapping: 4
before mapping: 3
after mapping: 6
{ _id: &#39;Chunk&#39;, values: [ 2, 4, 6 ] }
*/
</code></pre>
<h2>Taking Elements</h2>
<p>The &quot;taking&quot; operations in streams let you extract a specific set of elements, either by a fixed number, condition, or position within the stream. Here are a few ways to apply these operations:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>take</code></td>
<td>Extracts a fixed number of elements.</td>
</tr>
<tr>
<td><code>takeWhile</code></td>
<td>Extracts elements while a certain condition is met.</td>
</tr>
<tr>
<td><code>takeUntil</code></td>
<td>Extracts elements until a certain condition is met.</td>
</tr>
<tr>
<td><code>takeRight</code></td>
<td>Extracts a specified number of elements from the end.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Extracting Elements in Different Ways)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.iterate(0, (n) =&gt; n + 1)

// Using `take` to extract a fixed number of elements:
const s1 = Stream.take(stream, 5)
Effect.runPromise(Stream.runCollect(s1)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 0, 1, 2, 3, 4 ] }
*/

// Using `takeWhile` to extract elements while a condition is met:
const s2 = Stream.takeWhile(stream, (n) =&gt; n &lt; 5)
Effect.runPromise(Stream.runCollect(s2)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 0, 1, 2, 3, 4 ] }
*/

// Using `takeUntil` to extract elements until a condition is met:
const s3 = Stream.takeUntil(stream, (n) =&gt; n === 5)
Effect.runPromise(Stream.runCollect(s3)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 0, 1, 2, 3, 4, 5 ] }
*/

// Using `takeRight` to take elements from the end of the stream:
const s4 = Stream.takeRight(s3, 3)
Effect.runPromise(Stream.runCollect(s4)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 3, 4, 5 ] }
*/
</code></pre>
<h2>Streams as an Alternative to Async Iterables</h2>
<p>When working with asynchronous data sources, such as async iterables, you often need to consume data in a loop until a certain condition is met. Streams provide a similar approach and offer additional flexibility.</p>
<p>With async iterables, data is processed in a loop until a break or return statement is encountered. To replicate this behavior with Streams, consider these options:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>takeUntil</code></td>
<td>Takes elements from a stream until a specified condition is met, similar to breaking out of a loop.</td>
</tr>
<tr>
<td><code>toPull</code></td>
<td>Returns an effect that continuously pulls data chunks from the stream. This effect can fail with <code>None</code> when the stream is finished or with <code>Some</code> error if it fails.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>Stream.toPull</code>)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Simulate a chunked stream
const stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(
  Stream.rechunk(2)
)

const program = Effect.gen(function* () {
  // Create an effect to get data chunks from the stream
  const getChunk = yield* Stream.toPull(stream)

  // Continuously fetch and process chunks
  while (true) {
    const chunk = yield* getChunk
    console.log(chunk)
  }
})

Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2 ] }
{ _id: &#39;Chunk&#39;, values: [ 3, 4 ] }
{ _id: &#39;Chunk&#39;, values: [ 5 ] }
(FiberFailure) Error: {
  &quot;_id&quot;: &quot;Option&quot;,
  &quot;_tag&quot;: &quot;None&quot;
}
*/
</code></pre>
<h2>Mapping</h2>
<h3>Basic Mapping</h3>
<p>The <code>Stream.map</code> operation applies a specified function to each element in a stream, creating a new stream with the transformed values.</p>
<p><strong>Example</strong> (Incrementing Each Element by 1)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 2, 3).pipe(
  Stream.map((n) =&gt; n + 1) // Increment each element by 1
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 2, 3, 4 ] }
*/
</code></pre>
<h3>Mapping to a Constant Value</h3>
<p>The <code>Stream.as</code> method allows you to replace each success value in a stream with a specified constant value. This can be useful when you want all elements in the stream to emit a uniform value, regardless of the original data.</p>
<p><strong>Example</strong> (Mapping to <code>null</code>)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.range(1, 5).pipe(Stream.as(null))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ null, null, null, null, null ] }
*/
</code></pre>
<h3>Effectful Mapping</h3>
<p>For transformations involving effects, use <code>Stream.mapEffect</code>. This function applies an effectful operation to each element in the stream, producing a new stream with effectful results.</p>
<p><strong>Example</strong> (Random Number Generation)</p>
<pre><code class="language-ts">import { Stream, Random, Effect } from &quot;effect&quot;

const stream = Stream.make(10, 20, 30).pipe(
  // Generate a random number between 0 and each element
  Stream.mapEffect((n) =&gt; Random.nextIntBetween(0, n))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
{ _id: &#39;Chunk&#39;, values: [ 5, 9, 22 ] }
*/
</code></pre>
<p>To handle multiple effectful transformations concurrently, you can use the <a href="/docs/concurrency/basic-concurrency/#concurrency-options">concurrency</a> option. This option allows a specified number of effects to run concurrently, with results emitted downstream in their original order.</p>
<p><strong>Example</strong> (Fetching URLs Concurrently)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const fetchUrl = (url: string) =&gt;
  Effect.gen(function* () {
    console.log(`Fetching ${url}`)
    yield* Effect.sleep(&quot;100 millis&quot;)
    console.log(`Fetching ${url} done`)
    return [`Resource 0-${url}`, `Resource 1-${url}`, `Resource 2-${url}`]
  })

const stream = Stream.make(&quot;url1&quot;, &quot;url2&quot;, &quot;url3&quot;).pipe(
  // Fetch each URL concurrently with a limit of 2
  Stream.mapEffect(fetchUrl, { concurrency: 2 })
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
Fetching url1
Fetching url2
Fetching url1 done
Fetching url3
Fetching url2 done
Fetching url3 done
{
  _id: &#39;Chunk&#39;,
  values: [
    [ &#39;Resource 0-url1&#39;, &#39;Resource 1-url1&#39;, &#39;Resource 2-url1&#39; ],
    [ &#39;Resource 0-url2&#39;, &#39;Resource 1-url2&#39;, &#39;Resource 2-url2&#39; ],
    [ &#39;Resource 0-url3&#39;, &#39;Resource 1-url3&#39;, &#39;Resource 2-url3&#39; ]
  ]
}
*/
</code></pre>
<h3>Stateful Mapping</h3>
<p><code>Stream.mapAccum</code> is similar to <code>Stream.map</code>, but it applies a transformation with state tracking, allowing you to map and accumulate values within a single operation. This is useful for tasks like calculating a running total in a stream.</p>
<p><strong>Example</strong> (Calculating a Running Total)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.range(1, 5).pipe(
  //                                  ┌─── next state
  //                                  │          ┌─── emitted value
  //                                  ▼          ▼
  Stream.mapAccum(0, (state, n) =&gt; [state + n, state + n])
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 3, 6, 10, 15 ] }
*/
</code></pre>
<h3>Mapping and Flattening</h3>
<p>The <code>Stream.mapConcat</code> operation is similar to <code>Stream.map</code>, but it goes further by mapping each element to zero or more elements (as an <code>Iterable</code>) and then flattening the entire stream. This is particularly useful for transforming each element into multiple values.</p>
<p><strong>Example</strong> (Splitting and Flattening a Stream)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const numbers = Stream.make(&quot;1-2-3&quot;, &quot;4-5&quot;, &quot;6&quot;).pipe(
  Stream.mapConcat((s) =&gt; s.split(&quot;-&quot;))
)

Effect.runPromise(Stream.runCollect(numbers)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39; ] }
*/
</code></pre>
<h2>Filtering</h2>
<p>The <code>Stream.filter</code> operation allows you to pass through only elements that meet a specific condition. It&#39;s a way to retain elements in a stream that satisfy a particular criteria while discarding the rest.</p>
<p><strong>Example</strong> (Filtering Even Numbers)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.range(1, 11).pipe(Stream.filter((n) =&gt; n % 2 === 0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 2, 4, 6, 8, 10 ] }
*/
</code></pre>
<h2>Scanning</h2>
<p>Stream scanning allows you to apply a function cumulatively to each element in the stream, emitting every intermediate result. Unlike <code>reduce</code>, which only provides a final result, <code>scan</code> offers a step-by-step view of the accumulation process.</p>
<p><strong>Example</strong> (Cumulative Addition)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.range(1, 5).pipe(Stream.scan(0, (a, b) =&gt; a + b))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 0, 1, 3, 6, 10, 15 ] }
*/
</code></pre>
<p>If you need only the final accumulated value, you can use <a href="/docs/stream/consuming-streams/#using-a-fold-operation">Stream.runFold</a>:</p>
<p><strong>Example</strong> (Final Accumulated Result)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const fold = Stream.range(1, 5).pipe(Stream.runFold(0, (a, b) =&gt; a + b))

Effect.runPromise(fold).then(console.log) // Output: 15
</code></pre>
<h2>Draining</h2>
<p>Stream draining lets you execute effectful operations within a stream while discarding the resulting values. This can be useful when you need to run actions or perform side effects but don&#39;t require the emitted values. The <code>Stream.drain</code> function achieves this by ignoring all elements in the stream and producing an empty output stream.</p>
<p><strong>Example</strong> (Executing Effectful Operations without Collecting Values)</p>
<pre><code class="language-ts">import { Stream, Effect, Random } from &quot;effect&quot;

const stream = Stream.repeatEffect(
  Effect.gen(function* () {
    const nextInt = yield* Random.nextInt
    const number = Math.abs(nextInt % 10)
    console.log(`random number: ${number}`)
    return number
  })
).pipe(Stream.take(3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
random number: 7
random number: 5
random number: 0
{ _id: &#39;Chunk&#39;, values: [ 7, 5, 0 ] }
*/

const drained = Stream.drain(stream)

Effect.runPromise(Stream.runCollect(drained)).then(console.log)
/*
Example Output:
random number: 0
random number: 1
random number: 7
{ _id: &#39;Chunk&#39;, values: [] }
*/
</code></pre>
<h2>Detecting Changes in a Stream</h2>
<p>The <code>Stream.changes</code> operation detects and emits elements that differ from their preceding elements within a stream. This can be useful for tracking changes or deduplicating consecutive values.</p>
<p><strong>Example</strong> (Emitting Distinct Consecutive Elements)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, 3, 4 ] }
*/
</code></pre>
<h2>Zipping</h2>
<p>Zipping combines elements from two streams into a new stream, pairing elements from each input stream. This can be achieved with <code>Stream.zip</code> or <code>Stream.zipWith</code>, allowing for custom pairing logic.</p>
<p><strong>Example</strong> (Basic Zipping)</p>
<p>In this example, elements from the two streams are paired sequentially. The resulting stream ends when one of the streams is exhausted.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Zip two streams together
const stream = Stream.zip(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ [ 1, &#39;a&#39; ], [ 2, &#39;b&#39; ], [ 3, &#39;c&#39; ] ] }
*/
</code></pre>
<p><strong>Example</strong> (Custom Zipping Logic)</p>
<p>Here, <code>Stream.zipWith</code> applies custom logic to each pair, combining elements in a user-defined way.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Zip two streams with custom pairing logic
const stream = Stream.zipWith(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),
  (n, s) =&gt; [n + 10, s + &quot;!&quot;]
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ [ 11, &#39;a!&#39; ], [ 12, &#39;b!&#39; ], [ 13, &#39;c!&#39; ] ] }
*/
</code></pre>
<h3>Handling Stream Endings</h3>
<p>If one input stream ends before the other, you might want to zip with default values to avoid missing pairs. The <code>Stream.zipAll</code> and <code>Stream.zipAllWith</code> operators provide this functionality, allowing you to specify defaults for either stream.</p>
<p><strong>Example</strong> (Zipping with Default Values)</p>
<p>In this example, when the second stream completes, the first stream continues with &quot;x&quot; as a default value for the second stream.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),
  defaultSelf: -1,
  defaultOther: &quot;x&quot;
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    [ 1, &#39;a&#39; ],
    [ 2, &#39;b&#39; ],
    [ 3, &#39;c&#39; ],
    [ 4, &#39;x&#39; ],
    [ 5, &#39;x&#39; ],
    [ 6, &#39;x&#39; ]
  ]
}
*/
</code></pre>
<p><strong>Example</strong> (Custom Logic with zipAllWith)</p>
<p>With <code>Stream.zipAllWith</code>, custom logic determines how to combine elements when either stream runs out, offering flexibility to handle these cases.</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;),
  onSelf: (n) =&gt; [n, &quot;x&quot;],
  onOther: (s) =&gt; [-1, s],
  onBoth: (n, s) =&gt; [n + 10, s + &quot;!&quot;]
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    [ 11, &#39;a!&#39; ],
    [ 12, &#39;b!&#39; ],
    [ 13, &#39;c!&#39; ],
    [ 4, &#39;x&#39; ],
    [ 5, &#39;x&#39; ],
    [ 6, &#39;x&#39; ]
  ]
}
*/
</code></pre>
<h3>Zipping Streams at Different Rates</h3>
<p>When combining streams that emit elements at different speeds, you may not want to wait for the slower stream to emit. Using <code>Stream.zipLatest</code> or <code>Stream.zipLatestWith</code>, you can zip elements as soon as either stream produces a new value. These functions use the most recent element from the slower stream whenever a new value arrives from the faster stream.</p>
<p><strong>Example</strong> (Combining Streams with Different Emission Rates)</p>
<pre><code class="language-ts">import { Stream, Schedule, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced(&quot;1 second&quot;))
)

const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;).pipe(
  Stream.schedule(Schedule.spaced(&quot;500 millis&quot;))
)

const stream = Stream.zipLatest(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    [ 1, &#39;a&#39; ],    // s1 emits 1 and pairs with the latest value from s2
    [ 1, &#39;b&#39; ],    // s2 emits &#39;b&#39;, pairs with the latest value from s1
    [ 2, &#39;b&#39; ],    // s1 emits 2, pairs with the latest value from s2
    [ 2, &#39;c&#39; ],    // s2 emits &#39;c&#39;, pairs with the latest value from s1
    [ 2, &#39;d&#39; ],    // s2 emits &#39;d&#39;, pairs with the latest value from s1
    [ 3, &#39;d&#39; ]     // s1 emits 3, pairs with the latest value from s2
  ]
}
*/
</code></pre>
<h3>Pairing with Previous and Next Elements</h3>
<table>
<thead>
<tr>
<th>API</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>zipWithPrevious</code></td>
<td>Pairs each element of a stream with its previous element.</td>
</tr>
<tr>
<td><code>zipWithNext</code></td>
<td>Pairs each element of a stream with its next element.</td>
</tr>
<tr>
<td><code>zipWithPreviousAndNext</code></td>
<td>Pairs each element with both its previous and next.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Pairing Stream Elements with Next)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunks) =&gt;
  console.log(&quot;%o&quot;, chunks)
)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    [ 1, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 }, [length]: 2 ],
    [ 2, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 3 }, [length]: 2 ],
    [ 3, { _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 4 }, [length]: 2 ],
    [ 4, { _id: &#39;Option&#39;, _tag: &#39;None&#39; }, [length]: 2 ],
    [length]: 4
  ]
}
*/
</code></pre>
<h3>Indexing Stream Elements</h3>
<p>The <code>Stream.zipWithIndex</code> operator is a helpful tool for indexing each element in a stream, pairing each item with its respective position in the sequence. This is particularly useful when you want to keep track of the order of elements within a stream.</p>
<p><strong>Example</strong> (Indexing Each Element in a Stream)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.zipWithIndex(
  Stream.make(&quot;Mary&quot;, &quot;James&quot;, &quot;Robert&quot;, &quot;Patricia&quot;)
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    [ &#39;Mary&#39;, 0 ],
    [ &#39;James&#39;, 1 ],
    [ &#39;Robert&#39;, 2 ],
    [ &#39;Patricia&#39;, 3 ]
  ]
}
*/
</code></pre>
<h2>Cartesian Product of Streams</h2>
<p>The Stream module includes a feature for computing the <em>Cartesian Product</em> of two streams, allowing you to create combinations of elements from two different streams. This is helpful when you need to pair each element from one set with every element of another.</p>
<p>In simple terms, imagine you have two collections and want to form all possible pairs by picking one item from each. This pairing process is the Cartesian Product. In streams, this operation generates a new stream that includes every possible pairing of elements from the two input streams.</p>
<p>To create a Cartesian Product of two streams, the <code>Stream.cross</code> operator is available, along with similar variants. These operators combine two streams into a new stream of all possible element combinations.</p>
<p><strong>Example</strong> (Creating a Cartesian Product of Two Streams)</p>
<pre><code class="language-ts">import { Stream, Effect, Console } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3).pipe(Stream.tap(Console.log))
const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;).pipe(Stream.tap(Console.log))

const cartesianProduct = Stream.cross(s1, s2)

Effect.runPromise(Stream.runCollect(cartesianProduct)).then(console.log)
/*
Output:
1
a
b
2
a
b
3
a
b
{
  _id: &#39;Chunk&#39;,
  values: [
    [ 1, &#39;a&#39; ],
    [ 1, &#39;b&#39; ],
    [ 2, &#39;a&#39; ],
    [ 2, &#39;b&#39; ],
    [ 3, &#39;a&#39; ],
    [ 3, &#39;b&#39; ]
  ]
}
*/
</code></pre>
<Aside type="caution" title="Multiple Iterations of Right Stream">
  Note that the right-hand stream (`s2` in this example) will be iterated
  over multiple times, once for each element in the left-hand stream
  (`s1`). If the right-hand stream involves expensive or
  side-effect-producing operations, those will be executed repeatedly.
</Aside>

<h2>Partitioning</h2>
<p>Partitioning a stream involves dividing it into two distinct streams based on a specified condition. The Stream module offers two functions for this purpose: <code>Stream.partition</code> and <code>Stream.partitionEither</code>. Let&#39;s look at how these functions work and the best scenarios for their use.</p>
<h3>partition</h3>
<p>The <code>Stream.partition</code> function takes a predicate (a condition) as input and divides the original stream into two substreams. One substream will contain elements that meet the condition, while the other contains those that do not. Both resulting substreams are wrapped in a <code>Scope</code> type.</p>
<p><strong>Example</strong> (Partitioning a Stream into Odd and Even Numbers)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

//      ┌─── Effect&lt;[Stream&lt;number&gt;, Stream&lt;number&gt;], never, Scope&gt;
//      ▼
const program = Stream.range(1, 9).pipe(
  Stream.partition((n) =&gt; n % 2 === 0, { bufferSize: 5 })
)

Effect.runPromise(
  Effect.scoped(
    Effect.gen(function* () {
      const [odds, evens] = yield* program
      console.log(yield* Stream.runCollect(odds))
      console.log(yield* Stream.runCollect(evens))
    })
  )
)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 3, 5, 7, 9 ] }
{ _id: &#39;Chunk&#39;, values: [ 2, 4, 6, 8 ] }
*/
</code></pre>
<h3>partitionEither</h3>
<p>In some cases, you might need to partition a stream using a condition that involves an effect. For this, the <code>Stream.partitionEither</code> function is ideal. This function uses an effectful predicate to split the stream into two substreams: one for elements that produce <code>Either.left</code> values and another for elements that produce <code>Either.right</code> values.</p>
<p><strong>Example</strong> (Partitioning a Stream with an Effectful Predicate)</p>
<pre><code class="language-ts">import { Stream, Effect, Either } from &quot;effect&quot;

//      ┌─── Effect&lt;[Stream&lt;number&gt;, Stream&lt;number&gt;], never, Scope&gt;
//      ▼
const program = Stream.range(1, 9).pipe(
  Stream.partitionEither(
    // Simulate an effectful computation
    (n) =&gt; Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),
    { bufferSize: 5 }
  )
)

Effect.runPromise(
  Effect.scoped(
    Effect.gen(function* () {
      const [odds, evens] = yield* program
      console.log(yield* Stream.runCollect(odds))
      console.log(yield* Stream.runCollect(evens))
    })
  )
)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 3, 5, 7, 9 ] }
{ _id: &#39;Chunk&#39;, values: [ 2, 4, 6, 8 ] }
*/
</code></pre>
<h2>Grouping</h2>
<p>When processing streams of data, you may need to group elements based on specific criteria. The Stream module provides two functions for this purpose: <code>groupByKey</code>, <code>groupBy</code>, <code>grouped</code> and <code>groupedWithin</code>. Let&#39;s review how these functions work and when to use each one.</p>
<h3>groupByKey</h3>
<p>The <code>Stream.groupByKey</code> function partitions a stream based on a key function of type <code>(a: A) =&gt; K</code>, where <code>A</code> is the type of elements in the stream, and <code>K</code> represents the keys for grouping. This function is non-effectful and groups elements by simply applying the provided key function.</p>
<p>The result of <code>Stream.groupByKey</code> is a <code>GroupBy</code> data type, representing the grouped stream. To process each group, you can use <code>GroupBy.evaluate</code>, which takes a function of type <code>(key: K, stream: Stream&lt;V, E&gt;) =&gt; Stream.Stream&lt;...&gt;</code>. This function operates across all groups and merges them together in a non-deterministic order.</p>
<p><strong>Example</strong> (Grouping by Tens Place in Exam Scores)</p>
<p>In the following example, we use <code>Stream.groupByKey</code> to group exam scores by the tens place and count the number of scores in each group:</p>
<pre><code class="language-ts">import { Stream, GroupBy, Effect, Chunk } from &quot;effect&quot;

class Exam {
  constructor(readonly person: string, readonly score: number) {}
}

// Define a list of exam results
const examResults = [
  new Exam(&quot;Alex&quot;, 64),
  new Exam(&quot;Michael&quot;, 97),
  new Exam(&quot;Bill&quot;, 77),
  new Exam(&quot;John&quot;, 78),
  new Exam(&quot;Bobby&quot;, 71)
]

// Group exam results by the tens place in the score
const groupByKeyResult = Stream.fromIterable(examResults).pipe(
  Stream.groupByKey((exam) =&gt; Math.floor(exam.score / 10) * 10)
)

// Count the number of exam results in each group
const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =&gt;
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) =&gt; [key, Chunk.size(chunk)] as const)
    )
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ [ 60, 1 ], [ 90, 1 ], [ 70, 3 ] ] }
*/
</code></pre>
<h3>groupBy</h3>
<p>For more complex grouping requirements where partitioning involves effects, you can use the <code>Stream.groupBy</code> function. This function accepts an effectful partitioning function and returns a <code>GroupBy</code> data type, representing the grouped stream. You can then process each group by using <code>GroupBy.evaluate</code>, similar to <code>Stream.groupByKey</code>.</p>
<p><strong>Example</strong> (Grouping Names by First Letter)</p>
<p>In the following example, we group names by their first letter and count the number of names in each group. Here, the partitioning operation is set up as an effectful operation:</p>
<pre><code class="language-ts">import { Stream, GroupBy, Effect, Chunk } from &quot;effect&quot;

// Group names by their first letter
const groupByKeyResult = Stream.fromIterable([
  &quot;Mary&quot;,
  &quot;James&quot;,
  &quot;Robert&quot;,
  &quot;Patricia&quot;,
  &quot;John&quot;,
  &quot;Jennifer&quot;,
  &quot;Rebecca&quot;,
  &quot;Peter&quot;
]).pipe(
  // Simulate an effectful groupBy operation
  Stream.groupBy((name) =&gt; Effect.succeed([name.substring(0, 1), name]))
)

// Count the number of names in each group and display results
const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =&gt;
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) =&gt; [key, Chunk.size(chunk)] as const)
    )
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [ [ &#39;M&#39;, 1 ], [ &#39;J&#39;, 3 ], [ &#39;R&#39;, 2 ], [ &#39;P&#39;, 2 ] ]
}
*/
</code></pre>
<h3>grouped</h3>
<p>The <code>Stream.grouped</code> function is ideal for dividing a stream into chunks of a specified size, making it easier to handle data in smaller, organized segments. This is particularly helpful when processing or displaying data in batches.</p>
<p><strong>Example</strong> (Dividing a Stream into Chunks of 3 Elements)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Create a stream of numbers and group them into chunks of 3
const stream = Stream.range(0, 8).pipe(Stream.grouped(3))

Effect.runPromise(Stream.runCollect(stream)).then((chunks) =&gt;
  console.log(&quot;%o&quot;, chunks)
)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    { _id: &#39;Chunk&#39;, values: [ 0, 1, 2, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 3, 4, 5, [length]: 3 ] },
    { _id: &#39;Chunk&#39;, values: [ 6, 7, 8, [length]: 3 ] },
    [length]: 3
  ]
}
*/
</code></pre>
<h3>groupedWithin</h3>
<p>The <code>Stream.groupedWithin</code> function allows for flexible grouping by creating chunks based on either a specified maximum size or a time interval, whichever condition is met first. This is especially useful for working with data where timing constraints are involved.</p>
<p><strong>Example</strong> (Grouping by Size or Time Interval)</p>
<p>In this example, <code>Stream.groupedWithin(18, &quot;1.5 seconds&quot;)</code> groups the stream into chunks whenever either 18 elements accumulate or 1.5 seconds elapse since the last chunk was created.</p>
<pre><code class="language-ts">import { Stream, Schedule, Effect, Chunk } from &quot;effect&quot;

// Create a stream that repeats every second and group by size or time
const stream = Stream.range(0, 9).pipe(
  Stream.repeat(Schedule.spaced(&quot;1 second&quot;)),
  Stream.groupedWithin(18, &quot;1.5 seconds&quot;),
  Stream.take(3)
)

Effect.runPromise(Stream.runCollect(stream)).then((chunks) =&gt;
  console.log(Chunk.toArray(chunks))
)
/*
Output:
[
  {
    _id: &#39;Chunk&#39;,
    values: [
      0, 1, 2, 3, 4, 5, 6,
      7, 8, 9, 0, 1, 2, 3,
      4, 5, 6, 7
    ]
  },
  {
    _id: &#39;Chunk&#39;,
    values: [
      8, 9, 0, 1, 2,
      3, 4, 5, 6, 7,
      8, 9
    ]
  },
  {
    _id: &#39;Chunk&#39;,
    values: [
      0, 1, 2, 3, 4, 5, 6,
      7, 8, 9, 0, 1, 2, 3,
      4, 5, 6, 7
    ]
  }
]
*/
</code></pre>
<h2>Concatenation</h2>
<p>In stream processing, you may need to combine the contents of multiple streams. The Stream module offers several operators to achieve this, including <code>Stream.concat</code>, <code>Stream.concatAll</code>, and <code>Stream.flatMap</code>. Let&#39;s look at how each of these operators works.</p>
<h3>Simple Concatenation</h3>
<p>The <code>Stream.concat</code> operator is a straightforward method for joining two streams. It returns a new stream that emits elements from the first stream (left-hand) followed by elements from the second stream (right-hand). This is helpful when you want to combine two streams in a specific sequence.</p>
<p><strong>Example</strong> (Concatenating Two Streams Sequentially)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const stream = Stream.concat(Stream.make(1, 2, 3), Stream.make(&quot;a&quot;, &quot;b&quot;))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 2, 3, &#39;a&#39;, &#39;b&#39; ] }
*/
</code></pre>
<h3>Concatenating Multiple Streams</h3>
<p>If you have multiple streams to concatenate, <code>Stream.concatAll</code> provides an efficient way to combine them without manually chaining multiple <code>Stream.concat</code> operations. This function takes a <a href="/docs/data-types/chunk/">Chunk</a> of streams and returns a single stream containing the elements of each stream in sequence.</p>
<p><strong>Example</strong> (Concatenating Multiple Streams)</p>
<pre><code class="language-ts">import { Stream, Effect, Chunk } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(&quot;a&quot;, &quot;b&quot;)
const s3 = Stream.make(true, false, false)

const stream = Stream.concatAll&lt;number | string | boolean, never, never&gt;(
  Chunk.make(s1, s2, s3)
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    1,     2,     3,
    &#39;a&#39;,   &#39;b&#39;,   true,
    false, false
  ]
}
*/
</code></pre>
<h3>Advanced Concatenation with flatMap</h3>
<p>The <code>Stream.flatMap</code> operator allows for advanced concatenation by creating a stream where each element is generated by applying a function of type <code>(a: A) =&gt; Stream&lt;...&gt;</code> to each output of the source stream. This operator then concatenates all the resulting streams, effectively flattening them.</p>
<p><strong>Example</strong> (Generating Repeated Elements with <code>Stream.flatMap</code>)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Create a stream where each element is repeated 4 times
const stream = Stream.make(1, 2, 3).pipe(
  Stream.flatMap((a) =&gt; Stream.repeatValue(a).pipe(Stream.take(4)))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    1, 1, 1, 1, 2,
    2, 2, 2, 3, 3,
    3, 3
  ]
}
*/
</code></pre>
<p>If you need to perform the <code>flatMap</code> operation concurrently, you can use the <a href="/docs/concurrency/basic-concurrency/#concurrency-options">concurrency</a> option to control how many inner streams run simultaneously.
Additionally, if the order of concatenation is not important, you can use the <code>switch</code> option.</p>
<h2>Merging</h2>
<p>Sometimes, you may want to interleave elements from two streams and create a single output stream. In such cases, <code>Stream.concat</code> isn&#39;t suitable because it waits for the first stream to complete before consuming the second. For interleaving elements as they become available, <code>Stream.merge</code> and its variants are designed for this purpose.</p>
<h3>merge</h3>
<p>The <code>Stream.merge</code> operation combines elements from two source streams into a single stream, interleaving elements as they are produced. Unlike <code>Stream.concat</code>, <code>Stream.merge</code> does not wait for one stream to finish before starting the other.</p>
<p><strong>Example</strong> (Interleaving Two Streams with <code>Stream.merge</code>)</p>
<pre><code class="language-ts">import { Schedule, Stream, Effect } from &quot;effect&quot;

// Create two streams with different emission intervals
const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced(&quot;100 millis&quot;))
)
const s2 = Stream.make(4, 5, 6).pipe(
  Stream.schedule(Schedule.spaced(&quot;200 millis&quot;))
)

// Merge s1 and s2 into a single stream that interleaves their values
const merged = Stream.merge(s1, s2)

Effect.runPromise(Stream.runCollect(merged)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 4, 2, 3, 5, 6 ] }
*/
</code></pre>
<h3>Termination Strategy</h3>
<p>When merging two streams, it&#39;s important to consider the termination strategy, especially if each stream has a different lifetime.
By default, <code>Stream.merge</code> waits for both streams to terminate before ending the merged stream. However, you can modify this behavior with <code>haltStrategy</code>, selecting from four termination strategies:</p>
<table>
<thead>
<tr>
<th>Termination Strategy</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;left&quot;</code></td>
<td>The merged stream terminates when the left-hand stream terminates.</td>
</tr>
<tr>
<td><code>&quot;right&quot;</code></td>
<td>The merged stream terminates when the right-hand stream terminates.</td>
</tr>
<tr>
<td><code>&quot;both&quot;</code> (default)</td>
<td>The merged stream terminates only when both streams have terminated.</td>
</tr>
<tr>
<td><code>&quot;either&quot;</code></td>
<td>The merged stream terminates as soon as either stream terminates.</td>
</tr>
</tbody></table>
<p><strong>Example</strong> (Using <code>haltStrategy: &quot;left&quot;</code> to Control Stream Termination)</p>
<pre><code class="language-ts">import { Stream, Schedule, Effect } from &quot;effect&quot;

const s1 = Stream.range(1, 5).pipe(
  Stream.schedule(Schedule.spaced(&quot;100 millis&quot;))
)
const s2 = Stream.repeatValue(0).pipe(
  Stream.schedule(Schedule.spaced(&quot;200 millis&quot;))
)

const merged = Stream.merge(s1, s2, { haltStrategy: &quot;left&quot; })

Effect.runPromise(Stream.runCollect(merged)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    1, 0, 2, 3,
    0, 4, 5
  ]
}
*/
</code></pre>
<h3>mergeWith</h3>
<p>In some cases, you may want to merge two streams while transforming their elements into a unified type. <code>Stream.mergeWith</code> is designed for this purpose, allowing you to specify transformation functions for each source stream.</p>
<p><strong>Example</strong> (Merging and Transforming Two Streams)</p>
<pre><code class="language-ts">import { Schedule, Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).pipe(
  Stream.schedule(Schedule.spaced(&quot;100 millis&quot;))
)
const s2 = Stream.make(4.1, 5.3, 6.2).pipe(
  Stream.schedule(Schedule.spaced(&quot;200 millis&quot;))
)

const merged = Stream.mergeWith(s1, s2, {
  // Convert string elements from `s1` to integers
  onSelf: (s) =&gt; parseInt(s),
  // Round down decimal elements from `s2`
  onOther: (n) =&gt; Math.floor(n)
})

Effect.runPromise(Stream.runCollect(merged)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 4, 2, 3, 5, 6 ] }
*/
</code></pre>
<h2>Interleaving</h2>
<h3>interleave</h3>
<p>The <code>Stream.interleave</code> operator lets you pull one element at a time from each of two streams, creating a new interleaved stream. If one stream finishes first, the remaining elements from the other stream continue to be pulled until both streams are exhausted.</p>
<p><strong>Example</strong> (Basic Interleaving of Two Streams)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5, 6)

const stream = Stream.interleave(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: &#39;Chunk&#39;, values: [ 1, 4, 2, 5, 3, 6 ] }
*/
</code></pre>
<h3>interleaveWith</h3>
<p>For more complex interleaving, <code>Stream.interleaveWith</code> provides additional control by using a third stream of <code>boolean</code> values to dictate the interleaving pattern. When this stream emits <code>true</code>, an element is taken from the left-hand stream; otherwise, an element is taken from the right-hand stream.</p>
<p><strong>Example</strong> (Custom Interleaving Logic Using <code>Stream.interleaveWith</code>)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

const s1 = Stream.make(1, 3, 5, 7, 9)
const s2 = Stream.make(2, 4, 6, 8, 10)

// Define a boolean stream to control interleaving
const booleanStream = Stream.make(true, false, false).pipe(Stream.forever)

const stream = Stream.interleaveWith(s1, s2, booleanStream)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    1, 2,  4, 3, 6,
    8, 5, 10, 7, 9
  ]
}
*/
</code></pre>
<h2>Interspersing</h2>
<p>Interspersing adds separators or affixes in a stream, useful for formatting or structuring data in streams.</p>
<h3>intersperse</h3>
<p>The <code>Stream.intersperse</code> operator inserts a specified delimiter element between each pair of elements in a stream. This delimiter can be any chosen value and is added between each consecutive pair.</p>
<p><strong>Example</strong> (Inserting Delimiters Between Stream Elements)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Create a stream of numbers and intersperse `0` between them
const stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    1, 0, 2, 0, 3,
    0, 4, 0, 5
  ]
}
*/
</code></pre>
<h3>intersperseAffixes</h3>
<p>For more complex needs, <code>Stream.intersperseAffixes</code> provides control over different affixes at the start, between elements, and at the end of the stream.</p>
<p><strong>Example</strong> (Adding Affixes to a Stream)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Create a stream and add affixes:
// - `[` at the start
// - `|` between elements
// - `]` at the end
const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.intersperseAffixes({
    start: &quot;[&quot;,
    middle: &quot;|&quot;,
    end: &quot;]&quot;
  })
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{
  _id: &#39;Chunk&#39;,
  values: [
    &#39;[&#39;, 1,   &#39;|&#39;, 2,   &#39;|&#39;,
    3,   &#39;|&#39;, 4,   &#39;|&#39;, 5,
    &#39;]&#39;
  ]
}
*/
</code></pre>
<h2>Broadcasting</h2>
<p>Broadcasting a stream creates multiple downstream streams that each receive the same elements from the source stream. This is useful when you want to send each element to multiple consumers simultaneously. The upstream stream has a <code>maximumLag</code> parameter that sets the limit for how much it can get ahead before slowing down to match the speed of the slowest downstream stream.</p>
<p><strong>Example</strong> (Broadcasting to Multiple Downstream Streams)</p>
<p>In the following example, we broadcast a stream of numbers to two downstream consumers. The first calculates the maximum value in the stream, while the second logs each number with a delay. The upstream stream&#39;s speed adjusts based on the slower logging stream:</p>
<pre><code class="language-ts">import { Effect, Stream, Console, Schedule, Fiber } from &quot;effect&quot;

const numbers = Effect.scoped(
  Stream.range(1, 20).pipe(
    Stream.tap((n) =&gt;
      Console.log(`Emit ${n} element before broadcasting`)
    ),
    // Broadcast to 2 downstream consumers with max lag of 5
    Stream.broadcast(2, 5),
    Stream.flatMap(([first, second]) =&gt;
      Effect.gen(function* () {
        // First downstream stream: calculates maximum
        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) =&gt;
          Math.max(acc, e)
        ).pipe(
          Effect.andThen((max) =&gt; Console.log(`Maximum: ${max}`)),
          Effect.fork
        )

        // Second downstream stream: logs each element with a delay
        const fiber2 = yield* second.pipe(
          Stream.schedule(Schedule.spaced(&quot;1 second&quot;)),
          Stream.runForEach((n) =&gt;
            Console.log(`Logging to the Console: ${n}`)
          ),
          Effect.fork
        )

        // Wait for both fibers to complete
        yield* Fiber.join(fiber1).pipe(
          Effect.zip(Fiber.join(fiber2), { concurrent: true })
        )
      })
    ),
    Stream.runCollect
  )
)

Effect.runPromise(numbers).then(console.log)
/*
Output:
Emit 1 element before broadcasting
Emit 2 element before broadcasting
Emit 3 element before broadcasting
Emit 4 element before broadcasting
Emit 5 element before broadcasting
Emit 6 element before broadcasting
Emit 7 element before broadcasting
Emit 8 element before broadcasting
Emit 9 element before broadcasting
Emit 10 element before broadcasting
Emit 11 element before broadcasting
Logging to the Console: 1
Logging to the Console: 2
Logging to the Console: 3
Logging to the Console: 4
Logging to the Console: 5
Emit 12 element before broadcasting
Emit 13 element before broadcasting
Emit 14 element before broadcasting
Emit 15 element before broadcasting
Emit 16 element before broadcasting
Logging to the Console: 6
Logging to the Console: 7
Logging to the Console: 8
Logging to the Console: 9
Logging to the Console: 10
Emit 17 element before broadcasting
Emit 18 element before broadcasting
Emit 19 element before broadcasting
Emit 20 element before broadcasting
Logging to the Console: 11
Logging to the Console: 12
Logging to the Console: 13
Logging to the Console: 14
Logging to the Console: 15
Maximum: 20
Logging to the Console: 16
Logging to the Console: 17
Logging to the Console: 18
Logging to the Console: 19
Logging to the Console: 20
{ _id: &#39;Chunk&#39;, values: [ undefined ] }
*/
</code></pre>
<h2>Buffering</h2>
<p>Effect streams use a pull-based model, allowing downstream consumers to control the rate at which they request elements. However, when there&#39;s a mismatch in the speed between the producer and the consumer, buffering can help balance their interaction. The <code>Stream.buffer</code> operator is designed to manage this, allowing the producer to keep working even if the consumer is slower. You can set a maximum buffer capacity using the <code>capacity</code> option.</p>
<h3>buffer</h3>
<p>The <code>Stream.buffer</code> operator queues elements to allow the producer to work independently from the consumer, up to a specified capacity. This helps when a faster producer and a slower consumer need to operate smoothly without blocking each other.</p>
<p><strong>Example</strong> (Using a Buffer to Handle Speed Mismatch)</p>
<pre><code class="language-ts">import { Stream, Console, Schedule, Effect } from &quot;effect&quot;

const stream = Stream.range(1, 10).pipe(
  // Log each element before buffering
  Stream.tap((n) =&gt; Console.log(`before buffering: ${n}`)),
  // Buffer with a capacity of 4 elements
  Stream.buffer({ capacity: 4 }),
  // Log each element after buffering
  Stream.tap((n) =&gt; Console.log(`after buffering: ${n}`)),
  // Add a 5-second delay between each emission
  Stream.schedule(Schedule.spaced(&quot;5 seconds&quot;))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
before buffering: 1
before buffering: 2
before buffering: 3
before buffering: 4
before buffering: 5
before buffering: 6
after buffering: 1
after buffering: 2
before buffering: 7
after buffering: 3
before buffering: 8
after buffering: 4
before buffering: 9
after buffering: 5
before buffering: 10
...
*/
</code></pre>
<p>Different buffering options let you tailor the buffering strategy based on your use case:</p>
<table>
<thead>
<tr>
<th><strong>Buffering Type</strong></th>
<th><strong>Configuration</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bounded Queue</strong></td>
<td><code>{ capacity: number }</code></td>
<td>Limits the queue to a fixed size.</td>
</tr>
<tr>
<td><strong>Unbounded Queue</strong></td>
<td><code>{ capacity: &quot;unbounded&quot; }</code></td>
<td>Allows an unlimited number of buffered items.</td>
</tr>
<tr>
<td><strong>Sliding Queue</strong></td>
<td><code>{ capacity: number, strategy: &quot;sliding&quot; }</code></td>
<td>Keeps the most recent items, discarding older ones when full.</td>
</tr>
<tr>
<td><strong>Dropping Queue</strong></td>
<td><code>{ capacity: number, strategy: &quot;dropping&quot; }</code></td>
<td>Keeps the earliest items, discarding new ones when full.</td>
</tr>
</tbody></table>
<h2>Debouncing</h2>
<p>Debouncing is a technique used to prevent a function from firing too frequently, which is particularly useful when a stream emits values rapidly but only the last value after a pause is needed.</p>
<p>The <code>Stream.debounce</code> function achieves this by delaying the emission of values until a specified time period has passed without any new values. If a new value arrives during the waiting period, the timer resets, and only the latest value will eventually be emitted after a pause.</p>
<p><strong>Example</strong> (Debouncing a Stream of Rapidly Emitted Values)</p>
<pre><code class="language-ts">import { Stream, Effect } from &quot;effect&quot;

// Helper function to log with elapsed time since the last log
let last = Date.now()
const log = (message: string) =&gt;
  Effect.sync(() =&gt; {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3).pipe(
  // Emit the value 4 after 200 ms
  Stream.concat(
    Stream.fromEffect(Effect.sleep(&quot;200 millis&quot;).pipe(Effect.as(4)))
  ),
  // Continue with more rapid values
  Stream.concat(Stream.make(5, 6)),
  // Emit 7 after 150 ms
  Stream.concat(
    Stream.fromEffect(Effect.sleep(&quot;150 millis&quot;).pipe(Effect.as(7)))
  ),
  Stream.concat(Stream.make(8)),
  Stream.tap((n) =&gt; log(`Received ${n}`)),
  // Only emit values after a pause of at least 100 milliseconds
  Stream.debounce(&quot;100 millis&quot;),
  Stream.tap((n) =&gt; log(`&gt; Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
Received 1 after 5ms
Received 2 after 2ms
Received 3 after 0ms
&gt; Emitted 3 after 104ms
Received 4 after 99ms
Received 5 after 1ms
Received 6 after 0ms
&gt; Emitted 6 after 101ms
Received 7 after 50ms
Received 8 after 1ms
&gt; Emitted 8 after 101ms
{ _id: &#39;Chunk&#39;, values: [ 3, 6, 8 ] }
*/
</code></pre>
<h2>Throttling</h2>
<p>Throttling is a technique for regulating the rate at which elements are emitted from a stream. It helps maintain a steady data output pace, which is valuable in situations where data processing needs to occur at a consistent rate.</p>
<p>The <code>Stream.throttle</code> function uses the <a href="https://en.wikipedia.org/wiki/Token_bucket">token bucket algorithm</a> to control the rate of stream emissions.</p>
<p><strong>Example</strong> (Throttle Configuration)</p>
<pre><code class="language-ts">Stream.throttle({
  cost: () =&gt; 1,
  duration: &quot;100 millis&quot;,
  units: 1
})
</code></pre>
<p>In this configuration:</p>
<ul>
<li>Each chunk processed uses one token (<code>cost = () =&gt; 1</code>).</li>
<li>Tokens are replenished at a rate of one token (<code>units: 1</code>) every 100 milliseconds (<code>duration: &quot;100 millis&quot;</code>).</li>
</ul>
<Aside type="caution" title="Throttling Applies to Chunks, Not Elements">
  Note that throttling operates on chunks rather than individual elements.
  The `cost` function sets the token cost for each chunk.
</Aside>

<h3>Shape Strategy (Default)</h3>
<p>The &quot;shape&quot; strategy moderates data flow by delaying chunk emissions until they comply with specified bandwidth constraints.
This strategy ensures that data throughput does not exceed defined limits, allowing for steady and controlled data emission.</p>
<p><strong>Example</strong> (Applying Throttling with the Shape Strategy)</p>
<pre><code class="language-ts">import { Stream, Effect, Schedule, Chunk } from &quot;effect&quot;

// Helper function to log with elapsed time since last log
let last = Date.now()
const log = (message: string) =&gt;
  Effect.sync(() =&gt; {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced(&quot;50 millis&quot;)).pipe(
  Stream.take(6),
  Stream.tap((n) =&gt; log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: &quot;100 millis&quot;,
    units: 1
  }),
  Stream.tap((n) =&gt; log(`&gt; Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
Received 0 after 56ms
&gt; Emitted 0 after 0ms
Received 1 after 52ms
&gt; Emitted 1 after 48ms
Received 2 after 52ms
&gt; Emitted 2 after 49ms
Received 3 after 52ms
&gt; Emitted 3 after 48ms
Received 4 after 52ms
&gt; Emitted 4 after 47ms
Received 5 after 52ms
&gt; Emitted 5 after 49ms
{ _id: &#39;Chunk&#39;, values: [ 0, 1, 2, 3, 4, 5 ] }
*/
</code></pre>
<h3>Enforce Strategy</h3>
<p>The &quot;enforce&quot; strategy strictly regulates data flow by discarding chunks that exceed bandwidth constraints.</p>
<p><strong>Example</strong> (Throttling with the Enforce Strategy)</p>
<pre><code class="language-ts">import { Stream, Effect, Schedule, Chunk } from &quot;effect&quot;

// Helper function to log with elapsed time since last log
let last = Date.now()
const log = (message: string) =&gt;
  Effect.sync(() =&gt; {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3, 4, 5, 6).pipe(
  Stream.schedule(Schedule.exponential(&quot;100 millis&quot;)),
  Stream.tap((n) =&gt; log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: &quot;1 second&quot;,
    units: 1,
    strategy: &quot;enforce&quot;
  }),
  Stream.tap((n) =&gt; log(`&gt; Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
Received 1 after 106ms
&gt; Emitted 1 after 1ms
Received 2 after 200ms
Received 3 after 402ms
Received 4 after 801ms
&gt; Emitted 4 after 1ms
Received 5 after 1601ms
&gt; Emitted 5 after 1ms
Received 6 after 3201ms
&gt; Emitted 6 after 0ms
{ _id: &#39;Chunk&#39;, values: [ 1, 4, 5, 6 ] }
*/
</code></pre>
<h3>burst option</h3>
<p>The <code>Stream.throttle</code> function offers a burst option that allows for temporary increases in data throughput beyond the set rate limits.
This option is set to greater than 0 to activate burst capability (default is 0, indicating no burst support).
The burst capacity provides additional tokens in the token bucket, enabling the stream to momentarily exceed its configured rate when bursts of data occur.</p>
<p><strong>Example</strong> (Throttling with Burst Capacity)</p>
<pre><code class="language-ts">import { Effect, Schedule, Stream, Chunk } from &quot;effect&quot;

// Helper function to log with elapsed time since last log
let last = Date.now()
const log = (message: string) =&gt;
  Effect.sync(() =&gt; {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced(&quot;10 millis&quot;)).pipe(
  Stream.take(20),
  Stream.tap((n) =&gt; log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: &quot;200 millis&quot;,
    units: 5,
    strategy: &quot;enforce&quot;,
    burst: 2
  }),
  Stream.tap((n) =&gt; log(`&gt; Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Example Output:
Received 0 after 16ms
&gt; Emitted 0 after 0ms
Received 1 after 12ms
&gt; Emitted 1 after 0ms
Received 2 after 11ms
&gt; Emitted 2 after 0ms
Received 3 after 11ms
&gt; Emitted 3 after 0ms
Received 4 after 11ms
&gt; Emitted 4 after 1ms
Received 5 after 11ms
&gt; Emitted 5 after 0ms
Received 6 after 12ms
&gt; Emitted 6 after 0ms
Received 7 after 11ms
Received 8 after 12ms
Received 9 after 11ms
Received 10 after 11ms
&gt; Emitted 10 after 0ms
Received 11 after 11ms
Received 12 after 11ms
Received 13 after 12ms
&gt; Emitted 13 after 0ms
Received 14 after 11ms
Received 15 after 12ms
Received 16 after 11ms
Received 17 after 11ms
&gt; Emitted 17 after 0ms
Received 18 after 12ms
Received 19 after 10ms
{
  _id: &#39;Chunk&#39;,
  values: [
    0, 1,  2,  3,  4,
    5, 6, 10, 13, 17
  ]
}
*/
</code></pre>
<p>In this setup, the stream starts with a bucket containing 5 tokens, allowing the first five chunks to be emitted instantly.
The additional burst capacity of 2 accommodates further emissions momentarily, allowing for handling of subsequent data more flexibly.
Over time, as the bucket refills according to the throttle configuration, additional elements are emitted, demonstrating how the burst capability can manage uneven data flows effectively.</p>
<h2>Scheduling</h2>
<p>When working with streams, you may need to introduce specific time intervals between each element&#39;s emission. The <code>Stream.schedule</code> combinator allows you to set these intervals.</p>
<p><strong>Example</strong> (Adding a Delay Between Stream Emissions)</p>
<pre><code class="language-ts">import { Stream, Schedule, Console, Effect } from &quot;effect&quot;

// Create a stream that emits values with a 1-second delay between each
const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.schedule(Schedule.spaced(&quot;1 second&quot;)),
  Stream.tap(Console.log)
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
1
2
3
4
5
{
  _id: &quot;Chunk&quot;,
  values: [ 1, 2, 3, 4, 5 ]
}
*/
</code></pre>
<p>In this example, we&#39;ve used the <code>Schedule.spaced(&quot;1 second&quot;)</code> schedule to introduce a one-second gap between each emission in the stream.</p>
<hr>
<hr>
<h2>title: Resourceful Streams
description: Learn how to manage resources in streams with safe acquisition and release, finalization for cleanup tasks, and ensuring post-finalization actions for robust resource handling in streaming applications.
sidebar:
  order: 5</h2>
<p>In the Stream module, you&#39;ll find that most of the constructors offer a special variant designed for lifting a scoped resource into a <code>Stream</code>. When you use these specific constructors, you&#39;re essentially creating streams that are inherently safe with regards to resource management. These constructors, before creating the stream, handle the resource acquisition, and after the stream&#39;s usage, they ensure its proper closure.</p>
<p>Stream also provides us with <code>Stream.acquireRelease</code> and <code>Stream.finalizer</code> constructors that share similarities with <code>Effect.acquireRelease</code> and <code>Effect.addFinalizer</code>. These tools empower us to perform cleanup or finalization tasks before the stream concludes its operation.</p>
<h2>Acquire Release</h2>
<p>In this section, we&#39;ll explore an example that demonstrates the use of <code>Stream.acquireRelease</code> when working with file operations.</p>
<pre><code class="language-ts">import { Stream, Console, Effect } from &quot;effect&quot;

// Simulating File operations
const open = (filename: string) =&gt;
  Effect.gen(function* () {
    yield* Console.log(`Opening ${filename}`)
    return {
      getLines: Effect.succeed([&quot;Line 1&quot;, &quot;Line 2&quot;, &quot;Line 3&quot;]),
      close: Console.log(`Closing ${filename}`)
    }
  })

const stream = Stream.acquireRelease(
  open(&quot;file.txt&quot;),
  (file) =&gt; file.close
).pipe(Stream.flatMap((file) =&gt; file.getLines))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
Opening file.txt
Closing file.txt
{
  _id: &quot;Chunk&quot;,
  values: [
    [ &quot;Line 1&quot;, &quot;Line 2&quot;, &quot;Line 3&quot; ]
  ]
}
*/
</code></pre>
<p>In this code snippet, we&#39;re simulating file operations using the <code>open</code> function. The <code>Stream.acquireRelease</code> function is employed to ensure that the file is correctly opened and closed, and we then process the lines of the file using the acquired resource.</p>
<h2>Finalization</h2>
<p>In this section, we&#39;ll explore the concept of finalization in streams. Finalization allows us to execute a specific action before a stream ends. This can be particularly useful when we want to perform cleanup tasks or add final touches to a stream.</p>
<p>Imagine a scenario where our streaming application needs to clean up a temporary directory when it completes its execution. We can achieve this using the <code>Stream.finalizer</code> function:</p>
<pre><code class="language-ts">import { Stream, Console, Effect } from &quot;effect&quot;

const application = Stream.fromEffect(Console.log(&quot;Application Logic.&quot;))

const deleteDir = (dir: string) =&gt; Console.log(`Deleting dir: ${dir}`)

const program = application.pipe(
  Stream.concat(
    Stream.finalizer(
      deleteDir(&quot;tmp&quot;).pipe(
        Effect.andThen(Console.log(&quot;Temporary directory was deleted.&quot;))
      )
    )
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
/*
Output:
Application Logic.
Deleting dir: tmp
Temporary directory was deleted.
{
  _id: &quot;Chunk&quot;,
  values: [ undefined, undefined ]
}
*/
</code></pre>
<p>In this code example, we start with our application logic represented by the <code>application</code> stream. We then use <code>Stream.finalizer</code> to define a finalization step, which deletes a temporary directory and logs a message. This ensures that the temporary directory is cleaned up properly when the application completes its execution.</p>
<h2>Ensuring</h2>
<p>In this section, we&#39;ll explore a scenario where we need to perform actions after the finalization of a stream. To achieve this, we can utilize the <code>Stream.ensuring</code> operator.</p>
<p>Consider a situation where our application has completed its primary logic and finalized some resources, but we also need to perform additional actions afterward. We can use <code>Stream.ensuring</code> for this purpose:</p>
<pre><code class="language-ts">import { Stream, Console, Effect } from &quot;effect&quot;

const program = Stream.fromEffect(Console.log(&quot;Application Logic.&quot;)).pipe(
  Stream.concat(Stream.finalizer(Console.log(&quot;Finalizing the stream&quot;))),
  Stream.ensuring(
    Console.log(&quot;Doing some other works after stream&#39;s finalization&quot;)
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
/*
Output:
Application Logic.
Finalizing the stream
Doing some other works after stream&#39;s finalization
{
  _id: &quot;Chunk&quot;,
  values: [ undefined, undefined ]
}
*/
</code></pre>
<p>In this code example, we start with our application logic represented by the <code>Application Logic.</code> message. We then use <code>Stream.finalizer</code> to specify the finalization step, which logs <code>Finalizing the stream</code>. After that, we use <code>Stream.ensuring</code> to indicate that we want to perform additional tasks after the stream&#39;s finalization, resulting in the message <code>Performing additional tasks after stream&#39;s finalization</code>. This ensures that our post-finalization actions are executed as expected.</p>
<hr>
<hr>
<h2>title: TestClock
description: Control time during testing with Effect&#39;s TestClock, simulating time passage, delays, and recurring effects without waiting for real time.
sidebar:
  order: 0</h2>
<p>import { Aside } from &quot;@astrojs/starlight/components&quot;</p>
<p>In most cases, we want our unit tests to run as quickly as possible. Waiting for real time to pass can slow down our tests significantly. Effect provides a handy tool called <code>TestClock</code> that allows us to <strong>control time during testing</strong>. This means we can efficiently and predictably test code that involves time without having to wait for the actual time to pass.</p>
<h2>How TestClock Works</h2>
<p>Imagine <code>TestClock</code> as a wall clock that only moves forward when we adjust it manually using the <code>TestClock.adjust</code> and <code>TestClock.setTime</code> functions. The clock time does not progress on its own.</p>
<p>When we adjust the clock time, any effects scheduled to run at or before that time will execute. This allows us to simulate time passage in tests without waiting for real time.</p>
<p><strong>Example</strong> (Simulating a Timeout with TestClock)</p>
<pre><code class="language-ts">import { Effect, TestClock, Fiber, Option, TestContext } from &quot;effect&quot;
import * as assert from &quot;node:assert&quot;

const test = Effect.gen(function* () {
  // Create a fiber that sleeps for 5 minutes and then times out
  // after 1 minute
  const fiber = yield* Effect.sleep(&quot;5 minutes&quot;).pipe(
    Effect.timeoutTo({
      duration: &quot;1 minute&quot;,
      onSuccess: Option.some,
      onTimeout: () =&gt; Option.none&lt;void&gt;()
    }),
    Effect.fork
  )

  // Adjust the TestClock by 1 minute to simulate the passage of time
  yield* TestClock.adjust(&quot;1 minute&quot;)

  // Get the result of the fiber
  const result = yield* Fiber.join(fiber)

  // Check if the result is None, indicating a timeout
  assert.ok(Option.isNone(result))
}).pipe(Effect.provide(TestContext.TestContext))

Effect.runPromise(test)
</code></pre>
<p>A key point is forking the fiber where <code>Effect.sleep</code> is invoked. Calls to <code>Effect.sleep</code> and related methods wait until the clock time matches or exceeds the scheduled time for their execution. By forking the fiber, we retain control over the clock time adjustments.</p>
<Aside type="tip" title="Best Practices">
  A recommended pattern when using the `TestClock` is to fork the effect
  being tested, adjust the clock time as needed, and then verify that the
  expected outcomes have occurred.
</Aside>

<h2>Testing Recurring Effects</h2>
<p>Here&#39;s an example demonstrating how to test an effect that runs at fixed intervals using the <code>TestClock</code>:</p>
<p><strong>Example</strong> (Testing an Effect with Fixed Intervals)</p>
<p>In this example, we test an effect that runs at regular intervals. An unbounded queue is used to manage the effects, and we verify the following:</p>
<ol>
<li>No effect occurs before the specified recurrence period.</li>
<li>An effect occurs after the recurrence period.</li>
<li>The effect executes exactly once.</li>
</ol>
<pre><code class="language-ts">import { Effect, Queue, TestClock, Option, TestContext } from &quot;effect&quot;
import * as assert from &quot;node:assert&quot;

const test = Effect.gen(function* () {
  const q = yield* Queue.unbounded()

  yield* Queue.offer(q, undefined).pipe(
    // Delay the effect for 60 minutes and repeat it forever
    Effect.delay(&quot;60 minutes&quot;),
    Effect.forever,
    Effect.fork
  )

  // Check if no effect is performed before the recurrence period
  const a = yield* Queue.poll(q).pipe(Effect.andThen(Option.isNone))

  // Adjust the TestClock by 60 minutes to simulate the passage of time
  yield* TestClock.adjust(&quot;60 minutes&quot;)

  // Check if an effect is performed after the recurrence period
  const b = yield* Queue.take(q).pipe(Effect.as(true))

  // Check if the effect is performed exactly once
  const c = yield* Queue.poll(q).pipe(Effect.andThen(Option.isNone))

  // Adjust the TestClock by another 60 minutes
  yield* TestClock.adjust(&quot;60 minutes&quot;)

  // Check if another effect is performed
  const d = yield* Queue.take(q).pipe(Effect.as(true))
  const e = yield* Queue.poll(q).pipe(Effect.andThen(Option.isNone))

  // Ensure that all conditions are met
  assert.ok(a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e)
}).pipe(Effect.provide(TestContext.TestContext))

Effect.runPromise(test)
</code></pre>
<p>It&#39;s important to note that after each recurrence, the next occurrence is scheduled to happen at the appropriate time. Adjusting the clock by 60 minutes places exactly one value in the queue; adjusting by another 60 minutes adds another value.</p>
<h2>Testing Clock</h2>
<p>This example demonstrates how to test the behavior of the <code>Clock</code> using the <code>TestClock</code>:</p>
<p><strong>Example</strong> (Simulating Time Passage with TestClock)</p>
<pre><code class="language-ts">import { Effect, Clock, TestClock, TestContext } from &quot;effect&quot;
import * as assert from &quot;node:assert&quot;

const test = Effect.gen(function* () {
  // Get the current time using the Clock
  const startTime = yield* Clock.currentTimeMillis

  // Adjust the TestClock by 1 minute to simulate the passage of time
  yield* TestClock.adjust(&quot;1 minute&quot;)

  // Get the current time again
  const endTime = yield* Clock.currentTimeMillis

  // Check if the time difference is at least
  // 60,000 milliseconds (1 minute)
  assert.ok(endTime - startTime &gt;= 60_000)
}).pipe(Effect.provide(TestContext.TestContext))

Effect.runPromise(test)
</code></pre>
<h2>Testing Deferred</h2>
<p>The <code>TestClock</code> also impacts asynchronous code scheduled to run after a specific time.</p>
<p><strong>Example</strong> (Simulating Delayed Execution with Deferred and TestClock)</p>
<pre><code class="language-ts">import { Effect, Deferred, TestClock, TestContext } from &quot;effect&quot;
import * as assert from &quot;node:assert&quot;

const test = Effect.gen(function* () {
  // Create a deferred value
  const deferred = yield* Deferred.make&lt;number, void&gt;()

  // Run two effects concurrently: sleep for 10 seconds and succeed
  // the deferred with a value of 1
  yield* Effect.all(
    [Effect.sleep(&quot;10 seconds&quot;), Deferred.succeed(deferred, 1)],
    { concurrency: &quot;unbounded&quot; }
  ).pipe(Effect.fork)

  // Adjust the TestClock by 10 seconds
  yield* TestClock.adjust(&quot;10 seconds&quot;)

  // Await the value from the deferred
  const readRef = yield* Deferred.await(deferred)

  // Verify the deferred value is correctly set
  assert.ok(readRef === 1)
}).pipe(Effect.provide(TestContext.TestContext))

Effect.runPromise(test)
</code></pre>
<hr>
<hr>
<h2>title: Equal
description: Implement value-based equality checks for improved data integrity and predictable behavior in TypeScript.
sidebar:
  order: 0</h2>
<p>The Equal module provides a simple and convenient way to define and check for equality between two values in TypeScript.</p>
<p>Here are some key reasons why Effect exports an Equal module:</p>
<ol>
<li><p><strong>Value-Based Equality</strong>: JavaScript&#39;s native equality operators (<code>===</code> and <code>==</code>) check for equality by reference, meaning they compare objects based on their memory addresses rather than their content. This behavior can be problematic when you want to compare objects with the same values but different references. The Equal module offers a solution by allowing developers to define custom equality checks based on the values of objects.</p>
</li>
<li><p><strong>Custom Equality</strong>: The Equal module enables developers to implement custom equality checks for their data types and classes. This is crucial when you have specific requirements for determining when two objects should be considered equal. By implementing the <code>Equal</code> interface, developers can define their own equality logic.</p>
</li>
<li><p><strong>Data Integrity</strong>: In some applications, maintaining data integrity is crucial. The ability to perform value-based equality checks ensures that identical data is not duplicated within collections like sets or maps. This can lead to more efficient memory usage and more predictable behavior.</p>
</li>
<li><p><strong>Predictable Behavior</strong>: The Equal module promotes more predictable behavior when comparing objects. By explicitly defining equality criteria, developers can avoid unexpected results that may occur with JavaScript&#39;s default reference-based equality checks.</p>
</li>
</ol>
<h2>How to Perform Equality Checking in Effect</h2>
<p>In Effect it&#39;s advisable to <strong>stop using</strong> JavaScript&#39;s <code>===</code> and <code>==</code> operators and instead rely on the <code>Equal.equals</code> function.
This function can work with any data type that implements the <code>Equal</code> interface.
Some examples of such data types include <a href="/docs/data-types/option/">Option</a>, <a href="/docs/data-types/either/">Either</a>, <a href="https://effect-ts.github.io/effect/effect/HashSet.ts.html">HashSet</a>, and <a href="https://effect-ts.github.io/effect/effect/HashMap.ts.html">HashMap</a>.</p>
<p>When you use <code>Equal.equals</code> and your objects do not implement the <code>Equal</code> interface, it defaults to using the <code>===</code> operator for object comparison:</p>
<p><strong>Example</strong> (Using <code>Equal.equals</code> with Default Comparison)</p>
<pre><code class="language-ts">import { Equal } from &quot;effect&quot;

// Two objects with identical properties and values
const a = { name: &quot;Alice&quot;, age: 30 }
const b = { name: &quot;Alice&quot;, age: 30 }

// Equal.equals falls back to the default &#39;===&#39; comparison
console.log(Equal.equals(a, b))
// Output: false
</code></pre>
<p>In this example, <code>a</code> and <code>b</code> are two separate objects with the same contents. However, <code>===</code> considers them different because they occupy different memory locations. This behavior can lead to unexpected results when you want to compare values based on their content.</p>
<p>However, you can configure your models to ensure that <code>Equal.equals</code> behaves consistently with your custom equality checks. There are two alternative approaches:</p>
<ol>
<li><p><strong>Implementing the <code>Equal</code> Interface</strong>: This method is useful when you need to define your custom equality check.</p>
</li>
<li><p><strong>Using the Data Module</strong>: For simple value equality, the <a href="/docs/data-types/data/">Data</a> module provides a more straightforward solution by automatically generating default implementations for <code>Equal</code>.</p>
</li>
</ol>
<p>Let&#39;s explore both.</p>
<h3>Implementing the Equal Interface</h3>
<p>To create custom equality behavior, you can implement the <code>Equal</code> interface in your models. This interface extends the <code>Hash</code> interface from the <a href="/docs/trait/hash/">Hash</a> module.</p>
<p><strong>Example</strong> (Implementing <code>Equal</code> and <code>Hash</code> for a Custom Class)</p>
<pre><code class="language-ts">import { Equal, Hash } from &quot;effect&quot;

class Person implements Equal.Equal {
  constructor(
    readonly id: number, // Unique identifier
    readonly name: string,
    readonly age: number
  ) {}

  // Define equality based on id, name, and age
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Person) {
      return (
        Equal.equals(this.id, that.id) &amp;&amp;
        Equal.equals(this.name, that.name) &amp;&amp;
        Equal.equals(this.age, that.age)
      )
    }
    return false
  }

  // Generate a hash code based on the unique id
  [Hash.symbol](): number {
    return Hash.hash(this.id)
  }
}
</code></pre>
<p>In the above code, we define a custom equality function <code>[Equal.symbol]</code> and a hash function <code>[Hash.symbol]</code> for the <code>Person</code> class. The <code>Hash</code> interface optimizes equality checks by comparing hash values instead of the objects themselves. When you use the <code>Equal.equals</code> function to compare two objects, it first checks if their hash values are equal. If not, it quickly determines that the objects are not equal, avoiding the need for a detailed property-by-property comparison.</p>
<p>Once you&#39;ve implemented the <code>Equal</code> interface, you can utilize the <code>Equal.equals</code> function to check for equality using your custom logic.</p>
<p><strong>Example</strong> (Comparing <code>Person</code> Instances)</p>
<pre><code class="language-ts">import { Equal, Hash } from &quot;effect&quot;

class Person implements Equal.Equal {
  constructor(
    readonly id: number, // Unique identifier for each person
    readonly name: string,
    readonly age: number
  ) {}

  // Defines equality based on id, name, and age
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Person) {
      return (
        Equal.equals(this.id, that.id) &amp;&amp;
        Equal.equals(this.name, that.name) &amp;&amp;
        Equal.equals(this.age, that.age)
      )
    }
    return false
  }

  // Generates a hash code based primarily on the unique id
  [Hash.symbol](): number {
    return Hash.hash(this.id)
  }
}

const alice = new Person(1, &quot;Alice&quot;, 30)
console.log(Equal.equals(alice, new Person(1, &quot;Alice&quot;, 30)))
// Output: true

const bob = new Person(2, &quot;Bob&quot;, 40)
console.log(Equal.equals(alice, bob))
// Output: false
</code></pre>
<p>In this code, the equality check returns <code>true</code> when comparing <code>alice</code> to a new <code>Person</code> object with identical property values and <code>false</code> when comparing <code>alice</code> to <code>bob</code> due to their differing property values.</p>
<h3>Simplifying Equality with the Data Module</h3>
<p>Implementing both <code>Equal</code> and <code>Hash</code> can become cumbersome when all you need is straightforward value equality checks. Luckily, the <a href="/docs/data-types/data/">Data</a> module provides a simpler solution. It offers APIs that automatically generate default implementations for both <code>Equal</code> and <code>Hash</code>.</p>
<p><strong>Example</strong> (Using <code>Data.struct</code> for Equality Checks)</p>
<pre><code class="language-ts">import { Equal, Data } from &quot;effect&quot;

const alice = Data.struct({ id: 1, name: &quot;Alice&quot;, age: 30 })

const bob = Data.struct({ id: 2, name: &quot;Bob&quot;, age: 40 })

console.log(
  Equal.equals(alice, Data.struct({ id: 1, name: &quot;Alice&quot;, age: 30 }))
)
// Output: true

console.log(Equal.equals(alice, { id: 1, name: &quot;Alice&quot;, age: 30 }))
// Output: false

console.log(Equal.equals(alice, bob))
// Output: false
</code></pre>
<p>In this example, we use the <a href="/docs/data-types/data/#struct">Data.struct</a> function to create structured data objects and check their equality using <code>Equal.equals</code>. The Data module simplifies the process by providing a default implementation for both <code>Equal</code> and <code>Hash</code>, allowing you to focus on comparing values without the need for explicit implementations.</p>
<p>The Data module isn&#39;t limited to just structs. It can handle various data types, including tuples, arrays, and records. If you&#39;re curious about how to leverage its full range of features, you can explore the <a href="/docs/data-types/data/#value-equality">Data module documentation</a>.</p>
<h2>Working with Collections</h2>
<p>JavaScript&#39;s built-in <code>Set</code> and <code>Map</code> can be a bit tricky when it comes to checking equality:</p>
<p><strong>Example</strong> (Native <code>Set</code> with Reference-Based Equality)</p>
<pre><code class="language-ts">const set = new Set()

// Adding two objects with the same content to the set
set.add({ name: &quot;Alice&quot;, age: 30 })
set.add({ name: &quot;Alice&quot;, age: 30 })

// Even though the objects have identical values, they are treated
// as different elements because JavaScript compares objects by reference,
// not by value.
console.log(set.size)
// Output: 2
</code></pre>
<p>Even though the two elements in the set have the same values, the set contains two elements. Why? JavaScript&#39;s <code>Set</code> checks for equality by reference, not by values.</p>
<p>To perform value-based equality checks, you&#39;ll need to use the <code>Hash*</code> collection types available in the <code>effect</code> package. These collection types, such as <a href="https://effect-ts.github.io/effect/effect/HashSet.ts.html">HashSet</a> and <a href="https://effect-ts.github.io/effect/effect/HashMap.ts.html">HashMap</a>, provide support for the <code>Equal</code> interface.</p>
<h3>HashSet</h3>
<p>When you use the <code>HashSet</code>, it correctly handles value-based equality checks. In the following example, even though you&#39;re adding two objects with the same values, the <code>HashSet</code> treats them as a single element.</p>
<p><strong>Example</strong> (Using <code>HashSet</code> for Value-Based Equality)</p>
<pre><code class="language-ts">import { HashSet, Data } from &quot;effect&quot;

// Creating a HashSet with objects that implement the Equal interface
const set = HashSet.empty().pipe(
  HashSet.add(Data.struct({ name: &quot;Alice&quot;, age: 30 })),
  HashSet.add(Data.struct({ name: &quot;Alice&quot;, age: 30 }))
)

// HashSet recognizes them as equal, so only one element is stored
console.log(HashSet.size(set))
// Output: 1
</code></pre>
<p><strong>Note</strong>: It&#39;s crucial to use elements that implement the <code>Equal</code> interface, either by implementing custom equality checks or by using the Data module. This ensures proper functionality when working with <code>HashSet</code>. Without this, you&#39;ll encounter the same behavior as the native <code>Set</code> data type:</p>
<p><strong>Example</strong> (Reference-Based Equality in <code>HashSet</code>)</p>
<pre><code class="language-ts">import { HashSet } from &quot;effect&quot;

// Creating a HashSet with objects that do NOT implement
// the Equal interface
const set = HashSet.empty().pipe(
  HashSet.add({ name: &quot;Alice&quot;, age: 30 }),
  HashSet.add({ name: &quot;Alice&quot;, age: 30 })
)

// Since these objects are compared by reference,
// HashSet considers them different
console.log(HashSet.size(set))
// Output: 2
</code></pre>
<p>In this case, without using the Data module alongside <code>HashSet</code>, you&#39;ll experience the same behavior as the native <code>Set</code> data type. The set contains two elements because it checks for equality by reference, not by values.</p>
<h3>HashMap</h3>
<p>When working with the <code>HashMap</code>, you have the advantage of comparing keys by their values instead of their references. This is particularly helpful in scenarios where you want to associate values with keys based on their content.</p>
<p><strong>Example</strong> (Value-Based Key Comparisons with <code>HashMap</code>)</p>
<pre><code class="language-ts">import { HashMap, Data } from &quot;effect&quot;

// Adding two objects with identical values as keys
const map = HashMap.empty().pipe(
  HashMap.set(Data.struct({ name: &quot;Alice&quot;, age: 30 }), 1),
  HashMap.set(Data.struct({ name: &quot;Alice&quot;, age: 30 }), 2)
)

console.log(HashMap.size(map))
// Output: 1

// Retrieve the value associated with a key
console.log(HashMap.get(map, Data.struct({ name: &quot;Alice&quot;, age: 30 })))
/*
Output:
{ _id: &#39;Option&#39;, _tag: &#39;Some&#39;, value: 2 }
*/
</code></pre>
<p>In this code snippet, <code>HashMap</code> is used to create a map where the keys are objects constructed with <code>Data.struct</code>. These objects contain identical values, which would usually create separate entries in a regular JavaScript <code>Map</code> because the default comparison is reference-based.</p>
<p><code>HashMap</code>, however, uses value-based comparison, meaning the two objects with identical content are treated as the same key. Thus, when we add both objects, the second key-value pair overrides the first, resulting in a single entry in the map.</p>
<hr>
<hr>
<h2>title: Hash
description: Optimize equality checks with efficient hashing for faster comparisons in collections like hash sets and maps.
sidebar:
  order: 1</h2>
<p>The <code>Hash</code> interface is closely tied to the <a href="/docs/trait/equal/">Equal</a> interface and serves a supportive role in optimizing equality checks by providing a mechanism for hashing. Hashing is an important step in the efficient determination of equality between two values, particularly when used with data structures like hash tables.</p>
<h2>Role of Hash in Equality Checking</h2>
<p>The primary purpose of the <code>Hash</code> interface is to provide a quick and efficient way to determine if two values are definitely not equal, thereby complementing the <a href="/docs/trait/equal/">Equal</a> interface. When two values implement the <a href="/docs/trait/equal/">Equal</a> interface, their hash values (computed using the <code>Hash</code> interface) are compared first:</p>
<ul>
<li><strong>Different Hash Values</strong>: If the hash values are different, it is guaranteed that the values themselves are different. This quick check allows the system to avoid a potentially expensive equality check.</li>
<li><strong>Same Hash Values</strong>: If the hash values are the same, it does not guarantee that the values are equal, only that they might be. In this case, a more thorough comparison using the <a href="/docs/trait/equal/">Equal</a> interface is performed to determine actual equality.</li>
</ul>
<p>This method dramatically speeds up the equality checking process, especially in collections where quick look-up and insertion times are crucial, such as in hash sets or hash maps.</p>
<h2>Implementing the Hash Interface</h2>
<p>Consider a scenario where you have a custom <code>Person</code> class, and you want to check if two instances are equal based on their properties.
By implementing both the <code>Equal</code> and <code>Hash</code> interfaces, you can efficiently manage these checks:</p>
<p><strong>Example</strong> (Implementing <code>Equal</code> and <code>Hash</code> for a Custom Class)</p>
<pre><code class="language-ts">import { Equal, Hash } from &quot;effect&quot;

class Person implements Equal.Equal {
  constructor(
    readonly id: number, // Unique identifier
    readonly name: string,
    readonly age: number
  ) {}

  // Define equality based on id, name, and age
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Person) {
      return (
        Equal.equals(this.id, that.id) &amp;&amp;
        Equal.equals(this.name, that.name) &amp;&amp;
        Equal.equals(this.age, that.age)
      )
    }
    return false
  }

  // Generate a hash code based on the unique id
  [Hash.symbol](): number {
    return Hash.hash(this.id)
  }
}

const alice = new Person(1, &quot;Alice&quot;, 30)
console.log(Equal.equals(alice, new Person(1, &quot;Alice&quot;, 30)))
// Output: true

const bob = new Person(2, &quot;Bob&quot;, 40)
console.log(Equal.equals(alice, bob))
// Output: false
</code></pre>
<p>Explanation:</p>
<ul>
<li>The <code>[Equal.symbol]</code> method determines equality by comparing the <code>id</code>, <code>name</code>, and <code>age</code> fields of <code>Person</code> instances. This approach ensures that the equality check is comprehensive and considers all relevant attributes.</li>
<li>The <code>[Hash.symbol]</code> method computes a hash code using the <code>id</code> of the person. This value is used to quickly differentiate between instances in hashing operations, optimizing the performance of data structures that utilize hashing.</li>
<li>The equality check returns <code>true</code> when comparing <code>alice</code> to a new <code>Person</code> object with identical property values and <code>false</code> when comparing <code>alice</code> to <code>bob</code> due to their differing property values.</li>
</ul>

    </body>
    </html>
  